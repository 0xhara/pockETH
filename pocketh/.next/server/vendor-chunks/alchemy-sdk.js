"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/alchemy-sdk";
exports.ids = ["vendor-chunks/alchemy-sdk"];
exports.modules = {

/***/ "(ssr)/./node_modules/alchemy-sdk/dist/cjs/alchemy-provider-e539e7d0.js":
/*!************************************************************************!*\
  !*** ./node_modules/alchemy-sdk/dist/cjs/alchemy-provider-e539e7d0.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar index = __webpack_require__(/*! ./index-b1f4a2d9.js */ \"(ssr)/./node_modules/alchemy-sdk/dist/cjs/index-b1f4a2d9.js\");\nvar networks = __webpack_require__(/*! @ethersproject/networks */ \"(ssr)/./node_modules/@ethersproject/networks/lib.esm/index.js\");\nvar providers = __webpack_require__(/*! @ethersproject/providers */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/index.js\");\nvar web = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/./node_modules/@ethersproject/web/lib.esm/index.js\");\n__webpack_require__(/*! ./api/utils */ \"(ssr)/./node_modules/alchemy-sdk/dist/cjs/api/utils.js\");\n__webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/index.js\");\n__webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/index.js\");\n__webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/./node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/wallet */ \"(ssr)/./node_modules/@ethersproject/wallet/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/contracts */ \"(ssr)/./node_modules/@ethersproject/contracts/lib.esm/index.js\");\n/** Maximum size of a batch on the rpc provider. */ const DEFAULT_MAX_REQUEST_BATCH_SIZE = 100;\n/** Timeout interval before the pending batch is sent. */ const DEFAULT_REQUEST_BATCH_DELAY_MS = 10;\n/**\r\n * Internal class to enqueue requests and automatically send/process batches.\r\n *\r\n * The underlying batching mechanism is loosely based on ethers.js's\r\n * `JsonRpcBatchProvider`.\r\n *\r\n * @internal\r\n */ class RequestBatcher {\n    constructor(sendBatchFn, maxBatchSize = DEFAULT_MAX_REQUEST_BATCH_SIZE){\n        this.sendBatchFn = sendBatchFn;\n        this.maxBatchSize = maxBatchSize;\n        /**\r\n         * Array of enqueued requests along with the constructed promise handlers for\r\n         * each request.\r\n         */ this.pendingBatch = [];\n    }\n    /**\r\n     * Enqueues the provided request. The batch is immediately sent if the maximum\r\n     * batch size is reached. Otherwise, the request is enqueued onto a batch that\r\n     * is sent after 10ms.\r\n     *\r\n     * Returns a promise that resolves with the result of the request.\r\n     */ enqueueRequest(request) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            const inflightRequest = {\n                request,\n                resolve: undefined,\n                reject: undefined\n            };\n            const promise = new Promise((resolve, reject)=>{\n                inflightRequest.resolve = resolve;\n                inflightRequest.reject = reject;\n            });\n            this.pendingBatch.push(inflightRequest);\n            if (this.pendingBatch.length === this.maxBatchSize) {\n                // Send batch immediately if we are at the maximum batch size.\n                void this.sendBatchRequest();\n            } else if (!this.pendingBatchTimer) {\n                // Schedule batch for next event loop + short duration\n                this.pendingBatchTimer = setTimeout(()=>this.sendBatchRequest(), DEFAULT_REQUEST_BATCH_DELAY_MS);\n            }\n            return promise;\n        });\n    }\n    /**\r\n     * Sends the currently queued batches and resets the batch and timer. Processes\r\n     * the batched response results back to the original promises.\r\n     */ sendBatchRequest() {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            // Get the current batch and clear it, so new requests\n            // go into the next batch\n            const batch = this.pendingBatch;\n            this.pendingBatch = [];\n            if (this.pendingBatchTimer) {\n                clearTimeout(this.pendingBatchTimer);\n                this.pendingBatchTimer = undefined;\n            }\n            // Get the request as an array of requests\n            const request = batch.map((inflight)=>inflight.request);\n            return this.sendBatchFn(request).then((result)=>{\n                // For each result, feed it to the correct Promise, depending\n                // on whether it was a success or error\n                batch.forEach((inflightRequest, index)=>{\n                    const payload = result[index];\n                    if (payload.error) {\n                        const error = new Error(payload.error.message);\n                        error.code = payload.error.code;\n                        error.data = payload.error.data;\n                        inflightRequest.reject(error);\n                    } else {\n                        inflightRequest.resolve(payload.result);\n                    }\n                });\n            }, (error)=>{\n                batch.forEach((inflightRequest)=>{\n                    inflightRequest.reject(error);\n                });\n            });\n        });\n    }\n}\n/**\r\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getProvider()}.\r\n *\r\n * @public\r\n */ class AlchemyProvider extends providers.JsonRpcProvider {\n    /** @internal */ constructor(config){\n        // Normalize the API Key to a string.\n        const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n        // Generate our own connection info with the correct endpoint URLs.\n        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n        const connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, \"http\");\n        // If a hardcoded url was specified in the config, use that instead of the\n        // provided apiKey or network.\n        if (config.url !== undefined) {\n            connection.url = config.url;\n        }\n        connection.throttleLimit = config.maxRetries;\n        // Normalize the Alchemy named network input to the network names used by\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\n        // correctly set the network.\n        const ethersNetwork = index.EthersNetwork[alchemyNetwork];\n        super(connection, ethersNetwork);\n        this.apiKey = config.apiKey;\n        this.maxRetries = config.maxRetries;\n        this.batchRequests = config.batchRequests;\n        // TODO: support individual headers when calling batch\n        const batcherConnection = Object.assign(Object.assign({}, this.connection), {\n            headers: Object.assign(Object.assign({}, this.connection.headers), {\n                \"Alchemy-Ethers-Sdk-Method\": \"batchSend\"\n            })\n        });\n        const sendBatchFn = (requests)=>{\n            return web.fetchJson(batcherConnection, JSON.stringify(requests));\n        };\n        this.batcher = new RequestBatcher(sendBatchFn);\n        this.modifyFormatter();\n    }\n    /**\r\n     * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\r\n     * ethers.js. Returns the API key for an Alchemy provider.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ static getApiKey(apiKey) {\n        if (apiKey == null) {\n            return index.DEFAULT_ALCHEMY_API_KEY;\n        }\n        if (apiKey && typeof apiKey !== \"string\") {\n            throw new Error(`Invalid apiKey '${apiKey}' provided. apiKey must be a string.`);\n        }\n        return apiKey;\n    }\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ static getNetwork(network) {\n        if (typeof network === \"string\" && network in index.CustomNetworks) {\n            return index.CustomNetworks[network];\n        }\n        // Call the standard ethers.js getNetwork method for other networks.\n        return networks.getNetwork(network);\n    }\n    /**\r\n     * Converts the `Networkish` input to the network enum used by Alchemy.\r\n     *\r\n     * @internal\r\n     */ static getAlchemyNetwork(network) {\n        if (network === undefined) {\n            return index.DEFAULT_NETWORK;\n        }\n        if (typeof network === \"number\") {\n            throw new Error(`Invalid network '${network}' provided. Network must be a string.`);\n        }\n        // Guaranteed that `typeof network === 'string`.\n        const isValidNetwork = Object.values(index.Network).includes(network);\n        if (!isValidNetwork) {\n            throw new Error(`Invalid network '${network}' provided. Network must be one of: ` + `${Object.values(index.Network).join(\", \")}.`);\n        }\n        return network;\n    }\n    /**\r\n     * Returns a {@link ConnectionInfo} object compatible with ethers that contains\r\n     * the correct URLs for Alchemy.\r\n     *\r\n     * @internal\r\n     */ static getAlchemyConnectionInfo(network, apiKey, type) {\n        const url = type === \"http\" ? index.getAlchemyHttpUrl(network, apiKey) : index.getAlchemyWsUrl(network, apiKey);\n        return {\n            headers: index.IS_BROWSER ? {\n                \"Alchemy-Ethers-Sdk-Version\": index.VERSION\n            } : {\n                \"Alchemy-Ethers-Sdk-Version\": index.VERSION,\n                \"Accept-Encoding\": \"gzip\"\n            },\n            allowGzip: true,\n            url\n        };\n    }\n    /**\r\n     * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\r\n     * method is called when calling methods on the parent class `BaseProvider`.\r\n     *\r\n     * @override\r\n     */ detectNetwork() {\n        const _super = Object.create(null, {\n            detectNetwork: {\n                get: ()=>super.detectNetwork\n            }\n        });\n        return index.__awaiter(this, void 0, void 0, function*() {\n            let network = this.network;\n            if (network == null) {\n                network = yield _super.detectNetwork.call(this);\n                if (!network) {\n                    throw new Error(\"No network detected\");\n                }\n            }\n            return network;\n        });\n    }\n    _startPending() {\n        index.logWarn(\"WARNING: Alchemy Provider does not support pending filters\");\n    }\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */ isCommunityResource() {\n        return this.apiKey === index.DEFAULT_ALCHEMY_API_KEY;\n    }\n    /**\r\n     * Overrides the base {@link JsonRpcProvider.send} method to implement custom\r\n     * logic for sending requests to Alchemy.\r\n     *\r\n     * @param method The method name to use for the request.\r\n     * @param params The parameters to use for the request.\r\n     * @override\r\n     * @public\r\n     */ // TODO: Add headers for `perform()` override.\n    send(method, params) {\n        return this._send(method, params, \"send\");\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `JsonRpcProvider.send()`.\r\n     *\r\n     * This method is copied over directly in order to implement custom headers\r\n     *\r\n     * @internal\r\n     */ _send(method, params, methodName, forceBatch = false) {\n        const request = {\n            method,\n            params,\n            id: this._nextId++,\n            jsonrpc: \"2.0\"\n        };\n        // START MODIFIED CODE\n        const connection = Object.assign({}, this.connection);\n        connection.headers[\"Alchemy-Ethers-Sdk-Method\"] = methodName;\n        if (this.batchRequests || forceBatch) {\n            return this.batcher.enqueueRequest(request);\n        }\n        // END MODIFIED CODE\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: index.deepCopy(request),\n            provider: this\n        });\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = [\n            \"eth_chainId\",\n            \"eth_blockNumber\"\n        ].indexOf(method) >= 0;\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n        const result = web.fetchJson(this.connection, JSON.stringify(request), getResult).then((result)=>{\n            this.emit(\"debug\", {\n                action: \"response\",\n                request,\n                response: result,\n                provider: this\n            });\n            return result;\n        }, (error)=>{\n            this.emit(\"debug\", {\n                action: \"response\",\n                error,\n                request,\n                provider: this\n            });\n            throw error;\n        });\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(()=>{\n                // @ts-ignore - This is done by ethers.\n                this._cache[method] = null;\n            }, 0);\n        }\n        return result;\n    }\n    /**\r\n     * Overrides the base `Formatter` class inherited from ethers to support\r\n     * returning custom fields in Ethers response types.\r\n     *\r\n     * For context, ethers has a `Formatter` class that is used to format the\r\n     * response from a JSON-RPC request. Any fields that are not defined in the\r\n     * `Formatter` class are removed from the returned response. By modifying the\r\n     * `Formatter` class in this method, we can add support for fields that are\r\n     * not defined in ethers.\r\n     */ modifyFormatter() {\n        this.formatter.formats[\"receiptLog\"][\"removed\"] = (val)=>{\n            if (typeof val === \"boolean\") {\n                return val;\n            }\n            return undefined;\n        };\n    }\n}\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * Original code copied over from ether.js's\r\n * `@ethersproject/web/src.ts/index.ts`. Used to support\r\n * {@link AlchemyProvider._send}, which is also copied over.\r\n */ function getResult(payload) {\n    if (payload.error) {\n        const error = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n    return payload.result;\n}\nexports.AlchemyProvider = AlchemyProvider; //# sourceMappingURL=alchemy-provider-e539e7d0.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9janMvYWxjaGVteS1wcm92aWRlci1lNTM5ZTdkMC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO0FBQ3ZCLElBQUlFLFlBQVlGLG1CQUFPQSxDQUFDO0FBQ3hCLElBQUlHLE1BQU1ILG1CQUFPQSxDQUFDO0FBQ2xCQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUVSLGlEQUFpRCxHQUNqRCxNQUFNSSxpQ0FBaUM7QUFDdkMsdURBQXVELEdBQ3ZELE1BQU1DLGlDQUFpQztBQUN2Qzs7Ozs7OztDQU9DLEdBQ0QsTUFBTUM7SUFDRkMsWUFBWUMsV0FBVyxFQUFFQyxlQUFlTCw4QkFBOEIsQ0FBRTtRQUNwRSxJQUFJLENBQUNJLFdBQVcsR0FBR0E7UUFDbkIsSUFBSSxDQUFDQyxZQUFZLEdBQUdBO1FBQ3BCOzs7U0FHQyxHQUNELElBQUksQ0FBQ0MsWUFBWSxHQUFHLEVBQUU7SUFDMUI7SUFDQTs7Ozs7O0tBTUMsR0FDREMsZUFBZUMsT0FBTyxFQUFFO1FBQ3BCLE9BQU9iLE1BQU1jLFNBQVMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUN6QyxNQUFNQyxrQkFBa0I7Z0JBQ3BCRjtnQkFDQUcsU0FBU0M7Z0JBQ1RDLFFBQVFEO1lBQ1o7WUFDQSxNQUFNRSxVQUFVLElBQUlDLFFBQVEsQ0FBQ0osU0FBU0U7Z0JBQ2xDSCxnQkFBZ0JDLE9BQU8sR0FBR0E7Z0JBQzFCRCxnQkFBZ0JHLE1BQU0sR0FBR0E7WUFDN0I7WUFDQSxJQUFJLENBQUNQLFlBQVksQ0FBQ1UsSUFBSSxDQUFDTjtZQUN2QixJQUFJLElBQUksQ0FBQ0osWUFBWSxDQUFDVyxN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QVFGLE1BQU07QUFDekI7QUFFQThFLHVCQUF1QixHQUFHdEUsaUJBQzFCLHFEQUFxRCIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9janMvYWxjaGVteS1wcm92aWRlci1lNTM5ZTdkMC5qcz9mZmI4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGluZGV4ID0gcmVxdWlyZSgnLi9pbmRleC1iMWY0YTJkOS5qcycpO1xudmFyIG5ldHdvcmtzID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvbmV0d29ya3MnKTtcbnZhciBwcm92aWRlcnMgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9wcm92aWRlcnMnKTtcbnZhciB3ZWIgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC93ZWInKTtcbnJlcXVpcmUoJy4vYXBpL3V0aWxzJyk7XG5yZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9iaWdudW1iZXInKTtcbnJlcXVpcmUoJ2F4aW9zJyk7XG5yZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlcicpO1xucmVxdWlyZSgnQGV0aGVyc3Byb2plY3Qvd2FsbGV0Jyk7XG5yZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9jb250cmFjdHMnKTtcblxuLyoqIE1heGltdW0gc2l6ZSBvZiBhIGJhdGNoIG9uIHRoZSBycGMgcHJvdmlkZXIuICovXHJcbmNvbnN0IERFRkFVTFRfTUFYX1JFUVVFU1RfQkFUQ0hfU0laRSA9IDEwMDtcclxuLyoqIFRpbWVvdXQgaW50ZXJ2YWwgYmVmb3JlIHRoZSBwZW5kaW5nIGJhdGNoIGlzIHNlbnQuICovXHJcbmNvbnN0IERFRkFVTFRfUkVRVUVTVF9CQVRDSF9ERUxBWV9NUyA9IDEwO1xyXG4vKipcclxuICogSW50ZXJuYWwgY2xhc3MgdG8gZW5xdWV1ZSByZXF1ZXN0cyBhbmQgYXV0b21hdGljYWxseSBzZW5kL3Byb2Nlc3MgYmF0Y2hlcy5cclxuICpcclxuICogVGhlIHVuZGVybHlpbmcgYmF0Y2hpbmcgbWVjaGFuaXNtIGlzIGxvb3NlbHkgYmFzZWQgb24gZXRoZXJzLmpzJ3NcclxuICogYEpzb25ScGNCYXRjaFByb3ZpZGVyYC5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBSZXF1ZXN0QmF0Y2hlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZW5kQmF0Y2hGbiwgbWF4QmF0Y2hTaXplID0gREVGQVVMVF9NQVhfUkVRVUVTVF9CQVRDSF9TSVpFKSB7XHJcbiAgICAgICAgdGhpcy5zZW5kQmF0Y2hGbiA9IHNlbmRCYXRjaEZuO1xyXG4gICAgICAgIHRoaXMubWF4QmF0Y2hTaXplID0gbWF4QmF0Y2hTaXplO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFycmF5IG9mIGVucXVldWVkIHJlcXVlc3RzIGFsb25nIHdpdGggdGhlIGNvbnN0cnVjdGVkIHByb21pc2UgaGFuZGxlcnMgZm9yXHJcbiAgICAgICAgICogZWFjaCByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0JhdGNoID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVucXVldWVzIHRoZSBwcm92aWRlZCByZXF1ZXN0LiBUaGUgYmF0Y2ggaXMgaW1tZWRpYXRlbHkgc2VudCBpZiB0aGUgbWF4aW11bVxyXG4gICAgICogYmF0Y2ggc2l6ZSBpcyByZWFjaGVkLiBPdGhlcndpc2UsIHRoZSByZXF1ZXN0IGlzIGVucXVldWVkIG9udG8gYSBiYXRjaCB0aGF0XHJcbiAgICAgKiBpcyBzZW50IGFmdGVyIDEwbXMuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIGVucXVldWVSZXF1ZXN0KHJlcXVlc3QpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXguX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBpbmZsaWdodFJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgcmVqZWN0OiB1bmRlZmluZWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZWplY3QgPSByZWplY3Q7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdCYXRjaC5wdXNoKGluZmxpZ2h0UmVxdWVzdCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdCYXRjaC5sZW5ndGggPT09IHRoaXMubWF4QmF0Y2hTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZW5kIGJhdGNoIGltbWVkaWF0ZWx5IGlmIHdlIGFyZSBhdCB0aGUgbWF4aW11bSBiYXRjaCBzaXplLlxyXG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLnNlbmRCYXRjaFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5wZW5kaW5nQmF0Y2hUaW1lcikge1xyXG4gICAgICAgICAgICAgICAgLy8gU2NoZWR1bGUgYmF0Y2ggZm9yIG5leHQgZXZlbnQgbG9vcCArIHNob3J0IGR1cmF0aW9uXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCYXRjaFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbmRCYXRjaFJlcXVlc3QoKSwgREVGQVVMVF9SRVFVRVNUX0JBVENIX0RFTEFZX01TKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZHMgdGhlIGN1cnJlbnRseSBxdWV1ZWQgYmF0Y2hlcyBhbmQgcmVzZXRzIHRoZSBiYXRjaCBhbmQgdGltZXIuIFByb2Nlc3Nlc1xyXG4gICAgICogdGhlIGJhdGNoZWQgcmVzcG9uc2UgcmVzdWx0cyBiYWNrIHRvIHRoZSBvcmlnaW5hbCBwcm9taXNlcy5cclxuICAgICAqL1xyXG4gICAgc2VuZEJhdGNoUmVxdWVzdCgpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXguX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgYmF0Y2ggYW5kIGNsZWFyIGl0LCBzbyBuZXcgcmVxdWVzdHNcclxuICAgICAgICAgICAgLy8gZ28gaW50byB0aGUgbmV4dCBiYXRjaFxyXG4gICAgICAgICAgICBjb25zdCBiYXRjaCA9IHRoaXMucGVuZGluZ0JhdGNoO1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdCYXRjaCA9IFtdO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQmF0Y2hUaW1lcikge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGVuZGluZ0JhdGNoVGltZXIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQmF0Y2hUaW1lciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJlcXVlc3QgYXMgYW4gYXJyYXkgb2YgcmVxdWVzdHNcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IGJhdGNoLm1hcChpbmZsaWdodCA9PiBpbmZsaWdodC5yZXF1ZXN0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZEJhdGNoRm4ocmVxdWVzdCkudGhlbihyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggcmVzdWx0LCBmZWVkIGl0IHRvIHRoZSBjb3JyZWN0IFByb21pc2UsIGRlcGVuZGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gb24gd2hldGhlciBpdCB3YXMgYSBzdWNjZXNzIG9yIGVycm9yXHJcbiAgICAgICAgICAgICAgICBiYXRjaC5mb3JFYWNoKChpbmZsaWdodFJlcXVlc3QsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHJlc3VsdFtpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBheWxvYWQuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IocGF5bG9hZC5lcnJvci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9IHBheWxvYWQuZXJyb3IuY29kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuZGF0YSA9IHBheWxvYWQuZXJyb3IuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZsaWdodFJlcXVlc3QucmVzb2x2ZShwYXlsb2FkLnJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgIGJhdGNoLmZvckVhY2goaW5mbGlnaHRSZXF1ZXN0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpbmZsaWdodFJlcXVlc3QucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogU0RLJ3MgY3VzdG9tIGltcGxlbWVudGF0aW9uIG9mIGV0aGVycy5qcydzICdBbGNoZW15UHJvdmlkZXInLlxyXG4gKlxyXG4gKiBEbyBub3QgY2FsbCB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LiBJbnN0ZWFkLCBpbnN0YW50aWF0ZSBhbiBpbnN0YW5jZSBvZlxyXG4gKiB7QGxpbmsgQWxjaGVteX0gYW5kIGNhbGwge0BsaW5rIEFsY2hlbXkuY29uZmlnLmdldFByb3ZpZGVyKCl9LlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBBbGNoZW15UHJvdmlkZXIgZXh0ZW5kcyBwcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgQVBJIEtleSB0byBhIHN0cmluZy5cclxuICAgICAgICBjb25zdCBhcGlLZXkgPSBBbGNoZW15UHJvdmlkZXIuZ2V0QXBpS2V5KGNvbmZpZy5hcGlLZXkpO1xyXG4gICAgICAgIC8vIEdlbmVyYXRlIG91ciBvd24gY29ubmVjdGlvbiBpbmZvIHdpdGggdGhlIGNvcnJlY3QgZW5kcG9pbnQgVVJMcy5cclxuICAgICAgICBjb25zdCBhbGNoZW15TmV0d29yayA9IEFsY2hlbXlQcm92aWRlci5nZXRBbGNoZW15TmV0d29yayhjb25maWcubmV0d29yayk7XHJcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IEFsY2hlbXlQcm92aWRlci5nZXRBbGNoZW15Q29ubmVjdGlvbkluZm8oYWxjaGVteU5ldHdvcmssIGFwaUtleSwgJ2h0dHAnKTtcclxuICAgICAgICAvLyBJZiBhIGhhcmRjb2RlZCB1cmwgd2FzIHNwZWNpZmllZCBpbiB0aGUgY29uZmlnLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZVxyXG4gICAgICAgIC8vIHByb3ZpZGVkIGFwaUtleSBvciBuZXR3b3JrLlxyXG4gICAgICAgIGlmIChjb25maWcudXJsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29ubmVjdGlvbi51cmwgPSBjb25maWcudXJsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25uZWN0aW9uLnRocm90dGxlTGltaXQgPSBjb25maWcubWF4UmV0cmllcztcclxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIEFsY2hlbXkgbmFtZWQgbmV0d29yayBpbnB1dCB0byB0aGUgbmV0d29yayBuYW1lcyB1c2VkIGJ5XHJcbiAgICAgICAgLy8gZXRoZXJzLiBUaGlzIGFsbG93cyB0aGUgcGFyZW50IHN1cGVyIGNvbnN0cnVjdG9yIGluIEpzb25ScGNQcm92aWRlciB0b1xyXG4gICAgICAgIC8vIGNvcnJlY3RseSBzZXQgdGhlIG5ldHdvcmsuXHJcbiAgICAgICAgY29uc3QgZXRoZXJzTmV0d29yayA9IGluZGV4LkV0aGVyc05ldHdvcmtbYWxjaGVteU5ldHdvcmtdO1xyXG4gICAgICAgIHN1cGVyKGNvbm5lY3Rpb24sIGV0aGVyc05ldHdvcmspO1xyXG4gICAgICAgIHRoaXMuYXBpS2V5ID0gY29uZmlnLmFwaUtleTtcclxuICAgICAgICB0aGlzLm1heFJldHJpZXMgPSBjb25maWcubWF4UmV0cmllcztcclxuICAgICAgICB0aGlzLmJhdGNoUmVxdWVzdHMgPSBjb25maWcuYmF0Y2hSZXF1ZXN0cztcclxuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGluZGl2aWR1YWwgaGVhZGVycyB3aGVuIGNhbGxpbmcgYmF0Y2hcclxuICAgICAgICBjb25zdCBiYXRjaGVyQ29ubmVjdGlvbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25uZWN0aW9uKSwgeyBoZWFkZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29ubmVjdGlvbi5oZWFkZXJzKSwgeyAnQWxjaGVteS1FdGhlcnMtU2RrLU1ldGhvZCc6ICdiYXRjaFNlbmQnIH0pIH0pO1xyXG4gICAgICAgIGNvbnN0IHNlbmRCYXRjaEZuID0gKHJlcXVlc3RzKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB3ZWIuZmV0Y2hKc29uKGJhdGNoZXJDb25uZWN0aW9uLCBKU09OLnN0cmluZ2lmeShyZXF1ZXN0cykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5iYXRjaGVyID0gbmV3IFJlcXVlc3RCYXRjaGVyKHNlbmRCYXRjaEZuKTtcclxuICAgICAgICB0aGlzLm1vZGlmeUZvcm1hdHRlcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGBVcmxKc29uUnBjUHJvdmlkZXIuZ2V0QXBpS2V5YCBtZXRob2QgYXMgaW1wbGVtZW50ZWQgYnlcclxuICAgICAqIGV0aGVycy5qcy4gUmV0dXJucyB0aGUgQVBJIGtleSBmb3IgYW4gQWxjaGVteSBwcm92aWRlci5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0QXBpS2V5KGFwaUtleSkge1xyXG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXguREVGQVVMVF9BTENIRU1ZX0FQSV9LRVk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcGlLZXkgJiYgdHlwZW9mIGFwaUtleSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFwaUtleSAnJHthcGlLZXl9JyBwcm92aWRlZC4gYXBpS2V5IG11c3QgYmUgYSBzdHJpbmcuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcGlLZXk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgYEJhc2VQcm92aWRlci5nZXROZXR3b3JrYCBtZXRob2QgYXMgaW1wbGVtZW50ZWQgYnkgZXRoZXJzLmpzLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgb3ZlcnJpZGUgYWxsb3dzIHRoZSBTREsgdG8gc2V0IHRoZSBwcm92aWRlcidzIG5ldHdvcmsgdG8gdmFsdWVzIG5vdFxyXG4gICAgICogeWV0IHN1cHBvcnRlZCBieSBldGhlcnMuanMuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldE5ldHdvcmsobmV0d29yaykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmV0d29yayA9PT0gJ3N0cmluZycgJiYgbmV0d29yayBpbiBpbmRleC5DdXN0b21OZXR3b3Jrcykge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXguQ3VzdG9tTmV0d29ya3NbbmV0d29ya107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbGwgdGhlIHN0YW5kYXJkIGV0aGVycy5qcyBnZXROZXR3b3JrIG1ldGhvZCBmb3Igb3RoZXIgbmV0d29ya3MuXHJcbiAgICAgICAgcmV0dXJuIG5ldHdvcmtzLmdldE5ldHdvcmsobmV0d29yayk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBgTmV0d29ya2lzaGAgaW5wdXQgdG8gdGhlIG5ldHdvcmsgZW51bSB1c2VkIGJ5IEFsY2hlbXkuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRBbGNoZW15TmV0d29yayhuZXR3b3JrKSB7XHJcbiAgICAgICAgaWYgKG5ldHdvcmsgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXguREVGQVVMVF9ORVRXT1JLO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG5ldHdvcmsgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuZXR3b3JrICcke25ldHdvcmt9JyBwcm92aWRlZC4gTmV0d29yayBtdXN0IGJlIGEgc3RyaW5nLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHdWFyYW50ZWVkIHRoYXQgYHR5cGVvZiBuZXR3b3JrID09PSAnc3RyaW5nYC5cclxuICAgICAgICBjb25zdCBpc1ZhbGlkTmV0d29yayA9IE9iamVjdC52YWx1ZXMoaW5kZXguTmV0d29yaykuaW5jbHVkZXMobmV0d29yayk7XHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkTmV0d29yaykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbmV0d29yayAnJHtuZXR3b3JrfScgcHJvdmlkZWQuIE5ldHdvcmsgbXVzdCBiZSBvbmUgb2Y6IGAgK1xyXG4gICAgICAgICAgICAgICAgYCR7T2JqZWN0LnZhbHVlcyhpbmRleC5OZXR3b3JrKS5qb2luKCcsICcpfS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldHdvcms7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgQ29ubmVjdGlvbkluZm99IG9iamVjdCBjb21wYXRpYmxlIHdpdGggZXRoZXJzIHRoYXQgY29udGFpbnNcclxuICAgICAqIHRoZSBjb3JyZWN0IFVSTHMgZm9yIEFsY2hlbXkuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRBbGNoZW15Q29ubmVjdGlvbkluZm8obmV0d29yaywgYXBpS2V5LCB0eXBlKSB7XHJcbiAgICAgICAgY29uc3QgdXJsID0gdHlwZSA9PT0gJ2h0dHAnXHJcbiAgICAgICAgICAgID8gaW5kZXguZ2V0QWxjaGVteUh0dHBVcmwobmV0d29yaywgYXBpS2V5KVxyXG4gICAgICAgICAgICA6IGluZGV4LmdldEFsY2hlbXlXc1VybChuZXR3b3JrLCBhcGlLZXkpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGhlYWRlcnM6IGluZGV4LklTX0JST1dTRVJcclxuICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgICdBbGNoZW15LUV0aGVycy1TZGstVmVyc2lvbic6IGluZGV4LlZFUlNJT05cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgICAgICdBbGNoZW15LUV0aGVycy1TZGstVmVyc2lvbic6IGluZGV4LlZFUlNJT04sXHJcbiAgICAgICAgICAgICAgICAgICAgJ0FjY2VwdC1FbmNvZGluZyc6ICdnemlwJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWxsb3dHemlwOiB0cnVlLFxyXG4gICAgICAgICAgICB1cmxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIG1ldGhvZCBpbiBldGhlcnMuanMncyBgU3RhdGljSnNvblJwY1Byb3ZpZGVyYCBjbGFzcy4gVGhpc1xyXG4gICAgICogbWV0aG9kIGlzIGNhbGxlZCB3aGVuIGNhbGxpbmcgbWV0aG9kcyBvbiB0aGUgcGFyZW50IGNsYXNzIGBCYXNlUHJvdmlkZXJgLlxyXG4gICAgICpcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBkZXRlY3ROZXR3b3JrKCkge1xyXG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICAgICAgICBkZXRlY3ROZXR3b3JrOiB7IGdldDogKCkgPT4gc3VwZXIuZGV0ZWN0TmV0d29yayB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4Ll9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgbGV0IG5ldHdvcmsgPSB0aGlzLm5ldHdvcms7XHJcbiAgICAgICAgICAgIGlmIChuZXR3b3JrID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIG5ldHdvcmsgPSB5aWVsZCBfc3VwZXIuZGV0ZWN0TmV0d29yay5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFuZXR3b3JrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBuZXR3b3JrIGRldGVjdGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfc3RhcnRQZW5kaW5nKCkge1xyXG4gICAgICAgIGluZGV4LmxvZ1dhcm4oJ1dBUk5JTkc6IEFsY2hlbXkgUHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBwZW5kaW5nIGZpbHRlcnMnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBldGhlcidzIGBpc0NvbW11bml0eVJlc291cmNlKClgIG1ldGhvZC4gUmV0dXJucyB0cnVlIGlmIHRoZVxyXG4gICAgICogY3VycmVudCBhcGkga2V5IGlzIHRoZSBkZWZhdWx0IGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcGlLZXkgPT09IGluZGV4LkRFRkFVTFRfQUxDSEVNWV9BUElfS0VZO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGJhc2Uge0BsaW5rIEpzb25ScGNQcm92aWRlci5zZW5kfSBtZXRob2QgdG8gaW1wbGVtZW50IGN1c3RvbVxyXG4gICAgICogbG9naWMgZm9yIHNlbmRpbmcgcmVxdWVzdHMgdG8gQWxjaGVteS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWV0aG9kIFRoZSBtZXRob2QgbmFtZSB0byB1c2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBUaGUgcGFyYW1ldGVycyB0byB1c2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIC8vIFRPRE86IEFkZCBoZWFkZXJzIGZvciBgcGVyZm9ybSgpYCBvdmVycmlkZS5cclxuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2VuZChtZXRob2QsIHBhcmFtcywgJ3NlbmQnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRE8gTk9UIE1PRElGWS5cclxuICAgICAqXHJcbiAgICAgKiBPcmlnaW5hbCBjb2RlIGNvcGllZCBvdmVyIGZyb20gZXRoZXIuanMncyBgSnNvblJwY1Byb3ZpZGVyLnNlbmQoKWAuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY29waWVkIG92ZXIgZGlyZWN0bHkgaW4gb3JkZXIgdG8gaW1wbGVtZW50IGN1c3RvbSBoZWFkZXJzXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9zZW5kKG1ldGhvZCwgcGFyYW1zLCBtZXRob2ROYW1lLCBmb3JjZUJhdGNoID0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICBtZXRob2QsXHJcbiAgICAgICAgICAgIHBhcmFtcyxcclxuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRJZCsrLFxyXG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gU1RBUlQgTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbm5lY3Rpb24pO1xyXG4gICAgICAgIGNvbm5lY3Rpb24uaGVhZGVyc1snQWxjaGVteS1FdGhlcnMtU2RrLU1ldGhvZCddID0gbWV0aG9kTmFtZTtcclxuICAgICAgICBpZiAodGhpcy5iYXRjaFJlcXVlc3RzIHx8IGZvcmNlQmF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmF0Y2hlci5lbnF1ZXVlUmVxdWVzdChyZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRU5EIE1PRElGSUVEIENPREVcclxuICAgICAgICB0aGlzLmVtaXQoJ2RlYnVnJywge1xyXG4gICAgICAgICAgICBhY3Rpb246ICdyZXF1ZXN0JyxcclxuICAgICAgICAgICAgcmVxdWVzdDogaW5kZXguZGVlcENvcHkocmVxdWVzdCksXHJcbiAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gV2UgY2FuIGV4cGFuZCB0aGlzIGluIHRoZSBmdXR1cmUgdG8gYW55IGNhbGwsIGJ1dCBmb3Igbm93IHRoZXNlXHJcbiAgICAgICAgLy8gYXJlIHRoZSBiaWdnZXN0IHdpbnMgYW5kIGRvIG5vdCByZXF1aXJlIGFueSBzZXJpYWxpemluZyBwYXJhbWV0ZXJzLlxyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gWydldGhfY2hhaW5JZCcsICdldGhfYmxvY2tOdW1iZXInXS5pbmRleE9mKG1ldGhvZCkgPj0gMDtcclxuICAgICAgICBpZiAoY2FjaGUgJiYgdGhpcy5fY2FjaGVbbWV0aG9kXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVbbWV0aG9kXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gd2ViLmZldGNoSnNvbih0aGlzLmNvbm5lY3Rpb24sIEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLCBnZXRSZXN1bHQpLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdkZWJ1ZycsIHtcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ3Jlc3BvbnNlJyxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzdWx0LFxyXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSwgZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RlYnVnJywge1xyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAncmVzcG9uc2UnLFxyXG4gICAgICAgICAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxyXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIENhY2hlIHRoZSBmZXRjaCwgYnV0IGNsZWFyIGl0IG9uIHRoZSBuZXh0IGV2ZW50IGxvb3BcclxuICAgICAgICBpZiAoY2FjaGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FjaGVbbWV0aG9kXSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gVGhpcyBpcyBkb25lIGJ5IGV0aGVycy5cclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlW21ldGhvZF0gPSBudWxsO1xyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBiYXNlIGBGb3JtYXR0ZXJgIGNsYXNzIGluaGVyaXRlZCBmcm9tIGV0aGVycyB0byBzdXBwb3J0XHJcbiAgICAgKiByZXR1cm5pbmcgY3VzdG9tIGZpZWxkcyBpbiBFdGhlcnMgcmVzcG9uc2UgdHlwZXMuXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGNvbnRleHQsIGV0aGVycyBoYXMgYSBgRm9ybWF0dGVyYCBjbGFzcyB0aGF0IGlzIHVzZWQgdG8gZm9ybWF0IHRoZVxyXG4gICAgICogcmVzcG9uc2UgZnJvbSBhIEpTT04tUlBDIHJlcXVlc3QuIEFueSBmaWVsZHMgdGhhdCBhcmUgbm90IGRlZmluZWQgaW4gdGhlXHJcbiAgICAgKiBgRm9ybWF0dGVyYCBjbGFzcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSByZXR1cm5lZCByZXNwb25zZS4gQnkgbW9kaWZ5aW5nIHRoZVxyXG4gICAgICogYEZvcm1hdHRlcmAgY2xhc3MgaW4gdGhpcyBtZXRob2QsIHdlIGNhbiBhZGQgc3VwcG9ydCBmb3IgZmllbGRzIHRoYXQgYXJlXHJcbiAgICAgKiBub3QgZGVmaW5lZCBpbiBldGhlcnMuXHJcbiAgICAgKi9cclxuICAgIG1vZGlmeUZvcm1hdHRlcigpIHtcclxuICAgICAgICB0aGlzLmZvcm1hdHRlci5mb3JtYXRzWydyZWNlaXB0TG9nJ11bJ3JlbW92ZWQnXSA9IHZhbCA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBETyBOT1QgTU9ESUZZLlxyXG4gKlxyXG4gKiBPcmlnaW5hbCBjb2RlIGNvcGllZCBvdmVyIGZyb20gZXRoZXIuanMnc1xyXG4gKiBgQGV0aGVyc3Byb2plY3Qvd2ViL3NyYy50cy9pbmRleC50c2AuIFVzZWQgdG8gc3VwcG9ydFxyXG4gKiB7QGxpbmsgQWxjaGVteVByb3ZpZGVyLl9zZW5kfSwgd2hpY2ggaXMgYWxzbyBjb3BpZWQgb3Zlci5cclxuICovXHJcbmZ1bmN0aW9uIGdldFJlc3VsdChwYXlsb2FkKSB7XHJcbiAgICBpZiAocGF5bG9hZC5lcnJvcikge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKHBheWxvYWQuZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgZXJyb3IuY29kZSA9IHBheWxvYWQuZXJyb3IuY29kZTtcclxuICAgICAgICBlcnJvci5kYXRhID0gcGF5bG9hZC5lcnJvci5kYXRhO1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBheWxvYWQucmVzdWx0O1xyXG59XG5cbmV4cG9ydHMuQWxjaGVteVByb3ZpZGVyID0gQWxjaGVteVByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxjaGVteS1wcm92aWRlci1lNTM5ZTdkMC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJpbmRleCIsInJlcXVpcmUiLCJuZXR3b3JrcyIsInByb3ZpZGVycyIsIndlYiIsIkRFRkFVTFRfTUFYX1JFUVVFU1RfQkFUQ0hfU0laRSIsIkRFRkFVTFRfUkVRVUVTVF9CQVRDSF9ERUxBWV9NUyIsIlJlcXVlc3RCYXRjaGVyIiwiY29uc3RydWN0b3IiLCJzZW5kQmF0Y2hGbiIsIm1heEJhdGNoU2l6ZSIsInBlbmRpbmdCYXRjaCIsImVucXVldWVSZXF1ZXN0IiwicmVxdWVzdCIsIl9fYXdhaXRlciIsImluZmxpZ2h0UmVxdWVzdCIsInJlc29sdmUiLCJ1bmRlZmluZWQiLCJyZWplY3QiLCJwcm9taXNlIiwiUHJvbWlzZSIsInB1c2giLCJsZW5ndGgiLCJzZW5kQmF0Y2hSZXF1ZXN0IiwicGVuZGluZ0JhdGNoVGltZXIiLCJzZXRUaW1lb3V0IiwiYmF0Y2giLCJjbGVhclRpbWVvdXQiLCJtYXAiLCJpbmZsaWdodCIsInRoZW4iLCJyZXN1bHQiLCJmb3JFYWNoIiwicGF5bG9hZCIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiY29kZSIsImRhdGEiLCJBbGNoZW15UHJvdmlkZXIiLCJKc29uUnBjUHJvdmlkZXIiLCJjb25maWciLCJhcGlLZXkiLCJnZXRBcGlLZXkiLCJhbGNoZW15TmV0d29yayIsImdldEFsY2hlbXlOZXR3b3JrIiwibmV0d29yayIsImNvbm5lY3Rpb24iLCJnZXRBbGNoZW15Q29ubmVjdGlvbkluZm8iLCJ1cmwiLCJ0aHJvdHRsZUxpbWl0IiwibWF4UmV0cmllcyIsImV0aGVyc05ldHdvcmsiLCJFdGhlcnNOZXR3b3JrIiwiYmF0Y2hSZXF1ZXN0cyIsImJhdGNoZXJDb25uZWN0aW9uIiwiT2JqZWN0IiwiYXNzaWduIiwiaGVhZGVycyIsInJlcXVlc3RzIiwiZmV0Y2hKc29uIiwiSlNPTiIsInN0cmluZ2lmeSIsImJhdGNoZXIiLCJtb2RpZnlGb3JtYXR0ZXIiLCJERUZBVUxUX0FMQ0hFTVlfQVBJX0tFWSIsImdldE5ldHdvcmsiLCJDdXN0b21OZXR3b3JrcyIsIkRFRkFVTFRfTkVUV09SSyIsImlzVmFsaWROZXR3b3JrIiwidmFsdWVzIiwiTmV0d29yayIsImluY2x1ZGVzIiwiam9pbiIsInR5cGUiLCJnZXRBbGNoZW15SHR0cFVybCIsImdldEFsY2hlbXlXc1VybCIsIklTX0JST1dTRVIiLCJWRVJTSU9OIiwiYWxsb3dHemlwIiwiZGV0ZWN0TmV0d29yayIsIl9zdXBlciIsImNyZWF0ZSIsImdldCIsImNhbGwiLCJfc3RhcnRQZW5kaW5nIiwibG9nV2FybiIsImlzQ29tbXVuaXR5UmVzb3VyY2UiLCJzZW5kIiwibWV0aG9kIiwicGFyYW1zIiwiX3NlbmQiLCJtZXRob2ROYW1lIiwiZm9yY2VCYXRjaCIsImlkIiwiX25leHRJZCIsImpzb25ycGMiLCJlbWl0IiwiYWN0aW9uIiwiZGVlcENvcHkiLCJwcm92aWRlciIsImNhY2hlIiwiaW5kZXhPZiIsIl9jYWNoZSIsImdldFJlc3VsdCIsInJlc3BvbnNlIiwiZm9ybWF0dGVyIiwiZm9ybWF0cyIsInZhbCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/alchemy-sdk/dist/cjs/alchemy-provider-e539e7d0.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/alchemy-sdk/dist/cjs/alchemy-websocket-provider-d921db84.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/alchemy-sdk/dist/cjs/alchemy-websocket-provider-d921db84.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar index = __webpack_require__(/*! ./index-b1f4a2d9.js */ \"(ssr)/./node_modules/alchemy-sdk/dist/cjs/index-b1f4a2d9.js\");\nvar SturdyWebSocket = __webpack_require__(/*! sturdy-websocket */ \"(ssr)/./node_modules/sturdy-websocket/dist/index.js\");\nvar bignumber = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/index.js\");\nvar networks = __webpack_require__(/*! @ethersproject/networks */ \"(ssr)/./node_modules/@ethersproject/networks/lib.esm/index.js\");\nvar providers = __webpack_require__(/*! @ethersproject/providers */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/index.js\");\nvar alchemyProvider = __webpack_require__(/*! ./alchemy-provider-e539e7d0.js */ \"(ssr)/./node_modules/alchemy-sdk/dist/cjs/alchemy-provider-e539e7d0.js\");\n__webpack_require__(/*! ./api/utils */ \"(ssr)/./node_modules/alchemy-sdk/dist/cjs/api/utils.js\");\n__webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/index.js\");\n__webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/./node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/wallet */ \"(ssr)/./node_modules/@ethersproject/wallet/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/contracts */ \"(ssr)/./node_modules/@ethersproject/contracts/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/web */ \"(ssr)/./node_modules/@ethersproject/web/lib.esm/index.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nvar SturdyWebSocket__default = /*#__PURE__*/ _interopDefaultLegacy(SturdyWebSocket);\n/**\r\n * The maximum number of blocks to backfill. If more than this many blocks have\r\n * been missed, then we'll sadly miss data, but we want to make sure we don't\r\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\r\n */ const MAX_BACKFILL_BLOCKS = 120;\n/**\r\n * The WebsocketBackfiller fetches events that were sent since a provided block\r\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\r\n * events that were transmitted while the websocket connection was down.\r\n *\r\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\r\n *\r\n * @internal\r\n */ class WebsocketBackfiller {\n    constructor(provider){\n        this.provider = provider;\n        // TODO: Use HTTP provider to do backfill.\n        this.maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\n    }\n    /**\r\n     * Runs backfill for `newHeads` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param previousHeads Previous head requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     * @returns A list of `newHeads` events that were sent since the last backfill.\r\n     */ getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            throwIfCancelled(isCancelled);\n            const toBlockNumber = yield this.getBlockNumber();\n            throwIfCancelled(isCancelled);\n            // If there are no previous heads to fetch, return new heads since\n            // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\n            if (previousHeads.length === 0) {\n                return this.getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\n            }\n            // If the last emitted event is too far back in the past, there's no need\n            // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\n            // new heads.\n            const lastSeenBlockNumber = index.fromHex(previousHeads[previousHeads.length - 1].number);\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n            if (lastSeenBlockNumber <= minBlockNumber) {\n                return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n            }\n            // To capture all `newHeads` events, return all head events from the last\n            // seen block number to current + any of the previous heads that were re-orged.\n            const reorgHeads = yield this.getReorgHeads(isCancelled, previousHeads);\n            throwIfCancelled(isCancelled);\n            const intermediateHeads = yield this.getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1);\n            throwIfCancelled(isCancelled);\n            return [\n                ...reorgHeads,\n                ...intermediateHeads\n            ];\n        });\n    }\n    /**\r\n     * Runs backfill for `logs` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param filter The filter object that accompanies a logs subscription.\r\n     * @param previousLogs Previous log requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     */ getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            throwIfCancelled(isCancelled);\n            const toBlockNumber = yield this.getBlockNumber();\n            throwIfCancelled(isCancelled);\n            // If there are no previous logs to fetch, return new logs since\n            // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\n            if (previousLogs.length === 0) {\n                return this.getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\n            }\n            // If the last emitted log is too far back in the past, there's no need\n            // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\n            // worth of logs.\n            const lastSeenBlockNumber = index.fromHex(previousLogs[previousLogs.length - 1].blockNumber);\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n            if (lastSeenBlockNumber < minBlockNumber) {\n                return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n            }\n            // Return all log events that have happened along with log events that have\n            // been removed due to a chain reorg.\n            const commonAncestor = yield this.getCommonAncestor(isCancelled, previousLogs);\n            throwIfCancelled(isCancelled);\n            // All previous logs with a block number greater than the common ancestor\n            // were part of a re-org, so mark them as such.\n            const removedLogs = previousLogs.filter((log)=>index.fromHex(log.blockNumber) > commonAncestor.blockNumber).map((log)=>Object.assign(Object.assign({}, log), {\n                    removed: true\n                }));\n            // If no common ancestor was found, start backfill from the oldest log's\n            // block number.\n            const fromBlockInclusive = commonAncestor.blockNumber === Number.NEGATIVE_INFINITY ? index.fromHex(previousLogs[0].blockNumber) : commonAncestor.blockNumber;\n            let addedLogs = yield this.getLogsInRange(filter, fromBlockInclusive, toBlockNumber + 1);\n            // De-dupe any logs that were already emitted.\n            addedLogs = addedLogs.filter((log)=>log && (index.fromHex(log.blockNumber) > commonAncestor.blockNumber || index.fromHex(log.logIndex) > commonAncestor.logIndex));\n            throwIfCancelled(isCancelled);\n            return [\n                ...removedLogs,\n                ...addedLogs\n            ];\n        });\n    }\n    /**\r\n     * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */ setMaxBackfillBlock(newMax) {\n        this.maxBackfillBlocks = newMax;\n    }\n    /**\r\n     * Gets the current block number as a number.\r\n     *\r\n     * @private\r\n     */ getBlockNumber() {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            const blockNumberHex = yield this.provider.send(\"eth_blockNumber\");\n            return index.fromHex(blockNumberHex);\n        });\n    }\n    /**\r\n     * Gets all `newHead` events in the provided range. Note that the returned\r\n     * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\r\n     * that were part of a re-org.\r\n     *\r\n     * @private\r\n     */ getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            if (fromBlockInclusive >= toBlockExclusive) {\n                return [];\n            }\n            const batchParts = [];\n            for(let i = fromBlockInclusive; i < toBlockExclusive; i++){\n                batchParts.push({\n                    method: \"eth_getBlockByNumber\",\n                    params: [\n                        index.toHex(i),\n                        false\n                    ]\n                });\n            }\n            // TODO: handle errors\n            const blockHeads = yield this.provider.sendBatch(batchParts);\n            return blockHeads.map(toNewHeadsEvent);\n        });\n    }\n    /**\r\n     * Returns all heads that were part of a reorg event.\r\n     *\r\n     * @private\r\n     */ getReorgHeads(isCancelled, previousHeads) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            const result = [];\n            // Iterate from the most recent head backwards in order to find the first\n            // block that was part of a re-org.\n            for(let i = previousHeads.length - 1; i >= 0; i--){\n                const oldEvent = previousHeads[i];\n                const blockHead = yield this.getBlockByNumber(index.fromHex(oldEvent.number));\n                throwIfCancelled(isCancelled);\n                // If the hashes match, then current head in the iteration was not re-orged.\n                if (oldEvent.hash === blockHead.hash) {\n                    break;\n                }\n                result.push(toNewHeadsEvent(blockHead));\n            }\n            return result.reverse();\n        });\n    }\n    /**\r\n     * Simple wrapper around `eth_getBlockByNumber` that returns the complete\r\n     * block information for the provided block number.\r\n     *\r\n     * @private\r\n     */ getBlockByNumber(blockNumber) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            return this.provider.send(\"eth_getBlockByNumber\", [\n                index.toHex(blockNumber),\n                false\n            ]);\n        });\n    }\n    /**\r\n     * Given a list of previous log events, finds the common block number from the\r\n     * logs that matches the block head.\r\n     *\r\n     * This can be used to identify which logs are part of a re-org.\r\n     *\r\n     * Returns 1 less than the oldest log's block number if no common ancestor was found.\r\n     *\r\n     * @private\r\n     */ getCommonAncestor(isCancelled, previousLogs) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            // Iterate from the most recent head backwards in order to find the first\n            // block that was part of a re-org.\n            let blockHead = yield this.getBlockByNumber(index.fromHex(previousLogs[previousLogs.length - 1].blockNumber));\n            throwIfCancelled(isCancelled);\n            for(let i = previousLogs.length - 1; i >= 0; i--){\n                const oldLog = previousLogs[i];\n                // Ensure that updated blocks are fetched every time the log's block number\n                // changes.\n                if (oldLog.blockNumber !== blockHead.number) {\n                    blockHead = yield this.getBlockByNumber(index.fromHex(oldLog.blockNumber));\n                }\n                // Since logs are ordered in ascending order, the first log that matches\n                // the hash should be the largest logIndex.\n                if (oldLog.blockHash === blockHead.hash) {\n                    return {\n                        blockNumber: index.fromHex(oldLog.blockNumber),\n                        logIndex: index.fromHex(oldLog.logIndex)\n                    };\n                }\n            }\n            return {\n                blockNumber: Number.NEGATIVE_INFINITY,\n                logIndex: Number.NEGATIVE_INFINITY\n            };\n        });\n    }\n    /**\r\n     * Gets all `logs` events in the provided range. Note that the returned logs\r\n     * do not include removed logs.\r\n     *\r\n     * @private\r\n     */ getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            if (fromBlockInclusive >= toBlockExclusive) {\n                return [];\n            }\n            const rangeFilter = Object.assign(Object.assign({}, filter), {\n                fromBlock: index.toHex(fromBlockInclusive),\n                toBlock: index.toHex(toBlockExclusive - 1)\n            });\n            return this.provider.send(\"eth_getLogs\", [\n                rangeFilter\n            ]);\n        });\n    }\n}\nfunction toNewHeadsEvent(head) {\n    const result = Object.assign({}, head);\n    delete result.totalDifficulty;\n    delete result.transactions;\n    delete result.uncles;\n    return result;\n}\nfunction dedupeNewHeads(events) {\n    return dedupe(events, (event)=>event.hash);\n}\nfunction dedupeLogs(events) {\n    return dedupe(events, (event)=>`${event.blockHash}/${event.logIndex}`);\n}\nfunction dedupe(items, getKey) {\n    const keysSeen = new Set();\n    const result = [];\n    items.forEach((item)=>{\n        const key = getKey(item);\n        if (!keysSeen.has(key)) {\n            keysSeen.add(key);\n            result.push(item);\n        }\n    });\n    return result;\n}\nconst CANCELLED = new Error(\"Cancelled\");\nfunction throwIfCancelled(isCancelled) {\n    if (isCancelled()) {\n        throw CANCELLED;\n    }\n}\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\r\n * Subscriptions have a memory of recent events they have sent so that in the\r\n * event that they disconnect and need to backfill, they can detect re-orgs.\r\n * Keep a buffer that goes back at least these many blocks, the maximum amount\r\n * at which we might conceivably see a re-org.\r\n *\r\n * Note that while our buffer goes back this many blocks, it may contain more\r\n * than this many elements, since in the case of logs subscriptions more than\r\n * one event may be emitted for a block.\r\n */ const RETAINED_EVENT_BLOCK_COUNT = 10;\n/**\r\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\r\n *\r\n * @public\r\n */ class AlchemyWebSocketProvider extends providers.WebSocketProvider {\n    /** @internal */ constructor(config, wsConstructor){\n        var _a;\n        // Normalize the API Key to a string.\n        const apiKey = alchemyProvider.AlchemyProvider.getApiKey(config.apiKey);\n        // Generate our own connection info with the correct endpoint URLs.\n        const alchemyNetwork = alchemyProvider.AlchemyProvider.getAlchemyNetwork(config.network);\n        const connection = alchemyProvider.AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, \"wss\");\n        const protocol = `alchemy-sdk-${index.VERSION}`;\n        // Use the provided config URL override if it exists, otherwise use the created one.\n        const ws = new SturdyWebSocket__default[\"default\"]((_a = config.url) !== null && _a !== void 0 ? _a : connection.url, protocol, {\n            wsConstructor: wsConstructor !== null && wsConstructor !== void 0 ? wsConstructor : getWebsocketConstructor()\n        });\n        // Normalize the Alchemy named network input to the network names used by\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\n        // correctly set the network.\n        const ethersNetwork = index.EthersNetwork[alchemyNetwork];\n        super(ws, ethersNetwork);\n        this._events = [];\n        // In the case of a WebSocket reconnection, all subscriptions are lost and we\n        // create new ones to replace them, but we want to create the illusion that\n        // the original subscriptions persist. Thus, maintain a mapping from the\n        // \"virtual\" subscription ids which are visible to the consumer to the\n        // \"physical\" subscription ids of the actual connections. This terminology is\n        // borrowed from virtual and physical memory, which has a similar mapping.\n        /** @internal */ this.virtualSubscriptionsById = new Map();\n        /** @internal */ this.virtualIdsByPhysicalId = new Map();\n        /**\r\n         * The underlying ethers {@link WebSocketProvider} already handles and emits\r\n         * messages. To allow backfilling, track all messages that are emitted.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */ this.handleMessage = (event)=>{\n            const message = JSON.parse(event.data);\n            if (!isSubscriptionEvent(message)) {\n                return;\n            }\n            const physicalId = message.params.subscription;\n            const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n            if (!virtualId) {\n                return;\n            }\n            const subscription = this.virtualSubscriptionsById.get(virtualId);\n            if (subscription.method !== \"eth_subscribe\") {\n                return;\n            }\n            switch(subscription.params[0]){\n                case \"newHeads\":\n                    {\n                        const newHeadsSubscription = subscription;\n                        const newHeadsMessage = message;\n                        const { isBackfilling, backfillBuffer } = newHeadsSubscription;\n                        const { result } = newHeadsMessage.params;\n                        if (isBackfilling) {\n                            addToNewHeadsEventsBuffer(backfillBuffer, result);\n                        } else if (physicalId !== virtualId) {\n                            // In the case of a re-opened subscription, ethers will not emit the\n                            // event, so the SDK has to.\n                            this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n                        } else {\n                            // Ethers subscription mapping will emit the event, just store it.\n                            this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\n                        }\n                        break;\n                    }\n                case \"logs\":\n                    {\n                        const logsSubscription = subscription;\n                        const logsMessage = message;\n                        const { isBackfilling, backfillBuffer } = logsSubscription;\n                        const { result } = logsMessage.params;\n                        if (isBackfilling) {\n                            addToLogsEventsBuffer(backfillBuffer, result);\n                        } else if (virtualId !== physicalId) {\n                            this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n                        } else {\n                            this.rememberEvent(virtualId, result, getLogsBlockNumber);\n                        }\n                        break;\n                    }\n                default:\n                    if (physicalId !== virtualId) {\n                        // In the case of a re-opened subscription, ethers will not emit the\n                        // event, so the SDK has to.\n                        const { result } = message.params;\n                        this.emitEvent(virtualId, result);\n                    }\n            }\n        };\n        /**\r\n         * When the websocket connection reopens:\r\n         *\r\n         * 1. Resubscribe to all existing subscriptions and start backfilling\r\n         * 2. Restart heart beat.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */ this.handleReopen = ()=>{\n            this.virtualIdsByPhysicalId.clear();\n            const { cancel, isCancelled } = makeCancelToken();\n            this.cancelBackfill = cancel;\n            for (const subscription of this.virtualSubscriptionsById.values()){\n                void (()=>index.__awaiter(this, void 0, void 0, function*() {\n                        try {\n                            yield this.resubscribeAndBackfill(isCancelled, subscription);\n                        } catch (error) {\n                            if (!isCancelled()) {\n                                console.error(`Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`, error);\n                            }\n                        }\n                    }))();\n            }\n            this.startHeartbeat();\n        };\n        /**\r\n         * Cancels the heartbeat and any pending backfills being performed. This is\r\n         * called when the websocket connection goes down or is disconnected.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */ this.stopHeartbeatAndBackfill = ()=>{\n            if (this.heartbeatIntervalId != null) {\n                clearInterval(this.heartbeatIntervalId);\n                this.heartbeatIntervalId = undefined;\n            }\n            this.cancelBackfill();\n        };\n        this.apiKey = apiKey;\n        // Start heartbeat and backfiller for the websocket connection.\n        this.backfiller = new WebsocketBackfiller(this);\n        this.addSocketListeners();\n        this.startHeartbeat();\n        this.cancelBackfill = index.noop;\n    }\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ static getNetwork(network) {\n        if (typeof network === \"string\" && network in index.CustomNetworks) {\n            return index.CustomNetworks[network];\n        }\n        // Call the standard ethers.js getNetwork method for other networks.\n        return networks.getNetwork(network);\n    }\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based subscriptions.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */ // TODO: Override `Listener` type to get type autocompletions.\n    on(eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    }\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based\r\n     * subscriptions. Adds a listener to the triggered for only the next\r\n     * {@link eventName} event, after which it will be removed.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */ // TODO: Override `Listener` type to get type autocompletions.\n    once(eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    }\n    /**\r\n     * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n     * listener is provided, all listeners for the event will be removed.\r\n     *\r\n     * @param eventName Event to unlisten to.\r\n     * @param listener The listener function to remove.\r\n     * @override\r\n     * @public\r\n     */ off(eventName, listener) {\n        if (index.isAlchemyEvent(eventName)) {\n            return this._off(eventName, listener);\n        } else {\n            return super.off(eventName, listener);\n        }\n    }\n    /**\r\n     * Remove all listeners for the provided {@link eventName} event. If no event\r\n     * is provided, all events and their listeners are removed.\r\n     *\r\n     * @param eventName The event to remove all listeners for.\r\n     * @override\r\n     * @public\r\n     */ removeAllListeners(eventName) {\n        if (eventName !== undefined && index.isAlchemyEvent(eventName)) {\n            return this._removeAllListeners(eventName);\n        } else {\n            return super.removeAllListeners(eventName);\n        }\n    }\n    /**\r\n     * Returns the number of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, the total number of listeners for all events is returned.\r\n     *\r\n     * @param eventName The event to get the number of listeners for.\r\n     * @public\r\n     * @override\r\n     */ listenerCount(eventName) {\n        if (eventName !== undefined && index.isAlchemyEvent(eventName)) {\n            return this._listenerCount(eventName);\n        } else {\n            return super.listenerCount(eventName);\n        }\n    }\n    /**\r\n     * Returns an array of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, all listeners will be included.\r\n     *\r\n     * @param eventName The event to get the listeners for.\r\n     * @public\r\n     * @override\r\n     */ listeners(eventName) {\n        if (eventName !== undefined && index.isAlchemyEvent(eventName)) {\n            return this._listeners(eventName);\n        } else {\n            return super.listeners(eventName);\n        }\n    }\n    /**\r\n     * Overrides the method in `BaseProvider` in order to properly format the\r\n     * Alchemy subscription events.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ _addEventListener(eventName, listener, once) {\n        if (index.isAlchemyEvent(eventName)) {\n            index.verifyAlchemyEventName(eventName);\n            const event = new index.EthersEvent(index.getAlchemyEventTag(eventName), listener, once);\n            this._events.push(event);\n            this._startEvent(event);\n            return this;\n        } else {\n            return super._addEventListener(eventName, listener, once);\n        }\n    }\n    /**\r\n     * Overrides the `_startEvent()` method in ethers.js's\r\n     * {@link WebSocketProvider} to include additional alchemy methods.\r\n     *\r\n     * @param event\r\n     * @override\r\n     * @internal\r\n     */ _startEvent(event) {\n        // Check if the event type is a custom Alchemy subscription.\n        const customLogicTypes = [\n            ...index.ALCHEMY_EVENT_TYPES,\n            \"block\",\n            \"filter\"\n        ];\n        if (customLogicTypes.includes(event.type)) {\n            this.customStartEvent(event);\n        } else {\n            super._startEvent(event);\n        }\n    }\n    /**\r\n     * Overridden from ethers.js's {@link WebSocketProvider}\r\n     *\r\n     * Modified in order to add mappings for backfilling.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ _subscribe(tag, param, processFunc, event) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            let subIdPromise = this._subIds[tag];\n            // BEGIN MODIFIED CODE\n            const startingBlockNumber = yield this.getBlockNumber();\n            // END MODIFIED CODE\n            if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then((param)=>{\n                    return this.send(\"eth_subscribe\", param);\n                });\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            // BEGIN MODIFIED CODE\n            const resolvedParams = yield Promise.all(param);\n            this.virtualSubscriptionsById.set(subId, {\n                event: event,\n                method: \"eth_subscribe\",\n                params: resolvedParams,\n                startingBlockNumber,\n                virtualId: subId,\n                physicalId: subId,\n                sentEvents: [],\n                isBackfilling: false,\n                backfillBuffer: []\n            });\n            this.virtualIdsByPhysicalId.set(subId, subId);\n            // END MODIFIED CODE\n            this._subs[subId] = {\n                tag,\n                processFunc\n            };\n        });\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ emit(eventName, ...args) {\n        if (index.isAlchemyEvent(eventName)) {\n            let result = false;\n            const stopped = [];\n            // This line is the only modified line from the original method.\n            const eventTag = index.getAlchemyEventTag(eventName);\n            this._events = this._events.filter((event)=>{\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                setTimeout(()=>{\n                    event.listener.apply(this, args);\n                }, 0);\n                result = true;\n                if (event.once) {\n                    stopped.push(event);\n                    return false;\n                }\n                return true;\n            });\n            stopped.forEach((event)=>{\n                this._stopEvent(event);\n            });\n            return result;\n        } else {\n            return super.emit(eventName, ...args);\n        }\n    }\n    /** @internal */ sendBatch(parts) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            let nextId = 0;\n            const payload = parts.map(({ method, params })=>{\n                return {\n                    method,\n                    params,\n                    jsonrpc: \"2.0\",\n                    id: `alchemy-sdk:${nextId++}`\n                };\n            });\n            return this.sendBatchConcurrently(payload);\n        });\n    }\n    /** @override */ destroy() {\n        this.removeSocketListeners();\n        this.stopHeartbeatAndBackfill();\n        return super.destroy();\n    }\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */ isCommunityResource() {\n        return this.apiKey === index.DEFAULT_ALCHEMY_API_KEY;\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\r\n     *\r\n     * This method is copied over directly in order to support Alchemy's\r\n     * subscription type by allowing the provider to properly stop Alchemy's\r\n     * subscription events.\r\n     *\r\n     * @internal\r\n     */ _stopEvent(event) {\n        let tag = event.tag;\n        // START MODIFIED CODE\n        if (index.ALCHEMY_EVENT_TYPES.includes(event.type)) {\n            // There are remaining pending transaction listeners.\n            if (this._events.filter((e)=>index.ALCHEMY_EVENT_TYPES.includes(e.type)).length) {\n                return;\n            }\n        // END MODIFIED CODE\n        } else if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e)=>e.type === \"tx\").length) {\n                return;\n            }\n            tag = \"tx\";\n        } else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        const subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        void subId.then((subId)=>{\n            if (!this._subs[subId]) {\n                return;\n            }\n            delete this._subs[subId];\n            void this.send(\"eth_unsubscribe\", [\n                subId\n            ]);\n        });\n    }\n    /** @internal */ addSocketListeners() {\n        this._websocket.addEventListener(\"message\", this.handleMessage);\n        this._websocket.addEventListener(\"reopen\", this.handleReopen);\n        this._websocket.addEventListener(\"down\", this.stopHeartbeatAndBackfill);\n    }\n    /** @internal */ removeSocketListeners() {\n        this._websocket.removeEventListener(\"message\", this.handleMessage);\n        this._websocket.removeEventListener(\"reopen\", this.handleReopen);\n        this._websocket.removeEventListener(\"down\", this.stopHeartbeatAndBackfill);\n    }\n    /**\r\n     * Reopens the backfill based on\r\n     *\r\n     * @param isCancelled\r\n     * @param subscription\r\n     * @internal\r\n     */ resubscribeAndBackfill(isCancelled, subscription) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            const { virtualId, method, params, sentEvents, backfillBuffer, startingBlockNumber } = subscription;\n            subscription.isBackfilling = true;\n            backfillBuffer.length = 0;\n            try {\n                const physicalId = yield this.send(method, params);\n                throwIfCancelled(isCancelled);\n                subscription.physicalId = physicalId;\n                this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n                switch(params[0]){\n                    case \"newHeads\":\n                        {\n                            const backfillEvents = yield withBackoffRetries(()=>withTimeout(this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, ()=>!isCancelled());\n                            throwIfCancelled(isCancelled);\n                            const events = dedupeNewHeads([\n                                ...backfillEvents,\n                                ...backfillBuffer\n                            ]);\n                            events.forEach((event)=>this.emitNewHeadsEvent(virtualId, event));\n                            break;\n                        }\n                    case \"logs\":\n                        {\n                            const filter = params[1] || {};\n                            const backfillEvents = yield withBackoffRetries(()=>withTimeout(this.backfiller.getLogsBackfill(isCancelled, filter, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, ()=>!isCancelled());\n                            throwIfCancelled(isCancelled);\n                            const events = dedupeLogs([\n                                ...backfillEvents,\n                                ...backfillBuffer\n                            ]);\n                            events.forEach((event)=>this.emitLogsEvent(virtualId, event));\n                            break;\n                        }\n                    default:\n                        break;\n                }\n            } finally{\n                subscription.isBackfilling = false;\n                backfillBuffer.length = 0;\n            }\n        });\n    }\n    /** @internal */ emitNewHeadsEvent(virtualId, result) {\n        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n    }\n    /** @internal */ emitLogsEvent(virtualId, result) {\n        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n    }\n    /**\r\n     * Emits an event to consumers, but also remembers it in its subscriptions's\r\n     * `sentEvents` buffer so that we can detect re-orgs if the connection drops\r\n     * and needs to be reconnected.\r\n     *\r\n     * @internal\r\n     */ emitAndRememberEvent(virtualId, result, getBlockNumber) {\n        this.rememberEvent(virtualId, result, getBlockNumber);\n        this.emitEvent(virtualId, result);\n    }\n    emitEvent(virtualId, result) {\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\n        if (!subscription) {\n            return;\n        }\n        this.emitGenericEvent(subscription, result);\n    }\n    /** @internal */ rememberEvent(virtualId, result, getBlockNumber) {\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\n        if (!subscription) {\n            return;\n        }\n        // Web3 modifies these event objects once we pass them on (changing hex\n        // numbers to numbers). We want the original event, so make a defensive\n        // copy.\n        addToPastEventsBuffer(subscription.sentEvents, Object.assign({}, result), getBlockNumber);\n    }\n    /** @internal */ emitGenericEvent(subscription, result) {\n        const emitFunction = this.emitProcessFn(subscription.event);\n        emitFunction(result);\n    }\n    /**\r\n     * Starts a heartbeat that pings the websocket server periodically to ensure\r\n     * that the connection stays open.\r\n     *\r\n     * @internal\r\n     */ startHeartbeat() {\n        if (this.heartbeatIntervalId != null) {\n            return;\n        }\n        this.heartbeatIntervalId = setInterval(()=>index.__awaiter(this, void 0, void 0, function*() {\n                try {\n                    yield withTimeout(this.send(\"net_version\"), HEARTBEAT_WAIT_TIME);\n                } catch (_a) {\n                    this._websocket.reconnect();\n                }\n            }), HEARTBEAT_INTERVAL);\n    }\n    /**\r\n     * This method sends the batch concurrently as individual requests rather than\r\n     * as a batch, which was the original implementation. The original batch logic\r\n     * is preserved in this implementation in order for faster porting.\r\n     *\r\n     * @param payload\r\n     * @internal\r\n     */ // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\n    // TODO(errors): Use allSettled() once we have more error handling.\n    sendBatchConcurrently(payload) {\n        return index.__awaiter(this, void 0, void 0, function*() {\n            return Promise.all(payload.map((req)=>this.send(req.method, req.params)));\n        });\n    }\n    /** @internal */ customStartEvent(event) {\n        if (event.type === index.ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n            const { fromAddress, toAddress, hashesOnly } = event;\n            void this._subscribe(event.tag, [\n                index.AlchemySubscription.PENDING_TRANSACTIONS,\n                {\n                    fromAddress,\n                    toAddress,\n                    hashesOnly\n                }\n            ], this.emitProcessFn(event), event);\n        } else if (event.type === index.ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n            const { addresses, includeRemoved, hashesOnly } = event;\n            void this._subscribe(event.tag, [\n                index.AlchemySubscription.MINED_TRANSACTIONS,\n                {\n                    addresses,\n                    includeRemoved,\n                    hashesOnly\n                }\n            ], this.emitProcessFn(event), event);\n        } else if (event.type === \"block\") {\n            void this._subscribe(\"block\", [\n                \"newHeads\"\n            ], this.emitProcessFn(event), event);\n        } else if (event.type === \"filter\") {\n            void this._subscribe(event.tag, [\n                \"logs\",\n                this._getFilter(event.filter)\n            ], this.emitProcessFn(event), event);\n        }\n    }\n    /** @internal */ emitProcessFn(event) {\n        switch(event.type){\n            case index.ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\n                return (result)=>this.emit({\n                        method: index.AlchemySubscription.PENDING_TRANSACTIONS,\n                        fromAddress: event.fromAddress,\n                        toAddress: event.toAddress,\n                        hashesOnly: event.hashesOnly\n                    }, result);\n            case index.ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\n                return (result)=>this.emit({\n                        method: index.AlchemySubscription.MINED_TRANSACTIONS,\n                        addresses: event.addresses,\n                        includeRemoved: event.includeRemoved,\n                        hashesOnly: event.hashesOnly\n                    }, result);\n            case \"block\":\n                return (result)=>{\n                    const blockNumber = bignumber.BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                };\n            case \"filter\":\n                return (result)=>{\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                };\n            default:\n                throw new Error(\"Invalid event type to `emitProcessFn()`\");\n        }\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.off()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */ _off(eventName, listener) {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n        const stopped = [];\n        let found = false;\n        const eventTag = index.getAlchemyEventTag(eventName);\n        this._events = this._events.filter((event)=>{\n            if (event.tag !== eventTag || event.listener != listener) {\n                return true;\n            }\n            if (found) {\n                return true;\n            }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach((event)=>{\n            this._stopEvent(event);\n        });\n        return this;\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */ _removeAllListeners(eventName) {\n        let stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        } else {\n            const eventTag = index.getAlchemyEventTag(eventName);\n            this._events = this._events.filter((event)=>{\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach((event)=>{\n            this._stopEvent(event);\n        });\n        return this;\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */ _listenerCount(eventName) {\n        if (!eventName) {\n            return this._events.length;\n        }\n        const eventTag = index.getAlchemyEventTag(eventName);\n        return this._events.filter((event)=>{\n            return event.tag === eventTag;\n        }).length;\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */ _listeners(eventName) {\n        if (eventName == null) {\n            return this._events.map((event)=>event.listener);\n        }\n        const eventTag = index.getAlchemyEventTag(eventName);\n        return this._events.filter((event)=>event.tag === eventTag).map((event)=>event.listener);\n    }\n}\nfunction getWebsocketConstructor() {\n    return isNodeEnvironment() ? (__webpack_require__(/*! websocket */ \"(ssr)/./node_modules/websocket/index.js\").w3cwebsocket) : WebSocket;\n}\nfunction isNodeEnvironment() {\n    return typeof process !== \"undefined\" && process != null && process.versions != null && process.versions.node != null;\n}\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\nfunction makeCancelToken() {\n    let cancelled = false;\n    return {\n        cancel: ()=>cancelled = true,\n        isCancelled: ()=>cancelled\n    };\n}\n// TODO(cleanup): replace with SDK's backoff implementation\nconst MIN_RETRY_DELAY = 1000;\nconst RETRY_BACKOFF_FACTOR = 2;\nconst MAX_RETRY_DELAY = 30000;\nfunction withBackoffRetries(f, retryCount, shouldRetry = ()=>true) {\n    return index.__awaiter(this, void 0, void 0, function*() {\n        let nextWaitTime = 0;\n        let i = 0;\n        while(true){\n            try {\n                return yield f();\n            } catch (error) {\n                i++;\n                if (i >= retryCount || !shouldRetry(error)) {\n                    throw error;\n                }\n                yield delay(nextWaitTime);\n                if (!shouldRetry(error)) {\n                    throw error;\n                }\n                nextWaitTime = nextWaitTime === 0 ? MIN_RETRY_DELAY : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n            }\n        }\n    });\n}\nfunction delay(ms) {\n    return new Promise((resolve)=>setTimeout(resolve, ms));\n}\nfunction withTimeout(promise, ms) {\n    return Promise.race([\n        promise,\n        new Promise((_, reject)=>setTimeout(()=>reject(new Error(\"Timeout\")), ms))\n    ]);\n}\nfunction getNewHeadsBlockNumber(event) {\n    return index.fromHex(event.number);\n}\nfunction getLogsBlockNumber(event) {\n    return index.fromHex(event.blockNumber);\n}\nfunction isResponse(message) {\n    return Array.isArray(message) || message.jsonrpc === \"2.0\" && message.id !== undefined;\n}\nfunction isSubscriptionEvent(message) {\n    return !isResponse(message);\n}\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\n    addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\nfunction addToLogsEventsBuffer(pastEvents, event) {\n    addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n/**\r\n * Adds a new event to an array of events, evicting any events which are so old\r\n * that they will no longer feasibly be part of a reorg.\r\n */ function addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\n    const currentBlockNumber = getBlockNumber(event);\n    // Find first index of an event recent enough to retain, then drop everything\n    // at a lower index.\n    const firstGoodIndex = pastEvents.findIndex((e)=>getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT);\n    if (firstGoodIndex === -1) {\n        pastEvents.length = 0;\n    } else {\n        pastEvents.splice(0, firstGoodIndex);\n    }\n    pastEvents.push(event);\n}\nexports.AlchemyWebSocketProvider = AlchemyWebSocketProvider; //# sourceMappingURL=alchemy-websocket-provider-d921db84.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9janMvYWxjaGVteS13ZWJzb2NrZXQtcHJvdmlkZXItZDkyMWRiODQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQixJQUFJQyxrQkFBa0JELG1CQUFPQSxDQUFDO0FBQzlCLElBQUlFLFlBQVlGLG1CQUFPQSxDQUFDO0FBQ3hCLElBQUlHLFdBQVdILG1CQUFPQSxDQUFDO0FBQ3ZCLElBQUlJLFlBQVlKLG1CQUFPQSxDQUFDO0FBQ3hCLElBQUlLLGtCQUFrQkwsbUJBQU9BLENBQUM7QUFDOUJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVIsU0FBU00sc0JBQXVCQyxDQUFDO0lBQUksT0FBT0EsS0FBSyxPQUFPQSxNQUFNLFlBQVksYUFBYUEsSUFBSUEsSUFBSTtRQUFFLFdBQVdBO0lBQUU7QUFBRztBQUVqSCxJQUFJQywyQkFBMkIsV0FBVyxHQUFFRixzQkFBc0JMO0FBRWxFOzs7O0NBSUMsR0FDRCxNQUFNUSxzQkFBc0I7QUFDNUI7Ozs7Ozs7O0NBUUMsR0FDRCxNQUFNQztJQUNGQyxZQUFZQyxRQUFRLENBQUU7UUFDbEIsSUFBSSxDQUFDQSxRQUFRLEdBQUdBO1FBQ2hCLDBDQUEwQztRQUMxQyxJQUFJLENBQUNDLGlCQUFpQixHQUFHSjtJQUM3QjtJQUNBOzs7Ozs7O0tBT0MsR0FDREssb0JBQW9CQyxXQUFXLEVBQUVDLGFBQWEsRUFBRUMsZUFBZSxFQUFFO1FBQzdELE9BQU9sQixNQUFNbUIsU0FBUyxDQUFDLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ3pDQyxpQkFBaUJKO1lBQ2pCLE1BQU1LLGdCQUFnQixNQUFNLElBQUksQ0FBQ0MsY0FBYztZQUMvQ0YsaUJBQWlCSjtZQUNq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dkI7QUFDQSxTQUFTYSwwQkFBMEI4SSxVQUFVLEVBQUV0TSxLQUFLO0lBQ2hEb0osc0JBQXNCa0QsWUFBWXRNLE9BQU8wRDtBQUM3QztBQUNBLFNBQVNJLHNCQUFzQndJLFVBQVUsRUFBRXRNLEtBQUs7SUFDNUNvSixzQkFBc0JrRCxZQUFZdE0sT0FBTytEO0FBQzdDO0FBQ0E7OztDQUdDLEdBQ0QsU0FBU3FGLHNCQUFzQmtELFVBQVUsRUFBRXRNLEtBQUssRUFBRTlELGNBQWM7SUFDNUQsTUFBTXFRLHFCQUFxQnJRLGVBQWU4RDtJQUMxQyw2RUFBNkU7SUFDN0Usb0JBQW9CO0lBQ3BCLE1BQU13TSxpQkFBaUJGLFdBQVdHLFNBQVMsQ0FBQ3JSLENBQUFBLElBQUtjLGVBQWVkLEtBQUttUixxQkFBcUJ0TDtJQUMxRixJQUFJdUwsbUJBQW1CLENBQUMsR0FBRztRQUN2QkYsV0FBV25RLE1BQU0sR0FBRztJQUN4QixPQUNLO1FBQ0RtUSxXQUFXSSxNQUFNLENBQUMsR0FBR0Y7SUFDekI7SUFDQUYsV0FBVy9OLElBQUksQ0FBQ3lCO0FBQ3BCO0FBRUEyTSxnQ0FBZ0MsR0FBR3pMLDBCQUNuQywrREFBK0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL2FsY2hlbXktc2RrL2Rpc3QvY2pzL2FsY2hlbXktd2Vic29ja2V0LXByb3ZpZGVyLWQ5MjFkYjg0LmpzPzhiZWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5kZXggPSByZXF1aXJlKCcuL2luZGV4LWIxZjRhMmQ5LmpzJyk7XG52YXIgU3R1cmR5V2ViU29ja2V0ID0gcmVxdWlyZSgnc3R1cmR5LXdlYnNvY2tldCcpO1xudmFyIGJpZ251bWJlciA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2JpZ251bWJlcicpO1xudmFyIG5ldHdvcmtzID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvbmV0d29ya3MnKTtcbnZhciBwcm92aWRlcnMgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9wcm92aWRlcnMnKTtcbnZhciBhbGNoZW15UHJvdmlkZXIgPSByZXF1aXJlKCcuL2FsY2hlbXktcHJvdmlkZXItZTUzOWU3ZDAuanMnKTtcbnJlcXVpcmUoJy4vYXBpL3V0aWxzJyk7XG5yZXF1aXJlKCdheGlvcycpO1xucmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvYWJzdHJhY3QtcHJvdmlkZXInKTtcbnJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L3dhbGxldCcpO1xucmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvY29udHJhY3RzJyk7XG5yZXF1aXJlKCdAZXRoZXJzcHJvamVjdC93ZWInKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBTdHVyZHlXZWJTb2NrZXRfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KFN0dXJkeVdlYlNvY2tldCk7XG5cbi8qKlxyXG4gKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgYmxvY2tzIHRvIGJhY2tmaWxsLiBJZiBtb3JlIHRoYW4gdGhpcyBtYW55IGJsb2NrcyBoYXZlXHJcbiAqIGJlZW4gbWlzc2VkLCB0aGVuIHdlJ2xsIHNhZGx5IG1pc3MgZGF0YSwgYnV0IHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGRvbid0XHJcbiAqIGVuZCB1cCByZXF1ZXN0aW5nIHRob3VzYW5kcyBvZiBibG9ja3MgaWYgc29tZWJvZHkgbGVmdCB0aGVpciBsYXB0b3AgY2xvc2VkIGZvciBhIHdlZWsuXHJcbiAqL1xyXG5jb25zdCBNQVhfQkFDS0ZJTExfQkxPQ0tTID0gMTIwO1xyXG4vKipcclxuICogVGhlIFdlYnNvY2tldEJhY2tmaWxsZXIgZmV0Y2hlcyBldmVudHMgdGhhdCB3ZXJlIHNlbnQgc2luY2UgYSBwcm92aWRlZCBibG9ja1xyXG4gKiBudW1iZXIuIFRoaXMgaXMgdXNlZCBpbiB0aGUge0BsaW5rIEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlcn0gdG8gYmFja2ZpbGxcclxuICogZXZlbnRzIHRoYXQgd2VyZSB0cmFuc21pdHRlZCB3aGlsZSB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpb24gd2FzIGRvd24uXHJcbiAqXHJcbiAqIFRoZSBiYWNrZmlsbGVyIGJhY2tmaWxscyB0d28gbWFpbiBldGhfc3Vic2NyaWJlIGV2ZW50czogYGxvZ3NgIGFuZCBgbmV3SGVhZHNgLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFdlYnNvY2tldEJhY2tmaWxsZXIge1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XHJcbiAgICAgICAgLy8gVE9ETzogVXNlIEhUVFAgcHJvdmlkZXIgdG8gZG8gYmFja2ZpbGwuXHJcbiAgICAgICAgdGhpcy5tYXhCYWNrZmlsbEJsb2NrcyA9IE1BWF9CQUNLRklMTF9CTE9DS1M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgYmFja2ZpbGwgZm9yIGBuZXdIZWFkc2AgZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpc0NhbmNlbGxlZCBXaGV0aGVyIHRoZSBiYWNrZmlsbCByZXF1ZXN0IGlzIGNhbmNlbGxlZC5cclxuICAgICAqIEBwYXJhbSBwcmV2aW91c0hlYWRzIFByZXZpb3VzIGhlYWQgcmVxdWVzdHMgdGhhdCB3ZXJlIHNlbnQuXHJcbiAgICAgKiBAcGFyYW0gZnJvbUJsb2NrTnVtYmVyIFRoZSBibG9jayBudW1iZXIgdG8gc3RhcnQgYmFja2ZpbGxpbmcgZnJvbS5cclxuICAgICAqIEByZXR1cm5zIEEgbGlzdCBvZiBgbmV3SGVhZHNgIGV2ZW50cyB0aGF0IHdlcmUgc2VudCBzaW5jZSB0aGUgbGFzdCBiYWNrZmlsbC5cclxuICAgICAqL1xyXG4gICAgZ2V0TmV3SGVhZHNCYWNrZmlsbChpc0NhbmNlbGxlZCwgcHJldmlvdXNIZWFkcywgZnJvbUJsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4Ll9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvQmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLmdldEJsb2NrTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gcHJldmlvdXMgaGVhZHMgdG8gZmV0Y2gsIHJldHVybiBuZXcgaGVhZHMgc2luY2VcclxuICAgICAgICAgICAgLy8gYGZyb21CbG9ja051bWJlcmAsIG9yIHVwIHRvIG1heEJhY2tmaWxsQmxvY2tzIGZyb20gdGhlIGN1cnJlbnQgaGVhZC5cclxuICAgICAgICAgICAgaWYgKHByZXZpb3VzSGVhZHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWFkRXZlbnRzSW5SYW5nZShNYXRoLm1heChmcm9tQmxvY2tOdW1iZXIsIHRvQmxvY2tOdW1iZXIgLSB0aGlzLm1heEJhY2tmaWxsQmxvY2tzKSArIDEsIHRvQmxvY2tOdW1iZXIgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgbGFzdCBlbWl0dGVkIGV2ZW50IGlzIHRvbyBmYXIgYmFjayBpbiB0aGUgcGFzdCwgdGhlcmUncyBubyBuZWVkXHJcbiAgICAgICAgICAgIC8vIHRvIGJhY2tmaWxsIGZvciByZW9yZ3MuIEp1c3QgZmV0Y2ggdGhlIGxhc3QgYG1heEJhY2tmaWxsQmxvY2tzYCB3b3J0aCBvZlxyXG4gICAgICAgICAgICAvLyBuZXcgaGVhZHMuXHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3RTZWVuQmxvY2tOdW1iZXIgPSBpbmRleC5mcm9tSGV4KHByZXZpb3VzSGVhZHNbcHJldmlvdXNIZWFkcy5sZW5ndGggLSAxXS5udW1iZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBtaW5CbG9ja051bWJlciA9IHRvQmxvY2tOdW1iZXIgLSB0aGlzLm1heEJhY2tmaWxsQmxvY2tzICsgMTtcclxuICAgICAgICAgICAgaWYgKGxhc3RTZWVuQmxvY2tOdW1iZXIgPD0gbWluQmxvY2tOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEhlYWRFdmVudHNJblJhbmdlKG1pbkJsb2NrTnVtYmVyLCB0b0Jsb2NrTnVtYmVyICsgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVG8gY2FwdHVyZSBhbGwgYG5ld0hlYWRzYCBldmVudHMsIHJldHVybiBhbGwgaGVhZCBldmVudHMgZnJvbSB0aGUgbGFzdFxyXG4gICAgICAgICAgICAvLyBzZWVuIGJsb2NrIG51bWJlciB0byBjdXJyZW50ICsgYW55IG9mIHRoZSBwcmV2aW91cyBoZWFkcyB0aGF0IHdlcmUgcmUtb3JnZWQuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlb3JnSGVhZHMgPSB5aWVsZCB0aGlzLmdldFJlb3JnSGVhZHMoaXNDYW5jZWxsZWQsIHByZXZpb3VzSGVhZHMpO1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSGVhZHMgPSB5aWVsZCB0aGlzLmdldEhlYWRFdmVudHNJblJhbmdlKGxhc3RTZWVuQmxvY2tOdW1iZXIgKyAxLCB0b0Jsb2NrTnVtYmVyICsgMSk7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gWy4uLnJlb3JnSGVhZHMsIC4uLmludGVybWVkaWF0ZUhlYWRzXTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUnVucyBiYWNrZmlsbCBmb3IgYGxvZ3NgIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaXNDYW5jZWxsZWQgV2hldGhlciB0aGUgYmFja2ZpbGwgcmVxdWVzdCBpcyBjYW5jZWxsZWQuXHJcbiAgICAgKiBAcGFyYW0gZmlsdGVyIFRoZSBmaWx0ZXIgb2JqZWN0IHRoYXQgYWNjb21wYW5pZXMgYSBsb2dzIHN1YnNjcmlwdGlvbi5cclxuICAgICAqIEBwYXJhbSBwcmV2aW91c0xvZ3MgUHJldmlvdXMgbG9nIHJlcXVlc3RzIHRoYXQgd2VyZSBzZW50LlxyXG4gICAgICogQHBhcmFtIGZyb21CbG9ja051bWJlciBUaGUgYmxvY2sgbnVtYmVyIHRvIHN0YXJ0IGJhY2tmaWxsaW5nIGZyb20uXHJcbiAgICAgKi9cclxuICAgIGdldExvZ3NCYWNrZmlsbChpc0NhbmNlbGxlZCwgZmlsdGVyLCBwcmV2aW91c0xvZ3MsIGZyb21CbG9ja051bWJlcikge1xyXG4gICAgICAgIHJldHVybiBpbmRleC5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICBjb25zdCB0b0Jsb2NrTnVtYmVyID0geWllbGQgdGhpcy5nZXRCbG9ja051bWJlcigpO1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHByZXZpb3VzIGxvZ3MgdG8gZmV0Y2gsIHJldHVybiBuZXcgbG9ncyBzaW5jZVxyXG4gICAgICAgICAgICAvLyBgZnJvbUJsb2NrTnVtYmVyYCwgb3IgdXAgdG8gYG1heEJhY2tmaWxsQmxvY2tzYCBmcm9tIHRoZSBjdXJyZW50IGhlYWQuXHJcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0xvZ3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb2dzSW5SYW5nZShmaWx0ZXIsIE1hdGgubWF4KGZyb21CbG9ja051bWJlciwgdG9CbG9ja051bWJlciAtIHRoaXMubWF4QmFja2ZpbGxCbG9ja3MpICsgMSwgdG9CbG9ja051bWJlciArIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBsYXN0IGVtaXR0ZWQgbG9nIGlzIHRvbyBmYXIgYmFjayBpbiB0aGUgcGFzdCwgdGhlcmUncyBubyBuZWVkXHJcbiAgICAgICAgICAgIC8vIHRvIGJhY2tmaWxsIGZvciByZW1vdmVkIGxvZ3MuIEp1c3QgZmV0Y2ggdGhlIGxhc3QgYG1heEJhY2tmaWxsQmxvY2tzYFxyXG4gICAgICAgICAgICAvLyB3b3J0aCBvZiBsb2dzLlxyXG4gICAgICAgICAgICBjb25zdCBsYXN0U2VlbkJsb2NrTnVtYmVyID0gaW5kZXguZnJvbUhleChwcmV2aW91c0xvZ3NbcHJldmlvdXNMb2dzLmxlbmd0aCAtIDFdLmJsb2NrTnVtYmVyKTtcclxuICAgICAgICAgICAgY29uc3QgbWluQmxvY2tOdW1iZXIgPSB0b0Jsb2NrTnVtYmVyIC0gdGhpcy5tYXhCYWNrZmlsbEJsb2NrcyArIDE7XHJcbiAgICAgICAgICAgIGlmIChsYXN0U2VlbkJsb2NrTnVtYmVyIDwgbWluQmxvY2tOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExvZ3NJblJhbmdlKGZpbHRlciwgbWluQmxvY2tOdW1iZXIsIHRvQmxvY2tOdW1iZXIgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gYWxsIGxvZyBldmVudHMgdGhhdCBoYXZlIGhhcHBlbmVkIGFsb25nIHdpdGggbG9nIGV2ZW50cyB0aGF0IGhhdmVcclxuICAgICAgICAgICAgLy8gYmVlbiByZW1vdmVkIGR1ZSB0byBhIGNoYWluIHJlb3JnLlxyXG4gICAgICAgICAgICBjb25zdCBjb21tb25BbmNlc3RvciA9IHlpZWxkIHRoaXMuZ2V0Q29tbW9uQW5jZXN0b3IoaXNDYW5jZWxsZWQsIHByZXZpb3VzTG9ncyk7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICAvLyBBbGwgcHJldmlvdXMgbG9ncyB3aXRoIGEgYmxvY2sgbnVtYmVyIGdyZWF0ZXIgdGhhbiB0aGUgY29tbW9uIGFuY2VzdG9yXHJcbiAgICAgICAgICAgIC8vIHdlcmUgcGFydCBvZiBhIHJlLW9yZywgc28gbWFyayB0aGVtIGFzIHN1Y2guXHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRMb2dzID0gcHJldmlvdXNMb2dzXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGxvZyA9PiBpbmRleC5mcm9tSGV4KGxvZy5ibG9ja051bWJlcikgPiBjb21tb25BbmNlc3Rvci5ibG9ja051bWJlcilcclxuICAgICAgICAgICAgICAgIC5tYXAobG9nID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvZyksIHsgcmVtb3ZlZDogdHJ1ZSB9KSkpO1xyXG4gICAgICAgICAgICAvLyBJZiBubyBjb21tb24gYW5jZXN0b3Igd2FzIGZvdW5kLCBzdGFydCBiYWNrZmlsbCBmcm9tIHRoZSBvbGRlc3QgbG9nJ3NcclxuICAgICAgICAgICAgLy8gYmxvY2sgbnVtYmVyLlxyXG4gICAgICAgICAgICBjb25zdCBmcm9tQmxvY2tJbmNsdXNpdmUgPSBjb21tb25BbmNlc3Rvci5ibG9ja051bWJlciA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXHJcbiAgICAgICAgICAgICAgICA/IGluZGV4LmZyb21IZXgocHJldmlvdXNMb2dzWzBdLmJsb2NrTnVtYmVyKVxyXG4gICAgICAgICAgICAgICAgOiBjb21tb25BbmNlc3Rvci5ibG9ja051bWJlcjtcclxuICAgICAgICAgICAgbGV0IGFkZGVkTG9ncyA9IHlpZWxkIHRoaXMuZ2V0TG9nc0luUmFuZ2UoZmlsdGVyLCBmcm9tQmxvY2tJbmNsdXNpdmUsIHRvQmxvY2tOdW1iZXIgKyAxKTtcclxuICAgICAgICAgICAgLy8gRGUtZHVwZSBhbnkgbG9ncyB0aGF0IHdlcmUgYWxyZWFkeSBlbWl0dGVkLlxyXG4gICAgICAgICAgICBhZGRlZExvZ3MgPSBhZGRlZExvZ3MuZmlsdGVyKGxvZyA9PiBsb2cgJiZcclxuICAgICAgICAgICAgICAgIChpbmRleC5mcm9tSGV4KGxvZy5ibG9ja051bWJlcikgPiBjb21tb25BbmNlc3Rvci5ibG9ja051bWJlciB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4LmZyb21IZXgobG9nLmxvZ0luZGV4KSA+IGNvbW1vbkFuY2VzdG9yLmxvZ0luZGV4KSk7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gWy4uLnJlbW92ZWRMb2dzLCAuLi5hZGRlZExvZ3NdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgbmV3IG1heCBiYWNrZmlsbCBibG9ja3MuIFZJU0lCTEUgT05MWSBGT1IgVEVTVElORy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgc2V0TWF4QmFja2ZpbGxCbG9jayhuZXdNYXgpIHtcclxuICAgICAgICB0aGlzLm1heEJhY2tmaWxsQmxvY2tzID0gbmV3TWF4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGJsb2NrIG51bWJlciBhcyBhIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBnZXRCbG9ja051bWJlcigpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXguX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBibG9ja051bWJlckhleCA9IHlpZWxkIHRoaXMucHJvdmlkZXIuc2VuZCgnZXRoX2Jsb2NrTnVtYmVyJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleC5mcm9tSGV4KGJsb2NrTnVtYmVySGV4KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbGwgYG5ld0hlYWRgIGV2ZW50cyBpbiB0aGUgcHJvdmlkZWQgcmFuZ2UuIE5vdGUgdGhhdCB0aGUgcmV0dXJuZWRcclxuICAgICAqIGhlYWRzIGRvIG5vdCBpbmNsdWRlIHJlLW9yZ2VkIGhlYWRzLiBVc2Uge0BsaW5rIGdldFJlb3JnSGVhZHN9IHRvIGZpbmQgaGVhZHNcclxuICAgICAqIHRoYXQgd2VyZSBwYXJ0IG9mIGEgcmUtb3JnLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGdldEhlYWRFdmVudHNJblJhbmdlKGZyb21CbG9ja0luY2x1c2l2ZSwgdG9CbG9ja0V4Y2x1c2l2ZSkge1xyXG4gICAgICAgIHJldHVybiBpbmRleC5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tQmxvY2tJbmNsdXNpdmUgPj0gdG9CbG9ja0V4Y2x1c2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoUGFydHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZyb21CbG9ja0luY2x1c2l2ZTsgaSA8IHRvQmxvY2tFeGNsdXNpdmU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYmF0Y2hQYXJ0cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfZ2V0QmxvY2tCeU51bWJlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbaW5kZXgudG9IZXgoaSksIGZhbHNlXVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVE9ETzogaGFuZGxlIGVycm9yc1xyXG4gICAgICAgICAgICBjb25zdCBibG9ja0hlYWRzID0geWllbGQgdGhpcy5wcm92aWRlci5zZW5kQmF0Y2goYmF0Y2hQYXJ0cyk7XHJcbiAgICAgICAgICAgIHJldHVybiBibG9ja0hlYWRzLm1hcCh0b05ld0hlYWRzRXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCBoZWFkcyB0aGF0IHdlcmUgcGFydCBvZiBhIHJlb3JnIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGdldFJlb3JnSGVhZHMoaXNDYW5jZWxsZWQsIHByZXZpb3VzSGVhZHMpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXguX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSBmcm9tIHRoZSBtb3N0IHJlY2VudCBoZWFkIGJhY2t3YXJkcyBpbiBvcmRlciB0byBmaW5kIHRoZSBmaXJzdFxyXG4gICAgICAgICAgICAvLyBibG9jayB0aGF0IHdhcyBwYXJ0IG9mIGEgcmUtb3JnLlxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcHJldmlvdXNIZWFkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkRXZlbnQgPSBwcmV2aW91c0hlYWRzW2ldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2tIZWFkID0geWllbGQgdGhpcy5nZXRCbG9ja0J5TnVtYmVyKGluZGV4LmZyb21IZXgob2xkRXZlbnQubnVtYmVyKSk7XHJcbiAgICAgICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBoYXNoZXMgbWF0Y2gsIHRoZW4gY3VycmVudCBoZWFkIGluIHRoZSBpdGVyYXRpb24gd2FzIG5vdCByZS1vcmdlZC5cclxuICAgICAgICAgICAgICAgIGlmIChvbGRFdmVudC5oYXNoID09PSBibG9ja0hlYWQuaGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godG9OZXdIZWFkc0V2ZW50KGJsb2NrSGVhZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQucmV2ZXJzZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW1wbGUgd3JhcHBlciBhcm91bmQgYGV0aF9nZXRCbG9ja0J5TnVtYmVyYCB0aGF0IHJldHVybnMgdGhlIGNvbXBsZXRlXHJcbiAgICAgKiBibG9jayBpbmZvcm1hdGlvbiBmb3IgdGhlIHByb3ZpZGVkIGJsb2NrIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBnZXRCbG9ja0J5TnVtYmVyKGJsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4Ll9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZCgnZXRoX2dldEJsb2NrQnlOdW1iZXInLCBbXHJcbiAgICAgICAgICAgICAgICBpbmRleC50b0hleChibG9ja051bWJlciksXHJcbiAgICAgICAgICAgICAgICBmYWxzZVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBsaXN0IG9mIHByZXZpb3VzIGxvZyBldmVudHMsIGZpbmRzIHRoZSBjb21tb24gYmxvY2sgbnVtYmVyIGZyb20gdGhlXHJcbiAgICAgKiBsb2dzIHRoYXQgbWF0Y2hlcyB0aGUgYmxvY2sgaGVhZC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IHdoaWNoIGxvZ3MgYXJlIHBhcnQgb2YgYSByZS1vcmcuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJucyAxIGxlc3MgdGhhbiB0aGUgb2xkZXN0IGxvZydzIGJsb2NrIG51bWJlciBpZiBubyBjb21tb24gYW5jZXN0b3Igd2FzIGZvdW5kLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGdldENvbW1vbkFuY2VzdG9yKGlzQ2FuY2VsbGVkLCBwcmV2aW91c0xvZ3MpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXguX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAvLyBJdGVyYXRlIGZyb20gdGhlIG1vc3QgcmVjZW50IGhlYWQgYmFja3dhcmRzIGluIG9yZGVyIHRvIGZpbmQgdGhlIGZpcnN0XHJcbiAgICAgICAgICAgIC8vIGJsb2NrIHRoYXQgd2FzIHBhcnQgb2YgYSByZS1vcmcuXHJcbiAgICAgICAgICAgIGxldCBibG9ja0hlYWQgPSB5aWVsZCB0aGlzLmdldEJsb2NrQnlOdW1iZXIoaW5kZXguZnJvbUhleChwcmV2aW91c0xvZ3NbcHJldmlvdXNMb2dzLmxlbmd0aCAtIDFdLmJsb2NrTnVtYmVyKSk7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcHJldmlvdXNMb2dzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRMb2cgPSBwcmV2aW91c0xvZ3NbaV07XHJcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB1cGRhdGVkIGJsb2NrcyBhcmUgZmV0Y2hlZCBldmVyeSB0aW1lIHRoZSBsb2cncyBibG9jayBudW1iZXJcclxuICAgICAgICAgICAgICAgIC8vIGNoYW5nZXMuXHJcbiAgICAgICAgICAgICAgICBpZiAob2xkTG9nLmJsb2NrTnVtYmVyICE9PSBibG9ja0hlYWQubnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tIZWFkID0geWllbGQgdGhpcy5nZXRCbG9ja0J5TnVtYmVyKGluZGV4LmZyb21IZXgob2xkTG9nLmJsb2NrTnVtYmVyKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBsb2dzIGFyZSBvcmRlcmVkIGluIGFzY2VuZGluZyBvcmRlciwgdGhlIGZpcnN0IGxvZyB0aGF0IG1hdGNoZXNcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBoYXNoIHNob3VsZCBiZSB0aGUgbGFyZ2VzdCBsb2dJbmRleC5cclxuICAgICAgICAgICAgICAgIGlmIChvbGRMb2cuYmxvY2tIYXNoID09PSBibG9ja0hlYWQuaGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBpbmRleC5mcm9tSGV4KG9sZExvZy5ibG9ja051bWJlciksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0luZGV4OiBpbmRleC5mcm9tSGV4KG9sZExvZy5sb2dJbmRleClcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxyXG4gICAgICAgICAgICAgICAgbG9nSW5kZXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFsbCBgbG9nc2AgZXZlbnRzIGluIHRoZSBwcm92aWRlZCByYW5nZS4gTm90ZSB0aGF0IHRoZSByZXR1cm5lZCBsb2dzXHJcbiAgICAgKiBkbyBub3QgaW5jbHVkZSByZW1vdmVkIGxvZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqLyBnZXRMb2dzSW5SYW5nZShmaWx0ZXIsIGZyb21CbG9ja0luY2x1c2l2ZSwgdG9CbG9ja0V4Y2x1c2l2ZSkge1xyXG4gICAgICAgIHJldHVybiBpbmRleC5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tQmxvY2tJbmNsdXNpdmUgPj0gdG9CbG9ja0V4Y2x1c2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlRmlsdGVyID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWx0ZXIpLCB7IGZyb21CbG9jazogaW5kZXgudG9IZXgoZnJvbUJsb2NrSW5jbHVzaXZlKSwgdG9CbG9jazogaW5kZXgudG9IZXgodG9CbG9ja0V4Y2x1c2l2ZSAtIDEpIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKCdldGhfZ2V0TG9ncycsIFtyYW5nZUZpbHRlcl0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRvTmV3SGVhZHNFdmVudChoZWFkKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBoZWFkKTtcclxuICAgIGRlbGV0ZSByZXN1bHQudG90YWxEaWZmaWN1bHR5O1xyXG4gICAgZGVsZXRlIHJlc3VsdC50cmFuc2FjdGlvbnM7XHJcbiAgICBkZWxldGUgcmVzdWx0LnVuY2xlcztcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gZGVkdXBlTmV3SGVhZHMoZXZlbnRzKSB7XHJcbiAgICByZXR1cm4gZGVkdXBlKGV2ZW50cywgZXZlbnQgPT4gZXZlbnQuaGFzaCk7XHJcbn1cclxuZnVuY3Rpb24gZGVkdXBlTG9ncyhldmVudHMpIHtcclxuICAgIHJldHVybiBkZWR1cGUoZXZlbnRzLCBldmVudCA9PiBgJHtldmVudC5ibG9ja0hhc2h9LyR7ZXZlbnQubG9nSW5kZXh9YCk7XHJcbn1cclxuZnVuY3Rpb24gZGVkdXBlKGl0ZW1zLCBnZXRLZXkpIHtcclxuICAgIGNvbnN0IGtleXNTZWVuID0gbmV3IFNldCgpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGdldEtleShpdGVtKTtcclxuICAgICAgICBpZiAoIWtleXNTZWVuLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgIGtleXNTZWVuLmFkZChrZXkpO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuY29uc3QgQ0FOQ0VMTEVEID0gbmV3IEVycm9yKCdDYW5jZWxsZWQnKTtcclxuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCkge1xyXG4gICAgaWYgKGlzQ2FuY2VsbGVkKCkpIHtcclxuICAgICAgICB0aHJvdyBDQU5DRUxMRUQ7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgSEVBUlRCRUFUX0lOVEVSVkFMID0gMzAwMDA7XHJcbmNvbnN0IEhFQVJUQkVBVF9XQUlUX1RJTUUgPSAxMDAwMDtcclxuY29uc3QgQkFDS0ZJTExfVElNRU9VVCA9IDYwMDAwO1xyXG5jb25zdCBCQUNLRklMTF9SRVRSSUVTID0gNTtcclxuLyoqXHJcbiAqIFN1YnNjcmlwdGlvbnMgaGF2ZSBhIG1lbW9yeSBvZiByZWNlbnQgZXZlbnRzIHRoZXkgaGF2ZSBzZW50IHNvIHRoYXQgaW4gdGhlXHJcbiAqIGV2ZW50IHRoYXQgdGhleSBkaXNjb25uZWN0IGFuZCBuZWVkIHRvIGJhY2tmaWxsLCB0aGV5IGNhbiBkZXRlY3QgcmUtb3Jncy5cclxuICogS2VlcCBhIGJ1ZmZlciB0aGF0IGdvZXMgYmFjayBhdCBsZWFzdCB0aGVzZSBtYW55IGJsb2NrcywgdGhlIG1heGltdW0gYW1vdW50XHJcbiAqIGF0IHdoaWNoIHdlIG1pZ2h0IGNvbmNlaXZhYmx5IHNlZSBhIHJlLW9yZy5cclxuICpcclxuICogTm90ZSB0aGF0IHdoaWxlIG91ciBidWZmZXIgZ29lcyBiYWNrIHRoaXMgbWFueSBibG9ja3MsIGl0IG1heSBjb250YWluIG1vcmVcclxuICogdGhhbiB0aGlzIG1hbnkgZWxlbWVudHMsIHNpbmNlIGluIHRoZSBjYXNlIG9mIGxvZ3Mgc3Vic2NyaXB0aW9ucyBtb3JlIHRoYW5cclxuICogb25lIGV2ZW50IG1heSBiZSBlbWl0dGVkIGZvciBhIGJsb2NrLlxyXG4gKi9cclxuY29uc3QgUkVUQUlORURfRVZFTlRfQkxPQ0tfQ09VTlQgPSAxMDtcclxuLyoqXHJcbiAqIFNESydzIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiBmbyB0aGUgZXRoZXJzLmpzJ3MgJ0FsY2hlbXlXZWJTb2NrZXRQcm92aWRlcicuXHJcbiAqXHJcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIGluc3RhbnRpYXRlIGFuIGluc3RhbmNlIG9mXHJcbiAqIHtAbGluayBBbGNoZW15fSBhbmQgY2FsbCB7QGxpbmsgQWxjaGVteS5jb25maWcuZ2V0V2ViU29ja2V0UHJvdmlkZXIoKX0uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlciBleHRlbmRzIHByb3ZpZGVycy5XZWJTb2NrZXRQcm92aWRlciB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHdzQ29uc3RydWN0b3IpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBBUEkgS2V5IHRvIGEgc3RyaW5nLlxyXG4gICAgICAgIGNvbnN0IGFwaUtleSA9IGFsY2hlbXlQcm92aWRlci5BbGNoZW15UHJvdmlkZXIuZ2V0QXBpS2V5KGNvbmZpZy5hcGlLZXkpO1xyXG4gICAgICAgIC8vIEdlbmVyYXRlIG91ciBvd24gY29ubmVjdGlvbiBpbmZvIHdpdGggdGhlIGNvcnJlY3QgZW5kcG9pbnQgVVJMcy5cclxuICAgICAgICBjb25zdCBhbGNoZW15TmV0d29yayA9IGFsY2hlbXlQcm92aWRlci5BbGNoZW15UHJvdmlkZXIuZ2V0QWxjaGVteU5ldHdvcmsoY29uZmlnLm5ldHdvcmspO1xyXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhbGNoZW15UHJvdmlkZXIuQWxjaGVteVByb3ZpZGVyLmdldEFsY2hlbXlDb25uZWN0aW9uSW5mbyhhbGNoZW15TmV0d29yaywgYXBpS2V5LCAnd3NzJyk7XHJcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSBgYWxjaGVteS1zZGstJHtpbmRleC5WRVJTSU9OfWA7XHJcbiAgICAgICAgLy8gVXNlIHRoZSBwcm92aWRlZCBjb25maWcgVVJMIG92ZXJyaWRlIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIHVzZSB0aGUgY3JlYXRlZCBvbmUuXHJcbiAgICAgICAgY29uc3Qgd3MgPSBuZXcgU3R1cmR5V2ViU29ja2V0X19kZWZhdWx0W1wiZGVmYXVsdFwiXSgoX2EgPSBjb25maWcudXJsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25uZWN0aW9uLnVybCwgcHJvdG9jb2wsIHtcclxuICAgICAgICAgICAgd3NDb25zdHJ1Y3Rvcjogd3NDb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiB3c0NvbnN0cnVjdG9yICE9PSB2b2lkIDAgPyB3c0NvbnN0cnVjdG9yIDogZ2V0V2Vic29ja2V0Q29uc3RydWN0b3IoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgQWxjaGVteSBuYW1lZCBuZXR3b3JrIGlucHV0IHRvIHRoZSBuZXR3b3JrIG5hbWVzIHVzZWQgYnlcclxuICAgICAgICAvLyBldGhlcnMuIFRoaXMgYWxsb3dzIHRoZSBwYXJlbnQgc3VwZXIgY29uc3RydWN0b3IgaW4gSnNvblJwY1Byb3ZpZGVyIHRvXHJcbiAgICAgICAgLy8gY29ycmVjdGx5IHNldCB0aGUgbmV0d29yay5cclxuICAgICAgICBjb25zdCBldGhlcnNOZXR3b3JrID0gaW5kZXguRXRoZXJzTmV0d29ya1thbGNoZW15TmV0d29ya107XHJcbiAgICAgICAgc3VwZXIod3MsIGV0aGVyc05ldHdvcmspO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xyXG4gICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGEgV2ViU29ja2V0IHJlY29ubmVjdGlvbiwgYWxsIHN1YnNjcmlwdGlvbnMgYXJlIGxvc3QgYW5kIHdlXHJcbiAgICAgICAgLy8gY3JlYXRlIG5ldyBvbmVzIHRvIHJlcGxhY2UgdGhlbSwgYnV0IHdlIHdhbnQgdG8gY3JlYXRlIHRoZSBpbGx1c2lvbiB0aGF0XHJcbiAgICAgICAgLy8gdGhlIG9yaWdpbmFsIHN1YnNjcmlwdGlvbnMgcGVyc2lzdC4gVGh1cywgbWFpbnRhaW4gYSBtYXBwaW5nIGZyb20gdGhlXHJcbiAgICAgICAgLy8gXCJ2aXJ0dWFsXCIgc3Vic2NyaXB0aW9uIGlkcyB3aGljaCBhcmUgdmlzaWJsZSB0byB0aGUgY29uc3VtZXIgdG8gdGhlXHJcbiAgICAgICAgLy8gXCJwaHlzaWNhbFwiIHN1YnNjcmlwdGlvbiBpZHMgb2YgdGhlIGFjdHVhbCBjb25uZWN0aW9ucy4gVGhpcyB0ZXJtaW5vbG9neSBpc1xyXG4gICAgICAgIC8vIGJvcnJvd2VkIGZyb20gdmlydHVhbCBhbmQgcGh5c2ljYWwgbWVtb3J5LCB3aGljaCBoYXMgYSBzaW1pbGFyIG1hcHBpbmcuXHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMudmlydHVhbFN1YnNjcmlwdGlvbnNCeUlkID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLnZpcnR1YWxJZHNCeVBoeXNpY2FsSWQgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHVuZGVybHlpbmcgZXRoZXJzIHtAbGluayBXZWJTb2NrZXRQcm92aWRlcn0gYWxyZWFkeSBoYW5kbGVzIGFuZCBlbWl0c1xyXG4gICAgICAgICAqIG1lc3NhZ2VzLiBUbyBhbGxvdyBiYWNrZmlsbGluZywgdHJhY2sgYWxsIG1lc3NhZ2VzIHRoYXQgYXJlIGVtaXR0ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGlzIGlzIGEgZmllbGQgYXJyb3cgZnVuY3Rpb24gaW4gb3JkZXIgdG8gcHJlc2VydmUgYHRoaXNgIGNvbnRleHQgd2hlblxyXG4gICAgICAgICAqIHBhc3NpbmcgdGhlIG1ldGhvZCBhcyBhbiBldmVudCBsaXN0ZW5lci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaGFuZGxlTWVzc2FnZSA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcclxuICAgICAgICAgICAgaWYgKCFpc1N1YnNjcmlwdGlvbkV2ZW50KG1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcGh5c2ljYWxJZCA9IG1lc3NhZ2UucGFyYW1zLnN1YnNjcmlwdGlvbjtcclxuICAgICAgICAgICAgY29uc3QgdmlydHVhbElkID0gdGhpcy52aXJ0dWFsSWRzQnlQaHlzaWNhbElkLmdldChwaHlzaWNhbElkKTtcclxuICAgICAgICAgICAgaWYgKCF2aXJ0dWFsSWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLnZpcnR1YWxTdWJzY3JpcHRpb25zQnlJZC5nZXQodmlydHVhbElkKTtcclxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5tZXRob2QgIT09ICdldGhfc3Vic2NyaWJlJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAoc3Vic2NyaXB0aW9uLnBhcmFtc1swXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbmV3SGVhZHMnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SGVhZHNTdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SGVhZHNNZXNzYWdlID0gbWVzc2FnZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGlzQmFja2ZpbGxpbmcsIGJhY2tmaWxsQnVmZmVyIH0gPSBuZXdIZWFkc1N1YnNjcmlwdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlc3VsdCB9ID0gbmV3SGVhZHNNZXNzYWdlLnBhcmFtcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCYWNrZmlsbGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRUb05ld0hlYWRzRXZlbnRzQnVmZmVyKGJhY2tmaWxsQnVmZmVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwaHlzaWNhbElkICE9PSB2aXJ0dWFsSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYSByZS1vcGVuZWQgc3Vic2NyaXB0aW9uLCBldGhlcnMgd2lsbCBub3QgZW1pdCB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXZlbnQsIHNvIHRoZSBTREsgaGFzIHRvLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRBbmRSZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXROZXdIZWFkc0Jsb2NrTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV0aGVycyBzdWJzY3JpcHRpb24gbWFwcGluZyB3aWxsIGVtaXQgdGhlIGV2ZW50LCBqdXN0IHN0b3JlIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbWVtYmVyRXZlbnQodmlydHVhbElkLCByZXN1bHQsIGdldE5ld0hlYWRzQmxvY2tOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2xvZ3MnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nc1N1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dzTWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBpc0JhY2tmaWxsaW5nLCBiYWNrZmlsbEJ1ZmZlciB9ID0gbG9nc1N1YnNjcmlwdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlc3VsdCB9ID0gbG9nc01lc3NhZ2UucGFyYW1zO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0JhY2tmaWxsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFRvTG9nc0V2ZW50c0J1ZmZlcihiYWNrZmlsbEJ1ZmZlciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmlydHVhbElkICE9PSBwaHlzaWNhbElkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdEFuZFJlbWVtYmVyRXZlbnQodmlydHVhbElkLCByZXN1bHQsIGdldExvZ3NCbG9ja051bWJlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbWVtYmVyRXZlbnQodmlydHVhbElkLCByZXN1bHQsIGdldExvZ3NCbG9ja051bWJlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGh5c2ljYWxJZCAhPT0gdmlydHVhbElkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGEgcmUtb3BlbmVkIHN1YnNjcmlwdGlvbiwgZXRoZXJzIHdpbGwgbm90IGVtaXQgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZW50LCBzbyB0aGUgU0RLIGhhcyB0by5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IG1lc3NhZ2UucGFyYW1zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGVuIHRoZSB3ZWJzb2NrZXQgY29ubmVjdGlvbiByZW9wZW5zOlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogMS4gUmVzdWJzY3JpYmUgdG8gYWxsIGV4aXN0aW5nIHN1YnNjcmlwdGlvbnMgYW5kIHN0YXJ0IGJhY2tmaWxsaW5nXHJcbiAgICAgICAgICogMi4gUmVzdGFydCBoZWFydCBiZWF0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhpcyBpcyBhIGZpZWxkIGFycm93IGZ1bmN0aW9uIGluIG9yZGVyIHRvIHByZXNlcnZlIGB0aGlzYCBjb250ZXh0IHdoZW5cclxuICAgICAgICAgKiBwYXNzaW5nIHRoZSBtZXRob2QgYXMgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmhhbmRsZVJlb3BlbiA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsSWRzQnlQaHlzaWNhbElkLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY2FuY2VsLCBpc0NhbmNlbGxlZCB9ID0gbWFrZUNhbmNlbFRva2VuKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQmFja2ZpbGwgPSBjYW5jZWw7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3Vic2NyaXB0aW9uIG9mIHRoaXMudmlydHVhbFN1YnNjcmlwdGlvbnNCeUlkLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgICAgICB2b2lkICgoKSA9PiBpbmRleC5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5yZXN1YnNjcmliZUFuZEJhY2tmaWxsKGlzQ2FuY2VsbGVkLCBzdWJzY3JpcHRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0NhbmNlbGxlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB3aGlsZSBiYWNrZmlsbGluZyBcIiR7c3Vic2NyaXB0aW9uLnBhcmFtc1swXX1cIiBzdWJzY3JpcHRpb24uIFNvbWUgZXZlbnRzIG1heSBiZSBtaXNzaW5nLmAsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pKSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRIZWFydGJlYXQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbmNlbHMgdGhlIGhlYXJ0YmVhdCBhbmQgYW55IHBlbmRpbmcgYmFja2ZpbGxzIGJlaW5nIHBlcmZvcm1lZC4gVGhpcyBpc1xyXG4gICAgICAgICAqIGNhbGxlZCB3aGVuIHRoZSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBnb2VzIGRvd24gb3IgaXMgZGlzY29ubmVjdGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhpcyBpcyBhIGZpZWxkIGFycm93IGZ1bmN0aW9uIGluIG9yZGVyIHRvIHByZXNlcnZlIGB0aGlzYCBjb250ZXh0IHdoZW5cclxuICAgICAgICAgKiBwYXNzaW5nIHRoZSBtZXRob2QgYXMgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN0b3BIZWFydGJlYXRBbmRCYWNrZmlsbCA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxJZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxJZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsSWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jYW5jZWxCYWNrZmlsbCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XHJcbiAgICAgICAgLy8gU3RhcnQgaGVhcnRiZWF0IGFuZCBiYWNrZmlsbGVyIGZvciB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpb24uXHJcbiAgICAgICAgdGhpcy5iYWNrZmlsbGVyID0gbmV3IFdlYnNvY2tldEJhY2tmaWxsZXIodGhpcyk7XHJcbiAgICAgICAgdGhpcy5hZGRTb2NrZXRMaXN0ZW5lcnMoKTtcclxuICAgICAgICB0aGlzLnN0YXJ0SGVhcnRiZWF0KCk7XHJcbiAgICAgICAgdGhpcy5jYW5jZWxCYWNrZmlsbCA9IGluZGV4Lm5vb3A7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgYEJhc2VQcm92aWRlci5nZXROZXR3b3JrYCBtZXRob2QgYXMgaW1wbGVtZW50ZWQgYnkgZXRoZXJzLmpzLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgb3ZlcnJpZGUgYWxsb3dzIHRoZSBTREsgdG8gc2V0IHRoZSBwcm92aWRlcidzIG5ldHdvcmsgdG8gdmFsdWVzIG5vdFxyXG4gICAgICogeWV0IHN1cHBvcnRlZCBieSBldGhlcnMuanMuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldE5ldHdvcmsobmV0d29yaykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmV0d29yayA9PT0gJ3N0cmluZycgJiYgbmV0d29yayBpbiBpbmRleC5DdXN0b21OZXR3b3Jrcykge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXguQ3VzdG9tTmV0d29ya3NbbmV0d29ya107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbGwgdGhlIHN0YW5kYXJkIGV0aGVycy5qcyBnZXROZXR3b3JrIG1ldGhvZCBmb3Igb3RoZXIgbmV0d29ya3MuXHJcbiAgICAgICAgcmV0dXJuIG5ldHdvcmtzLmdldE5ldHdvcmsobmV0d29yayk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRkZW4gaW1wbGVtZW50YXRpb24gb2YgZXRoZXJzIHRoYXQgaW5jbHVkZXMgQWxjaGVteSBiYXNlZCBzdWJzY3JpcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgRXZlbnQgdG8gc3Vic2NyaWJlIHRvXHJcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIC8vIFRPRE86IE92ZXJyaWRlIGBMaXN0ZW5lcmAgdHlwZSB0byBnZXQgdHlwZSBhdXRvY29tcGxldGlvbnMuXHJcbiAgICBvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZGVuIGltcGxlbWVudGF0aW9uIG9mIGV0aGVycyB0aGF0IGluY2x1ZGVzIEFsY2hlbXkgYmFzZWRcclxuICAgICAqIHN1YnNjcmlwdGlvbnMuIEFkZHMgYSBsaXN0ZW5lciB0byB0aGUgdHJpZ2dlcmVkIGZvciBvbmx5IHRoZSBuZXh0XHJcbiAgICAgKiB7QGxpbmsgZXZlbnROYW1lfSBldmVudCwgYWZ0ZXIgd2hpY2ggaXQgd2lsbCBiZSByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgRXZlbnQgdG8gc3Vic2NyaWJlIHRvXHJcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIC8vIFRPRE86IE92ZXJyaWRlIGBMaXN0ZW5lcmAgdHlwZSB0byBnZXQgdHlwZSBhdXRvY29tcGxldGlvbnMuXHJcbiAgICBvbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCB0cnVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgcHJvdmlkZWQge0BsaW5rIGxpc3RlbmVyfSBmb3IgdGhlIHtAbGluayBldmVudE5hbWV9IGV2ZW50LiBJZiBub1xyXG4gICAgICogbGlzdGVuZXIgaXMgcHJvdmlkZWQsIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBldmVudCB3aWxsIGJlIHJlbW92ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBFdmVudCB0byB1bmxpc3RlbiB0by5cclxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlLlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgaWYgKGluZGV4LmlzQWxjaGVteUV2ZW50KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29mZihldmVudE5hbWUsIGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgdGhlIHByb3ZpZGVkIHtAbGluayBldmVudE5hbWV9IGV2ZW50LiBJZiBubyBldmVudFxyXG4gICAgICogaXMgcHJvdmlkZWQsIGFsbCBldmVudHMgYW5kIHRoZWlyIGxpc3RlbmVycyBhcmUgcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBldmVudCB0byByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IuXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xyXG4gICAgICAgIGlmIChldmVudE5hbWUgIT09IHVuZGVmaW5lZCAmJiBpbmRleC5pc0FsY2hlbXlFdmVudChldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgZm9yIHRoZSBwcm92aWRlZCB7QGxpbmsgZXZlbnROYW1lfSBldmVudC4gSWZcclxuICAgICAqIG5vIGV2ZW50IGlzIHByb3ZpZGVkLCB0aGUgdG90YWwgbnVtYmVyIG9mIGxpc3RlbmVycyBmb3IgYWxsIGV2ZW50cyBpcyByZXR1cm5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBldmVudCB0byBnZXQgdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgZm9yLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgaWYgKGV2ZW50TmFtZSAhPT0gdW5kZWZpbmVkICYmIGluZGV4LmlzQWxjaGVteUV2ZW50KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3RlbmVyQ291bnQoZXZlbnROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5saXN0ZW5lckNvdW50KGV2ZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGxpc3RlbmVycyBmb3IgdGhlIHByb3ZpZGVkIHtAbGluayBldmVudE5hbWV9IGV2ZW50LiBJZlxyXG4gICAgICogbm8gZXZlbnQgaXMgcHJvdmlkZWQsIGFsbCBsaXN0ZW5lcnMgd2lsbCBiZSBpbmNsdWRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBldmVudCB0byBnZXQgdGhlIGxpc3RlbmVycyBmb3IuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgbGlzdGVuZXJzKGV2ZW50TmFtZSkge1xyXG4gICAgICAgIGlmIChldmVudE5hbWUgIT09IHVuZGVmaW5lZCAmJiBpbmRleC5pc0FsY2hlbXlFdmVudChldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcnMoZXZlbnROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5saXN0ZW5lcnMoZXZlbnROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgbWV0aG9kIGluIGBCYXNlUHJvdmlkZXJgIGluIG9yZGVyIHRvIHByb3Blcmx5IGZvcm1hdCB0aGVcclxuICAgICAqIEFsY2hlbXkgc3Vic2NyaXB0aW9uIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBfYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvbmNlKSB7XHJcbiAgICAgICAgaWYgKGluZGV4LmlzQWxjaGVteUV2ZW50KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICAgICAgaW5kZXgudmVyaWZ5QWxjaGVteUV2ZW50TmFtZShldmVudE5hbWUpO1xyXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBpbmRleC5FdGhlcnNFdmVudChpbmRleC5nZXRBbGNoZW15RXZlbnRUYWcoZXZlbnROYW1lKSwgbGlzdGVuZXIsIG9uY2UpO1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMucHVzaChldmVudCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0RXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5fYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvbmNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgYF9zdGFydEV2ZW50KClgIG1ldGhvZCBpbiBldGhlcnMuanMnc1xyXG4gICAgICoge0BsaW5rIFdlYlNvY2tldFByb3ZpZGVyfSB0byBpbmNsdWRlIGFkZGl0aW9uYWwgYWxjaGVteSBtZXRob2RzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudFxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3N0YXJ0RXZlbnQoZXZlbnQpIHtcclxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgZXZlbnQgdHlwZSBpcyBhIGN1c3RvbSBBbGNoZW15IHN1YnNjcmlwdGlvbi5cclxuICAgICAgICBjb25zdCBjdXN0b21Mb2dpY1R5cGVzID0gWy4uLmluZGV4LkFMQ0hFTVlfRVZFTlRfVFlQRVMsICdibG9jaycsICdmaWx0ZXInXTtcclxuICAgICAgICBpZiAoY3VzdG9tTG9naWNUeXBlcy5pbmNsdWRlcyhldmVudC50eXBlKSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1c3RvbVN0YXJ0RXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3VwZXIuX3N0YXJ0RXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGRlbiBmcm9tIGV0aGVycy5qcydzIHtAbGluayBXZWJTb2NrZXRQcm92aWRlcn1cclxuICAgICAqXHJcbiAgICAgKiBNb2RpZmllZCBpbiBvcmRlciB0byBhZGQgbWFwcGluZ3MgZm9yIGJhY2tmaWxsaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIF9zdWJzY3JpYmUodGFnLCBwYXJhbSwgcHJvY2Vzc0Z1bmMsIGV2ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4Ll9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgbGV0IHN1YklkUHJvbWlzZSA9IHRoaXMuX3N1Yklkc1t0YWddO1xyXG4gICAgICAgICAgICAvLyBCRUdJTiBNT0RJRklFRCBDT0RFXHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0aW5nQmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLmdldEJsb2NrTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIC8vIEVORCBNT0RJRklFRCBDT0RFXHJcbiAgICAgICAgICAgIGlmIChzdWJJZFByb21pc2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc3ViSWRQcm9taXNlID0gUHJvbWlzZS5hbGwocGFyYW0pLnRoZW4ocGFyYW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmQoJ2V0aF9zdWJzY3JpYmUnLCBwYXJhbSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N1Yklkc1t0YWddID0gc3ViSWRQcm9taXNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHN1YklkID0geWllbGQgc3ViSWRQcm9taXNlO1xyXG4gICAgICAgICAgICAvLyBCRUdJTiBNT0RJRklFRCBDT0RFXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkUGFyYW1zID0geWllbGQgUHJvbWlzZS5hbGwocGFyYW0pO1xyXG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxTdWJzY3JpcHRpb25zQnlJZC5zZXQoc3ViSWQsIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcclxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9zdWJzY3JpYmUnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1zOiByZXNvbHZlZFBhcmFtcyxcclxuICAgICAgICAgICAgICAgIHN0YXJ0aW5nQmxvY2tOdW1iZXIsXHJcbiAgICAgICAgICAgICAgICB2aXJ0dWFsSWQ6IHN1YklkLFxyXG4gICAgICAgICAgICAgICAgcGh5c2ljYWxJZDogc3ViSWQsXHJcbiAgICAgICAgICAgICAgICBzZW50RXZlbnRzOiBbXSxcclxuICAgICAgICAgICAgICAgIGlzQmFja2ZpbGxpbmc6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgYmFja2ZpbGxCdWZmZXI6IFtdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxJZHNCeVBoeXNpY2FsSWQuc2V0KHN1YklkLCBzdWJJZCk7XHJcbiAgICAgICAgICAgIC8vIEVORCBNT0RJRklFRCBDT0RFXHJcbiAgICAgICAgICAgIHRoaXMuX3N1YnNbc3ViSWRdID0geyB0YWcsIHByb2Nlc3NGdW5jIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERPIE5PVCBNT0RJRlkuXHJcbiAgICAgKlxyXG4gICAgICogT3JpZ2luYWwgY29kZSBjb3BpZWQgb3ZlciBmcm9tIGV0aGVyLmpzJ3MgYEJhc2VQcm92aWRlcmAuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY29waWVkIG92ZXIgZGlyZWN0bHkgaW4gb3JkZXIgdG8gaW1wbGVtZW50IEFsY2hlbXkncyB1bmlxdWVcclxuICAgICAqIHN1YnNjcmlwdGlvbiB0eXBlcy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IHRoaXMgbWV0aG9kIGNhbGxzXHJcbiAgICAgKiB7QGxpbmsgZ2V0QWxjaGVteUV2ZW50VGFnfSBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBgZ2V0RXZlbnRUYWcoKWAgbWV0aG9kIGluXHJcbiAgICAgKiBvcmRlciB0byBwYXJzZSB0aGUgQWxjaGVteSBzdWJzY3JpcHRpb24gZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpIHtcclxuICAgICAgICBpZiAoaW5kZXguaXNBbGNoZW15RXZlbnQoZXZlbnROYW1lKSkge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0b3BwZWQgPSBbXTtcclxuICAgICAgICAgICAgLy8gVGhpcyBsaW5lIGlzIHRoZSBvbmx5IG1vZGlmaWVkIGxpbmUgZnJvbSB0aGUgb3JpZ2luYWwgbWV0aG9kLlxyXG4gICAgICAgICAgICBjb25zdCBldmVudFRhZyA9IGluZGV4LmdldEFsY2hlbXlFdmVudFRhZyhldmVudE5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMuZmlsdGVyKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC5saXN0ZW5lci5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudC5vbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHN0b3BwZWQuZm9yRWFjaChldmVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5lbWl0KGV2ZW50TmFtZSwgLi4uYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgc2VuZEJhdGNoKHBhcnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4Ll9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgbGV0IG5leHRJZCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBwYXJ0cy5tYXAoKHsgbWV0aG9kLCBwYXJhbXMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2QsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxyXG4gICAgICAgICAgICAgICAgICAgIGlkOiBgYWxjaGVteS1zZGs6JHtuZXh0SWQrK31gXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZEJhdGNoQ29uY3VycmVudGx5KHBheWxvYWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEBvdmVycmlkZSAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZVNvY2tldExpc3RlbmVycygpO1xyXG4gICAgICAgIHRoaXMuc3RvcEhlYXJ0YmVhdEFuZEJhY2tmaWxsKCk7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBldGhlcidzIGBpc0NvbW11bml0eVJlc291cmNlKClgIG1ldGhvZC4gUmV0dXJucyB0cnVlIGlmIHRoZVxyXG4gICAgICogY3VycmVudCBhcGkga2V5IGlzIHRoZSBkZWZhdWx0IGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcGlLZXkgPT09IGluZGV4LkRFRkFVTFRfQUxDSEVNWV9BUElfS0VZO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBETyBOT1QgTU9ESUZZLlxyXG4gICAgICpcclxuICAgICAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzIGBXZWJTb2NrZXRQcm92aWRlci5fc3RvcEV2ZW50KClgLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNvcGllZCBvdmVyIGRpcmVjdGx5IGluIG9yZGVyIHRvIHN1cHBvcnQgQWxjaGVteSdzXHJcbiAgICAgKiBzdWJzY3JpcHRpb24gdHlwZSBieSBhbGxvd2luZyB0aGUgcHJvdmlkZXIgdG8gcHJvcGVybHkgc3RvcCBBbGNoZW15J3NcclxuICAgICAqIHN1YnNjcmlwdGlvbiBldmVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9zdG9wRXZlbnQoZXZlbnQpIHtcclxuICAgICAgICBsZXQgdGFnID0gZXZlbnQudGFnO1xyXG4gICAgICAgIC8vIFNUQVJUIE1PRElGSUVEIENPREVcclxuICAgICAgICBpZiAoaW5kZXguQUxDSEVNWV9FVkVOVF9UWVBFUy5pbmNsdWRlcyhldmVudC50eXBlKSkge1xyXG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgcmVtYWluaW5nIHBlbmRpbmcgdHJhbnNhY3Rpb24gbGlzdGVuZXJzLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRzLmZpbHRlcihlID0+IGluZGV4LkFMQ0hFTVlfRVZFTlRfVFlQRVMuaW5jbHVkZXMoZS50eXBlKSkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRU5EIE1PRElGSUVEIENPREVcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ3R4Jykge1xyXG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgcmVtYWluaW5nIHRyYW5zYWN0aW9uIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRzLmZpbHRlcihlID0+IGUudHlwZSA9PT0gJ3R4JykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGFnID0gJ3R4JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5saXN0ZW5lckNvdW50KGV2ZW50LmV2ZW50KSkge1xyXG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgcmVtYWluaW5nIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN1YklkID0gdGhpcy5fc3ViSWRzW3RhZ107XHJcbiAgICAgICAgaWYgKCFzdWJJZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJJZHNbdGFnXTtcclxuICAgICAgICB2b2lkIHN1YklkLnRoZW4oc3ViSWQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N1YnNbc3ViSWRdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNbc3ViSWRdO1xyXG4gICAgICAgICAgICB2b2lkIHRoaXMuc2VuZCgnZXRoX3Vuc3Vic2NyaWJlJywgW3N1YklkXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBhZGRTb2NrZXRMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLmhhbmRsZU1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuX3dlYnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdyZW9wZW4nLCB0aGlzLmhhbmRsZVJlb3Blbik7XHJcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Rvd24nLCB0aGlzLnN0b3BIZWFydGJlYXRBbmRCYWNrZmlsbCk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICByZW1vdmVTb2NrZXRMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLmhhbmRsZU1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuX3dlYnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW9wZW4nLCB0aGlzLmhhbmRsZVJlb3Blbik7XHJcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rvd24nLCB0aGlzLnN0b3BIZWFydGJlYXRBbmRCYWNrZmlsbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlb3BlbnMgdGhlIGJhY2tmaWxsIGJhc2VkIG9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlzQ2FuY2VsbGVkXHJcbiAgICAgKiBAcGFyYW0gc3Vic2NyaXB0aW9uXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcmVzdWJzY3JpYmVBbmRCYWNrZmlsbChpc0NhbmNlbGxlZCwgc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4Ll9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyB2aXJ0dWFsSWQsIG1ldGhvZCwgcGFyYW1zLCBzZW50RXZlbnRzLCBiYWNrZmlsbEJ1ZmZlciwgc3RhcnRpbmdCbG9ja051bWJlciB9ID0gc3Vic2NyaXB0aW9uO1xyXG4gICAgICAgICAgICBzdWJzY3JpcHRpb24uaXNCYWNrZmlsbGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGJhY2tmaWxsQnVmZmVyLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwaHlzaWNhbElkID0geWllbGQgdGhpcy5zZW5kKG1ldGhvZCwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnBoeXNpY2FsSWQgPSBwaHlzaWNhbElkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aXJ0dWFsSWRzQnlQaHlzaWNhbElkLnNldChwaHlzaWNhbElkLCB2aXJ0dWFsSWQpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwYXJhbXNbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICduZXdIZWFkcyc6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFja2ZpbGxFdmVudHMgPSB5aWVsZCB3aXRoQmFja29mZlJldHJpZXMoKCkgPT4gd2l0aFRpbWVvdXQodGhpcy5iYWNrZmlsbGVyLmdldE5ld0hlYWRzQmFja2ZpbGwoaXNDYW5jZWxsZWQsIHNlbnRFdmVudHMsIHN0YXJ0aW5nQmxvY2tOdW1iZXIpLCBCQUNLRklMTF9USU1FT1VUKSwgQkFDS0ZJTExfUkVUUklFUywgKCkgPT4gIWlzQ2FuY2VsbGVkKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gZGVkdXBlTmV3SGVhZHMoWy4uLmJhY2tmaWxsRXZlbnRzLCAuLi5iYWNrZmlsbEJ1ZmZlcl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMuZm9yRWFjaChldmVudCA9PiB0aGlzLmVtaXROZXdIZWFkc0V2ZW50KHZpcnR1YWxJZCwgZXZlbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xvZ3MnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHBhcmFtc1sxXSB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFja2ZpbGxFdmVudHMgPSB5aWVsZCB3aXRoQmFja29mZlJldHJpZXMoKCkgPT4gd2l0aFRpbWVvdXQodGhpcy5iYWNrZmlsbGVyLmdldExvZ3NCYWNrZmlsbChpc0NhbmNlbGxlZCwgZmlsdGVyLCBzZW50RXZlbnRzLCBzdGFydGluZ0Jsb2NrTnVtYmVyKSwgQkFDS0ZJTExfVElNRU9VVCksIEJBQ0tGSUxMX1JFVFJJRVMsICgpID0+ICFpc0NhbmNlbGxlZCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IGRlZHVwZUxvZ3MoWy4uLmJhY2tmaWxsRXZlbnRzLCAuLi5iYWNrZmlsbEJ1ZmZlcl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMuZm9yRWFjaChldmVudCA9PiB0aGlzLmVtaXRMb2dzRXZlbnQodmlydHVhbElkLCBldmVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uaXNCYWNrZmlsbGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYmFja2ZpbGxCdWZmZXIubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgZW1pdE5ld0hlYWRzRXZlbnQodmlydHVhbElkLCByZXN1bHQpIHtcclxuICAgICAgICB0aGlzLmVtaXRBbmRSZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXROZXdIZWFkc0Jsb2NrTnVtYmVyKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGVtaXRMb2dzRXZlbnQodmlydHVhbElkLCByZXN1bHQpIHtcclxuICAgICAgICB0aGlzLmVtaXRBbmRSZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXRMb2dzQmxvY2tOdW1iZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbWl0cyBhbiBldmVudCB0byBjb25zdW1lcnMsIGJ1dCBhbHNvIHJlbWVtYmVycyBpdCBpbiBpdHMgc3Vic2NyaXB0aW9ucydzXHJcbiAgICAgKiBgc2VudEV2ZW50c2AgYnVmZmVyIHNvIHRoYXQgd2UgY2FuIGRldGVjdCByZS1vcmdzIGlmIHRoZSBjb25uZWN0aW9uIGRyb3BzXHJcbiAgICAgKiBhbmQgbmVlZHMgdG8gYmUgcmVjb25uZWN0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGVtaXRBbmRSZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXRCbG9ja051bWJlcikge1xyXG4gICAgICAgIHRoaXMucmVtZW1iZXJFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCwgZ2V0QmxvY2tOdW1iZXIpO1xyXG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0KTtcclxuICAgIH1cclxuICAgIGVtaXRFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCkge1xyXG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMudmlydHVhbFN1YnNjcmlwdGlvbnNCeUlkLmdldCh2aXJ0dWFsSWQpO1xyXG4gICAgICAgIGlmICghc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbWl0R2VuZXJpY0V2ZW50KHN1YnNjcmlwdGlvbiwgcmVzdWx0KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHJlbWVtYmVyRXZlbnQodmlydHVhbElkLCByZXN1bHQsIGdldEJsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy52aXJ0dWFsU3Vic2NyaXB0aW9uc0J5SWQuZ2V0KHZpcnR1YWxJZCk7XHJcbiAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZWIzIG1vZGlmaWVzIHRoZXNlIGV2ZW50IG9iamVjdHMgb25jZSB3ZSBwYXNzIHRoZW0gb24gKGNoYW5naW5nIGhleFxyXG4gICAgICAgIC8vIG51bWJlcnMgdG8gbnVtYmVycykuIFdlIHdhbnQgdGhlIG9yaWdpbmFsIGV2ZW50LCBzbyBtYWtlIGEgZGVmZW5zaXZlXHJcbiAgICAgICAgLy8gY29weS5cclxuICAgICAgICBhZGRUb1Bhc3RFdmVudHNCdWZmZXIoc3Vic2NyaXB0aW9uLnNlbnRFdmVudHMsIE9iamVjdC5hc3NpZ24oe30sIHJlc3VsdCksIGdldEJsb2NrTnVtYmVyKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGVtaXRHZW5lcmljRXZlbnQoc3Vic2NyaXB0aW9uLCByZXN1bHQpIHtcclxuICAgICAgICBjb25zdCBlbWl0RnVuY3Rpb24gPSB0aGlzLmVtaXRQcm9jZXNzRm4oc3Vic2NyaXB0aW9uLmV2ZW50KTtcclxuICAgICAgICBlbWl0RnVuY3Rpb24ocmVzdWx0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIGEgaGVhcnRiZWF0IHRoYXQgcGluZ3MgdGhlIHdlYnNvY2tldCBzZXJ2ZXIgcGVyaW9kaWNhbGx5IHRvIGVuc3VyZVxyXG4gICAgICogdGhhdCB0aGUgY29ubmVjdGlvbiBzdGF5cyBvcGVuLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBzdGFydEhlYXJ0YmVhdCgpIHtcclxuICAgICAgICBpZiAodGhpcy5oZWFydGJlYXRJbnRlcnZhbElkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiBpbmRleC5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCB3aXRoVGltZW91dCh0aGlzLnNlbmQoJ25ldF92ZXJzaW9uJyksIEhFQVJUQkVBVF9XQUlUX1RJTUUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vic29ja2V0LnJlY29ubmVjdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksIEhFQVJUQkVBVF9JTlRFUlZBTCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHNlbmRzIHRoZSBiYXRjaCBjb25jdXJyZW50bHkgYXMgaW5kaXZpZHVhbCByZXF1ZXN0cyByYXRoZXIgdGhhblxyXG4gICAgICogYXMgYSBiYXRjaCwgd2hpY2ggd2FzIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbi4gVGhlIG9yaWdpbmFsIGJhdGNoIGxvZ2ljXHJcbiAgICAgKiBpcyBwcmVzZXJ2ZWQgaW4gdGhpcyBpbXBsZW1lbnRhdGlvbiBpbiBvcmRlciBmb3IgZmFzdGVyIHBvcnRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBheWxvYWRcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICAvLyBUT0RPKGNsZWFudXApOiBSZWZhY3RvciBhbmQgcmVtb3ZlIHVzYWdlcyBvZiBgc2VuZEJhdGNoKClgLlxyXG4gICAgLy8gVE9ETyhlcnJvcnMpOiBVc2UgYWxsU2V0dGxlZCgpIG9uY2Ugd2UgaGF2ZSBtb3JlIGVycm9yIGhhbmRsaW5nLlxyXG4gICAgc2VuZEJhdGNoQ29uY3VycmVudGx5KHBheWxvYWQpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXguX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocGF5bG9hZC5tYXAocmVxID0+IHRoaXMuc2VuZChyZXEubWV0aG9kLCByZXEucGFyYW1zKSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgY3VzdG9tU3RhcnRFdmVudChldmVudCkge1xyXG4gICAgICAgIGlmIChldmVudC50eXBlID09PSBpbmRleC5BTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBmcm9tQWRkcmVzcywgdG9BZGRyZXNzLCBoYXNoZXNPbmx5IH0gPSBldmVudDtcclxuICAgICAgICAgICAgdm9pZCB0aGlzLl9zdWJzY3JpYmUoZXZlbnQudGFnLCBbXHJcbiAgICAgICAgICAgICAgICBpbmRleC5BbGNoZW15U3Vic2NyaXB0aW9uLlBFTkRJTkdfVFJBTlNBQ1RJT05TLFxyXG4gICAgICAgICAgICAgICAgeyBmcm9tQWRkcmVzcywgdG9BZGRyZXNzLCBoYXNoZXNPbmx5IH1cclxuICAgICAgICAgICAgXSwgdGhpcy5lbWl0UHJvY2Vzc0ZuKGV2ZW50KSwgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChldmVudC50eXBlID09PSBpbmRleC5BTENIRU1ZX01JTkVEX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgYWRkcmVzc2VzLCBpbmNsdWRlUmVtb3ZlZCwgaGFzaGVzT25seSB9ID0gZXZlbnQ7XHJcbiAgICAgICAgICAgIHZvaWQgdGhpcy5fc3Vic2NyaWJlKGV2ZW50LnRhZywgW1xyXG4gICAgICAgICAgICAgICAgaW5kZXguQWxjaGVteVN1YnNjcmlwdGlvbi5NSU5FRF9UUkFOU0FDVElPTlMsXHJcbiAgICAgICAgICAgICAgICB7IGFkZHJlc3NlcywgaW5jbHVkZVJlbW92ZWQsIGhhc2hlc09ubHkgfVxyXG4gICAgICAgICAgICBdLCB0aGlzLmVtaXRQcm9jZXNzRm4oZXZlbnQpLCBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICdibG9jaycpIHtcclxuICAgICAgICAgICAgdm9pZCB0aGlzLl9zdWJzY3JpYmUoJ2Jsb2NrJywgWyduZXdIZWFkcyddLCB0aGlzLmVtaXRQcm9jZXNzRm4oZXZlbnQpLCBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICdmaWx0ZXInKSB7XHJcbiAgICAgICAgICAgIHZvaWQgdGhpcy5fc3Vic2NyaWJlKGV2ZW50LnRhZywgWydsb2dzJywgdGhpcy5fZ2V0RmlsdGVyKGV2ZW50LmZpbHRlcildLCB0aGlzLmVtaXRQcm9jZXNzRm4oZXZlbnQpLCBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgZW1pdFByb2Nlc3NGbihldmVudCkge1xyXG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIGluZGV4LkFMQ0hFTVlfUEVORElOR19UUkFOU0FDVElPTlNfRVZFTlRfVFlQRTpcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT4gdGhpcy5lbWl0KHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IGluZGV4LkFsY2hlbXlTdWJzY3JpcHRpb24uUEVORElOR19UUkFOU0FDVElPTlMsXHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbUFkZHJlc3M6IGV2ZW50LmZyb21BZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvQWRkcmVzczogZXZlbnQudG9BZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIGhhc2hlc09ubHk6IGV2ZW50Lmhhc2hlc09ubHlcclxuICAgICAgICAgICAgICAgIH0sIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIGNhc2UgaW5kZXguQUxDSEVNWV9NSU5FRF9UUkFOU0FDVElPTlNfRVZFTlRfVFlQRTpcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT4gdGhpcy5lbWl0KHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IGluZGV4LkFsY2hlbXlTdWJzY3JpcHRpb24uTUlORURfVFJBTlNBQ1RJT05TLFxyXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3NlczogZXZlbnQuYWRkcmVzc2VzLFxyXG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGVSZW1vdmVkOiBldmVudC5pbmNsdWRlUmVtb3ZlZCxcclxuICAgICAgICAgICAgICAgICAgICBoYXNoZXNPbmx5OiBldmVudC5oYXNoZXNPbmx5XHJcbiAgICAgICAgICAgICAgICB9LCByZXN1bHQpO1xyXG4gICAgICAgICAgICBjYXNlICdibG9jayc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShyZXN1bHQubnVtYmVyKS50b051bWJlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWQuYmxvY2sgPSBibG9ja051bWJlcjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Jsb2NrJywgYmxvY2tOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY2FzZSAnZmlsdGVyJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVtb3ZlZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZW1vdmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudC5maWx0ZXIsIHRoaXMuZm9ybWF0dGVyLmZpbHRlckxvZyhyZXN1bHQpKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZXZlbnQgdHlwZSB0byBgZW1pdFByb2Nlc3NGbigpYCcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRE8gTk9UIE1PRElGWS5cclxuICAgICAqXHJcbiAgICAgKiBPcmlnaW5hbCBjb2RlIGNvcGllZCBvdmVyIGZyb20gZXRoZXIuanMncyBgQmFzZVByb3ZpZGVyLm9mZigpYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjb3BpZWQgb3ZlciBkaXJlY3RseSBpbiBvcmRlciB0byBpbXBsZW1lbnQgQWxjaGVteSdzIHVuaXF1ZVxyXG4gICAgICogc3Vic2NyaXB0aW9uIHR5cGVzLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhpcyBtZXRob2QgY2FsbHNcclxuICAgICAqIHtAbGluayBnZXRBbGNoZW15RXZlbnRUYWd9IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGBnZXRFdmVudFRhZygpYCBtZXRob2QgaW5cclxuICAgICAqIG9yZGVyIHRvIHBhcnNlIHRoZSBBbGNoZW15IHN1YnNjcmlwdGlvbiBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RvcHBlZCA9IFtdO1xyXG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGV2ZW50VGFnID0gaW5kZXguZ2V0QWxjaGVteUV2ZW50VGFnKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcihldmVudCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnIHx8IGV2ZW50Lmxpc3RlbmVyICE9IGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgc3RvcHBlZC5wdXNoKGV2ZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN0b3BwZWQuZm9yRWFjaChldmVudCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BFdmVudChldmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERPIE5PVCBNT0RJRlkuXHJcbiAgICAgKlxyXG4gICAgICogT3JpZ2luYWwgY29kZSBjb3BpZWQgb3ZlciBmcm9tIGV0aGVyLmpzJ3MgYEJhc2VQcm92aWRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKWAuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY29waWVkIG92ZXIgZGlyZWN0bHkgaW4gb3JkZXIgdG8gaW1wbGVtZW50IEFsY2hlbXkncyB1bmlxdWVcclxuICAgICAqIHN1YnNjcmlwdGlvbiB0eXBlcy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IHRoaXMgbWV0aG9kIGNhbGxzXHJcbiAgICAgKiB7QGxpbmsgZ2V0QWxjaGVteUV2ZW50VGFnfSBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBgZ2V0RXZlbnRUYWcoKWAgbWV0aG9kIGluXHJcbiAgICAgKiBvcmRlciB0byBwYXJzZSB0aGUgQWxjaGVteSBzdWJzY3JpcHRpb24gZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX3JlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpIHtcclxuICAgICAgICBsZXQgc3RvcHBlZCA9IFtdO1xyXG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdG9wcGVkID0gdGhpcy5fZXZlbnRzO1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50VGFnID0gaW5kZXguZ2V0QWxjaGVteUV2ZW50VGFnKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhZyAhPT0gZXZlbnRUYWcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdG9wcGVkLmZvckVhY2goZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBETyBOT1QgTU9ESUZZLlxyXG4gICAgICpcclxuICAgICAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzIGBCYXNlUHJvdmlkZXIubGlzdGVuZXJDb3VudCgpYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjb3BpZWQgb3ZlciBkaXJlY3RseSBpbiBvcmRlciB0byBpbXBsZW1lbnQgQWxjaGVteSdzIHVuaXF1ZVxyXG4gICAgICogc3Vic2NyaXB0aW9uIHR5cGVzLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhpcyBtZXRob2QgY2FsbHNcclxuICAgICAqIHtAbGluayBnZXRBbGNoZW15RXZlbnRUYWd9IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGBnZXRFdmVudFRhZygpYCBtZXRob2QgaW5cclxuICAgICAqIG9yZGVyIHRvIHBhcnNlIHRoZSBBbGNoZW15IHN1YnNjcmlwdGlvbiBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfbGlzdGVuZXJDb3VudChldmVudE5hbWUpIHtcclxuICAgICAgICBpZiAoIWV2ZW50TmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXZlbnRUYWcgPSBpbmRleC5nZXRBbGNoZW15RXZlbnRUYWcoZXZlbnROYW1lKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmZpbHRlcihldmVudCA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudC50YWcgPT09IGV2ZW50VGFnO1xyXG4gICAgICAgIH0pLmxlbmd0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRE8gTk9UIE1PRElGWS5cclxuICAgICAqXHJcbiAgICAgKiBPcmlnaW5hbCBjb2RlIGNvcGllZCBvdmVyIGZyb20gZXRoZXIuanMncyBgQmFzZVByb3ZpZGVyLmxpc3RlbmVycygpYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjb3BpZWQgb3ZlciBkaXJlY3RseSBpbiBvcmRlciB0byBpbXBsZW1lbnQgQWxjaGVteSdzIHVuaXF1ZVxyXG4gICAgICogc3Vic2NyaXB0aW9uIHR5cGVzLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhpcyBtZXRob2QgY2FsbHNcclxuICAgICAqIHtAbGluayBnZXRBbGNoZW15RXZlbnRUYWd9IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGBnZXRFdmVudFRhZygpYCBtZXRob2QgaW5cclxuICAgICAqIG9yZGVyIHRvIHBhcnNlIHRoZSBBbGNoZW15IHN1YnNjcmlwdGlvbiBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfbGlzdGVuZXJzKGV2ZW50TmFtZSkge1xyXG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLm1hcChldmVudCA9PiBldmVudC5saXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGV2ZW50VGFnID0gaW5kZXguZ2V0QWxjaGVteUV2ZW50VGFnKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50c1xyXG4gICAgICAgICAgICAuZmlsdGVyKGV2ZW50ID0+IGV2ZW50LnRhZyA9PT0gZXZlbnRUYWcpXHJcbiAgICAgICAgICAgIC5tYXAoZXZlbnQgPT4gZXZlbnQubGlzdGVuZXIpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFdlYnNvY2tldENvbnN0cnVjdG9yKCkge1xyXG4gICAgcmV0dXJuIGlzTm9kZUVudmlyb25tZW50KCkgPyByZXF1aXJlKCd3ZWJzb2NrZXQnKS53M2N3ZWJzb2NrZXQgOiBXZWJTb2NrZXQ7XHJcbn1cclxuZnVuY3Rpb24gaXNOb2RlRW52aXJvbm1lbnQoKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIHByb2Nlc3MgIT0gbnVsbCAmJlxyXG4gICAgICAgIHByb2Nlc3MudmVyc2lvbnMgIT0gbnVsbCAmJlxyXG4gICAgICAgIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPSBudWxsKTtcclxufVxyXG4vLyBUT0RPKGNsZWFudXApOiBVc2UgY2xhc3MgdmFyaWFibGUgcmF0aGVyIHRoYW4gcGFzc2luZyBgaXNDYW5jZWxsZWRgIGV2ZXJ5d2hlcmUuXHJcbmZ1bmN0aW9uIG1ha2VDYW5jZWxUb2tlbigpIHtcclxuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcclxuICAgIHJldHVybiB7IGNhbmNlbDogKCkgPT4gKGNhbmNlbGxlZCA9IHRydWUpLCBpc0NhbmNlbGxlZDogKCkgPT4gY2FuY2VsbGVkIH07XHJcbn1cclxuLy8gVE9ETyhjbGVhbnVwKTogcmVwbGFjZSB3aXRoIFNESydzIGJhY2tvZmYgaW1wbGVtZW50YXRpb25cclxuY29uc3QgTUlOX1JFVFJZX0RFTEFZID0gMTAwMDtcclxuY29uc3QgUkVUUllfQkFDS09GRl9GQUNUT1IgPSAyO1xyXG5jb25zdCBNQVhfUkVUUllfREVMQVkgPSAzMDAwMDtcclxuZnVuY3Rpb24gd2l0aEJhY2tvZmZSZXRyaWVzKGYsIHJldHJ5Q291bnQsIHNob3VsZFJldHJ5ID0gKCkgPT4gdHJ1ZSkge1xyXG4gICAgcmV0dXJuIGluZGV4Ll9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBsZXQgbmV4dFdhaXRUaW1lID0gMDtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBmKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSByZXRyeUNvdW50IHx8ICFzaG91bGRSZXRyeShlcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHlpZWxkIGRlbGF5KG5leHRXYWl0VGltZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFJldHJ5KGVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV4dFdhaXRUaW1lID1cclxuICAgICAgICAgICAgICAgICAgICBuZXh0V2FpdFRpbWUgPT09IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBNSU5fUkVUUllfREVMQVlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1pbihNQVhfUkVUUllfREVMQVksIFJFVFJZX0JBQ0tPRkZfRkFDVE9SICogbmV4dFdhaXRUaW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGRlbGF5KG1zKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XHJcbn1cclxuZnVuY3Rpb24gd2l0aFRpbWVvdXQocHJvbWlzZSwgbXMpIHtcclxuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW1xyXG4gICAgICAgIHByb21pc2UsXHJcbiAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKCdUaW1lb3V0JykpLCBtcykpXHJcbiAgICBdKTtcclxufVxyXG5mdW5jdGlvbiBnZXROZXdIZWFkc0Jsb2NrTnVtYmVyKGV2ZW50KSB7XHJcbiAgICByZXR1cm4gaW5kZXguZnJvbUhleChldmVudC5udW1iZXIpO1xyXG59XHJcbmZ1bmN0aW9uIGdldExvZ3NCbG9ja051bWJlcihldmVudCkge1xyXG4gICAgcmV0dXJuIGluZGV4LmZyb21IZXgoZXZlbnQuYmxvY2tOdW1iZXIpO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVzcG9uc2UobWVzc2FnZSkge1xyXG4gICAgcmV0dXJuIChBcnJheS5pc0FycmF5KG1lc3NhZ2UpIHx8XHJcbiAgICAgICAgKG1lc3NhZ2UuanNvbnJwYyA9PT0gJzIuMCcgJiYgbWVzc2FnZS5pZCAhPT0gdW5kZWZpbmVkKSk7XHJcbn1cclxuZnVuY3Rpb24gaXNTdWJzY3JpcHRpb25FdmVudChtZXNzYWdlKSB7XHJcbiAgICByZXR1cm4gIWlzUmVzcG9uc2UobWVzc2FnZSk7XHJcbn1cclxuZnVuY3Rpb24gYWRkVG9OZXdIZWFkc0V2ZW50c0J1ZmZlcihwYXN0RXZlbnRzLCBldmVudCkge1xyXG4gICAgYWRkVG9QYXN0RXZlbnRzQnVmZmVyKHBhc3RFdmVudHMsIGV2ZW50LCBnZXROZXdIZWFkc0Jsb2NrTnVtYmVyKTtcclxufVxyXG5mdW5jdGlvbiBhZGRUb0xvZ3NFdmVudHNCdWZmZXIocGFzdEV2ZW50cywgZXZlbnQpIHtcclxuICAgIGFkZFRvUGFzdEV2ZW50c0J1ZmZlcihwYXN0RXZlbnRzLCBldmVudCwgZ2V0TG9nc0Jsb2NrTnVtYmVyKTtcclxufVxyXG4vKipcclxuICogQWRkcyBhIG5ldyBldmVudCB0byBhbiBhcnJheSBvZiBldmVudHMsIGV2aWN0aW5nIGFueSBldmVudHMgd2hpY2ggYXJlIHNvIG9sZFxyXG4gKiB0aGF0IHRoZXkgd2lsbCBubyBsb25nZXIgZmVhc2libHkgYmUgcGFydCBvZiBhIHJlb3JnLlxyXG4gKi9cclxuZnVuY3Rpb24gYWRkVG9QYXN0RXZlbnRzQnVmZmVyKHBhc3RFdmVudHMsIGV2ZW50LCBnZXRCbG9ja051bWJlcikge1xyXG4gICAgY29uc3QgY3VycmVudEJsb2NrTnVtYmVyID0gZ2V0QmxvY2tOdW1iZXIoZXZlbnQpO1xyXG4gICAgLy8gRmluZCBmaXJzdCBpbmRleCBvZiBhbiBldmVudCByZWNlbnQgZW5vdWdoIHRvIHJldGFpbiwgdGhlbiBkcm9wIGV2ZXJ5dGhpbmdcclxuICAgIC8vIGF0IGEgbG93ZXIgaW5kZXguXHJcbiAgICBjb25zdCBmaXJzdEdvb2RJbmRleCA9IHBhc3RFdmVudHMuZmluZEluZGV4KGUgPT4gZ2V0QmxvY2tOdW1iZXIoZSkgPiBjdXJyZW50QmxvY2tOdW1iZXIgLSBSRVRBSU5FRF9FVkVOVF9CTE9DS19DT1VOVCk7XHJcbiAgICBpZiAoZmlyc3RHb29kSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgcGFzdEV2ZW50cy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcGFzdEV2ZW50cy5zcGxpY2UoMCwgZmlyc3RHb29kSW5kZXgpO1xyXG4gICAgfVxyXG4gICAgcGFzdEV2ZW50cy5wdXNoKGV2ZW50KTtcclxufVxuXG5leHBvcnRzLkFsY2hlbXlXZWJTb2NrZXRQcm92aWRlciA9IEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsY2hlbXktd2Vic29ja2V0LXByb3ZpZGVyLWQ5MjFkYjg0LmpzLm1hcFxuIl0sIm5hbWVzIjpbImluZGV4IiwicmVxdWlyZSIsIlN0dXJkeVdlYlNvY2tldCIsImJpZ251bWJlciIsIm5ldHdvcmtzIiwicHJvdmlkZXJzIiwiYWxjaGVteVByb3ZpZGVyIiwiX2ludGVyb3BEZWZhdWx0TGVnYWN5IiwiZSIsIlN0dXJkeVdlYlNvY2tldF9fZGVmYXVsdCIsIk1BWF9CQUNLRklMTF9CTE9DS1MiLCJXZWJzb2NrZXRCYWNrZmlsbGVyIiwiY29uc3RydWN0b3IiLCJwcm92aWRlciIsIm1heEJhY2tmaWxsQmxvY2tzIiwiZ2V0TmV3SGVhZHNCYWNrZmlsbCIsImlzQ2FuY2VsbGVkIiwicHJldmlvdXNIZWFkcyIsImZyb21CbG9ja051bWJlciIsIl9fYXdhaXRlciIsInRocm93SWZDYW5jZWxsZWQiLCJ0b0Jsb2NrTnVtYmVyIiwiZ2V0QmxvY2tOdW1iZXIiLCJsZW5ndGgiLCJnZXRIZWFkRXZlbnRzSW5SYW5nZSIsIk1hdGgiLCJtYXgiLCJsYXN0U2VlbkJsb2NrTnVtYmVyIiwiZnJvbUhleCIsIm51bWJlciIsIm1pbkJsb2NrTnVtYmVyIiwicmVvcmdIZWFkcyIsImdldFJlb3JnSGVhZHMiLCJpbnRlcm1lZGlhdGVIZWFkcyIsImdldExvZ3NCYWNrZmlsbCIsImZpbHRlciIsInByZXZpb3VzTG9ncyIsImdldExvZ3NJblJhbmdlIiwiYmxvY2tOdW1iZXIiLCJjb21tb25BbmNlc3RvciIsImdldENvbW1vbkFuY2VzdG9yIiwicmVtb3ZlZExvZ3MiLCJsb2ciLCJtYXAiLCJPYmplY3QiLCJhc3NpZ24iLCJyZW1vdmVkIiwiZnJvbUJsb2NrSW5jbHVzaXZlIiwiTnVtYmVyIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJhZGRlZExvZ3MiLCJsb2dJbmRleCIsInNldE1heEJhY2tmaWxsQmxvY2siLCJuZXdNYXgiLCJibG9ja051bWJlckhleCIsInNlbmQiLCJ0b0Jsb2NrRXhjbHVzaXZlIiwiYmF0Y2hQYXJ0cyIsImkiLCJwdXNoIiwibWV0aG9kIiwicGFyYW1zIiwidG9IZXgiLCJibG9ja0hlYWRzIiwic2VuZEJhdGNoIiwidG9OZXdIZWFkc0V2ZW50IiwicmVzdWx0Iiwib2xkRXZlbnQiLCJibG9ja0hlYWQiLCJnZXRCbG9ja0J5TnVtYmVyIiwiaGFzaCIsInJldmVyc2UiLCJvbGRMb2ciLCJibG9ja0hhc2giLCJyYW5nZUZpbHRlciIsImZyb21CbG9jayIsInRvQmxvY2siLCJoZWFkIiwidG90YWxEaWZmaWN1bHR5IiwidHJhbnNhY3Rpb25zIiwidW5jbGVzIiwiZGVkdXBlTmV3SGVhZHMiLCJldmVudHMiLCJkZWR1cGUiLCJldmVudCIsImRlZHVwZUxvZ3MiLCJpdGVtcyIsImdldEtleSIsImtleXNTZWVuIiwiU2V0IiwiZm9yRWFjaCIsIml0ZW0iLCJrZXkiLCJoYXMiLCJhZGQiLCJDQU5DRUxMRUQiLCJFcnJvciIsIkhFQVJUQkVBVF9JTlRFUlZBTCIsIkhFQVJUQkVBVF9XQUlUX1RJTUUiLCJCQUNLRklMTF9USU1FT1VUIiwiQkFDS0ZJTExfUkVUUklFUyIsIlJFVEFJTkVEX0VWRU5UX0JMT0NLX0NPVU5UIiwiQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyIiwiV2ViU29ja2V0UHJvdmlkZXIiLCJjb25maWciLCJ3c0NvbnN0cnVjdG9yIiwiX2EiLCJhcGlLZXkiLCJBbGNoZW15UHJvdmlkZXIiLCJnZXRBcGlLZXkiLCJhbGNoZW15TmV0d29yayIsImdldEFsY2hlbXlOZXR3b3JrIiwibmV0d29yayIsImNvbm5lY3Rpb24iLCJnZXRBbGNoZW15Q29ubmVjdGlvbkluZm8iLCJwcm90b2NvbCIsIlZFUlNJT04iLCJ3cyIsInVybCIsImdldFdlYnNvY2tldENvbnN0cnVjdG9yIiwiZXRoZXJzTmV0d29yayIsIkV0aGVyc05ldHdvcmsiLCJfZXZlbnRzIiwidmlydHVhbFN1YnNjcmlwdGlvbnNCeUlkIiwiTWFwIiwidmlydHVhbElkc0J5UGh5c2ljYWxJZCIsImhhbmRsZU1lc3NhZ2UiLCJtZXNzYWdlIiwiSlNPTiIsInBhcnNlIiwiZGF0YSIsImlzU3Vic2NyaXB0aW9uRXZlbnQiLCJwaHlzaWNhbElkIiwic3Vic2NyaXB0aW9uIiwidmlydHVhbElkIiwiZ2V0IiwibmV3SGVhZHNTdWJzY3JpcHRpb24iLCJuZXdIZWFkc01lc3NhZ2UiLCJpc0JhY2tmaWxsaW5nIiwiYmFja2ZpbGxCdWZmZXIiLCJhZGRUb05ld0hlYWRzRXZlbnRzQnVmZmVyIiwiZW1pdEFuZFJlbWVtYmVyRXZlbnQiLCJnZXROZXdIZWFkc0Jsb2NrTnVtYmVyIiwicmVtZW1iZXJFdmVudCIsImxvZ3NTdWJzY3JpcHRpb24iLCJsb2dzTWVzc2FnZSIsImFkZFRvTG9nc0V2ZW50c0J1ZmZlciIsImdldExvZ3NCbG9ja051bWJlciIsImVtaXRFdmVudCIsImhhbmRsZVJlb3BlbiIsImNsZWFyIiwiY2FuY2VsIiwibWFrZUNhbmNlbFRva2VuIiwiY2FuY2VsQmFja2ZpbGwiLCJ2YWx1ZXMiLCJyZXN1YnNjcmliZUFuZEJhY2tmaWxsIiwiZXJyb3IiLCJjb25zb2xlIiwic3RhcnRIZWFydGJlYXQiLCJzdG9wSGVhcnRiZWF0QW5kQmFja2ZpbGwiLCJoZWFydGJlYXRJbnRlcnZhbElkIiwiY2xlYXJJbnRlcnZhbCIsInVuZGVmaW5lZCIsImJhY2tmaWxsZXIiLCJhZGRTb2NrZXRMaXN0ZW5lcnMiLCJub29wIiwiZ2V0TmV0d29yayIsIkN1c3RvbU5ldHdvcmtzIiwib24iLCJldmVudE5hbWUiLCJsaXN0ZW5lciIsIl9hZGRFdmVudExpc3RlbmVyIiwib25jZSIsIm9mZiIsImlzQWxjaGVteUV2ZW50IiwiX29mZiIsInJlbW92ZUFsbExpc3RlbmVycyIsIl9yZW1vdmVBbGxMaXN0ZW5lcnMiLCJsaXN0ZW5lckNvdW50IiwiX2xpc3RlbmVyQ291bnQiLCJsaXN0ZW5lcnMiLCJfbGlzdGVuZXJzIiwidmVyaWZ5QWxjaGVteUV2ZW50TmFtZSIsIkV0aGVyc0V2ZW50IiwiZ2V0QWxjaGVteUV2ZW50VGFnIiwiX3N0YXJ0RXZlbnQiLCJjdXN0b21Mb2dpY1R5cGVzIiwiQUxDSEVNWV9FVkVOVF9UWVBFUyIsImluY2x1ZGVzIiwidHlwZSIsImN1c3RvbVN0YXJ0RXZlbnQiLCJfc3Vic2NyaWJlIiwidGFnIiwicGFyYW0iLCJwcm9jZXNzRnVuYyIsInN1YklkUHJvbWlzZSIsIl9zdWJJZHMiLCJzdGFydGluZ0Jsb2NrTnVtYmVyIiwiUHJvbWlzZSIsImFsbCIsInRoZW4iLCJzdWJJZCIsInJlc29sdmVkUGFyYW1zIiwic2V0Iiwic2VudEV2ZW50cyIsIl9zdWJzIiwiZW1pdCIsImFyZ3MiLCJzdG9wcGVkIiwiZXZlbnRUYWciLCJzZXRUaW1lb3V0IiwiYXBwbHkiLCJfc3RvcEV2ZW50IiwicGFydHMiLCJuZXh0SWQiLCJwYXlsb2FkIiwianNvbnJwYyIsImlkIiwic2VuZEJhdGNoQ29uY3VycmVudGx5IiwiZGVzdHJveSIsInJlbW92ZVNvY2tldExpc3RlbmVycyIsImlzQ29tbXVuaXR5UmVzb3VyY2UiLCJERUZBVUxUX0FMQ0hFTVlfQVBJX0tFWSIsIl93ZWJzb2NrZXQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImJhY2tmaWxsRXZlbnRzIiwid2l0aEJhY2tvZmZSZXRyaWVzIiwid2l0aFRpbWVvdXQiLCJlbWl0TmV3SGVhZHNFdmVudCIsImVtaXRMb2dzRXZlbnQiLCJlbWl0R2VuZXJpY0V2ZW50IiwiYWRkVG9QYXN0RXZlbnRzQnVmZmVyIiwiZW1pdEZ1bmN0aW9uIiwiZW1pdFByb2Nlc3NGbiIsInNldEludGVydmFsIiwicmVjb25uZWN0IiwicmVxIiwiQUxDSEVNWV9QRU5ESU5HX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFIiwiZnJvbUFkZHJlc3MiLCJ0b0FkZHJlc3MiLCJoYXNoZXNPbmx5IiwiQWxjaGVteVN1YnNjcmlwdGlvbiIsIlBFTkRJTkdfVFJBTlNBQ1RJT05TIiwiQUxDSEVNWV9NSU5FRF9UUkFOU0FDVElPTlNfRVZFTlRfVFlQRSIsImFkZHJlc3NlcyIsImluY2x1ZGVSZW1vdmVkIiwiTUlORURfVFJBTlNBQ1RJT05TIiwiX2dldEZpbHRlciIsIkJpZ051bWJlciIsImZyb20iLCJ0b051bWJlciIsIl9lbWl0dGVkIiwiYmxvY2siLCJmb3JtYXR0ZXIiLCJmaWx0ZXJMb2ciLCJmb3VuZCIsImlzTm9kZUVudmlyb25tZW50IiwidzNjd2Vic29ja2V0IiwiV2ViU29ja2V0IiwicHJvY2VzcyIsInZlcnNpb25zIiwibm9kZSIsImNhbmNlbGxlZCIsIk1JTl9SRVRSWV9ERUxBWSIsIlJFVFJZX0JBQ0tPRkZfRkFDVE9SIiwiTUFYX1JFVFJZX0RFTEFZIiwiZiIsInJldHJ5Q291bnQiLCJzaG91bGRSZXRyeSIsIm5leHRXYWl0VGltZSIsImRlbGF5IiwibWluIiwibXMiLCJyZXNvbHZlIiwicHJvbWlzZSIsInJhY2UiLCJfIiwicmVqZWN0IiwiaXNSZXNwb25zZSIsIkFycmF5IiwiaXNBcnJheSIsInBhc3RFdmVudHMiLCJjdXJyZW50QmxvY2tOdW1iZXIiLCJmaXJzdEdvb2RJbmRleCIsImZpbmRJbmRleCIsInNwbGljZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/alchemy-sdk/dist/cjs/alchemy-websocket-provider-d921db84.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/alchemy-sdk/dist/cjs/api/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/alchemy-sdk/dist/cjs/api/utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar hash = __webpack_require__(/*! @ethersproject/hash */ \"(ssr)/./node_modules/@ethersproject/hash/lib.esm/index.js\");\nvar bytes = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\nvar units = __webpack_require__(/*! @ethersproject/units */ \"(ssr)/./node_modules/@ethersproject/units/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/index.js\");\nvar abi = __webpack_require__(/*! @ethersproject/abi */ \"(ssr)/./node_modules/@ethersproject/abi/lib.esm/index.js\");\nconst version$1 = \"logger/5.7.0\";\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\nconst LogLevels = {\n    debug: 1,\n    \"default\": 2,\n    info: 2,\n    warning: 3,\n    error: 4,\n    off: 5\n};\nlet _logLevel = LogLevels[\"default\"];\nlet _globalLogger = null;\nfunction _checkNormalize() {\n    try {\n        const missing = [];\n        // Make sure all forms of normalization are supported\n        [\n            \"NFD\",\n            \"NFC\",\n            \"NFKD\",\n            \"NFKC\"\n        ].forEach((form)=>{\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                }\n                ;\n            } catch (error) {\n                missing.push(form);\n            }\n        });\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\");\n        }\n    } catch (error) {\n        return error.message;\n    }\n    return null;\n}\nconst _normalizeError = _checkNormalize();\nvar LogLevel;\n(function(LogLevel) {\n    LogLevel[\"DEBUG\"] = \"DEBUG\";\n    LogLevel[\"INFO\"] = \"INFO\";\n    LogLevel[\"WARNING\"] = \"WARNING\";\n    LogLevel[\"ERROR\"] = \"ERROR\";\n    LogLevel[\"OFF\"] = \"OFF\";\n})(LogLevel || (LogLevel = {}));\nvar ErrorCode;\n(function(ErrorCode) {\n    ///////////////////\n    // Generic Errors\n    // Unknown Error\n    ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n    // Not Implemented\n    ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n    // Unsupported Operation\n    //   - operation\n    ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n    // Some sort of bad response from the server\n    ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n    // Timeout\n    ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\";\n    ///////////////////\n    // Operational  Errors\n    // Buffer Overrun\n    ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n    ///////////////////\n    // Argument Errors\n    // Missing new operator to an object\n    //  - name: The name of the class\n    ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\";\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n    ///////////////////\n    // Blockchain Errors\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    ErrorCode[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n    ///////////////////\n    // Interaction Errors\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ErrorCode[\"ACTION_REJECTED\"] = \"ACTION_REJECTED\";\n})(ErrorCode || (ErrorCode = {}));\nconst HEX = \"0123456789abcdef\";\nclass Logger {\n    constructor(version){\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n    _log(logLevel, args) {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) {\n            return;\n        }\n        console.log.apply(console, args);\n    }\n    debug(...args) {\n        this._log(Logger.levels.DEBUG, args);\n    }\n    info(...args) {\n        this._log(Logger.levels.INFO, args);\n    }\n    warn(...args) {\n        this._log(Logger.levels.WARNING, args);\n    }\n    makeError(message, code, params) {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, {});\n        }\n        if (!code) {\n            code = Logger.errors.UNKNOWN_ERROR;\n        }\n        if (!params) {\n            params = {};\n        }\n        const messageDetails = [];\n        Object.keys(params).forEach((key)=>{\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for(let i = 0; i < value.length; i++){\n                        hex += HEX[value[i] >> 4];\n                        hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${code}`);\n        messageDetails.push(`version=${this.version}`);\n        const reason = message;\n        let url = \"\";\n        switch(code){\n            case ErrorCode.NUMERIC_FAULT:\n                {\n                    url = \"NUMERIC_FAULT\";\n                    const fault = message;\n                    switch(fault){\n                        case \"overflow\":\n                        case \"underflow\":\n                        case \"division-by-zero\":\n                            url += \"-\" + fault;\n                            break;\n                        case \"negative-power\":\n                        case \"negative-width\":\n                            url += \"-unsupported\";\n                            break;\n                        case \"unbound-bitwise-result\":\n                            url += \"-unbound-result\";\n                            break;\n                    }\n                    break;\n                }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n        if (url) {\n            message += \" [ See: https://links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n        // @TODO: Any??\n        const error = new Error(message);\n        error.reason = reason;\n        error.code = code;\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n        return error;\n    }\n    throwError(message, code, params) {\n        throw this.makeError(message, code, params);\n    }\n    throwArgumentError(message, name, value) {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n    assert(condition, message, code, params) {\n        if (!!condition) {\n            return;\n        }\n        this.throwError(message, code, params);\n    }\n    assertArgument(condition, message, name, value) {\n        if (!!condition) {\n            return;\n        }\n        this.throwArgumentError(message, name, value);\n    }\n    checkNormalize(message) {\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\",\n                form: _normalizeError\n            });\n        }\n    }\n    checkSafeUint53(value, message) {\n        if (typeof value !== \"number\") {\n            return;\n        }\n        if (message == null) {\n            message = \"value not safe\";\n        }\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n    checkArgumentCount(count, expectedCount, message) {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n    checkNew(target, kind) {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, {\n                name: kind.name\n            });\n        }\n    }\n    checkAbstract(target, kind) {\n        if (target === kind) {\n            this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger.errors.UNSUPPORTED_OPERATION, {\n                name: target.name,\n                operation: \"new\"\n            });\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, {\n                name: kind.name\n            });\n        }\n    }\n    static globalLogger() {\n        if (!_globalLogger) {\n            _globalLogger = new Logger(version$1);\n        }\n        return _globalLogger;\n    }\n    static setCensorship(censorship, permanent) {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        if (_permanentCensorErrors) {\n            if (!censorship) {\n                return;\n            }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n    static setLogLevel(logLevel) {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n    static from(version) {\n        return new Logger(version);\n    }\n}\nLogger.errors = ErrorCode;\nLogger.levels = LogLevel;\nconst version = \"strings/5.7.0\";\nconst logger = new Logger(version);\n///////////////////////////////\nvar UnicodeNormalizationForm;\n(function(UnicodeNormalizationForm) {\n    UnicodeNormalizationForm[\"current\"] = \"\";\n    UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n    UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n    UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n    UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));\nvar Utf8ErrorReason;\n(function(Utf8ErrorReason) {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"UNEXPECTED_CONTINUE\"] = \"unexpected continuation byte\";\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"BAD_PREFIX\"] = \"bad codepoint prefix\";\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"OVERRUN\"] = \"string overrun\";\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    Utf8ErrorReason[\"MISSING_CONTINUE\"] = \"missing continuation byte\";\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    Utf8ErrorReason[\"OUT_OF_RANGE\"] = \"out of UTF-8 range\";\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    Utf8ErrorReason[\"UTF16_SURROGATE\"] = \"UTF-16 surrogate\";\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    Utf8ErrorReason[\"OVERLONG\"] = \"overlong representation\";\n})(Utf8ErrorReason || (Utf8ErrorReason = {}));\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    return logger.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for(let o = offset + 1; o < bytes.length; o++){\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes);\n}\n// Common error handing strategies\nconst Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes$1, onError) {\n    if (onError == null) {\n        onError = Utf8ErrorFuncs.error;\n    }\n    bytes$1 = bytes.arrayify(bytes$1);\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while(i < bytes$1.length){\n        const c = bytes$1[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes$1, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes$1, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes$1.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes$1, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & (1 << 8 - extraLength - 1) - 1;\n        for(let j = 0; j < extraLength; j++){\n            let nextChar = bytes$1[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes$1, result);\n                res = null;\n                break;\n            }\n            res = res << 6 | nextChar & 0x3f;\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes$1, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes$1, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes$1, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nfunction toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n    let result = [];\n    for(let i = 0; i < str.length; i++){\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        } else if (c < 0x800) {\n            result.push(c >> 6 | 0xc0);\n            result.push(c & 0x3f | 0x80);\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push(pair >> 18 | 0xf0);\n            result.push(pair >> 12 & 0x3f | 0x80);\n            result.push(pair >> 6 & 0x3f | 0x80);\n            result.push(pair & 0x3f | 0x80);\n        } else {\n            result.push(c >> 12 | 0xe0);\n            result.push(c >> 6 & 0x3f | 0x80);\n            result.push(c & 0x3f | 0x80);\n        }\n    }\n    return bytes.arrayify(result);\n}\nfunction _toUtf8String(codePoints) {\n    return codePoints.map((codePoint)=>{\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((codePoint >> 10 & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\");\n}\nfunction toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\nfunction bytes2(data) {\n    if (data.length % 4 !== 0) {\n        throw new Error(\"bad data\");\n    }\n    let result = [];\n    for(let i = 0; i < data.length; i += 4){\n        result.push(parseInt(data.substring(i, i + 4), 16));\n    }\n    return result;\n}\nfunction createTable(data, func) {\n    if (!func) {\n        func = function(value) {\n            return [\n                parseInt(value, 16)\n            ];\n        };\n    }\n    let lo = 0;\n    let result = {};\n    data.split(\",\").forEach((pair)=>{\n        let comps = pair.split(\":\");\n        lo += parseInt(comps[0], 16);\n        result[lo] = func(comps[1]);\n    });\n    return result;\n}\nfunction createRangeTable(data) {\n    let hi = 0;\n    return data.split(\",\").map((v)=>{\n        let comps = v.split(\"-\");\n        if (comps.length === 1) {\n            comps[1] = \"0\";\n        } else if (comps[1] === \"\") {\n            comps[1] = \"1\";\n        }\n        let lo = hi + parseInt(comps[0], 16);\n        hi = parseInt(comps[1], 16);\n        return {\n            l: lo,\n            h: hi\n        };\n    });\n}\ncreateRangeTable(\"221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d\");\n// @TODO: Make this relative...\n\"ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff\".split(\",\").map((v)=>parseInt(v, 16));\ncreateTable(\"b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3\");\ncreateTable(\"179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7\");\ncreateTable(\"df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D\", bytes2);\ncreateRangeTable(\"80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001\");\nObject.defineProperty(exports, \"dnsEncode\", ({\n    enumerable: true,\n    get: function() {\n        return hash.dnsEncode;\n    }\n}));\nObject.defineProperty(exports, \"hashMessage\", ({\n    enumerable: true,\n    get: function() {\n        return hash.hashMessage;\n    }\n}));\nObject.defineProperty(exports, \"id\", ({\n    enumerable: true,\n    get: function() {\n        return hash.id;\n    }\n}));\nObject.defineProperty(exports, \"isValidName\", ({\n    enumerable: true,\n    get: function() {\n        return hash.isValidName;\n    }\n}));\nObject.defineProperty(exports, \"namehash\", ({\n    enumerable: true,\n    get: function() {\n        return hash.namehash;\n    }\n}));\nObject.defineProperty(exports, \"arrayify\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.arrayify;\n    }\n}));\nObject.defineProperty(exports, \"concat\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.concat;\n    }\n}));\nObject.defineProperty(exports, \"hexConcat\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.hexConcat;\n    }\n}));\nObject.defineProperty(exports, \"hexDataLength\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.hexDataLength;\n    }\n}));\nObject.defineProperty(exports, \"hexDataSlice\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.hexDataSlice;\n    }\n}));\nObject.defineProperty(exports, \"hexStripZeros\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.hexStripZeros;\n    }\n}));\nObject.defineProperty(exports, \"hexValue\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.hexValue;\n    }\n}));\nObject.defineProperty(exports, \"hexZeroPad\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.hexZeroPad;\n    }\n}));\nObject.defineProperty(exports, \"hexlify\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.hexlify;\n    }\n}));\nObject.defineProperty(exports, \"isBytes\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.isBytes;\n    }\n}));\nObject.defineProperty(exports, \"isBytesLike\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.isBytesLike;\n    }\n}));\nObject.defineProperty(exports, \"isHexString\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.isHexString;\n    }\n}));\nObject.defineProperty(exports, \"joinSignature\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.joinSignature;\n    }\n}));\nObject.defineProperty(exports, \"splitSignature\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.splitSignature;\n    }\n}));\nObject.defineProperty(exports, \"stripZeros\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.stripZeros;\n    }\n}));\nObject.defineProperty(exports, \"zeroPad\", ({\n    enumerable: true,\n    get: function() {\n        return bytes.zeroPad;\n    }\n}));\nObject.defineProperty(exports, \"formatEther\", ({\n    enumerable: true,\n    get: function() {\n        return units.formatEther;\n    }\n}));\nObject.defineProperty(exports, \"formatUnits\", ({\n    enumerable: true,\n    get: function() {\n        return units.formatUnits;\n    }\n}));\nObject.defineProperty(exports, \"parseEther\", ({\n    enumerable: true,\n    get: function() {\n        return units.parseEther;\n    }\n}));\nObject.defineProperty(exports, \"parseUnits\", ({\n    enumerable: true,\n    get: function() {\n        return units.parseUnits;\n    }\n}));\nObject.defineProperty(exports, \"Interface\", ({\n    enumerable: true,\n    get: function() {\n        return abi.Interface;\n    }\n}));\nexports.toUtf8Bytes = toUtf8Bytes;\nexports.toUtf8String = toUtf8String; //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9janMvYXBpL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELElBQUlDLE9BQU9DLG1CQUFPQSxDQUFDO0FBQ25CLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlFLFFBQVFGLG1CQUFPQSxDQUFDO0FBQ3BCQSxtQkFBT0EsQ0FBQztBQUNSLElBQUlHLE1BQU1ILG1CQUFPQSxDQUFDO0FBRWxCLE1BQU1JLFlBQVk7QUFFbEIsSUFBSUMseUJBQXlCO0FBQzdCLElBQUlDLGdCQUFnQjtBQUNwQixNQUFNQyxZQUFZO0lBQUVDLE9BQU87SUFBRyxXQUFXO0lBQUdDLE1BQU07SUFBR0MsU0FBUztJQUFHQyxPQUFPO0lBQUdDLEtBQUs7QUFBRTtBQUNsRixJQUFJQyxZQUFZTixTQUFTLENBQUMsVUFBVTtBQUNwQyxJQUFJTyxnQkFBZ0I7QUFDcEIsU0FBU0M7SUFDTCxJQUFJO1FBQ0EsTUFBTUMsVUFBVSxFQUFFO1FBQ2xCLHFEQUFxRDtRQUNyRDtZQUFDO1lBQU87WUFBTztZQUFRO1NBQU8sQ0FBQ0MsT0FBTyxDQUFDLENBQUNDO1lBQ3BDLElBQUk7Z0JBQ0EsSUFBSSxPQUFPQyxTQUFTLENBQUNELFVBQVUsUUFBUTtvQkFDbkMsTUFBTSxJQUFJRSxNQUFNO2dCQUNwQjs7WUFFSixFQUNBLE9BQU9ULE9BQU87Z0JBQ1ZLLFFBQVFLLElBQUksQ0FBQ0g7WUFDakI7UUFDSjtRQUNBLElBQUlGLFFBQVFNLE1BQU0sRUFBRTtZQUNoQixNQUFNLElBQUlGLE1BQU0sYUFBYUosUUFBUU8sSUFBSSxDQUFDO1FBQzlDO1FBQ0EsSUFBSUMsT0FBT0MsWUFBWSxDQUFDLE1BQU1OLFNBQVMsQ0FBQyxXQUFXSyxPQUFPQyxZQUFZLENBQUMsTUFBTSxTQUFTO1lBQ2xGLE1BQU0sSUFBSUwsTUFBTTtRQUNwQjtJQUNKLEVBQ0Es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WjRILEtBQUs7UUFBYyxPQUFPN0osTUFBTWlMLE9BQU87SUFBRTtBQUM3QyxDQUFDLEVBQUM7QUFDRnZMLCtDQUE4QztJQUMxQ3VDLFlBQVk7SUFDWjRILEtBQUs7UUFBYyxPQUFPNUosTUFBTWlMLFdBQVc7SUFBRTtBQUNqRCxDQUFDLEVBQUM7QUFDRnhMLCtDQUE4QztJQUMxQ3VDLFlBQVk7SUFDWjRILEtBQUs7UUFBYyxPQUFPNUosTUFBTWtMLFdBQVc7SUFBRTtBQUNqRCxDQUFDLEVBQUM7QUFDRnpMLDhDQUE2QztJQUN6Q3VDLFlBQVk7SUFDWjRILEtBQUs7UUFBYyxPQUFPNUosTUFBTW1MLFVBQVU7SUFBRTtBQUNoRCxDQUFDLEVBQUM7QUFDRjFMLDhDQUE2QztJQUN6Q3VDLFlBQVk7SUFDWjRILEtBQUs7UUFBYyxPQUFPNUosTUFBTW9MLFVBQVU7SUFBRTtBQUNoRCxDQUFDLEVBQUM7QUFDRjNMLDZDQUE0QztJQUN4Q3VDLFlBQVk7SUFDWjRILEtBQUs7UUFBYyxPQUFPM0osSUFBSW9MLFNBQVM7SUFBRTtBQUM3QyxDQUFDLEVBQUM7QUFDRjFMLG1CQUFtQixHQUFHd0k7QUFDdEJ4SSxvQkFBb0IsR0FBR2tKLGNBQ3ZCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9janMvYXBpL3V0aWxzLmpzP2M4YjMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2hhc2gnKTtcbnZhciBieXRlcyA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2J5dGVzJyk7XG52YXIgdW5pdHMgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC91bml0cycpO1xucmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyJyk7XG52YXIgYWJpID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvYWJpJyk7XG5cbmNvbnN0IHZlcnNpb24kMSA9IFwibG9nZ2VyLzUuNy4wXCI7XG5cbmxldCBfcGVybWFuZW50Q2Vuc29yRXJyb3JzID0gZmFsc2U7XG5sZXQgX2NlbnNvckVycm9ycyA9IGZhbHNlO1xuY29uc3QgTG9nTGV2ZWxzID0geyBkZWJ1ZzogMSwgXCJkZWZhdWx0XCI6IDIsIGluZm86IDIsIHdhcm5pbmc6IDMsIGVycm9yOiA0LCBvZmY6IDUgfTtcbmxldCBfbG9nTGV2ZWwgPSBMb2dMZXZlbHNbXCJkZWZhdWx0XCJdO1xubGV0IF9nbG9iYWxMb2dnZXIgPSBudWxsO1xuZnVuY3Rpb24gX2NoZWNrTm9ybWFsaXplKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSBbXTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGFsbCBmb3JtcyBvZiBub3JtYWxpemF0aW9uIGFyZSBzdXBwb3J0ZWRcbiAgICAgICAgW1wiTkZEXCIsIFwiTkZDXCIsIFwiTkZLRFwiLCBcIk5GS0NcIl0uZm9yRWFjaCgoZm9ybSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoXCJ0ZXN0XCIubm9ybWFsaXplKGZvcm0pICE9PSBcInRlc3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgbm9ybWFsaXplXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2goZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobWlzc2luZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgXCIgKyBtaXNzaW5nLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlOSkubm9ybWFsaXplKFwiTkZEXCIpICE9PSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4NjUsIDB4MDMwMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJyb2tlbiBpbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgX25vcm1hbGl6ZUVycm9yID0gX2NoZWNrTm9ybWFsaXplKCk7XG52YXIgTG9nTGV2ZWw7XG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gICAgTG9nTGV2ZWxbXCJERUJVR1wiXSA9IFwiREVCVUdcIjtcbiAgICBMb2dMZXZlbFtcIklORk9cIl0gPSBcIklORk9cIjtcbiAgICBMb2dMZXZlbFtcIldBUk5JTkdcIl0gPSBcIldBUk5JTkdcIjtcbiAgICBMb2dMZXZlbFtcIkVSUk9SXCJdID0gXCJFUlJPUlwiO1xuICAgIExvZ0xldmVsW1wiT0ZGXCJdID0gXCJPRkZcIjtcbn0pKExvZ0xldmVsIHx8IChMb2dMZXZlbCA9IHt9KSk7XG52YXIgRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChFcnJvckNvZGUpIHtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gR2VuZXJpYyBFcnJvcnNcbiAgICAvLyBVbmtub3duIEVycm9yXG4gICAgRXJyb3JDb2RlW1wiVU5LTk9XTl9FUlJPUlwiXSA9IFwiVU5LTk9XTl9FUlJPUlwiO1xuICAgIC8vIE5vdCBJbXBsZW1lbnRlZFxuICAgIEVycm9yQ29kZVtcIk5PVF9JTVBMRU1FTlRFRFwiXSA9IFwiTk9UX0lNUExFTUVOVEVEXCI7XG4gICAgLy8gVW5zdXBwb3J0ZWQgT3BlcmF0aW9uXG4gICAgLy8gICAtIG9wZXJhdGlvblxuICAgIEVycm9yQ29kZVtcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiXSA9IFwiVU5TVVBQT1JURURfT1BFUkFUSU9OXCI7XG4gICAgLy8gTmV0d29yayBFcnJvciAoaS5lLiBFdGhlcmV1bSBOZXR3b3JrLCBzdWNoIGFzIGFuIGludmFsaWQgY2hhaW4gSUQpXG4gICAgLy8gICAtIGV2ZW50IChcIm5vTmV0d29ya1wiIGlzIG5vdCByZS10aHJvd24gaW4gcHJvdmlkZXIucmVhZHk7IG90aGVyd2lzZSB0aHJvd24pXG4gICAgRXJyb3JDb2RlW1wiTkVUV09SS19FUlJPUlwiXSA9IFwiTkVUV09SS19FUlJPUlwiO1xuICAgIC8vIFNvbWUgc29ydCBvZiBiYWQgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyXG4gICAgRXJyb3JDb2RlW1wiU0VSVkVSX0VSUk9SXCJdID0gXCJTRVJWRVJfRVJST1JcIjtcbiAgICAvLyBUaW1lb3V0XG4gICAgRXJyb3JDb2RlW1wiVElNRU9VVFwiXSA9IFwiVElNRU9VVFwiO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBPcGVyYXRpb25hbCAgRXJyb3JzXG4gICAgLy8gQnVmZmVyIE92ZXJydW5cbiAgICBFcnJvckNvZGVbXCJCVUZGRVJfT1ZFUlJVTlwiXSA9IFwiQlVGRkVSX09WRVJSVU5cIjtcbiAgICAvLyBOdW1lcmljIEZhdWx0XG4gICAgLy8gICAtIG9wZXJhdGlvbjogdGhlIG9wZXJhdGlvbiBiZWluZyBleGVjdXRlZFxuICAgIC8vICAgLSBmYXVsdDogdGhlIHJlYXNvbiB0aGlzIGZhdWx0ZWRcbiAgICBFcnJvckNvZGVbXCJOVU1FUklDX0ZBVUxUXCJdID0gXCJOVU1FUklDX0ZBVUxUXCI7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEFyZ3VtZW50IEVycm9yc1xuICAgIC8vIE1pc3NpbmcgbmV3IG9wZXJhdG9yIHRvIGFuIG9iamVjdFxuICAgIC8vICAtIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBjbGFzc1xuICAgIEVycm9yQ29kZVtcIk1JU1NJTkdfTkVXXCJdID0gXCJNSVNTSU5HX05FV1wiO1xuICAgIC8vIEludmFsaWQgYXJndW1lbnQgKGUuZy4gdmFsdWUgaXMgaW5jb21wYXRpYmxlIHdpdGggdHlwZSkgdG8gYSBmdW5jdGlvbjpcbiAgICAvLyAgIC0gYXJndW1lbnQ6IFRoZSBhcmd1bWVudCBuYW1lIHRoYXQgd2FzIGludmFsaWRcbiAgICAvLyAgIC0gdmFsdWU6IFRoZSB2YWx1ZSBvZiB0aGUgYXJndW1lbnRcbiAgICBFcnJvckNvZGVbXCJJTlZBTElEX0FSR1VNRU5UXCJdID0gXCJJTlZBTElEX0FSR1VNRU5UXCI7XG4gICAgLy8gTWlzc2luZyBhcmd1bWVudCB0byBhIGZ1bmN0aW9uOlxuICAgIC8vICAgLSBjb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgcmVjZWl2ZWRcbiAgICAvLyAgIC0gZXhwZWN0ZWRDb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgZXhwZWN0ZWRcbiAgICBFcnJvckNvZGVbXCJNSVNTSU5HX0FSR1VNRU5UXCJdID0gXCJNSVNTSU5HX0FSR1VNRU5UXCI7XG4gICAgLy8gVG9vIG1hbnkgYXJndW1lbnRzXG4gICAgLy8gICAtIGNvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyByZWNlaXZlZFxuICAgIC8vICAgLSBleHBlY3RlZENvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBleHBlY3RlZFxuICAgIEVycm9yQ29kZVtcIlVORVhQRUNURURfQVJHVU1FTlRcIl0gPSBcIlVORVhQRUNURURfQVJHVU1FTlRcIjtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQmxvY2tjaGFpbiBFcnJvcnNcbiAgICAvLyBDYWxsIGV4Y2VwdGlvblxuICAgIC8vICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb25cbiAgICAvLyAgLSBhZGRyZXNzPzogdGhlIGNvbnRyYWN0IGFkZHJlc3NcbiAgICAvLyAgLSBhcmdzPzogVGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byB0aGUgZnVuY3Rpb25cbiAgICAvLyAgLSBtZXRob2Q/OiBUaGUgU29saWRpdHkgbWV0aG9kIHNpZ25hdHVyZVxuICAgIC8vICAtIGVycm9yU2lnbmF0dXJlPzogVGhlIEVJUDg0OCBlcnJvciBzaWduYXR1cmVcbiAgICAvLyAgLSBlcnJvckFyZ3M/OiBUaGUgRUlQODQ4IGVycm9yIHBhcmFtZXRlcnNcbiAgICAvLyAgLSByZWFzb246IFRoZSByZWFzb24gKG9ubHkgZm9yIEVJUDg0OCBcIkVycm9yKHN0cmluZylcIilcbiAgICBFcnJvckNvZGVbXCJDQUxMX0VYQ0VQVElPTlwiXSA9IFwiQ0FMTF9FWENFUFRJT05cIjtcbiAgICAvLyBJbnN1ZmZpY2llbnQgZnVuZHMgKDwgdmFsdWUgKyBnYXNMaW1pdCAqIGdhc1ByaWNlKVxuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIGF0dGVtcHRlZFxuICAgIEVycm9yQ29kZVtcIklOU1VGRklDSUVOVF9GVU5EU1wiXSA9IFwiSU5TVUZGSUNJRU5UX0ZVTkRTXCI7XG4gICAgLy8gTm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXG4gICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gYXR0ZW1wdGVkXG4gICAgRXJyb3JDb2RlW1wiTk9OQ0VfRVhQSVJFRFwiXSA9IFwiTk9OQ0VfRVhQSVJFRFwiO1xuICAgIC8vIFRoZSByZXBsYWNlbWVudCBmZWUgZm9yIHRoZSB0cmFuc2FjdGlvbiBpcyB0b28gbG93XG4gICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gYXR0ZW1wdGVkXG4gICAgRXJyb3JDb2RlW1wiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIl0gPSBcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCI7XG4gICAgLy8gVGhlIGdhcyBsaW1pdCBjb3VsZCBub3QgYmUgZXN0aW1hdGVkXG4gICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gcGFzc2VkIHRvIGVzdGltYXRlR2FzXG4gICAgRXJyb3JDb2RlW1wiVU5QUkVESUNUQUJMRV9HQVNfTElNSVRcIl0gPSBcIlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUXCI7XG4gICAgLy8gVGhlIHRyYW5zYWN0aW9uIHdhcyByZXBsYWNlZCBieSBvbmUgd2l0aCBhIGhpZ2hlciBnYXMgcHJpY2VcbiAgICAvLyAgIC0gcmVhc29uOiBcImNhbmNlbGxlZFwiLCBcInJlcGxhY2VkXCIgb3IgXCJyZXByaWNlZFwiXG4gICAgLy8gICAtIGNhbmNlbGxlZDogdHJ1ZSBpZiByZWFzb24gPT0gXCJjYW5jZWxsZWRcIiBvciByZWFzb24gPT0gXCJyZXBsYWNlZFwiKVxuICAgIC8vICAgLSBoYXNoOiBvcmlnaW5hbCB0cmFuc2FjdGlvbiBoYXNoXG4gICAgLy8gICAtIHJlcGxhY2VtZW50OiB0aGUgZnVsbCBUcmFuc2FjdGlvbnNSZXNwb25zZSBmb3IgdGhlIHJlcGxhY2VtZW50XG4gICAgLy8gICAtIHJlY2VpcHQ6IHRoZSByZWNlaXB0IG9mIHRoZSByZXBsYWNlbWVudFxuICAgIEVycm9yQ29kZVtcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCJdID0gXCJUUkFOU0FDVElPTl9SRVBMQUNFRFwiO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBJbnRlcmFjdGlvbiBFcnJvcnNcbiAgICAvLyBUaGUgdXNlciByZWplY3RlZCB0aGUgYWN0aW9uLCBzdWNoIGFzIHNpZ25pbmcgYSBtZXNzYWdlIG9yIHNlbmRpbmdcbiAgICAvLyBhIHRyYW5zYWN0aW9uXG4gICAgRXJyb3JDb2RlW1wiQUNUSU9OX1JFSkVDVEVEXCJdID0gXCJBQ1RJT05fUkVKRUNURURcIjtcbn0pKEVycm9yQ29kZSB8fCAoRXJyb3JDb2RlID0ge30pKTtcbmNvbnN0IEhFWCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuY2xhc3MgTG9nZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnNpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2ZXJzaW9uLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfbG9nKGxvZ0xldmVsLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gbG9nTGV2ZWwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKExvZ0xldmVsc1tsZXZlbF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGxvZyBsZXZlbCBuYW1lXCIsIFwibG9nTGV2ZWxcIiwgbG9nTGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfbG9nTGV2ZWwgPiBMb2dMZXZlbHNbbGV2ZWxdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgfVxuICAgIGRlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuREVCVUcsIGFyZ3MpO1xuICAgIH1cbiAgICBpbmZvKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuSU5GTywgYXJncyk7XG4gICAgfVxuICAgIHdhcm4oLi4uYXJncykge1xuICAgICAgICB0aGlzLl9sb2coTG9nZ2VyLmxldmVscy5XQVJOSU5HLCBhcmdzKTtcbiAgICB9XG4gICAgbWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcykge1xuICAgICAgICAvLyBFcnJvcnMgYXJlIGJlaW5nIGNlbnNvcmVkXG4gICAgICAgIGlmIChfY2Vuc29yRXJyb3JzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlRXJyb3IoXCJjZW5zb3JlZCBlcnJvclwiLCBjb2RlLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICBjb2RlID0gTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlRGV0YWlscyA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGV4ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGV4ICs9IEhFWFt2YWx1ZVtpXSA+PiA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhleCArPSBIRVhbdmFsdWVbaV0gJiAweDBmXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVVpbnQ4QXJyYXkoMHhcIiArIGhleCArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeShwYXJhbXNba2V5XS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGBjb2RlPSR7Y29kZX1gKTtcbiAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChgdmVyc2lvbj0ke3RoaXMudmVyc2lvbn1gKTtcbiAgICAgICAgY29uc3QgcmVhc29uID0gbWVzc2FnZTtcbiAgICAgICAgbGV0IHVybCA9IFwiXCI7XG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuTlVNRVJJQ19GQVVMVDoge1xuICAgICAgICAgICAgICAgIHVybCA9IFwiTlVNRVJJQ19GQVVMVFwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhdWx0ID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvdmVyZmxvd1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidW5kZXJmbG93XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkaXZpc2lvbi1ieS16ZXJvXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCItXCIgKyBmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmVnYXRpdmUtcG93ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5lZ2F0aXZlLXdpZHRoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCItdW5zdXBwb3J0ZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidW5ib3VuZC1iaXR3aXNlLXJlc3VsdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiLXVuYm91bmQtcmVzdWx0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5DQUxMX0VYQ0VQVElPTjpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLklOU1VGRklDSUVOVF9GVU5EUzpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLk1JU1NJTkdfTkVXOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuTk9OQ0VfRVhQSVJFRDpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuVFJBTlNBQ1RJT05fUkVQTEFDRUQ6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVDpcbiAgICAgICAgICAgICAgICB1cmwgPSBjb2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgWyBTZWU6IGh0dHBzOi9cXC9saW5rcy5ldGhlcnMub3JnL3Y1LWVycm9ycy1cIiArIHVybCArIFwiIF1cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZURldGFpbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChcIiArIG1lc3NhZ2VEZXRhaWxzLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiBBbnk/P1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgZXJyb3IucmVhc29uID0gcmVhc29uO1xuICAgICAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGVycm9yW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3dFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5tYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKTtcbiAgICB9XG4gICAgdGhyb3dBcmd1bWVudEVycm9yKG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICBhcmd1bWVudDogbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSwgY29kZSwgcGFyYW1zKSB7XG4gICAgICAgIGlmICghIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChjb25kaXRpb24sIG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICghIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dBcmd1bWVudEVycm9yKG1lc3NhZ2UsIG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgY2hlY2tOb3JtYWxpemUobWVzc2FnZSkge1xuICAgICAgICBpZiAoX25vcm1hbGl6ZUVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIlN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIGZvcm06IF9ub3JtYWxpemVFcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tTYWZlVWludDUzKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcInZhbHVlIG5vdCBzYWZlXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAweDFmZmZmZmZmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5OVU1FUklDX0ZBVUxULCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImNoZWNrU2FmZUludGVnZXJcIixcbiAgICAgICAgICAgICAgICBmYXVsdDogXCJvdXQtb2Ytc2FmZS1yYW5nZVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICUgMSkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJjaGVja1NhZmVJbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgZmF1bHQ6IFwibm9uLWludGVnZXJcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrQXJndW1lbnRDb3VudChjb3VudCwgZXhwZWN0ZWRDb3VudCwgbWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiOiBcIiArIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnQgPCBleHBlY3RlZENvdW50KSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIGFyZ3VtZW50XCIgKyBtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLk1JU1NJTkdfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ID4gZXhwZWN0ZWRDb3VudCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwidG9vIG1hbnkgYXJndW1lbnRzXCIgKyBtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tOZXcodGFyZ2V0LCBraW5kKSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IE9iamVjdCB8fCB0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBuZXdcIiwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX05FVywgeyBuYW1lOiBraW5kLm5hbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tBYnN0cmFjdCh0YXJnZXQsIGtpbmQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0ga2luZCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiY2Fubm90IGluc3RhbnRpYXRlIGFic3RyYWN0IGNsYXNzIFwiICsgSlNPTi5zdHJpbmdpZnkoa2luZC5uYW1lKSArIFwiIGRpcmVjdGx5OyB1c2UgYSBzdWItY2xhc3NcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgbmFtZTogdGFyZ2V0Lm5hbWUsIG9wZXJhdGlvbjogXCJuZXdcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0YXJnZXQgPT09IE9iamVjdCB8fCB0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBuZXdcIiwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX05FVywgeyBuYW1lOiBraW5kLm5hbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdsb2JhbExvZ2dlcigpIHtcbiAgICAgICAgaWYgKCFfZ2xvYmFsTG9nZ2VyKSB7XG4gICAgICAgICAgICBfZ2xvYmFsTG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uJDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZ2xvYmFsTG9nZ2VyO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0Q2Vuc29yc2hpcChjZW5zb3JzaGlwLCBwZXJtYW5lbnQpIHtcbiAgICAgICAgaWYgKCFjZW5zb3JzaGlwICYmIHBlcm1hbmVudCkge1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxMb2dnZXIoKS50aHJvd0Vycm9yKFwiY2Fubm90IHBlcm1hbmVudGx5IGRpc2FibGUgY2Vuc29yc2hpcFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXRDZW5zb3JzaGlwXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfcGVybWFuZW50Q2Vuc29yRXJyb3JzKSB7XG4gICAgICAgICAgICBpZiAoIWNlbnNvcnNoaXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdsb2JhbExvZ2dlcigpLnRocm93RXJyb3IoXCJlcnJvciBjZW5zb3JzaGlwIHBlcm1hbmVudFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXRDZW5zb3JzaGlwXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIF9jZW5zb3JFcnJvcnMgPSAhIWNlbnNvcnNoaXA7XG4gICAgICAgIF9wZXJtYW5lbnRDZW5zb3JFcnJvcnMgPSAhIXBlcm1hbmVudDtcbiAgICB9XG4gICAgc3RhdGljIHNldExvZ0xldmVsKGxvZ0xldmVsKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gTG9nTGV2ZWxzW2xvZ0xldmVsLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICBpZiAobGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgTG9nZ2VyLmdsb2JhbExvZ2dlcigpLndhcm4oXCJpbnZhbGlkIGxvZyBsZXZlbCAtIFwiICsgbG9nTGV2ZWwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF9sb2dMZXZlbCA9IGxldmVsO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuICAgIH1cbn1cbkxvZ2dlci5lcnJvcnMgPSBFcnJvckNvZGU7XG5Mb2dnZXIubGV2ZWxzID0gTG9nTGV2ZWw7XG5cbmNvbnN0IHZlcnNpb24gPSBcInN0cmluZ3MvNS43LjBcIjtcblxuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbnZhciBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm07XG4oZnVuY3Rpb24gKFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSkge1xuICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcImN1cnJlbnRcIl0gPSBcIlwiO1xuICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GQ1wiXSA9IFwiTkZDXCI7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZEXCJdID0gXCJORkRcIjtcbiAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORktDXCJdID0gXCJORktDXCI7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZLRFwiXSA9IFwiTkZLRFwiO1xufSkoVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtIHx8IChVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0gPSB7fSkpO1xudmFyIFV0ZjhFcnJvclJlYXNvbjtcbihmdW5jdGlvbiAoVXRmOEVycm9yUmVhc29uKSB7XG4gICAgLy8gQSBjb250aW51YXRpb24gYnl0ZSB3YXMgcHJlc2VudCB3aGVyZSB0aGVyZSB3YXMgbm90aGluZyB0byBjb250aW51ZVxuICAgIC8vIC0gb2Zmc2V0ID0gdGhlIGluZGV4IHRoZSBjb2RlcG9pbnQgYmVnYW4gaW5cbiAgICBVdGY4RXJyb3JSZWFzb25bXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCJdID0gXCJ1bmV4cGVjdGVkIGNvbnRpbnVhdGlvbiBieXRlXCI7XG4gICAgLy8gQW4gaW52YWxpZCAobm9uLWNvbnRpbnVhdGlvbikgYnl0ZSB0byBzdGFydCBhIFVURi04IGNvZGVwb2ludCB3YXMgZm91bmRcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG4gICAgVXRmOEVycm9yUmVhc29uW1wiQkFEX1BSRUZJWFwiXSA9IFwiYmFkIGNvZGVwb2ludCBwcmVmaXhcIjtcbiAgICAvLyBUaGUgc3RyaW5nIGlzIHRvbyBzaG9ydCB0byBwcm9jZXNzIHRoZSBleHBlY3RlZCBjb2RlcG9pbnRcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG4gICAgVXRmOEVycm9yUmVhc29uW1wiT1ZFUlJVTlwiXSA9IFwic3RyaW5nIG92ZXJydW5cIjtcbiAgICAvLyBBIG1pc3NpbmcgY29udGludWF0aW9uIGJ5dGUgd2FzIGV4cGVjdGVkIGJ1dCBub3QgZm91bmRcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29udGludWF0aW9uIGJ5dGUgd2FzIGV4cGVjdGVkIGF0XG4gICAgVXRmOEVycm9yUmVhc29uW1wiTUlTU0lOR19DT05USU5VRVwiXSA9IFwibWlzc2luZyBjb250aW51YXRpb24gYnl0ZVwiO1xuICAgIC8vIFRoZSBjb21wdXRlZCBjb2RlIHBvaW50IGlzIG91dHNpZGUgdGhlIHJhbmdlIGZvciBVVEYtOFxuICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcbiAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IG91dHNpZGUgdGhlIFVURi04IHJhbmdlXG4gICAgVXRmOEVycm9yUmVhc29uW1wiT1VUX09GX1JBTkdFXCJdID0gXCJvdXQgb2YgVVRGLTggcmFuZ2VcIjtcbiAgICAvLyBVVEYtOCBzdHJpbmdzIG1heSBub3QgY29udGFpbiBVVEYtMTYgc3Vycm9nYXRlIHBhaXJzXG4gICAgLy8gLSBvZmZzZXQgICAgICAgPSBzdGFydCBvZiB0aGlzIGNvZGVwb2ludFxuICAgIC8vIC0gYmFkQ29kZXBvaW50ID0gdGhlIGNvbXB1dGVkIGNvZGVwb2ludDsgaW5zaWRlIHRoZSBVVEYtMTYgc3Vycm9nYXRlIHJhbmdlXG4gICAgVXRmOEVycm9yUmVhc29uW1wiVVRGMTZfU1VSUk9HQVRFXCJdID0gXCJVVEYtMTYgc3Vycm9nYXRlXCI7XG4gICAgLy8gVGhlIHN0cmluZyBpcyBhbiBvdmVybG9uZyByZXByZXNlbnRhdGlvblxuICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcbiAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IGFscmVhZHkgYm91bmRzIGNoZWNrZWRcbiAgICBVdGY4RXJyb3JSZWFzb25bXCJPVkVSTE9OR1wiXSA9IFwib3ZlcmxvbmcgcmVwcmVzZW50YXRpb25cIjtcbn0pKFV0ZjhFcnJvclJlYXNvbiB8fCAoVXRmOEVycm9yUmVhc29uID0ge30pKTtcbmZ1bmN0aW9uIGVycm9yRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgY29kZXBvaW50IGF0IG9mZnNldCAke29mZnNldH07ICR7cmVhc29ufWAsIFwiYnl0ZXNcIiwgYnl0ZXMpO1xufVxuZnVuY3Rpb24gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gaW52YWxpZCBwcmVmaXggKGluY2x1ZGluZyBzdHJheSBjb250aW51YXRpb24pLCBza2lwIGFueSBhZGRpdGlvbmFsIGNvbnRpbnVhdGlvbiBieXRlc1xuICAgIGlmIChyZWFzb24gPT09IFV0ZjhFcnJvclJlYXNvbi5CQURfUFJFRklYIHx8IHJlYXNvbiA9PT0gVXRmOEVycm9yUmVhc29uLlVORVhQRUNURURfQ09OVElOVUUpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBvID0gb2Zmc2V0ICsgMTsgbyA8IGJ5dGVzLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXNbb10gPj4gNiAhPT0gMHgwMikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICAvLyBUaGlzIGJ5dGUgcnVucyB1cyBwYXN0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc28ganVzdCBqdW1wIHRvIHRoZSBlbmRcbiAgICAvLyAoYnV0IHRoZSBmaXJzdCBieXRlIHdhcyByZWFkIGFscmVhZHkgcmVhZCBhbmQgdGhlcmVmb3JlIHNraXBwZWQpXG4gICAgaWYgKHJlYXNvbiA9PT0gVXRmOEVycm9yUmVhc29uLk9WRVJSVU4pIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLmxlbmd0aCAtIG9mZnNldCAtIDE7XG4gICAgfVxuICAgIC8vIE5vdGhpbmcgdG8gc2tpcFxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gcmVwbGFjZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIE92ZXJsb25nIHJlcHJlc2VudGF0aW9ucyBhcmUgb3RoZXJ3aXNlIFwidmFsaWRcIiBjb2RlIHBvaW50czsganVzdCBub24tZGVpc3Rpbmd0aXNoZWRcbiAgICBpZiAocmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uT1ZFUkxPTkcpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goYmFkQ29kZXBvaW50KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vIFB1dCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGludG8gdGhlIG91dHB1dFxuICAgIG91dHB1dC5wdXNoKDB4ZmZmZCk7XG4gICAgLy8gT3RoZXJ3aXNlLCBwcm9jZXNzIGFzIGlmIGlnbm9yaW5nIGVycm9yc1xuICAgIHJldHVybiBpZ25vcmVGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcyk7XG59XG4vLyBDb21tb24gZXJyb3IgaGFuZGluZyBzdHJhdGVnaWVzXG5jb25zdCBVdGY4RXJyb3JGdW5jcyA9IE9iamVjdC5mcmVlemUoe1xuICAgIGVycm9yOiBlcnJvckZ1bmMsXG4gICAgaWdub3JlOiBpZ25vcmVGdW5jLFxuICAgIHJlcGxhY2U6IHJlcGxhY2VGdW5jXG59KTtcbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMzNTY0OTMvZGVjb2RlLXV0Zi04LXdpdGgtamF2YXNjcmlwdCMxMzY5MTQ5OVxuZnVuY3Rpb24gZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMkMSwgb25FcnJvcikge1xuICAgIGlmIChvbkVycm9yID09IG51bGwpIHtcbiAgICAgICAgb25FcnJvciA9IFV0ZjhFcnJvckZ1bmNzLmVycm9yO1xuICAgIH1cbiAgICBieXRlcyQxID0gYnl0ZXMuYXJyYXlpZnkoYnl0ZXMkMSk7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIC8vIEludmFsaWQgYnl0ZXMgYXJlIGlnbm9yZWRcbiAgICB3aGlsZSAoaSA8IGJ5dGVzJDEubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGMgPSBieXRlcyQxW2krK107XG4gICAgICAgIC8vIDB4eHggeHh4eFxuICAgICAgICBpZiAoYyA+PiA3ID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11bHRpYnl0ZTsgaG93IG1hbnkgYnl0ZXMgbGVmdCBmb3IgdGhpcyBjaGFyYWN0ZXI/XG4gICAgICAgIGxldCBleHRyYUxlbmd0aCA9IG51bGw7XG4gICAgICAgIGxldCBvdmVybG9uZ01hc2sgPSBudWxsO1xuICAgICAgICAvLyAxMTB4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIGlmICgoYyAmIDB4ZTApID09PSAweGMwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDE7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweDdmO1xuICAgICAgICAgICAgLy8gMTExMCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjApID09PSAweGUwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDI7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweDdmZjtcbiAgICAgICAgICAgIC8vIDExMTEgMHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4IDEweHggeHh4eFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmOCkgPT09IDB4ZjApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMztcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4ZmZmZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICgoYyAmIDB4YzApID09PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5VTkVYUEVDVEVEX0NPTlRJTlVFLCBpIC0gMSwgYnl0ZXMkMSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uQkFEX1BSRUZJWCwgaSAtIDEsIGJ5dGVzJDEsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyB3ZSBoYXZlIGVub3VnaCBieXRlcyBpbiBvdXIgZGF0YT9cbiAgICAgICAgaWYgKGkgLSAxICsgZXh0cmFMZW5ndGggPj0gYnl0ZXMkMS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1ZFUlJVTiwgaSAtIDEsIGJ5dGVzJDEsIHJlc3VsdCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxlbmd0aCBwcmVmaXggZnJvbSB0aGUgY2hhclxuICAgICAgICBsZXQgcmVzID0gYyAmICgoMSA8PCAoOCAtIGV4dHJhTGVuZ3RoIC0gMSkpIC0gMSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZXh0cmFMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IG5leHRDaGFyID0gYnl0ZXMkMVtpXTtcbiAgICAgICAgICAgIC8vIEludmFsaWQgY29udGludWF0aW9uIGJ5dGVcbiAgICAgICAgICAgIGlmICgobmV4dENoYXIgJiAweGMwKSAhPSAweDgwKSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5NSVNTSU5HX0NPTlRJTlVFLCBpLCBieXRlcyQxLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJlcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSAocmVzIDw8IDYpIHwgKG5leHRDaGFyICYgMHgzZik7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VlIGFib3ZlIGxvb3AgZm9yIGludmFsaWQgY29udGludWF0aW9uIGJ5dGVcbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWF4aW11bSBjb2RlIHBvaW50XG4gICAgICAgIGlmIChyZXMgPiAweDEwZmZmZikge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5PVVRfT0ZfUkFOR0UsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzJDEsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2VydmVkIGZvciBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICBpZiAocmVzID49IDB4ZDgwMCAmJiByZXMgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLlVURjE2X1NVUlJPR0FURSwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMkMSwgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJsb25nIHNlcXVlbmNlcyAobW9yZSBieXRlcyB0aGFuIG5lZWRlZClcbiAgICAgICAgaWYgKHJlcyA8PSBvdmVybG9uZ01hc2spIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1ZFUkxPTkcsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzJDEsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4NzI5NDA1L2hvdy10by1jb252ZXJ0LXV0Zjgtc3RyaW5nLXRvLWJ5dGUtYXJyYXlcbmZ1bmN0aW9uIHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSA9IFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5jdXJyZW50KSB7XG4gICAgaWYgKGZvcm0gIT0gVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLmN1cnJlbnQpIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrTm9ybWFsaXplKCk7XG4gICAgICAgIHN0ciA9IHN0ci5ub3JtYWxpemUoZm9ybSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiA2KSB8IDB4YzApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmYzAwKSA9PSAweGQ4MDApIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnN0IGMyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoaSA+PSBzdHIubGVuZ3RoIHx8IChjMiAmIDB4ZmMwMCkgIT09IDB4ZGMwMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdXRmLTggc3RyaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSAweDEwMDAwICsgKChjICYgMHgwM2ZmKSA8PCAxMCkgKyAoYzIgJiAweDAzZmYpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgPj4gMTgpIHwgMHhmMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gMTIpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiAxMikgfCAweGUwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgoYyA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzLmFycmF5aWZ5KHJlc3VsdCk7XG59XG5mdW5jdGlvbiBfdG9VdGY4U3RyaW5nKGNvZGVQb2ludHMpIHtcbiAgICByZXR1cm4gY29kZVBvaW50cy5tYXAoKGNvZGVQb2ludCkgPT4ge1xuICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKCgoY29kZVBvaW50ID4+IDEwKSAmIDB4M2ZmKSArIDB4ZDgwMCksICgoY29kZVBvaW50ICYgMHgzZmYpICsgMHhkYzAwKSk7XG4gICAgfSkuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHRvVXRmOFN0cmluZyhieXRlcywgb25FcnJvcikge1xuICAgIHJldHVybiBfdG9VdGY4U3RyaW5nKGdldFV0ZjhDb2RlUG9pbnRzKGJ5dGVzLCBvbkVycm9yKSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzMihkYXRhKSB7XG4gICAgaWYgKChkYXRhLmxlbmd0aCAlIDQpICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBkYXRhXCIpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KGRhdGEuc3Vic3RyaW5nKGksIGkgKyA0KSwgMTYpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlKGRhdGEsIGZ1bmMpIHtcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gW3BhcnNlSW50KHZhbHVlLCAxNildOyB9O1xuICAgIH1cbiAgICBsZXQgbG8gPSAwO1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBkYXRhLnNwbGl0KFwiLFwiKS5mb3JFYWNoKChwYWlyKSA9PiB7XG4gICAgICAgIGxldCBjb21wcyA9IHBhaXIuc3BsaXQoXCI6XCIpO1xuICAgICAgICBsbyArPSBwYXJzZUludChjb21wc1swXSwgMTYpO1xuICAgICAgICByZXN1bHRbbG9dID0gZnVuYyhjb21wc1sxXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJhbmdlVGFibGUoZGF0YSkge1xuICAgIGxldCBoaSA9IDA7XG4gICAgcmV0dXJuIGRhdGEuc3BsaXQoXCIsXCIpLm1hcCgodikgPT4ge1xuICAgICAgICBsZXQgY29tcHMgPSB2LnNwbGl0KFwiLVwiKTtcbiAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29tcHNbMV0gPSBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21wc1sxXSA9PT0gXCJcIikge1xuICAgICAgICAgICAgY29tcHNbMV0gPSBcIjFcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbG8gPSBoaSArIHBhcnNlSW50KGNvbXBzWzBdLCAxNik7XG4gICAgICAgIGhpID0gcGFyc2VJbnQoY29tcHNbMV0sIDE2KTtcbiAgICAgICAgcmV0dXJuIHsgbDogbG8sIGg6IGhpIH07XG4gICAgfSk7XG59XG5jcmVhdGVSYW5nZVRhYmxlKFwiMjIxLDEzLTFiLDVmLSw0MC0xMCw1MS1mLDExLTMsMy0zLDItMiwyLTQsOCwyLDE1LDJkLDI4LTgsODgsNDgsMjctLDMtNSwxMS0yMCwyNy0sOCwyOCwzLTUsMTIsMTgsYi1hLDFjLTQsNi0xNiwyLWQsMi0yLDIsMWItNCwxNy05LDhmLSwxMCxmLDFmLTIsMWMtMzQsMzMtMTRlLDQsMzYtLDEzLSw2LTIsMWEtZiw0LDktLDMtLDE3LDgsMi0yLDUtLDIsOC0sMy0sNC04LDItMywzLDYtLDE2LTYsMi0sNy0zLDMtLDE3LDgsMywzLDMtLDIsNi0zLDMtLDQtYSw1LDItNiwxMC1iLDQsOCwyLDQsMTcsOCwzLDYtLGIsNCw0LSwyLWUsMi00LGItMTAsNCw5LSwzLSwxNyw4LDMtLDUtLDktMiwzLSw0LTcsMy0zLDMsNC0zLGMtMTAsMyw3LTIsNCw1LTIsMywyLDMtMiwzLTIsNC0yLDksNC0zLDYtMiw0LDUtOCwyLWUsZC1kLDQsOSw0LDE4LGIsNi0zLDgsNCw1LTYsMy04LDMtMyxiLTExLDMsOSw0LDE4LGIsNi0zLDgsNCw1LTYsMy02LDIsMy0zLGItMTEsMyw5LDQsMTgsMTEtMyw3LSw0LDUtOCwyLTcsMy0zLGItMTEsMywxMy0yLDE5LGEsMi0sOC0yLDItMyw3LDIsOS0xMSw0LWIsM2ItMywxZS0yNCwzLDItLDMsMi0sMi01LDUsOCw0LDIsMi0sMyxlLDQtLDYsMiw3LSxiLSwzLTIxLDQ5LDIzLTUsMWMtMyw5LDI1LDEwLSwyLTJmLDIzLDYsMyw4LTIsNS01LDFiLTQ1LDI3LTksMmEtLDItMyw1Yi00LDQ1LTQsNTMtNSw4LDQwLDIsNS0sOCwyLDUtLDI4LDIsNS0sMjAsMiw1LSw4LDIsNS0sOCw4LDE4LDIwLDIsNS0sOCwyOCwxNC01LDFkLTIyLDU2LWIsMjc3LTgsMWUtMiw1Mi1lLGUsOC1hLDE4LTgsMTUtYixlLDQsMy1iLDVlLTIsYi0xNSwxMCxiLTUsNTktNywyYi01NTUsOWQtMyw1Yi01LDE3LSw3LSwyNy0sNy0sOSwyLDIsMiwyMC0sMzYsMTAsZi0sNywxNC0sNCxhLDU0LTMsMi02LDYtNSw5LSwxYy0xMCwxMy0xZCwxYy0xNCwzYy0sMTAtNiwzMi1iLDI0MC0zMCwyOC0xOCxjLTE0LGEwLDExNS0sMyw2Ni0sYi03Niw1LDUtLDFkLDI0LDIsNS0yLDIsOC0sMzUtMiwxOSxmLTEwLDFkLTMsMzExLTM3ZiwxYiw1YS1iLGQ3LTE5LGQtMyw0MSw1Ny0sNjgtNCwyOS0zLDVmLDI5LTM3LDJlLTIsMjUtYywyYy0yLDRlLTMsMzAsNzgtMyw2NC0sMjAsMTliNy00OSw1MWE3LTU5LDQ4ZS0yLDM4LTczOCwyYmE1LTViLDIyMmYtLDNjLTk0LDgtYiw2LTQsMWIsNiwyLDMsMyw2ZC0yMCwxNmUtZiw0MS0sMzctNywyZS0yLDExLWYsNS1iLDE4LSxiLDE0LDUtMyw2LDg4LSwyLGJmLTIsNy0sNy0sNy0sNC0yLDgsOC05LDgtMmZmLDIwLDUtYiwxYy1iNCwyNy0sMjctY2JiMSxmNy05LDI4LTIsYjUtMjIxLDU2LDQ4LDMtLDItLDMtLDUsZCwyLDUsMyw0Miw1LSw5LDgsMWQsNSw2LDItMiw4LDE1My0zLDEyMy0zLDMzLTI3ZmQsYTZkYS01MTI4LDIxZi01ZGYsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLDItMWQsNjEtZmY3ZFwiKTtcbi8vIEBUT0RPOiBNYWtlIHRoaXMgcmVsYXRpdmUuLi5cblwiYWQsMzRmLDE4MDYsMTgwYiwxODBjLDE4MGQsMjAwYiwyMDBjLDIwMGQsMjA2MCxmZWZmXCIuc3BsaXQoXCIsXCIpLm1hcCgodikgPT4gcGFyc2VJbnQodiwgMTYpKTtcbmNyZWF0ZVRhYmxlKFwiYjU6M2JjLGMzOmZmLDc6NzMsMjoyNTMsNToyNTQsMzoyNTYsMToyNTcsNToyNTksMToyNWIsMzoyNjAsMToyNjMsMjoyNjksMToyNjgsNToyNmYsMToyNzIsMjoyNzUsNzoyODAsMzoyODMsNToyODgsMzoyOGEsMToyOGIsNToyOTIsM2Y6MTk1LDE6MWJmLDI5OjE5ZSwxMjU6M2I5LDhiOjNiMiwxOjNiOCwxOjNjNSwzOjNjNiwxOjNjMCwxYTozYmEsMTozYzEsMTozYzMsMjozYjgsMTozYjUsMWJjOTozYjksMWM6MWY3NiwxOjFmNzcsZjoxZjdhLDE6MWY3YixkOjFmNzgsMToxZjc5LDE6MWY3YywxOjFmN2QsMTA3OjYzLDU6MjViLDQ6NjgsMTo2OCwxOjY4LDM6NjksMTo2OSwxOjZjLDM6NmUsNDo3MCwxOjcxLDE6NzIsMTo3MiwxOjcyLDc6N2EsMjozYzksMjo3YSwyOjZiLDE6ZTUsMTo2MiwxOjYzLDM6NjUsMTo2NiwyOjZkLGI6M2IzLDE6M2MwLDY6NjQsMWI1NzQ6M2I4LDFhOjNjMywyMDozYjgsMWE6M2MzLDIwOjNiOCwxYTozYzMsMjA6M2I4LDFhOjNjMywyMDozYjgsMWE6M2MzXCIpO1xuY3JlYXRlVGFibGUoXCIxNzk6MSwyOjEsMjoxLDU6MSwyOjEsYTo0ZixhOjEsODoxLDI6MSwyOjEsMzoxLDU6MSwzOjEsNDoxLDI6MSwzOjEsNDoxLDg6MiwxOjEsMjoyLDE6MSwyOjIsMjc6MiwxOTU6MjYsMjoyNSwxOjI1LDE6MjUsMjo0MCwyOjNmLDE6M2YsMzM6MSwxMTotNiwxOi05LDFhYzc6LTNhLDZkOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsOTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsYjotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDk6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCw5Oi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCxjOi04LDI6LTgsMjotOCwyOi04LDk6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCw0OTotOCwxOi04LDE6LTRhLDE6LTRhLGQ6LTU2LDE6LTU2LDE6LTU2LDE6LTU2LGQ6LTgsMTotOCxmOi04LDE6LTgsMzotN1wiKTtcbmNyZWF0ZVRhYmxlKFwiZGY6MDA3MzAwNzMsNTE6MDA2OTAzMDcsMTk6MDJCQzAwNkUsYTc6MDA2QTAzMEMsMThhOjAwMjAwM0I5LDE2OjAzQjkwMzA4MDMwMSwyMDowM0M1MDMwODAzMDEsMWQ3OjA1NjUwNTgyLDE5MGY6MDA2ODAzMzEsMTowMDc0MDMwOCwxOjAwNzcwMzBBLDE6MDA3OTAzMEEsMTowMDYxMDJCRSxiNjowM0M1MDMxMywyOjAzQzUwMzEzMDMwMCwyOjAzQzUwMzEzMDMwMSwyOjAzQzUwMzEzMDM0MiwyYToxRjAwMDNCOSwxOjFGMDEwM0I5LDE6MUYwMjAzQjksMToxRjAzMDNCOSwxOjFGMDQwM0I5LDE6MUYwNTAzQjksMToxRjA2MDNCOSwxOjFGMDcwM0I5LDE6MUYwMDAzQjksMToxRjAxMDNCOSwxOjFGMDIwM0I5LDE6MUYwMzAzQjksMToxRjA0MDNCOSwxOjFGMDUwM0I5LDE6MUYwNjAzQjksMToxRjA3MDNCOSwxOjFGMjAwM0I5LDE6MUYyMTAzQjksMToxRjIyMDNCOSwxOjFGMjMwM0I5LDE6MUYyNDAzQjksMToxRjI1MDNCOSwxOjFGMjYwM0I5LDE6MUYyNzAzQjksMToxRjIwMDNCOSwxOjFGMjEwM0I5LDE6MUYyMjAzQjksMToxRjIzMDNCOSwxOjFGMjQwM0I5LDE6MUYyNTAzQjksMToxRjI2MDNCOSwxOjFGMjcwM0I5LDE6MUY2MDAzQjksMToxRjYxMDNCOSwxOjFGNjIwM0I5LDE6MUY2MzAzQjksMToxRjY0MDNCOSwxOjFGNjUwM0I5LDE6MUY2NjAzQjksMToxRjY3MDNCOSwxOjFGNjAwM0I5LDE6MUY2MTAzQjksMToxRjYyMDNCOSwxOjFGNjMwM0I5LDE6MUY2NDAzQjksMToxRjY1MDNCOSwxOjFGNjYwM0I5LDE6MUY2NzAzQjksMzoxRjcwMDNCOSwxOjAzQjEwM0I5LDE6MDNBQzAzQjksMjowM0IxMDM0MiwxOjAzQjEwMzQyMDNCOSw1OjAzQjEwM0I5LDY6MUY3NDAzQjksMTowM0I3MDNCOSwxOjAzQUUwM0I5LDI6MDNCNzAzNDIsMTowM0I3MDM0MjAzQjksNTowM0I3MDNCOSw2OjAzQjkwMzA4MDMwMCwxOjAzQjkwMzA4MDMwMSwzOjAzQjkwMzQyLDE6MDNCOTAzMDgwMzQyLGI6MDNDNTAzMDgwMzAwLDE6MDNDNTAzMDgwMzAxLDE6MDNDMTAzMTMsMjowM0M1MDM0MiwxOjAzQzUwMzA4MDM0MixiOjFGN0MwM0I5LDE6MDNDOTAzQjksMTowM0NFMDNCOSwyOjAzQzkwMzQyLDE6MDNDOTAzNDIwM0I5LDU6MDNDOTAzQjksYWM6MDA3MjAwNzMsNWI6MDBCMDAwNjMsNjowMEIwMDA2NixkOjAwNkUwMDZGLGE6MDA3MzAwNkQsMTowMDc0MDA2NTAwNkMsMTowMDc0MDA2RCwxMjRmOjAwNjgwMDcwMDA2MSwyOjAwNjEwMDc1LDI6MDA2RjAwNzYsYjowMDcwMDA2MSwxOjAwNkUwMDYxLDE6MDNCQzAwNjEsMTowMDZEMDA2MSwxOjAwNkIwMDYxLDE6MDA2QjAwNjIsMTowMDZEMDA2MiwxOjAwNjcwMDYyLDM6MDA3MDAwNjYsMTowMDZFMDA2NiwxOjAzQkMwMDY2LDQ6MDA2ODAwN0EsMTowMDZCMDA2ODAwN0EsMTowMDZEMDA2ODAwN0EsMTowMDY3MDA2ODAwN0EsMTowMDc0MDA2ODAwN0EsMTU6MDA3MDAwNjEsMTowMDZCMDA3MDAwNjEsMTowMDZEMDA3MDAwNjEsMTowMDY3MDA3MDAwNjEsODowMDcwMDA3NiwxOjAwNkUwMDc2LDE6MDNCQzAwNzYsMTowMDZEMDA3NiwxOjAwNkIwMDc2LDE6MDA2RDAwNzYsMTowMDcwMDA3NywxOjAwNkUwMDc3LDE6MDNCQzAwNzcsMTowMDZEMDA3NywxOjAwNkIwMDc3LDE6MDA2RDAwNzcsMTowMDZCMDNDOSwxOjAwNkQwM0M5LDI6MDA2MjAwNzEsMzowMDYzMjIxNTAwNkIwMDY3LDE6MDA2MzAwNkYwMDJFLDE6MDA2NDAwNjIsMTowMDY3MDA3OSwyOjAwNjgwMDcwLDI6MDA2QjAwNkIsMTowMDZCMDA2RCw5OjAwNzAwMDY4LDI6MDA3MDAwNzAwMDZELDE6MDA3MDAwNzIsMjowMDczMDA3NiwxOjAwNzcwMDYyLGM3MjM6MDA2NjAwNjYsMTowMDY2MDA2OSwxOjAwNjYwMDZDLDE6MDA2NjAwNjYwMDY5LDE6MDA2NjAwNjYwMDZDLDE6MDA3MzAwNzQsMTowMDczMDA3NCxkOjA1NzQwNTc2LDE6MDU3NDA1NjUsMTowNTc0MDU2QiwxOjA1N0UwNTc2LDE6MDU3NDA1NkRcIiwgYnl0ZXMyKTtcbmNyZWF0ZVJhbmdlVGFibGUoXCI4MC0yMCwyYTAtLDM5YywzMixmNzEsMThlLDdmMi1mLDE5LTcsMzAtNCw3LTUsZjgxLWIsNSxhODAwLTIwZmYsNGQxLTFmLDExMCxmYS02LGQxNzQtNywyZTg0LSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSwyLDFmLTVmLGZmN2YtMjAwMDFcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZG5zRW5jb2RlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNoLmRuc0VuY29kZTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2hhc2hNZXNzYWdlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNoLmhhc2hNZXNzYWdlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnaWQnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2guaWQ7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdpc1ZhbGlkTmFtZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaC5pc1ZhbGlkTmFtZTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ25hbWVoYXNoJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNoLm5hbWVoYXNoOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnYXJyYXlpZnknLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzLmFycmF5aWZ5OyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnY29uY2F0Jywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlcy5jb25jYXQ7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdoZXhDb25jYXQnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzLmhleENvbmNhdDsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2hleERhdGFMZW5ndGgnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzLmhleERhdGFMZW5ndGg7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdoZXhEYXRhU2xpY2UnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzLmhleERhdGFTbGljZTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2hleFN0cmlwWmVyb3MnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzLmhleFN0cmlwWmVyb3M7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdoZXhWYWx1ZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZXMuaGV4VmFsdWU7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdoZXhaZXJvUGFkJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlcy5oZXhaZXJvUGFkOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnaGV4bGlmeScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZXMuaGV4bGlmeTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2lzQnl0ZXMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzLmlzQnl0ZXM7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdpc0J5dGVzTGlrZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZXMuaXNCeXRlc0xpa2U7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdpc0hleFN0cmluZycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZXMuaXNIZXhTdHJpbmc7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdqb2luU2lnbmF0dXJlJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBieXRlcy5qb2luU2lnbmF0dXJlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnc3BsaXRTaWduYXR1cmUnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzLnNwbGl0U2lnbmF0dXJlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnc3RyaXBaZXJvcycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnl0ZXMuc3RyaXBaZXJvczsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3plcm9QYWQnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ5dGVzLnplcm9QYWQ7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdmb3JtYXRFdGhlcicsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pdHMuZm9ybWF0RXRoZXI7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdmb3JtYXRVbml0cycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pdHMuZm9ybWF0VW5pdHM7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdwYXJzZUV0aGVyJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bml0cy5wYXJzZUV0aGVyOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncGFyc2VVbml0cycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pdHMucGFyc2VVbml0czsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0ludGVyZmFjZScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJpLkludGVyZmFjZTsgfVxufSk7XG5leHBvcnRzLnRvVXRmOEJ5dGVzID0gdG9VdGY4Qnl0ZXM7XG5leHBvcnRzLnRvVXRmOFN0cmluZyA9IHRvVXRmOFN0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaGFzaCIsInJlcXVpcmUiLCJieXRlcyIsInVuaXRzIiwiYWJpIiwidmVyc2lvbiQxIiwiX3Blcm1hbmVudENlbnNvckVycm9ycyIsIl9jZW5zb3JFcnJvcnMiLCJMb2dMZXZlbHMiLCJkZWJ1ZyIsImluZm8iLCJ3YXJuaW5nIiwiZXJyb3IiLCJvZmYiLCJfbG9nTGV2ZWwiLCJfZ2xvYmFsTG9nZ2VyIiwiX2NoZWNrTm9ybWFsaXplIiwibWlzc2luZyIsImZvckVhY2giLCJmb3JtIiwibm9ybWFsaXplIiwiRXJyb3IiLCJwdXNoIiwibGVuZ3RoIiwiam9pbiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIm1lc3NhZ2UiLCJfbm9ybWFsaXplRXJyb3IiLCJMb2dMZXZlbCIsIkVycm9yQ29kZSIsIkhFWCIsIkxvZ2dlciIsImNvbnN0cnVjdG9yIiwidmVyc2lvbiIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsIl9sb2ciLCJsb2dMZXZlbCIsImFyZ3MiLCJsZXZlbCIsInRvTG93ZXJDYXNlIiwidGhyb3dBcmd1bWVudEVycm9yIiwiY29uc29sZSIsImxvZyIsImFwcGx5IiwibGV2ZWxzIiwiREVCVUciLCJJTkZPIiwid2FybiIsIldBUk5JTkciLCJtYWtlRXJyb3IiLCJjb2RlIiwicGFyYW1zIiwiZXJyb3JzIiwiVU5LTk9XTl9FUlJPUiIsIm1lc3NhZ2VEZXRhaWxzIiwia2V5cyIsImtleSIsIlVpbnQ4QXJyYXkiLCJoZXgiLCJpIiwiSlNPTiIsInN0cmluZ2lmeSIsInRvU3RyaW5nIiwicmVhc29uIiwidXJsIiwiTlVNRVJJQ19GQVVMVCIsImZhdWx0IiwiQ0FMTF9FWENFUFRJT04iLCJJTlNVRkZJQ0lFTlRfRlVORFMiLCJNSVNTSU5HX05FVyIsIk5PTkNFX0VYUElSRUQiLCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCIsIlRSQU5TQUNUSU9OX1JFUExBQ0VEIiwiVU5QUkVESUNUQUJMRV9HQVNfTElNSVQiLCJ0aHJvd0Vycm9yIiwibmFtZSIsIklOVkFMSURfQVJHVU1FTlQiLCJhcmd1bWVudCIsImFzc2VydCIsImNvbmRpdGlvbiIsImFzc2VydEFyZ3VtZW50IiwiY2hlY2tOb3JtYWxpemUiLCJVTlNVUFBPUlRFRF9PUEVSQVRJT04iLCJvcGVyYXRpb24iLCJjaGVja1NhZmVVaW50NTMiLCJjaGVja0FyZ3VtZW50Q291bnQiLCJjb3VudCIsImV4cGVjdGVkQ291bnQiLCJNSVNTSU5HX0FSR1VNRU5UIiwiVU5FWFBFQ1RFRF9BUkdVTUVOVCIsImNoZWNrTmV3IiwidGFyZ2V0Iiwia2luZCIsImNoZWNrQWJzdHJhY3QiLCJnbG9iYWxMb2dnZXIiLCJzZXRDZW5zb3JzaGlwIiwiY2Vuc29yc2hpcCIsInBlcm1hbmVudCIsInNldExvZ0xldmVsIiwiZnJvbSIsImxvZ2dlciIsIlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSIsIlV0ZjhFcnJvclJlYXNvbiIsImVycm9yRnVuYyIsIm9mZnNldCIsIm91dHB1dCIsImJhZENvZGVwb2ludCIsImlnbm9yZUZ1bmMiLCJCQURfUFJFRklYIiwiVU5FWFBFQ1RFRF9DT05USU5VRSIsIm8iLCJPVkVSUlVOIiwicmVwbGFjZUZ1bmMiLCJPVkVSTE9ORyIsIlV0ZjhFcnJvckZ1bmNzIiwiZnJlZXplIiwiaWdub3JlIiwicmVwbGFjZSIsImdldFV0ZjhDb2RlUG9pbnRzIiwiYnl0ZXMkMSIsIm9uRXJyb3IiLCJhcnJheWlmeSIsInJlc3VsdCIsImMiLCJleHRyYUxlbmd0aCIsIm92ZXJsb25nTWFzayIsInJlcyIsImoiLCJuZXh0Q2hhciIsIk1JU1NJTkdfQ09OVElOVUUiLCJPVVRfT0ZfUkFOR0UiLCJVVEYxNl9TVVJST0dBVEUiLCJ0b1V0ZjhCeXRlcyIsInN0ciIsImN1cnJlbnQiLCJjaGFyQ29kZUF0IiwiYzIiLCJwYWlyIiwiX3RvVXRmOFN0cmluZyIsImNvZGVQb2ludHMiLCJtYXAiLCJjb2RlUG9pbnQiLCJ0b1V0ZjhTdHJpbmciLCJieXRlczIiLCJkYXRhIiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJjcmVhdGVUYWJsZSIsImZ1bmMiLCJsbyIsInNwbGl0IiwiY29tcHMiLCJjcmVhdGVSYW5nZVRhYmxlIiwiaGkiLCJ2IiwibCIsImgiLCJnZXQiLCJkbnNFbmNvZGUiLCJoYXNoTWVzc2FnZSIsImlkIiwiaXNWYWxpZE5hbWUiLCJuYW1laGFzaCIsImNvbmNhdCIsImhleENvbmNhdCIsImhleERhdGFMZW5ndGgiLCJoZXhEYXRhU2xpY2UiLCJoZXhTdHJpcFplcm9zIiwiaGV4VmFsdWUiLCJoZXhaZXJvUGFkIiwiaGV4bGlmeSIsImlzQnl0ZXMiLCJpc0J5dGVzTGlrZSIsImlzSGV4U3RyaW5nIiwiam9pblNpZ25hdHVyZSIsInNwbGl0U2lnbmF0dXJlIiwic3RyaXBaZXJvcyIsInplcm9QYWQiLCJmb3JtYXRFdGhlciIsImZvcm1hdFVuaXRzIiwicGFyc2VFdGhlciIsInBhcnNlVW5pdHMiLCJJbnRlcmZhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/alchemy-sdk/dist/cjs/api/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/alchemy-sdk/dist/cjs/index-b1f4a2d9.js":
/*!*************************************************************!*\
  !*** ./node_modules/alchemy-sdk/dist/cjs/index-b1f4a2d9.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar utils = __webpack_require__(/*! ./api/utils */ \"(ssr)/./node_modules/alchemy-sdk/dist/cjs/api/utils.js\");\nvar bignumber = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/index.js\");\nvar axios = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/index.js\");\nvar abstractProvider = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/./node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\nvar wallet = __webpack_require__(/*! @ethersproject/wallet */ \"(ssr)/./node_modules/@ethersproject/wallet/lib.esm/index.js\");\nvar contracts = __webpack_require__(/*! @ethersproject/contracts */ \"(ssr)/./node_modules/@ethersproject/contracts/lib.esm/index.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nvar axios__default = /*#__PURE__*/ _interopDefaultLegacy(axios);\n/**\r\n * The supported networks by Alchemy. Note that some functions are not available\r\n * on all networks. Please refer to the Alchemy documentation for which APIs are\r\n * available on which networks\r\n * {@link https://docs.alchemy.com/alchemy/apis/feature-support-by-chain}\r\n *\r\n * @public\r\n */ exports.Network = void 0;\n(function(Network) {\n    Network[\"ETH_MAINNET\"] = \"eth-mainnet\";\n    Network[\"ETH_GOERLI\"] = \"eth-goerli\";\n    Network[\"ETH_SEPOLIA\"] = \"eth-sepolia\";\n    Network[\"OPT_MAINNET\"] = \"opt-mainnet\";\n    Network[\"OPT_GOERLI\"] = \"opt-goerli\";\n    Network[\"OPT_SEPOLIA\"] = \"opt-sepolia\";\n    Network[\"ARB_MAINNET\"] = \"arb-mainnet\";\n    Network[\"ARB_GOERLI\"] = \"arb-goerli\";\n    Network[\"ARB_SEPOLIA\"] = \"arb-sepolia\";\n    Network[\"MATIC_MAINNET\"] = \"polygon-mainnet\";\n    Network[\"MATIC_MUMBAI\"] = \"polygon-mumbai\";\n    Network[\"ASTAR_MAINNET\"] = \"astar-mainnet\";\n    Network[\"POLYGONZKEVM_MAINNET\"] = \"polygonzkevm-mainnet\";\n    Network[\"POLYGONZKEVM_TESTNET\"] = \"polygonzkevm-testnet\";\n    Network[\"BASE_MAINNET\"] = \"base-mainnet\";\n    Network[\"BASE_GOERLI\"] = \"base-goerli\";\n    Network[\"BASE_SEPOLIA\"] = \"base-sepolia\";\n})(exports.Network || (exports.Network = {}));\n/** Token Types for the `getTokenBalances()` endpoint. */ exports.TokenBalanceType = void 0;\n(function(TokenBalanceType) {\n    /**\r\n     * Option to fetch the top 100 tokens by 24-hour volume. This option is only\r\n     * available on Mainnet in Ethereum, Polygon, and Arbitrum.\r\n     */ TokenBalanceType[\"DEFAULT_TOKENS\"] = \"DEFAULT_TOKENS\";\n    /**\r\n     * Option to fetch the set of ERC-20 tokens that the address as ever held. his\r\n     * list is produced by an address's historical transfer activity and includes\r\n     * all tokens that the address has ever received.\r\n     */ TokenBalanceType[\"ERC20\"] = \"erc20\";\n})(exports.TokenBalanceType || (exports.TokenBalanceType = {}));\n/**\r\n * Categories of transfers to use with the {@link AssetTransfersParams} request\r\n * object when using {@link CoreNamespace.getAssetTransfers}.\r\n *\r\n * @public\r\n */ exports.AssetTransfersCategory = void 0;\n(function(AssetTransfersCategory) {\n    /**\r\n     * Top level ETH transactions that occur where the `fromAddress` is an\r\n     * external user-created address. External addresses have private keys and are\r\n     * accessed by users.\r\n     */ AssetTransfersCategory[\"EXTERNAL\"] = \"external\";\n    /**\r\n     * Top level ETH transactions that occur where the `fromAddress` is an\r\n     * internal, smart contract address. For example, a smart contract calling\r\n     * another smart contract or sending\r\n     */ AssetTransfersCategory[\"INTERNAL\"] = \"internal\";\n    /** ERC20 transfers. */ AssetTransfersCategory[\"ERC20\"] = \"erc20\";\n    /** ERC721 transfers. */ AssetTransfersCategory[\"ERC721\"] = \"erc721\";\n    /** ERC1155 transfers. */ AssetTransfersCategory[\"ERC1155\"] = \"erc1155\";\n    /** Special contracts that don't follow ERC 721/1155, (ex: CryptoKitties). */ AssetTransfersCategory[\"SPECIALNFT\"] = \"specialnft\";\n})(exports.AssetTransfersCategory || (exports.AssetTransfersCategory = {}));\n/**\r\n * The type of transfer for the request. Note that using `TO` will also include\r\n * NFTs that were minted by the owner.\r\n */ exports.GetTransfersForOwnerTransferType = void 0;\n(function(GetTransfersForOwnerTransferType) {\n    GetTransfersForOwnerTransferType[\"TO\"] = \"TO\";\n    GetTransfersForOwnerTransferType[\"FROM\"] = \"FROM\";\n})(exports.GetTransfersForOwnerTransferType || (exports.GetTransfersForOwnerTransferType = {}));\n/**\r\n * Enum for representing the supported sorting orders of the API.\r\n *\r\n * @public\r\n */ exports.SortingOrder = void 0;\n(function(SortingOrder) {\n    SortingOrder[\"ASCENDING\"] = \"asc\";\n    SortingOrder[\"DESCENDING\"] = \"desc\";\n})(exports.SortingOrder || (exports.SortingOrder = {}));\n/** An OpenSea collection's approval status. */ exports.OpenSeaSafelistRequestStatus = void 0;\n(function(OpenSeaSafelistRequestStatus) {\n    /** Verified collection. */ OpenSeaSafelistRequestStatus[\"VERIFIED\"] = \"verified\";\n    /** Collections that are approved on open sea and can be found in search results. */ OpenSeaSafelistRequestStatus[\"APPROVED\"] = \"approved\";\n    /** Collections that requested safelisting on OpenSea. */ OpenSeaSafelistRequestStatus[\"REQUESTED\"] = \"requested\";\n    /** Brand new collections. */ OpenSeaSafelistRequestStatus[\"NOT_REQUESTED\"] = \"not_requested\";\n})(exports.OpenSeaSafelistRequestStatus || (exports.OpenSeaSafelistRequestStatus = {}));\n/**\r\n * Method names for Alchemy's custom Subscription API endpoints.\r\n *\r\n * This value is provided in the `method` field when creating an event filter on\r\n * the Websocket Namespace.\r\n */ exports.AlchemySubscription = void 0;\n(function(AlchemySubscription) {\n    AlchemySubscription[\"PENDING_TRANSACTIONS\"] = \"alchemy_pendingTransactions\";\n    AlchemySubscription[\"MINED_TRANSACTIONS\"] = \"alchemy_minedTransactions\";\n})(exports.AlchemySubscription || (exports.AlchemySubscription = {}));\n/**\r\n * Asset type returned when calling {@link TransactNamespace.simulateAssetChanges}.\r\n * Allows you to determine if the assets approved or / and transferred are\r\n * native, tokens or NFTs.\r\n */ exports.SimulateAssetType = void 0;\n(function(SimulateAssetType) {\n    /**\r\n     * Native transfers that involve the currency of the chain the simulation is\r\n     * run on (ex: ETH for Ethereum, MATIC for Polygon, ETH for Arbitrum).\r\n     */ SimulateAssetType[\"NATIVE\"] = \"NATIVE\";\n    /** ERC20 approval or transfers. */ SimulateAssetType[\"ERC20\"] = \"ERC20\";\n    /** ERC721 approval or transfers. */ SimulateAssetType[\"ERC721\"] = \"ERC721\";\n    /** ERC1155 approval or transfers. */ SimulateAssetType[\"ERC1155\"] = \"ERC1155\";\n    /**\r\n     * Special contracts that don't follow ERC 721/1155.Currently limited to\r\n     * CryptoKitties and CryptoPunks.\r\n     */ SimulateAssetType[\"SPECIAL_NFT\"] = \"SPECIAL_NFT\";\n})(exports.SimulateAssetType || (exports.SimulateAssetType = {}));\n/**\r\n * Change type returned when calling {@link TransactNamespace.simulateAssetChanges}.\r\n */ exports.SimulateChangeType = void 0;\n(function(SimulateChangeType) {\n    /**\r\n     * Represents a transaction that approved or disapproved permissions for a\r\n     * contract.\r\n     *\r\n     * APPROVE without token ID  approve all tokens\r\n     * APPROVE without amount  approve all amount\r\n     * APPROVE with zero amount  approval being cleared\r\n     */ SimulateChangeType[\"APPROVE\"] = \"APPROVE\";\n    /**\r\n     * Represents a transaction that transferred tokens from one address to another.\r\n     */ SimulateChangeType[\"TRANSFER\"] = \"TRANSFER\";\n})(exports.SimulateChangeType || (exports.SimulateChangeType = {}));\n/**\r\n * Authority used to decode calls and logs when using the\r\n * {@link TransactNamespace.simulateExecution} method.\r\n */ exports.DecodingAuthority = void 0;\n(function(DecodingAuthority) {\n    DecodingAuthority[\"ETHERSCAN\"] = \"ETHERSCAN\";\n})(exports.DecodingAuthority || (exports.DecodingAuthority = {}));\n/** The type of call in a debug call trace. */ exports.DebugCallType = void 0;\n(function(DebugCallType) {\n    DebugCallType[\"CREATE\"] = \"CREATE\";\n    DebugCallType[\"CALL\"] = \"CALL\";\n    DebugCallType[\"STATICCALL\"] = \"STATICCALL\";\n    DebugCallType[\"DELEGATECALL\"] = \"DELEGATECALL\";\n})(exports.DebugCallType || (exports.DebugCallType = {}));\n/**\r\n * Potential transaction job statuses for a {@link GasOptimizedTransactionResponse}\r\n *\r\n * @internal\r\n */ // TODO(txjob): Remove internal tag once this feature is released.\nexports.GasOptimizedTransactionStatus = void 0;\n(function(GasOptimizedTransactionStatus) {\n    GasOptimizedTransactionStatus[\"UNSPECIFIED\"] = \"TRANSACTION_JOB_STATUS_UNSPECIFIED\";\n    GasOptimizedTransactionStatus[\"IN_PROGRESS\"] = \"IN_PROGRESS\";\n    GasOptimizedTransactionStatus[\"COMPLETE\"] = \"COMPLETE\";\n    GasOptimizedTransactionStatus[\"ABANDONED\"] = \"ABANDONED\";\n})(exports.GasOptimizedTransactionStatus || (exports.GasOptimizedTransactionStatus = {}));\n/** The version of the webhook. All newly created webhooks default to V2. */ exports.WebhookVersion = void 0;\n(function(WebhookVersion) {\n    WebhookVersion[\"V1\"] = \"V1\";\n    WebhookVersion[\"V2\"] = \"V2\";\n})(exports.WebhookVersion || (exports.WebhookVersion = {}));\n/** The type of {@link Webhook}. */ exports.WebhookType = void 0;\n(function(WebhookType) {\n    WebhookType[\"MINED_TRANSACTION\"] = \"MINED_TRANSACTION\";\n    WebhookType[\"DROPPED_TRANSACTION\"] = \"DROPPED_TRANSACTION\";\n    WebhookType[\"ADDRESS_ACTIVITY\"] = \"ADDRESS_ACTIVITY\";\n    WebhookType[\"NFT_ACTIVITY\"] = \"NFT_ACTIVITY\";\n    WebhookType[\"NFT_METADATA_UPDATE\"] = \"NFT_METADATA_UPDATE\";\n    WebhookType[\"GRAPHQL\"] = \"GRAPHQL\";\n})(exports.WebhookType || (exports.WebhookType = {}));\n/**\r\n * Commitment level of the target block with using methods in the\r\n * {@link DebugNamespace}\r\n */ exports.CommitmentLevel = void 0;\n(function(CommitmentLevel) {\n    /**\r\n     * Sample next block inferred by Alchemy built on top of the latest block.\r\n     * This contains the set of transactions taken from the local mempool and\r\n     * is a proxy for blocks that have not been mined yet.\r\n     */ CommitmentLevel[\"PENDING\"] = \"pending\";\n    /**\r\n     * The most recent block in the canonical chain observed by Alchemy. Note that\r\n     * this block may be re-orged out of the canonical chain.\r\n     */ CommitmentLevel[\"LATEST\"] = \"latest\";\n    /**\r\n     * The most recent crypto-economically secure block that cannot be re-orged\r\n     * outside of manual intervention driven by community coordination. This is\r\n     * only available on {@link Network.ETH_GOERLI} and {@link Network.ETH_SEPOLIA}.\r\n     */ CommitmentLevel[\"SAFE\"] = \"safe\";\n    /**\r\n     * The most recent secure block that has been accepted by >2/3 of validators.\r\n     * This block is very unlikely to be re-orged. This is only available on\r\n     * {@link Network.ETH_GOERLI} and {@link Network.ETH_SEPOLIA}.\r\n     */ CommitmentLevel[\"FINALIZED\"] = \"finalized\";\n    /**\r\n     * The lowest numbered block available that is usually the first block created.\r\n     */ CommitmentLevel[\"EARLIEST\"] = \"earliest\";\n})(exports.CommitmentLevel || (exports.CommitmentLevel = {}));\n/**\r\n * The type of tracer to use when running debug methods in the\r\n * {@link DebugNamespace}.\r\n */ exports.DebugTracerType = void 0;\n(function(DebugTracerType) {\n    DebugTracerType[\"CALL_TRACER\"] = \"callTracer\";\n    DebugTracerType[\"PRESTATE_TRACER\"] = \"prestateTracer\";\n})(exports.DebugTracerType || (exports.DebugTracerType = {}));\n/**\r\n * An enum for specifying the token type on NFTs.\r\n *\r\n * @public\r\n */ exports.NftTokenType = void 0;\n(function(NftTokenType) {\n    NftTokenType[\"ERC721\"] = \"ERC721\";\n    NftTokenType[\"ERC1155\"] = \"ERC1155\";\n    NftTokenType[\"NO_SUPPORTED_NFT_STANDARD\"] = \"NO_SUPPORTED_NFT_STANDARD\";\n    NftTokenType[\"NOT_A_CONTRACT\"] = \"NOT_A_CONTRACT\";\n    NftTokenType[\"UNKNOWN\"] = \"UNKNOWN\";\n})(exports.NftTokenType || (exports.NftTokenType = {}));\n/** Potential reasons why an NFT contract was classified as spam. */ exports.NftSpamClassification = void 0;\n(function(NftSpamClassification) {\n    NftSpamClassification[\"Erc721TooManyOwners\"] = \"Erc721TooManyOwners\";\n    NftSpamClassification[\"Erc721TooManyTokens\"] = \"Erc721TooManyTokens\";\n    NftSpamClassification[\"Erc721DishonestTotalSupply\"] = \"Erc721DishonestTotalSupply\";\n    NftSpamClassification[\"MostlyHoneyPotOwners\"] = \"MostlyHoneyPotOwners\";\n    NftSpamClassification[\"OwnedByMostHoneyPots\"] = \"OwnedByMostHoneyPots\";\n    NftSpamClassification[\"LowDistinctOwnersPercent\"] = \"LowDistinctOwnersPercent\";\n    NftSpamClassification[\"HighHoneyPotOwnerPercent\"] = \"HighHoneyPotOwnerPercent\";\n    NftSpamClassification[\"HighHoneyPotPercent\"] = \"HighHoneyPotPercent\";\n    NftSpamClassification[\"HoneyPotsOwnMultipleTokens\"] = \"HoneyPotsOwnMultipleTokens\";\n    NftSpamClassification[\"NoSalesActivity\"] = \"NoSalesActivity\";\n    NftSpamClassification[\"HighAirdropPercent\"] = \"HighAirdropPercent\";\n    NftSpamClassification[\"Unknown\"] = \"Unknown\";\n})(exports.NftSpamClassification || (exports.NftSpamClassification = {}));\n/**\r\n * Enum of NFT filters that can be applied to a {@link getNftsForOwner} or a\r\n * {@link getContractsForOwner} request.\r\n *\r\n * @beta\r\n */ exports.NftFilters = void 0;\n(function(NftFilters) {\n    /** NFTs that have been classified as spam. */ NftFilters[\"SPAM\"] = \"SPAM\";\n    /** NFTs that have been airdropped to a user. */ NftFilters[\"AIRDROPS\"] = \"AIRDROPS\";\n})(exports.NftFilters || (exports.NftFilters = {}));\n/**\r\n * Enum of ordering that can be applied to a {@link getNftsForOwner} or a\r\n * {@link getContractsForOwner} response.\r\n *\r\n * @beta\r\n */ exports.NftOrdering = void 0;\n(function(NftOrdering) {\n    NftOrdering[\"TRANSFERTIME\"] = \"TRANSFERTIME\";\n})(exports.NftOrdering || (exports.NftOrdering = {}));\n/**\r\n * Enum representing the supported NFT marketplaces by the\r\n * {@link NftNamespace.getNftSales} method.\r\n *\r\n * @public\r\n */ exports.NftSaleMarketplace = void 0;\n(function(NftSaleMarketplace) {\n    NftSaleMarketplace[\"SEAPORT\"] = \"seaport\";\n    NftSaleMarketplace[\"LOOKSRARE\"] = \"looksrare\";\n    NftSaleMarketplace[\"X2Y2\"] = \"x2y2\";\n    NftSaleMarketplace[\"WYVERN\"] = \"wyvern\";\n    NftSaleMarketplace[\"CRYPTOPUNKS\"] = \"cryptopunks\";\n    NftSaleMarketplace[\"BLUR\"] = \"blur\";\n    NftSaleMarketplace[\"UNKNOWN\"] = \"unknown\";\n})(exports.NftSaleMarketplace || (exports.NftSaleMarketplace = {}));\n/**\r\n * Enum for specifying the taker type for the {@link NftNamespace.getNftSales}\r\n * method.\r\n *\r\n * @public\r\n */ exports.NftSaleTakerType = void 0;\n(function(NftSaleTakerType) {\n    NftSaleTakerType[\"BUYER\"] = \"buyer\";\n    NftSaleTakerType[\"SELLER\"] = \"seller\";\n})(exports.NftSaleTakerType || (exports.NftSaleTakerType = {}));\n/** The current state of the NFT contract refresh process. */ exports.NftRefreshState = void 0;\n(function(NftRefreshState) {\n    /** The provided contract is not an NFT or does not contain metadata. */ NftRefreshState[\"DOES_NOT_EXIST\"] = \"does_not_exist\";\n    /** The contract has already been queued for refresh. */ NftRefreshState[\"ALREADY_QUEUED\"] = \"already_queued\";\n    /** The contract is currently being refreshed. */ NftRefreshState[\"IN_PROGRESS\"] = \"in_progress\";\n    /** The contract refresh is complete. */ NftRefreshState[\"FINISHED\"] = \"finished\";\n    /** The contract refresh has been queued and await execution. */ NftRefreshState[\"QUEUED\"] = \"queued\";\n    /** The contract was unable to be queued due to an internal error. */ NftRefreshState[\"QUEUE_FAILED\"] = \"queue_failed\";\n})(exports.NftRefreshState || (exports.NftRefreshState = {}));\n/**\r\n * Enum representing the supported NFT marketplaces on a\r\n * {@link NftCollectionFloorPrice} object.\r\n */ exports.NftCollectionMarketplace = void 0;\n(function(NftCollectionMarketplace) {\n    NftCollectionMarketplace[\"OPENSEA\"] = \"OpenSea\";\n})(exports.NftCollectionMarketplace || (exports.NftCollectionMarketplace = {}));\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __awaiter$1(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function verb(n) {\n        if (g[n]) i[n] = function(v) {\n            return new Promise(function(a, b) {\n                q.push([\n                    n,\n                    v,\n                    a,\n                    b\n                ]) > 1 || resume(n, v);\n            });\n        };\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\nconst DEFAULT_ALCHEMY_API_KEY = \"demo\";\nconst DEFAULT_NETWORK = exports.Network.ETH_MAINNET;\nconst DEFAULT_MAX_RETRIES = 5;\nconst DEFAULT_REQUEST_TIMEOUT = 0; // 0 = no timeout\n/**\r\n * Returns the base URL for making Alchemy API requests. The `alchemy.com`\r\n * endpoints only work with non eth json-rpc requests.\r\n *\r\n * @internal\r\n */ function getAlchemyHttpUrl(network, apiKey) {\n    return `https://${network}.g.alchemy.com/v2/${apiKey}`;\n}\nfunction getAlchemyNftHttpUrl(network, apiKey) {\n    return `https://${network}.g.alchemy.com/nft/v3/${apiKey}`;\n}\nfunction getAlchemyWsUrl(network, apiKey) {\n    return `wss://${network}.g.alchemy.com/v2/${apiKey}`;\n}\nfunction getAlchemyWebhookHttpUrl() {\n    return \"https://dashboard.alchemy.com/api\";\n}\nvar AlchemyApiType;\n(function(AlchemyApiType) {\n    AlchemyApiType[AlchemyApiType[\"BASE\"] = 0] = \"BASE\";\n    AlchemyApiType[AlchemyApiType[\"NFT\"] = 1] = \"NFT\";\n    AlchemyApiType[AlchemyApiType[\"WEBHOOK\"] = 2] = \"WEBHOOK\";\n})(AlchemyApiType || (AlchemyApiType = {}));\n/**\r\n * Mapping of network names to their corresponding Network strings used to\r\n * create an Ethers.js Provider instance.\r\n */ const EthersNetwork = {\n    [exports.Network.ETH_MAINNET]: \"mainnet\",\n    [exports.Network.ETH_GOERLI]: \"goerli\",\n    [exports.Network.ETH_SEPOLIA]: \"sepolia\",\n    [exports.Network.OPT_MAINNET]: \"optimism\",\n    [exports.Network.OPT_GOERLI]: \"optimism-goerli\",\n    [exports.Network.OPT_SEPOLIA]: \"optimism-sepolia\",\n    [exports.Network.ARB_MAINNET]: \"arbitrum\",\n    [exports.Network.ARB_GOERLI]: \"arbitrum-goerli\",\n    [exports.Network.ARB_SEPOLIA]: \"arbitrum-sepolia\",\n    [exports.Network.MATIC_MAINNET]: \"matic\",\n    [exports.Network.MATIC_MUMBAI]: \"maticmum\",\n    [exports.Network.ASTAR_MAINNET]: \"astar-mainnet\",\n    [exports.Network.POLYGONZKEVM_MAINNET]: \"polygonzkevm-mainnet\",\n    [exports.Network.POLYGONZKEVM_TESTNET]: \"polygonzkevm-testnet\",\n    [exports.Network.BASE_MAINNET]: \"base-mainnet\",\n    [exports.Network.BASE_GOERLI]: \"base-goerli\",\n    [exports.Network.BASE_SEPOLIA]: \"base-sepolia\"\n};\n/**\r\n * Mapping of network names to their corresponding Ethers Network objects. These\r\n * networks are not yet supported by Ethers and are listed here to be overriden\r\n * in the provider.\r\n */ const CustomNetworks = {\n    \"arbitrum-goerli\": {\n        chainId: 421613,\n        name: \"arbitrum-goerli\"\n    },\n    \"arbitrum-sepolia\": {\n        chainId: 421614,\n        name: \"arbitrum-sepolia\"\n    },\n    \"astar-mainnet\": {\n        chainId: 592,\n        name: \"astar-mainnet\"\n    },\n    sepolia: {\n        chainId: 11155111,\n        name: \"sepolia\"\n    },\n    \"optimism-sepolia\": {\n        chainId: 11155420,\n        name: \"optimism-sepolia\"\n    },\n    \"polygonzkevm-mainnet\": {\n        chainId: 1101,\n        name: \"polygonzkevm-mainnet\"\n    },\n    \"polygonzkevm-testnet\": {\n        chainId: 1442,\n        name: \"polygonzkevm-testnet\"\n    },\n    \"base-mainnet\": {\n        chainId: 8453,\n        name: \"base-mainnet\"\n    },\n    \"base-goerli\": {\n        chainId: 84531,\n        name: \"base-goerli\"\n    },\n    \"base-sepolia\": {\n        chainId: 84532,\n        name: \"base-sepolia\"\n    }\n};\nfunction noop() {\n// It's a no-op\n}\nconst ETH_NULL_VALUE = \"0x\";\nconst ETH_NULL_ADDRESS = \"0x0000000000000000000000000000000000000000\";\n/**\r\n * This class holds the config information for the SDK client instance and\r\n * exposes the underlying providers for more advanced use cases.\r\n *\r\n * @public\r\n */ class AlchemyConfig {\n    constructor(config){\n        this.apiKey = (config === null || config === void 0 ? void 0 : config.apiKey) || DEFAULT_ALCHEMY_API_KEY;\n        this.network = (config === null || config === void 0 ? void 0 : config.network) || DEFAULT_NETWORK;\n        this.maxRetries = (config === null || config === void 0 ? void 0 : config.maxRetries) || DEFAULT_MAX_RETRIES;\n        this.url = config === null || config === void 0 ? void 0 : config.url;\n        this.authToken = config === null || config === void 0 ? void 0 : config.authToken;\n        this.batchRequests = (config === null || config === void 0 ? void 0 : config.batchRequests) || false;\n        this.requestTimeout = (config === null || config === void 0 ? void 0 : config.requestTimeout) || DEFAULT_REQUEST_TIMEOUT;\n    }\n    /**\r\n     * Returns the URL endpoint to send the HTTP request to. If a custom URL was\r\n     * provided in the config, that URL is returned. Otherwise, the default URL is\r\n     * from the network and API key.\r\n     *\r\n     * @param apiType - The type of API to get the URL for.\r\n     * @internal\r\n     */ _getRequestUrl(apiType) {\n        if (this.url !== undefined) {\n            return this.url;\n        } else if (apiType === AlchemyApiType.NFT) {\n            return getAlchemyNftHttpUrl(this.network, this.apiKey);\n        } else if (apiType === AlchemyApiType.WEBHOOK) {\n            return getAlchemyWebhookHttpUrl();\n        } else {\n            return getAlchemyHttpUrl(this.network, this.apiKey);\n        }\n    }\n    /**\r\n     * Returns an AlchemyProvider instance. Only one provider is created per\r\n     * Alchemy instance.\r\n     *\r\n     * The AlchemyProvider is a wrapper around ether's `AlchemyProvider` class and\r\n     * has been expanded to support Alchemy's Enhanced APIs.\r\n     *\r\n     * Most common methods on the provider are available as top-level methods on\r\n     * the {@link Alchemy} instance, but the provider is exposed here to access\r\n     * other less-common methods.\r\n     *\r\n     * @public\r\n     */ getProvider() {\n        if (!this._baseAlchemyProvider) {\n            this._baseAlchemyProvider = (()=>__awaiter$1(this, void 0, void 0, function*() {\n                    const { AlchemyProvider } = yield Promise.resolve().then(function() {\n                        return __webpack_require__(/*! ./alchemy-provider-e539e7d0.js */ \"(ssr)/./node_modules/alchemy-sdk/dist/cjs/alchemy-provider-e539e7d0.js\");\n                    });\n                    return new AlchemyProvider(this);\n                }))();\n        }\n        return this._baseAlchemyProvider;\n    }\n    /**\r\n     * Returns an AlchemyWebsocketProvider instance. Only one provider is created\r\n     * per Alchemy instance.\r\n     *\r\n     * The AlchemyWebSocketProvider is a wrapper around ether's\r\n     * `AlchemyWebSocketProvider` class and has been expanded to support Alchemy's\r\n     * Subscription APIs, automatic backfilling, and other performance improvements.\r\n     *\r\n     * Most common methods on the provider are available as top-level methods on\r\n     * the {@link Alchemy} instance, but the provider is exposed here to access\r\n     * other less-common methods.\r\n     */ getWebSocketProvider() {\n        if (!this._baseAlchemyWssProvider) {\n            this._baseAlchemyWssProvider = (()=>__awaiter$1(this, void 0, void 0, function*() {\n                    const { AlchemyWebSocketProvider } = yield Promise.resolve().then(function() {\n                        return __webpack_require__(/*! ./alchemy-websocket-provider-d921db84.js */ \"(ssr)/./node_modules/alchemy-sdk/dist/cjs/alchemy-websocket-provider-d921db84.js\");\n                    });\n                    return new AlchemyWebSocketProvider(this);\n                }))();\n        }\n        return this._baseAlchemyWssProvider;\n    }\n}\nconst version$1 = \"logger/5.7.0\";\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\nconst LogLevels = {\n    debug: 1,\n    \"default\": 2,\n    info: 2,\n    warning: 3,\n    error: 4,\n    off: 5\n};\nlet _logLevel = LogLevels[\"default\"];\nlet _globalLogger = null;\nfunction _checkNormalize() {\n    try {\n        const missing = [];\n        // Make sure all forms of normalization are supported\n        [\n            \"NFD\",\n            \"NFC\",\n            \"NFKD\",\n            \"NFKC\"\n        ].forEach((form)=>{\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                }\n                ;\n            } catch (error) {\n                missing.push(form);\n            }\n        });\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\");\n        }\n    } catch (error) {\n        return error.message;\n    }\n    return null;\n}\nconst _normalizeError = _checkNormalize();\nvar LogLevel$1;\n(function(LogLevel) {\n    LogLevel[\"DEBUG\"] = \"DEBUG\";\n    LogLevel[\"INFO\"] = \"INFO\";\n    LogLevel[\"WARNING\"] = \"WARNING\";\n    LogLevel[\"ERROR\"] = \"ERROR\";\n    LogLevel[\"OFF\"] = \"OFF\";\n})(LogLevel$1 || (LogLevel$1 = {}));\nvar ErrorCode;\n(function(ErrorCode) {\n    ///////////////////\n    // Generic Errors\n    // Unknown Error\n    ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n    // Not Implemented\n    ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n    // Unsupported Operation\n    //   - operation\n    ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n    // Some sort of bad response from the server\n    ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n    // Timeout\n    ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\";\n    ///////////////////\n    // Operational  Errors\n    // Buffer Overrun\n    ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n    ///////////////////\n    // Argument Errors\n    // Missing new operator to an object\n    //  - name: The name of the class\n    ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\";\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n    ///////////////////\n    // Blockchain Errors\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    ErrorCode[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n    ///////////////////\n    // Interaction Errors\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ErrorCode[\"ACTION_REJECTED\"] = \"ACTION_REJECTED\";\n})(ErrorCode || (ErrorCode = {}));\nconst HEX = \"0123456789abcdef\";\nclass Logger$1 {\n    constructor(version){\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n    _log(logLevel, args) {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) {\n            return;\n        }\n        console.log.apply(console, args);\n    }\n    debug(...args) {\n        this._log(Logger$1.levels.DEBUG, args);\n    }\n    info(...args) {\n        this._log(Logger$1.levels.INFO, args);\n    }\n    warn(...args) {\n        this._log(Logger$1.levels.WARNING, args);\n    }\n    makeError(message, code, params) {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, {});\n        }\n        if (!code) {\n            code = Logger$1.errors.UNKNOWN_ERROR;\n        }\n        if (!params) {\n            params = {};\n        }\n        const messageDetails = [];\n        Object.keys(params).forEach((key)=>{\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for(let i = 0; i < value.length; i++){\n                        hex += HEX[value[i] >> 4];\n                        hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${code}`);\n        messageDetails.push(`version=${this.version}`);\n        const reason = message;\n        let url = \"\";\n        switch(code){\n            case ErrorCode.NUMERIC_FAULT:\n                {\n                    url = \"NUMERIC_FAULT\";\n                    const fault = message;\n                    switch(fault){\n                        case \"overflow\":\n                        case \"underflow\":\n                        case \"division-by-zero\":\n                            url += \"-\" + fault;\n                            break;\n                        case \"negative-power\":\n                        case \"negative-width\":\n                            url += \"-unsupported\";\n                            break;\n                        case \"unbound-bitwise-result\":\n                            url += \"-unbound-result\";\n                            break;\n                    }\n                    break;\n                }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n        if (url) {\n            message += \" [ See: https://links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n        // @TODO: Any??\n        const error = new Error(message);\n        error.reason = reason;\n        error.code = code;\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n        return error;\n    }\n    throwError(message, code, params) {\n        throw this.makeError(message, code, params);\n    }\n    throwArgumentError(message, name, value) {\n        return this.throwError(message, Logger$1.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n    assert(condition, message, code, params) {\n        if (!!condition) {\n            return;\n        }\n        this.throwError(message, code, params);\n    }\n    assertArgument(condition, message, name, value) {\n        if (!!condition) {\n            return;\n        }\n        this.throwArgumentError(message, name, value);\n    }\n    checkNormalize(message) {\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger$1.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\",\n                form: _normalizeError\n            });\n        }\n    }\n    checkSafeUint53(value, message) {\n        if (typeof value !== \"number\") {\n            return;\n        }\n        if (message == null) {\n            message = \"value not safe\";\n        }\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger$1.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n        if (value % 1) {\n            this.throwError(message, Logger$1.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n    checkArgumentCount(count, expectedCount, message) {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger$1.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger$1.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n    checkNew(target, kind) {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger$1.errors.MISSING_NEW, {\n                name: kind.name\n            });\n        }\n    }\n    checkAbstract(target, kind) {\n        if (target === kind) {\n            this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger$1.errors.UNSUPPORTED_OPERATION, {\n                name: target.name,\n                operation: \"new\"\n            });\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger$1.errors.MISSING_NEW, {\n                name: kind.name\n            });\n        }\n    }\n    static globalLogger() {\n        if (!_globalLogger) {\n            _globalLogger = new Logger$1(version$1);\n        }\n        return _globalLogger;\n    }\n    static setCensorship(censorship, permanent) {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger$1.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        if (_permanentCensorErrors) {\n            if (!censorship) {\n                return;\n            }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger$1.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n    static setLogLevel(logLevel) {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger$1.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n    static from(version) {\n        return new Logger$1(version);\n    }\n}\nLogger$1.errors = ErrorCode;\nLogger$1.levels = LogLevel$1;\nconst version = \"properties/5.7.0\";\nvar __awaiter =  false || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst logger = new Logger$1(version);\nfunction defineReadOnly(object, name, value) {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false\n    });\n}\nfunction resolveProperties(object) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const promises = Object.keys(object).map((key)=>{\n            const value = object[key];\n            return Promise.resolve(value).then((v)=>({\n                    key: key,\n                    value: v\n                }));\n        });\n        const results = yield Promise.all(promises);\n        return results.reduce((accum, result)=>{\n            accum[result.key] = result.value;\n            return accum;\n        }, {});\n    });\n}\nconst opaque = {\n    bigint: true,\n    boolean: true,\n    \"function\": true,\n    number: true,\n    string: true\n};\nfunction _isFrozen(object) {\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof object]) {\n        return true;\n    }\n    if (Array.isArray(object) || typeof object === \"object\") {\n        if (!Object.isFrozen(object)) {\n            return false;\n        }\n        const keys = Object.keys(object);\n        for(let i = 0; i < keys.length; i++){\n            let value = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                continue;\n            }\n            if (!_isFrozen(value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, \"object\", object);\n}\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object) {\n    if (_isFrozen(object)) {\n        return object;\n    }\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item)=>deepCopy(item)));\n    }\n    if (typeof object === \"object\") {\n        const result = {};\n        for(const key in object){\n            const value = object[key];\n            if (value === undefined) {\n                continue;\n            }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n        return result;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, \"object\", object);\n}\nfunction deepCopy(object) {\n    return _deepCopy(object);\n}\n/**\r\n * Converts a hex string to a decimal number.\r\n *\r\n * @param hexString - The hex string to convert.\r\n * @public\r\n */ function fromHex(hexString) {\n    return bignumber.BigNumber.from(hexString).toNumber();\n}\n/**\r\n * Converts a number to a hex string.\r\n *\r\n * @param num - The number to convert to hex.\r\n * @public\r\n */ function toHex(num) {\n    return bignumber.BigNumber.from(num).toHexString();\n}\n/**\r\n * Checks if a value is a hex string.\r\n *\r\n * @param possibleHexString - The value to check.\r\n * @public\r\n */ function isHex(possibleHexString) {\n    return /^0x[0-9a-fA-F]+$/.test(possibleHexString);\n}\nfunction formatBlock(block) {\n    if (typeof block === \"string\") {\n        return block;\n    } else if (Number.isInteger(block)) {\n        return toHex(block);\n    }\n    return block.toString();\n}\nfunction stringToEnum(x, enumb) {\n    return Object.values(enumb).includes(x) ? x : null;\n}\nfunction getNftContractForNftFromRaw(rawNftContract) {\n    return nullsToUndefined(Object.assign(Object.assign({}, getNftContractFromRaw(rawNftContract)), {\n        spamClassifications: rawNftContract.spamClassifications.map(parseNftSpamClassification)\n    }));\n}\nfunction getNftContractsForOwnerFromRaw(rawNftContract) {\n    return nullsToUndefined(Object.assign(Object.assign({}, getNftContractFromRaw(rawNftContract)), {\n        displayNft: rawNftContract.displayNft,\n        image: rawNftContract.image,\n        totalBalance: rawNftContract.totalBalance,\n        numDistinctTokensOwned: rawNftContract.numDistinctTokensOwned,\n        isSpam: rawNftContract.isSpam\n    }));\n}\nfunction getNftContractFromRaw(rawNftContract) {\n    return nullsToUndefined(Object.assign(Object.assign({}, rawNftContract), {\n        tokenType: parseNftTokenType(rawNftContract.tokenType),\n        openSeaMetadata: Object.assign(Object.assign({}, rawNftContract.openSeaMetadata), {\n            safelistRequestStatus: rawNftContract.openSeaMetadata.safelistRequestStatus !== null ? stringToEnum(rawNftContract.openSeaMetadata.safelistRequestStatus, exports.OpenSeaSafelistRequestStatus) : null\n        })\n    }));\n}\nfunction getNftCollectionFromRaw(rawNftCollection) {\n    return nullsToUndefined(Object.assign(Object.assign({}, rawNftCollection), {\n        floorPrice: Object.assign(Object.assign({}, rawNftCollection.floorPrice), {\n            marketplace: parseNftCollectionMarketplace(rawNftCollection.floorPrice.marketplace)\n        })\n    }));\n}\nfunction getBaseNftFromRaw(rawBaseNft, contractAddress) {\n    return {\n        contractAddress: contractAddress ? contractAddress : rawBaseNft.contractAddress,\n        tokenId: rawBaseNft.tokenId\n    };\n}\nfunction getNftFromRaw(rawNft) {\n    return nullsToUndefined(Object.assign(Object.assign({}, rawNft), {\n        contract: getNftContractForNftFromRaw(rawNft.contract),\n        tokenType: parseNftTokenType(rawNft.tokenType),\n        acquiredAt: rawNft.acquiredAt,\n        collection: rawNft.collection,\n        mint: rawNft.mint\n    }));\n}\nfunction getNftSalesFromRaw(rawNftSales) {\n    return nullsToUndefined({\n        nftSales: rawNftSales.nftSales.map((rawNftSale)=>Object.assign(Object.assign({}, rawNftSale), {\n                marketplace: parseNftSaleMarketplace(rawNftSale.marketplace),\n                taker: parseNftTaker(rawNftSale.taker)\n            })),\n        validAt: rawNftSales.validAt,\n        pageKey: rawNftSales.pageKey\n    });\n}\nfunction parseNftSaleMarketplace(marketplace) {\n    switch(marketplace){\n        case \"looksrare\":\n            return exports.NftSaleMarketplace.LOOKSRARE;\n        case \"seaport\":\n            return exports.NftSaleMarketplace.SEAPORT;\n        case \"x2y2\":\n            return exports.NftSaleMarketplace.X2Y2;\n        case \"wyvern\":\n            return exports.NftSaleMarketplace.WYVERN;\n        case \"cryptopunks\":\n            return exports.NftSaleMarketplace.CRYPTOPUNKS;\n        case \"blur\":\n            return exports.NftSaleMarketplace.BLUR;\n        default:\n            return exports.NftSaleMarketplace.UNKNOWN;\n    }\n}\nfunction parseNftCollectionMarketplace(marketplace) {\n    switch(marketplace){\n        case \"OpenSea\":\n            return exports.NftCollectionMarketplace.OPENSEA;\n        default:\n            return undefined;\n    }\n}\nfunction parseNftTaker(taker) {\n    // The `.toLowerCase()` call is needed because the API returns the capitalized values\n    switch(taker.toLowerCase()){\n        case \"buyer\":\n            return exports.NftSaleTakerType.BUYER;\n        case \"seller\":\n            return exports.NftSaleTakerType.SELLER;\n        default:\n            throw new Error(`Unsupported NftSaleTakerType ${taker}`);\n    }\n}\nfunction parseNftSpamClassification(s) {\n    const res = stringToEnum(s, exports.NftSpamClassification);\n    if (res == null) {\n        return exports.NftSpamClassification.Unknown;\n    }\n    return res;\n}\nfunction parseNftTokenType(tokenType) {\n    switch(tokenType){\n        case \"erc721\":\n        case \"ERC721\":\n            return exports.NftTokenType.ERC721;\n        case \"erc1155\":\n        case \"ERC1155\":\n            return exports.NftTokenType.ERC1155;\n        case \"no_supported_nft_standard\":\n        case \"NO_SUPPORTED_NFT_STANDARD\":\n            return exports.NftTokenType.NO_SUPPORTED_NFT_STANDARD;\n        case \"not_a_contract\":\n        case \"NOT_A_CONTRACT\":\n            return exports.NftTokenType.NOT_A_CONTRACT;\n        default:\n            return exports.NftTokenType.UNKNOWN;\n    }\n}\nconst IS_BROWSER =  false && 0;\nfunction nullsToUndefined(obj) {\n    if (obj === null || obj === undefined) {\n        return undefined;\n    }\n    if (obj.constructor.name === \"Object\" || Array.isArray(obj)) {\n        for(const key in obj){\n            obj[key] = nullsToUndefined(obj[key]);\n        }\n    }\n    return obj;\n}\n/**\r\n * This file contains the underlying implementations for exposed API surface in\r\n * the {@link CoreNamespace}. By moving the methods out into a separate file,\r\n * other namespaces can access these methods without depending on the entire\r\n * CoreNamespace, or override the `srcMethod` param used for logging.\r\n */ /**\r\n * Gets the asset transfers for the provided params.\r\n */ function getAssetTransfers(config, params, srcMethod = \"getAssetTransfers\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const provider = yield config.getProvider();\n        if (params.fromAddress) {\n            params.fromAddress = yield provider._getAddress(params.fromAddress);\n        }\n        if (params.toAddress) {\n            params.toAddress = yield provider._getAddress(params.toAddress);\n        }\n        return provider._send(\"alchemy_getAssetTransfers\", [\n            Object.assign(Object.assign({}, params), {\n                fromBlock: params.fromBlock != null ? formatBlock(params.fromBlock) : undefined,\n                toBlock: params.toBlock != null ? formatBlock(params.toBlock) : undefined,\n                maxCount: params.maxCount != null ? toHex(params.maxCount) : undefined\n            })\n        ], srcMethod);\n    });\n}\nfunction getTransactionReceipts(config, params, srcMethod = \"getTransactionReceipts\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const provider = yield config.getProvider();\n        return provider._send(\"alchemy_getTransactionReceipts\", [\n            params\n        ], srcMethod);\n    });\n}\n/**\r\n * This method is based on the ethers implementation of getLogs, but is expanded\r\n * to support specifying an address array in the filter.\r\n *\r\n * The main modifications made to support an address array are:\r\n * - Custom `getFilter()` method that supports an address array\r\n * - Use of `arrayOf()` formatter to format the logs to avoid the `Formatter` import.\r\n * - Use of `provider.send()` to avoid formatting logic in `provider.perform()`.\r\n */ function getLogs(config, filter) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const provider = yield config.getProvider();\n        yield provider.getNetwork();\n        const params = yield resolveProperties({\n            filter: getFilter(config, filter)\n        });\n        const logs = yield provider.send(\"eth_getLogs\", [\n            params.filter\n        ]);\n        logs.forEach((log)=>{\n            if (log.removed == null) {\n                log.removed = false;\n            }\n        });\n        return arrayOf(provider.formatter.filterLog.bind(provider.formatter))(logs);\n    });\n}\n/**\r\n * This method is based on and copied from the ethers implementation of\r\n * `JsonRpcProvider._getFilter()`, but is extended to support an address array.\r\n *\r\n * This implementation is a hacky way to get around the ethers formatter. The\r\n * formatter is used to check the types of the `filter` params, but ethers does\r\n * not allow an array in the `address` field. To preserve the ethers formatter\r\n * on the other fields, we use the formatter to check the types of those other\r\n * fields, and then manually check the `address` field last.\r\n */ function getFilter(config, filter) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        // START MODIFIED CODE\n        const provider = yield config.getProvider();\n        const resolvedFilter = yield filter;\n        let result = {};\n        // END MODIFIED CODE\n        [\n            \"blockHash\",\n            \"topics\"\n        ].forEach((key)=>{\n            if (resolvedFilter[key] == null) {\n                return;\n            }\n            result[key] = resolvedFilter[key];\n        });\n        [\n            \"fromBlock\",\n            \"toBlock\"\n        ].forEach((key)=>{\n            if (resolvedFilter[key] == null) {\n                return;\n            }\n            result[key] = provider._getBlockTag(resolvedFilter[key]);\n        });\n        // BEGIN MODIFIED CODE\n        // Format the `result` object using the ethers formatter without the `address`\n        // field.\n        result = provider.formatter.filter((yield resolveProperties(result)));\n        // After formatting the other fields, manually format the `address` field\n        // before adding it to the `result` object.\n        if (Array.isArray(resolvedFilter.address)) {\n            result.address = yield Promise.all(resolvedFilter.address.map((address)=>__awaiter$1(this, void 0, void 0, function*() {\n                    return provider._getAddress(address);\n                })));\n        } else if (resolvedFilter.address != null) {\n            result.address = yield provider._getAddress(resolvedFilter.address);\n        }\n        return result;\n    // END MODIFIED CODE\n    });\n}\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * This function is directly copied over from ethers implementation of\r\n * `Formatter.arrayOf()`. It is copied here to avoid having to import the\r\n * `Formatter` class or `FormatterFunc` type from ethers, that are not part of\r\n * the default export.\r\n *\r\n * This function returns a function that applies the formatter to an array of\r\n * values, and is used to format the logs returned by `getLogs()`.\r\n */ function arrayOf(format) {\n    return function(array) {\n        if (!Array.isArray(array)) {\n            throw new Error(\"not an array\");\n        }\n        const result = [];\n        array.forEach((value)=>{\n            result.push(format(value));\n        });\n        return result;\n    };\n}\n/**\r\n * The core namespace contains all commonly-used [Ethers.js\r\n * Provider](https://docs.ethers.io/v5/api/providers/api-providers/#AlchemyProvider)\r\n * methods. If you are already using Ethers.js, you should be simply able to\r\n * replace the Ethers.js Provider object with `alchemy.core` when accessing\r\n * provider methods and it should just work.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the core namespace\r\n * via `alchemy.core`.\r\n */ class CoreNamespace {\n    /** @internal */ constructor(config){\n        this.config = config;\n    }\n    /**\r\n     * Returns the balance of a given address as of the provided block.\r\n     *\r\n     * @param addressOrName The address or name of the account to get the balance for.\r\n     * @param blockTag The optional block number or hash to get the balance for.\r\n     *   Defaults to 'latest' if unspecified.\r\n     * @public\r\n     */ getBalance(addressOrName, blockTag) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getBalance(addressOrName, blockTag);\n        });\n    }\n    /**\r\n     * Checks if the provided address is a smart contract.\r\n     *\r\n     * @param address The address to check type for.\r\n     * @public\r\n     */ isContractAddress(address) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const code = yield provider.getCode(address);\n            return code !== \"0x\";\n        });\n    }\n    /**\r\n     * Returns the contract code of the provided address at the block. If there is\r\n     * no contract deployed, the result is `0x`.\r\n     *\r\n     * @param addressOrName The address or name of the account to get the code for.\r\n     * @param blockTag The optional block number or hash to get the code for.\r\n     *   Defaults to 'latest' if unspecified.\r\n     * @public\r\n     */ getCode(addressOrName, blockTag) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getCode(addressOrName, blockTag);\n        });\n    }\n    /**\r\n     * Return the value of the provided position at the provided address, at the\r\n     * provided block in `Bytes32` format.\r\n     *\r\n     * @param addressOrName The address or name of the account to get the code for.\r\n     * @param position The position of the storage slot to get.\r\n     * @param blockTag The optional block number or hash to get the code for.\r\n     *   Defaults to 'latest' if unspecified.\r\n     * @public\r\n     */ getStorageAt(addressOrName, position, blockTag) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getStorageAt(addressOrName, position, blockTag);\n        });\n    }\n    /**\r\n     * Returns the number of transactions ever sent from the provided address, as\r\n     * of the provided block tag. This value is used as the nonce for the next\r\n     * transaction from the address sent to the network.\r\n     *\r\n     * @param addressOrName The address or name of the account to get the nonce for.\r\n     * @param blockTag The optional block number or hash to get the nonce for.\r\n     * @public\r\n     */ getTransactionCount(addressOrName, blockTag) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getTransactionCount(addressOrName, blockTag);\n        });\n    }\n    /**\r\n     * Returns the block from the network based on the provided block number or\r\n     * hash. Transactions on the block are represented as an array of transaction\r\n     * hashes. To get the full transaction details on the block, use\r\n     * {@link getBlockWithTransactions} instead.\r\n     *\r\n     * @param blockHashOrBlockTag The block number or hash to get the block for.\r\n     * @public\r\n     */ getBlock(blockHashOrBlockTag) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getBlock(blockHashOrBlockTag);\n        });\n    }\n    /**\r\n     * Returns the block from the network based on the provided block number or\r\n     * hash. Transactions on the block are represented as an array of\r\n     * {@link TransactionResponse} objects.\r\n     *\r\n     * @param blockHashOrBlockTag The block number or hash to get the block for.\r\n     * @public\r\n     */ getBlockWithTransactions(blockHashOrBlockTag) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getBlockWithTransactions(blockHashOrBlockTag);\n        });\n    }\n    /**\r\n     * Returns the {@link EthersNetworkAlias} Alchemy is connected to.\r\n     *\r\n     * @public\r\n     */ getNetwork() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getNetwork();\n        });\n    }\n    /**\r\n     * Returns the block number of the most recently mined block.\r\n     *\r\n     * @public\r\n     */ getBlockNumber() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getBlockNumber();\n        });\n    }\n    /**\r\n     * Returns the best guess of the current gas price to use in a transaction.\r\n     *\r\n     * @public\r\n     */ getGasPrice() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getGasPrice();\n        });\n    }\n    /**\r\n     * Returns the recommended fee data to use in a transaction.\r\n     *\r\n     * For an EIP-1559 transaction, the maxFeePerGas and maxPriorityFeePerGas\r\n     * should be used.\r\n     *\r\n     * For legacy transactions and networks which do not support EIP-1559, the\r\n     * gasPrice should be used.\r\n     *\r\n     * @public\r\n     */ getFeeData() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getFeeData();\n        });\n    }\n    /**\r\n     * Returns a Promise which will stall until the network has heen established,\r\n     * ignoring errors due to the target node not being active yet.\r\n     *\r\n     * This can be used for testing or attaching scripts to wait until the node is\r\n     * up and running smoothly.\r\n     *\r\n     * @public\r\n     */ ready() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.ready;\n        });\n    }\n    /**\r\n     * Returns the result of executing the transaction, using call. A call does\r\n     * not require any ether, but cannot change any state. This is useful for\r\n     * calling getters on Contracts.\r\n     *\r\n     * @param transaction The transaction to execute.\r\n     * @param blockTag The optional block number or hash to get the call for.\r\n     * @public\r\n     */ call(transaction, blockTag) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.call(transaction, blockTag);\n        });\n    }\n    /**\r\n     * Returns an estimate of the amount of gas that would be required to submit\r\n     * transaction to the network.\r\n     *\r\n     * An estimate may not be accurate since there could be another transaction on\r\n     * the network that was not accounted for, but after being mined affects the\r\n     * relevant state.\r\n     *\r\n     * This is an alias for {@link TransactNamespace.estimateGas}.\r\n     *\r\n     * @param transaction The transaction to estimate gas for.\r\n     * @public\r\n     */ estimateGas(transaction) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.estimateGas(transaction);\n        });\n    }\n    /**\r\n     * Returns the transaction with hash or null if the transaction is unknown.\r\n     *\r\n     * If a transaction has not been mined, this method will search the\r\n     * transaction pool. Various backends may have more restrictive transaction\r\n     * pool access (e.g. if the gas price is too low or the transaction was only\r\n     * recently sent and not yet indexed) in which case this method may also return null.\r\n     *\r\n     * NOTE: This is an alias for {@link TransactNamespace.getTransaction}.\r\n     *\r\n     * @param transactionHash The hash of the transaction to get.\r\n     * @public\r\n     */ getTransaction(transactionHash) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getTransaction(transactionHash);\n        });\n    }\n    /**\r\n     * Returns the transaction receipt for hash or null if the transaction has not\r\n     * been mined.\r\n     *\r\n     * To stall until the transaction has been mined, consider the\r\n     * waitForTransaction method below.\r\n     *\r\n     * @param transactionHash The hash of the transaction to get.\r\n     * @public\r\n     */ getTransactionReceipt(transactionHash) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getTransactionReceipt(transactionHash);\n        });\n    }\n    /**\r\n     * Submits transaction to the network to be mined. The transaction must be\r\n     * signed, and be valid (i.e. the nonce is correct and the account has\r\n     * sufficient balance to pay for the transaction).\r\n     *\r\n     * NOTE: This is an alias for {@link TransactNamespace.getTransaction}.\r\n     *\r\n     * @param signedTransaction The signed transaction to send.\r\n     * @public\r\n     */ sendTransaction(signedTransaction) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.sendTransaction(signedTransaction);\n        });\n    }\n    /**\r\n     * Returns a promise which will not resolve until specified transaction hash is mined.\r\n     *\r\n     * If {@link confirmations} is 0, this method is non-blocking and if the\r\n     * transaction has not been mined returns null. Otherwise, this method will\r\n     * block until the transaction has confirmed blocks mined on top of the block\r\n     * in which it was mined.\r\n     *\r\n     * NOTE: This is an alias for {@link TransactNamespace.getTransaction}.\r\n     *\r\n     * @param transactionHash The hash of the transaction to wait for.\r\n     * @param confirmations The number of blocks to wait for.\r\n     * @param timeout The maximum time to wait for the transaction to confirm.\r\n     * @public\r\n     */ waitForTransaction(transactionHash, confirmations, timeout) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.waitForTransaction(transactionHash, confirmations, timeout);\n        });\n    }\n    /**\r\n     * Returns an array of logs that match the provided filter.\r\n     *\r\n     * @param filter The filter object to use.\r\n     * @public\r\n     */ getLogs(filter) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            return getLogs(this.config, filter);\n        });\n    }\n    /**\r\n     * Allows sending a raw message to the Alchemy backend.\r\n     *\r\n     * @param method The method to call.\r\n     * @param params The parameters to pass to the method.\r\n     * @public\r\n     */ send(method, params) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.send(method, params);\n        });\n    }\n    /**\r\n     * Finds the address that deployed the provided contract and block number it\r\n     * was deployed in.\r\n     *\r\n     * NOTE: This method performs a binary search across all blocks since genesis\r\n     * and can take a long time to complete. This method is a convenience method\r\n     * that will eventually be replaced by a single call to an Alchemy endpoint\r\n     * with this information cached.\r\n     *\r\n     * @param contractAddress - The contract address to find the deployer for.\r\n     * @beta\r\n     */ findContractDeployer(contractAddress) {\n        var _a;\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const currentBlockNum = yield provider.getBlockNumber();\n            if ((yield provider.getCode(contractAddress, currentBlockNum)) === ETH_NULL_VALUE) {\n                throw new Error(`Contract '${contractAddress}' does not exist`);\n            }\n            // Binary search for the block number that the contract was deployed in.\n            const firstBlock = yield binarySearchFirstBlock(0, currentBlockNum + 1, contractAddress, this.config);\n            // Find the first transaction in the block that matches the provided address.\n            const txReceipts = yield getTransactionReceipts(this.config, {\n                blockNumber: toHex(firstBlock)\n            }, \"findContractDeployer\");\n            const matchingReceipt = (_a = txReceipts.receipts) === null || _a === void 0 ? void 0 : _a.find((receipt)=>receipt.contractAddress === contractAddress.toLowerCase());\n            return {\n                deployerAddress: matchingReceipt === null || matchingReceipt === void 0 ? void 0 : matchingReceipt.from,\n                blockNumber: firstBlock\n            };\n        });\n    }\n    getTokenBalances(addressOrName, contractAddressesOrOptions) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const address = yield provider._getAddress(addressOrName);\n            if (Array.isArray(contractAddressesOrOptions)) {\n                if (contractAddressesOrOptions.length > 1500) {\n                    throw new Error(\"You cannot pass in more than 1500 contract addresses to getTokenBalances()\");\n                }\n                if (contractAddressesOrOptions.length === 0) {\n                    throw new Error(\"getTokenBalances() requires at least one contractAddress when using an array\");\n                }\n                return provider._send(\"alchemy_getTokenBalances\", [\n                    address,\n                    contractAddressesOrOptions\n                ], \"getTokenBalances\");\n            } else {\n                const tokenType = contractAddressesOrOptions === undefined ? exports.TokenBalanceType.ERC20 : contractAddressesOrOptions.type;\n                const params = [\n                    address,\n                    tokenType\n                ];\n                if ((contractAddressesOrOptions === null || contractAddressesOrOptions === void 0 ? void 0 : contractAddressesOrOptions.type) === exports.TokenBalanceType.ERC20 && contractAddressesOrOptions.pageKey) {\n                    params.push({\n                        pageKey: contractAddressesOrOptions.pageKey\n                    });\n                }\n                return provider._send(\"alchemy_getTokenBalances\", params, \"getTokenBalances\");\n            }\n        });\n    }\n    /**\r\n     * Returns the tokens that the specified address owns, along with the amount\r\n     * of each token and the relevant metadata.\r\n     *\r\n     * @param addressOrName The owner address to get the tokens with balances for.\r\n     * @param options Additional options to pass to the request.\r\n     * @public\r\n     */ getTokensForOwner(addressOrName, options) {\n        var _a;\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const address = yield provider._getAddress(addressOrName);\n            const params = [\n                address,\n                (_a = options === null || options === void 0 ? void 0 : options.contractAddresses) !== null && _a !== void 0 ? _a : exports.TokenBalanceType.ERC20\n            ];\n            if (options === null || options === void 0 ? void 0 : options.pageKey) {\n                params.push({\n                    pageKey: options.pageKey\n                });\n            }\n            const response = yield provider._send(\"alchemy_getTokenBalances\", params, \"getTokensForOwner\");\n            const formattedBalances = response.tokenBalances.map((balance)=>({\n                    contractAddress: balance.contractAddress,\n                    rawBalance: bignumber.BigNumber.from(balance.tokenBalance).toString()\n                }));\n            const metadataPromises = yield Promise.allSettled(response.tokenBalances.map((token)=>provider._send(\"alchemy_getTokenMetadata\", [\n                    token.contractAddress\n                ], \"getTokensForOwner\", /* forceBatch= */ true)));\n            const metadata = metadataPromises.map((p)=>p.status === \"fulfilled\" ? p.value : {\n                    name: null,\n                    symbol: null,\n                    decimals: null,\n                    logo: null\n                });\n            const ownedTokens = formattedBalances.map((balance, index)=>Object.assign(Object.assign(Object.assign({}, balance), metadata[index]), {\n                    balance: metadata[index].decimals !== null ? utils.formatUnits(balance.rawBalance, metadata[index].decimals) : undefined\n                }));\n            return {\n                tokens: ownedTokens.map((t)=>nullsToUndefined(t)),\n                pageKey: response.pageKey\n            };\n        });\n    }\n    /**\r\n     * Returns metadata for a given token contract address.\r\n     *\r\n     * @param address The contract address to get metadata for.\r\n     * @public\r\n     */ getTokenMetadata(address) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider._send(\"alchemy_getTokenMetadata\", [\n                address\n            ], \"getTokenMetadata\");\n        });\n    }\n    getAssetTransfers(params) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            return getAssetTransfers(this.config, params);\n        });\n    }\n    /**\r\n     * Gets all transaction receipts for a given block by number or block hash.\r\n     *\r\n     * @param params An object containing fields for the transaction receipt query.\r\n     * @public\r\n     */ getTransactionReceipts(params) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            return getTransactionReceipts(this.config, params);\n        });\n    }\n    /**\r\n     * Returns the underlying owner address for the provided ENS address, or `null`\r\n     * if the ENS name does not have an underlying address.\r\n     *\r\n     * @param name The ENS address name to resolve.\r\n     */ resolveName(name) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.resolveName(name);\n        });\n    }\n    /**\r\n     * Performs a reverse lookup of the address in ENS using the Reverse Registrar. If the name does not exist, or the forward lookup does not match, null is returned.\r\n     *\r\n     * An ENS name requires additional configuration to setup a reverse record, so not all ENS addresses will map back to the original ENS domain.\r\n     *\r\n     * @param address The address to look up the ENS domain name for.\r\n     */ lookupAddress(address) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.lookupAddress(address);\n        });\n    }\n}\n/**\r\n * Perform a binary search between an integer range of block numbers to find the\r\n * block number where the contract was deployed.\r\n *\r\n * @internal\r\n */ function binarySearchFirstBlock(start, end, address, config) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        if (start >= end) {\n            return end;\n        }\n        const mid = Math.floor((start + end) / 2);\n        const provider = yield config.getProvider();\n        const code = yield provider.getCode(address, mid);\n        if (code === ETH_NULL_VALUE) {\n            return binarySearchFirstBlock(mid + 1, end, address, config);\n        }\n        return binarySearchFirstBlock(start, mid, address, config);\n    });\n}\n/**\r\n * The Debug namespace contains methods to access the non-standard RPC methods\r\n * for inspecting and debugging transactions.\r\n *\r\n * For more information on the different methods and use cases please read our\r\n * [documentation](https://docs.alchemy.com/reference/debug-api-quickstart).\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the debug namespace\r\n * via `alchemy.debug`.\r\n */ class DebugNamespace {\n    /** @internal */ constructor(config){\n        this.config = config;\n    }\n    traceCall(transaction, blockIdentifier, tracer) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const params = [\n                transaction,\n                blockIdentifier,\n                parseTracerParams(tracer)\n            ];\n            return provider._send(\"debug_traceCall\", params, \"traceCall\");\n        });\n    }\n    traceTransaction(transactionHash, tracer, timeout) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const params = [\n                transactionHash,\n                parseTracerParams(tracer, timeout)\n            ];\n            return provider._send(\"debug_traceTransaction\", params, \"traceTransaction\");\n        });\n    }\n    traceBlock(blockIdentifier, tracer) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            let method;\n            let params;\n            if (utils.isHexString(blockIdentifier, 32)) {\n                method = \"debug_traceBlockByHash\";\n                params = [\n                    blockIdentifier,\n                    parseTracerParams(tracer)\n                ];\n            } else {\n                method = \"debug_traceBlockByNumber\";\n                const block = typeof blockIdentifier === \"number\" ? utils.hexStripZeros(utils.hexValue(blockIdentifier)) : blockIdentifier;\n                params = [\n                    block,\n                    parseTracerParams(tracer)\n                ];\n            }\n            return provider._send(method, params, \"traceBlock\");\n        });\n    }\n}\nfunction parseTracerParams(tracer, timeout) {\n    return Object.assign({\n        tracer: tracer.type\n    }, tracer.onlyTopCall !== undefined && {\n        tracerConfig: {\n            onlyTopCall: tracer.onlyTopCall,\n            timeout\n        }\n    });\n}\nfunction sanitizeTokenType(tokenType) {\n    if (tokenType === exports.NftTokenType.ERC1155 || tokenType === exports.NftTokenType.ERC721) {\n        return tokenType;\n    }\n    return undefined;\n}\n/**\r\n * The SDK has 4 log levels and a 5th option for disabling all logging. By\r\n * default, the log level is set to INFO.\r\n *\r\n * The order is a follows: DEBUG < INFO < WARN < ERROR\r\n *\r\n * All log types above the current log level will be outputted.\r\n */ var LogLevel;\n(function(LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"INFO\"] = 1] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 2] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 3] = \"ERROR\";\n    LogLevel[LogLevel[\"SILENT\"] = 4] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\nconst logLevelStringToEnum = {\n    debug: LogLevel.DEBUG,\n    info: LogLevel.INFO,\n    warn: LogLevel.WARN,\n    error: LogLevel.ERROR,\n    silent: LogLevel.SILENT\n};\n// HACKY: Use the console method as a string rather than the function itself\n// in order to allow for mocking in tests.\nconst logLevelToConsoleFn = {\n    [LogLevel.DEBUG]: \"log\",\n    [LogLevel.INFO]: \"info\",\n    [LogLevel.WARN]: \"warn\",\n    [LogLevel.ERROR]: \"error\"\n};\nconst DEFAULT_LOG_LEVEL = LogLevel.INFO;\n/**\r\n * Configures the verbosity of logging. The default log level is `info`.\r\n *\r\n * @param logLevel - The verbosity of logging. Can be any of the following values:\r\n *\r\n *   - `debug`: The most verbose logging level.\r\n *   - `info`: The default logging level.\r\n *   - `warn`: A logging level for non-critical issues.\r\n *   - `error`: A logging level for critical issues.\r\n *   - `silent`: Turn off all logging.\r\n *\r\n * @public\r\n */ function setLogLevel(logLevel) {\n    loggerClient.logLevel = logLevelStringToEnum[logLevel];\n}\nfunction logDebug(message, ...args) {\n    loggerClient.debug(message, args);\n}\nfunction logInfo(message, ...args) {\n    loggerClient.info(message, args);\n}\nfunction logWarn(message, ...args) {\n    loggerClient.warn(message, args);\n}\nclass Logger {\n    constructor(){\n        /** The log level of the given Logger instance. */ this._logLevel = DEFAULT_LOG_LEVEL;\n    }\n    get logLevel() {\n        return this._logLevel;\n    }\n    set logLevel(val) {\n        if (!(val in LogLevel)) {\n            throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n        }\n        this._logLevel = val;\n    }\n    debug(...args) {\n        this._log(LogLevel.DEBUG, ...args);\n    }\n    info(...args) {\n        this._log(LogLevel.INFO, ...args);\n    }\n    warn(...args) {\n        this._log(LogLevel.WARN, ...args);\n    }\n    error(...args) {\n        this._log(LogLevel.ERROR, ...args);\n    }\n    /**\r\n     * Forwards log messages to their corresponding console counterparts if the\r\n     * log level allows it.\r\n     */ _log(logLevel, ...args) {\n        if (logLevel < this._logLevel) {\n            return;\n        }\n        const now = new Date().toISOString();\n        const method = logLevelToConsoleFn[logLevel];\n        if (method) {\n            console[method](`[${now}] Alchemy:`, ...args.map(stringify));\n        } else {\n            throw new Error(`Logger received an invalid logLevel (value: ${logLevel})`);\n        }\n    }\n}\nfunction stringify(obj) {\n    if (typeof obj === \"string\") {\n        return obj;\n    } else {\n        try {\n            return JSON.stringify(obj);\n        } catch (e) {\n            // Failed to convert to JSON, log the object directly.\n            return obj;\n        }\n    }\n}\n// Instantiate default logger for the SDK.\nconst loggerClient = new Logger();\n// This file is autogenerated by injectVersion.js. Any changes will be\n// overwritten on commit!\nconst VERSION = \"3.1.0\";\n/**\r\n * Given a REST endpoint, method, and params, sends the request with axios and\r\n * returns the response.\r\n */ /**\r\n * Helper function to send http requests using Axis.\r\n *\r\n * @private\r\n */ function sendAxiosRequest(baseUrl, restApiName, methodName, params, overrides) {\n    var _a;\n    const requestUrl = baseUrl + \"/\" + restApiName;\n    const config = Object.assign(Object.assign({}, overrides), {\n        headers: Object.assign(Object.assign(Object.assign({}, overrides === null || overrides === void 0 ? void 0 : overrides.headers), !IS_BROWSER && {\n            \"Accept-Encoding\": \"gzip\"\n        }), {\n            \"Alchemy-Ethers-Sdk-Version\": VERSION,\n            \"Alchemy-Ethers-Sdk-Method\": methodName\n        }),\n        method: (_a = overrides === null || overrides === void 0 ? void 0 : overrides.method) !== null && _a !== void 0 ? _a : \"GET\",\n        url: requestUrl,\n        params\n    });\n    return axios__default[\"default\"](config);\n}\nconst DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\nconst DEFAULT_BACKOFF_MULTIPLIER = 1.5;\nconst DEFAULT_BACKOFF_MAX_DELAY_MS = 30 * 1000;\nconst DEFAULT_BACKOFF_MAX_ATTEMPTS = 5;\n/**\r\n * Helper class for implementing exponential backoff and max retry attempts.\r\n *\r\n * @private\r\n * @internal\r\n */ class ExponentialBackoff {\n    constructor(maxAttempts = DEFAULT_BACKOFF_MAX_ATTEMPTS){\n        this.maxAttempts = maxAttempts;\n        this.initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS;\n        this.backoffMultiplier = DEFAULT_BACKOFF_MULTIPLIER;\n        this.maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS;\n        this.numAttempts = 0;\n        this.currentDelayMs = 0;\n        this.isInBackoff = false;\n    }\n    /**\r\n     * Returns a promise that resolves after the the backoff delay. The delay is\r\n     * increased for each attempt. The promise is rejected if the maximum number\r\n     * of attempts is exceeded.\r\n     */ // TODO: beautify this into an async iterator.\n    backoff() {\n        if (this.numAttempts >= this.maxAttempts) {\n            return Promise.reject(new Error(`Exceeded maximum number of attempts: ${this.maxAttempts}`));\n        }\n        if (this.isInBackoff) {\n            return Promise.reject(new Error(\"A backoff operation is already in progress\"));\n        }\n        const backoffDelayWithJitterMs = this.withJitterMs(this.currentDelayMs);\n        if (backoffDelayWithJitterMs > 0) {\n            logDebug(\"ExponentialBackoff.backoff\", `Backing off for ${backoffDelayWithJitterMs}ms`);\n        }\n        // Calculate the next delay.\n        this.currentDelayMs *= this.backoffMultiplier;\n        this.currentDelayMs = Math.max(this.currentDelayMs, this.initialDelayMs);\n        this.currentDelayMs = Math.min(this.currentDelayMs, this.maxDelayMs);\n        this.numAttempts += 1;\n        return new Promise((resolve)=>{\n            this.isInBackoff = true;\n            setTimeout(()=>{\n                this.isInBackoff = false;\n                resolve();\n            }, backoffDelayWithJitterMs);\n        });\n    }\n    /**\r\n     * Applies +/- 50% jitter to the backoff delay, up to the max delay cap.\r\n     *\r\n     * @private\r\n     * @param delayMs\r\n     */ withJitterMs(delayMs) {\n        return Math.min(delayMs + (Math.random() - 0.5) * delayMs, this.maxDelayMs);\n    }\n}\n/**\r\n * A wrapper function to make http requests and retry if the request fails.\r\n *\r\n * @internal\r\n */ // TODO: Wrap Axios error in AlchemyError.\nfunction requestHttpWithBackoff(config, apiType, restApiName, methodName, params, overrides) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        let lastError = undefined;\n        const backoff = new ExponentialBackoff(config.maxRetries);\n        for(let attempt = 0; attempt < config.maxRetries + 1; attempt++){\n            try {\n                if (lastError !== undefined) {\n                    logInfo(\"requestHttp\", `Retrying after error: ${lastError.message}`);\n                }\n                try {\n                    yield backoff.backoff();\n                } catch (err) {\n                    break;\n                }\n                const response = yield sendAxiosRequest(config._getRequestUrl(apiType), restApiName, methodName, params, Object.assign(Object.assign({}, overrides), {\n                    timeout: config.requestTimeout\n                }));\n                if (response.status === 200) {\n                    logDebug(restApiName, `Successful request: ${restApiName}`);\n                    return response.data;\n                } else {\n                    logInfo(restApiName, `Request failed: ${restApiName}, ${response.status}, ${response.data}`);\n                    lastError = new Error(response.status + \": \" + response.data);\n                }\n            } catch (err) {\n                if (!axios__default[\"default\"].isAxiosError(err) || err.response === undefined) {\n                    throw err;\n                }\n                // TODO: Standardize all errors into AlchemyError\n                lastError = new Error(err.response.status + \": \" + err.response.data);\n                if (!isRetryableHttpError(err, apiType)) {\n                    break;\n                }\n            }\n        }\n        return Promise.reject(lastError);\n    });\n}\nfunction isRetryableHttpError(err, apiType) {\n    // TODO: remove 500s after webhooks are more stable.\n    const retryableCodes = apiType === AlchemyApiType.WEBHOOK ? [\n        429,\n        500\n    ] : [\n        429\n    ];\n    return err.response !== undefined && retryableCodes.includes(err.response.status);\n}\n/**\r\n * Fetches all pages in a paginated endpoint, given a `pageKey` field that\r\n * represents the property name containing the next page token.\r\n *\r\n * @internal\r\n */ function paginateEndpoint(config, apiType, restApiName, methodName, reqPageKey, resPageKey, params) {\n    return __asyncGenerator(this, arguments, function* paginateEndpoint_1() {\n        let hasNext = true;\n        const requestParams = Object.assign({}, params);\n        while(hasNext){\n            const response = yield __await(requestHttpWithBackoff(config, apiType, restApiName, methodName, requestParams));\n            yield yield __await(response);\n            if (response[resPageKey] !== null) {\n                requestParams[reqPageKey] = response[resPageKey];\n            } else {\n                hasNext = false;\n            }\n        }\n    });\n}\n/**\r\n * This file contains the underlying implementations for exposed API surface in\r\n * the {@link NftNamespace}. By moving the methods out into a separate file,\r\n * other namespaces can access these methods without depending on the entire\r\n * NftNamespace.\r\n */ /**\r\n * Get the NFT metadata for the provided contract address.\r\n */ function getNftMetadata(config, contractAddress, tokenId, options, srcMethod = \"getNftMetadata\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getNFTMetadata\", srcMethod, {\n            contractAddress,\n            tokenId: bignumber.BigNumber.from(tokenId).toString(),\n            tokenType: sanitizeTokenType(options === null || options === void 0 ? void 0 : options.tokenType),\n            tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs,\n            refreshCache: options === null || options === void 0 ? void 0 : options.refreshCache\n        });\n        return getNftFromRaw(response);\n    });\n}\nfunction getNftMetadataBatch(config, tokens, options) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const data = {\n            tokens,\n            tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs,\n            refreshCache: options === null || options === void 0 ? void 0 : options.refreshCache\n        };\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getNFTMetadataBatch\", \"getNftMetadataBatch\", {}, {\n            method: \"POST\",\n            data\n        });\n        return {\n            nfts: response.nfts.map((nft)=>getNftFromRaw(nft))\n        };\n    });\n}\nfunction getContractMetadata(config, contractAddress, srcMethod = \"getContractMetadata\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getContractMetadata\", srcMethod, {\n            contractAddress\n        });\n        return getNftContractFromRaw(response);\n    });\n}\nfunction getContractMetadataBatch(config, contractAddresses) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getContractMetadataBatch\", \"getContractMetadataBatch\", {}, {\n            method: \"POST\",\n            data: {\n                contractAddresses\n            }\n        });\n        return {\n            contracts: response.contracts.map(getNftContractFromRaw)\n        };\n    });\n}\nfunction getCollectionMetadata(config, collectionSlug, srcMethod = \"getCollectionMetadata\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getCollectionMetadata\", srcMethod, {\n            collectionSlug\n        });\n        return getNftCollectionFromRaw(response);\n    });\n}\nfunction getNftsForOwnerIterator(config, owner, options, srcMethod = \"getNftsForOwnerIterator\") {\n    return __asyncGenerator(this, arguments, function* getNftsForOwnerIterator_1() {\n        var e_1, _a;\n        const withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);\n        try {\n            for(var _b = __asyncValues(paginateEndpoint(config, AlchemyApiType.NFT, \"getNFTsForOwner\", srcMethod, \"pageKey\", \"pageKey\", {\n                contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,\n                pageKey: options === null || options === void 0 ? void 0 : options.pageKey,\n                excludeFilters: options === null || options === void 0 ? void 0 : options.excludeFilters,\n                includeFilters: options === null || options === void 0 ? void 0 : options.includeFilters,\n                owner,\n                withMetadata,\n                tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs,\n                orderBy: options === null || options === void 0 ? void 0 : options.orderBy\n            })), _c; _c = yield __await(_b.next()), !_c.done;){\n                const response = _c.value;\n                for (const ownedNft of response.ownedNfts){\n                    yield yield __await(Object.assign(Object.assign({}, nftFromGetNftResponse(ownedNft)), {\n                        balance: ownedNft.balance\n                    }));\n                }\n            }\n        } catch (e_1_1) {\n            e_1 = {\n                error: e_1_1\n            };\n        } finally{\n            try {\n                if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n            } finally{\n                if (e_1) throw e_1.error;\n            }\n        }\n    });\n}\nfunction getNftsForOwner(config, owner, options, srcMethod = \"getNftsForOwner\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getNFTsForOwner\", srcMethod, {\n            contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey,\n            excludeFilters: options === null || options === void 0 ? void 0 : options.excludeFilters,\n            includeFilters: options === null || options === void 0 ? void 0 : options.includeFilters,\n            owner,\n            pageSize: options === null || options === void 0 ? void 0 : options.pageSize,\n            withMetadata,\n            tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs,\n            orderBy: options === null || options === void 0 ? void 0 : options.orderBy\n        });\n        if (withMetadata) {\n            return nullsToUndefined({\n                ownedNfts: response.ownedNfts.map((res)=>Object.assign(Object.assign({}, getNftFromRaw(res)), {\n                        balance: res.balance\n                    })),\n                pageKey: response.pageKey,\n                totalCount: response.totalCount,\n                validAt: response.validAt\n            });\n        }\n        return nullsToUndefined({\n            ownedNfts: response.ownedNfts.map((res)=>Object.assign(Object.assign({}, getBaseNftFromRaw(res)), {\n                    balance: res.balance\n                })),\n            pageKey: response.pageKey,\n            totalCount: response.totalCount,\n            validAt: response.validAt\n        });\n    });\n}\nfunction getNftsForContract(config, contractAddress, options, srcMethod = \"getNftsForContract\") {\n    var _a;\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getNFTsForContract\", srcMethod, {\n            contractAddress,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey,\n            withMetadata,\n            limit: (_a = options === null || options === void 0 ? void 0 : options.pageSize) !== null && _a !== void 0 ? _a : undefined,\n            tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs\n        });\n        if (withMetadata) {\n            return nullsToUndefined({\n                nfts: response.nfts.map((res)=>getNftFromRaw(res)),\n                pageKey: response.pageKey\n            });\n        }\n        return nullsToUndefined({\n            nfts: response.nfts.map((res)=>getBaseNftFromRaw(res, contractAddress)),\n            pageKey: response.pageKey\n        });\n    });\n}\nfunction getNftsForContractIterator(config, contractAddress, options, srcMethod = \"getNftsForContractIterator\") {\n    return __asyncGenerator(this, arguments, function* getNftsForContractIterator_1() {\n        var e_2, _a;\n        const withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);\n        try {\n            for(var _b = __asyncValues(paginateEndpoint(config, AlchemyApiType.NFT, \"getNFTsForContract\", srcMethod, \"pageKey\", \"pageKey\", {\n                contractAddress,\n                pageKey: options === null || options === void 0 ? void 0 : options.pageKey,\n                withMetadata\n            })), _c; _c = yield __await(_b.next()), !_c.done;){\n                const response = _c.value;\n                for (const nft of response.nfts){\n                    yield yield __await(nftFromGetNftContractResponse(nft, contractAddress));\n                }\n            }\n        } catch (e_2_1) {\n            e_2 = {\n                error: e_2_1\n            };\n        } finally{\n            try {\n                if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n            } finally{\n                if (e_2) throw e_2.error;\n            }\n        }\n    });\n}\nfunction getOwnersForContract(config, contractAddress, options, srcMethod = \"getOwnersForContract\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        // Cast to `any` to avoid more type wrangling.\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getOwnersForContract\", srcMethod, Object.assign(Object.assign({}, options), {\n            contractAddress\n        }));\n        if (options === null || options === void 0 ? void 0 : options.withTokenBalances) {\n            return nullsToUndefined({\n                owners: response.owners,\n                pageKey: response.pageKey\n            });\n        }\n        return nullsToUndefined({\n            owners: response.owners,\n            pageKey: response.pageKey\n        });\n    });\n}\nfunction getContractsForOwner(config, owner, options, srcMethod = \"getContractsForOwner\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getContractsForOwner\", srcMethod, {\n            owner,\n            excludeFilters: options === null || options === void 0 ? void 0 : options.excludeFilters,\n            includeFilters: options === null || options === void 0 ? void 0 : options.includeFilters,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey,\n            pageSize: options === null || options === void 0 ? void 0 : options.pageSize,\n            orderBy: options === null || options === void 0 ? void 0 : options.orderBy\n        });\n        return nullsToUndefined({\n            contracts: response.contracts.map(getNftContractsForOwnerFromRaw),\n            pageKey: response.pageKey,\n            totalCount: response.totalCount\n        });\n    });\n}\nfunction getOwnersForNft(config, contractAddress, tokenId, options, srcMethod = \"getOwnersForNft\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        return requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getOwnersForNFT\", srcMethod, Object.assign({\n            contractAddress,\n            tokenId: bignumber.BigNumber.from(tokenId).toString()\n        }, options));\n    });\n}\nfunction getMintedNfts(config, owner, options) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const provider = yield config.getProvider();\n        const ownerAddress = yield provider._getAddress(owner);\n        const category = nftTokenTypeToCategory(options === null || options === void 0 ? void 0 : options.tokenType);\n        const params = {\n            fromBlock: \"0x0\",\n            fromAddress: ETH_NULL_ADDRESS,\n            toAddress: ownerAddress,\n            excludeZeroValue: true,\n            contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,\n            category,\n            maxCount: 100,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey\n        };\n        const response = yield getAssetTransfers(config, params, \"getMintedNfts\");\n        return getNftsForTransfers(config, response);\n    });\n}\nfunction getTransfersForOwner(config, owner, transferType, options) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const provider = yield config.getProvider();\n        const ownerAddress = yield provider._getAddress(owner);\n        const category = nftTokenTypeToCategory(options === null || options === void 0 ? void 0 : options.tokenType);\n        const params = {\n            fromBlock: \"0x0\",\n            excludeZeroValue: true,\n            contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,\n            category,\n            maxCount: 100,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey\n        };\n        if (transferType === exports.GetTransfersForOwnerTransferType.TO) {\n            params.toAddress = ownerAddress;\n        } else {\n            params.fromAddress = ownerAddress;\n        }\n        const transfersResponse = yield getAssetTransfers(config, params, \"getTransfersForOwner\");\n        return getNftsForTransfers(config, transfersResponse);\n    });\n}\nfunction getTransfersForContract(config, contract, options) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const category = [\n            exports.AssetTransfersCategory.ERC721,\n            exports.AssetTransfersCategory.ERC1155,\n            exports.AssetTransfersCategory.SPECIALNFT\n        ];\n        const provider = yield config.getProvider();\n        const fromBlock = (options === null || options === void 0 ? void 0 : options.fromBlock) ? provider.formatter.blockTag((yield provider._getBlockTag(options.fromBlock))) : \"0x0\";\n        const toBlock = (options === null || options === void 0 ? void 0 : options.toBlock) ? provider.formatter.blockTag((yield provider._getBlockTag(options.toBlock))) : undefined;\n        const params = {\n            fromBlock,\n            toBlock,\n            excludeZeroValue: true,\n            contractAddresses: [\n                contract\n            ],\n            order: options === null || options === void 0 ? void 0 : options.order,\n            category,\n            maxCount: 100,\n            pageKey: options === null || options === void 0 ? void 0 : options.pageKey\n        };\n        const transfersResponse = yield getAssetTransfers(config, params, \"getTransfersForContract\");\n        return getNftsForTransfers(config, transfersResponse);\n    });\n}\nfunction nftTokenTypeToCategory(tokenType) {\n    switch(tokenType){\n        case exports.NftTokenType.ERC721:\n            return [\n                exports.AssetTransfersCategory.ERC721\n            ];\n        case exports.NftTokenType.ERC1155:\n            return [\n                exports.AssetTransfersCategory.ERC1155\n            ];\n        default:\n            return [\n                exports.AssetTransfersCategory.ERC721,\n                exports.AssetTransfersCategory.ERC1155,\n                exports.AssetTransfersCategory.SPECIALNFT\n            ];\n    }\n}\nfunction parse1155Transfer(transfer) {\n    return transfer.erc1155Metadata.map((metadata)=>({\n            contractAddress: transfer.rawContract.address,\n            tokenId: metadata.tokenId,\n            tokenType: exports.NftTokenType.ERC1155\n        }));\n}\nfunction verifyNftOwnership(config, owner, contractAddresses, srcMethod = \"verifyNftOwnership\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        if (typeof contractAddresses === \"string\") {\n            const response = yield getNftsForOwner(config, owner, {\n                contractAddresses: [\n                    contractAddresses\n                ],\n                omitMetadata: true\n            }, srcMethod);\n            return response.ownedNfts.length > 0;\n        } else {\n            if (contractAddresses.length === 0) {\n                throw new Error(\"Must provide at least one contract address\");\n            }\n            const response = yield getNftsForOwner(config, owner, {\n                contractAddresses,\n                omitMetadata: true\n            }, srcMethod);\n            // Create map where all input contract addresses are set to false, then flip\n            // owned nfts to true.\n            const result = contractAddresses.reduce((acc, curr)=>{\n                acc[curr] = false;\n                return acc;\n            }, {});\n            for (const nft of response.ownedNfts){\n                result[nft.contractAddress] = true;\n            }\n            return result;\n        }\n    });\n}\nfunction isSpamContract(config, contractAddress, srcMethod = \"isSpamContract\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        return requestHttpWithBackoff(config, AlchemyApiType.NFT, \"isSpamContract\", srcMethod, {\n            contractAddress\n        });\n    });\n}\nfunction getSpamContracts(config, srcMethod = \"getSpamContracts\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        return requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getSpamContracts\", srcMethod, undefined);\n    });\n}\nfunction getFloorPrice(config, contractAddress, srcMethod = \"getFloorPrice\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getFloorPrice\", srcMethod, {\n            contractAddress\n        });\n        return nullsToUndefined(response);\n    });\n}\nfunction getNftSales(config, options = {}, srcMethod = \"getNftSales\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        // Avoid ts compiler complaining about the contractAddress field.\n        const params = Object.assign({}, options);\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getNFTSales\", srcMethod, {\n            fromBlock: params === null || params === void 0 ? void 0 : params.fromBlock,\n            toBlock: params === null || params === void 0 ? void 0 : params.toBlock,\n            order: params === null || params === void 0 ? void 0 : params.order,\n            marketplace: params === null || params === void 0 ? void 0 : params.marketplace,\n            contractAddress: params === null || params === void 0 ? void 0 : params.contractAddress,\n            tokenId: (params === null || params === void 0 ? void 0 : params.tokenId) ? bignumber.BigNumber.from(params === null || params === void 0 ? void 0 : params.tokenId).toString() : undefined,\n            sellerAddress: params === null || params === void 0 ? void 0 : params.sellerAddress,\n            buyerAddress: params === null || params === void 0 ? void 0 : params.buyerAddress,\n            taker: params === null || params === void 0 ? void 0 : params.taker,\n            limit: params === null || params === void 0 ? void 0 : params.limit,\n            pageKey: params === null || params === void 0 ? void 0 : params.pageKey\n        });\n        return getNftSalesFromRaw(response);\n    });\n}\nfunction computeRarity(config, contractAddress, tokenId, srcMethod = \"computeRarity\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"computeRarity\", srcMethod, {\n            contractAddress,\n            tokenId: bignumber.BigNumber.from(tokenId).toString()\n        });\n        return nullsToUndefined(response);\n    });\n}\nfunction searchContractMetadata(config, query, srcMethod = \"searchContractMetadata\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"searchContractMetadata\", srcMethod, {\n            query\n        });\n        return {\n            contracts: response.contracts.map(getNftContractFromRaw)\n        };\n    });\n}\nfunction summarizeNftAttributes(config, contractAddress, srcMethod = \"summarizeNftAttributes\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        return requestHttpWithBackoff(config, AlchemyApiType.NFT, \"summarizeNFTAttributes\", srcMethod, {\n            contractAddress\n        });\n    });\n}\nfunction refreshNftMetadata(config, contractAddress, tokenId, srcMethod = \"refreshNftMetadata\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const tokenIdString = bignumber.BigNumber.from(tokenId).toString();\n        const first = yield getNftMetadata(config, contractAddress, tokenIdString, undefined, srcMethod);\n        const second = yield refresh(config, contractAddress, tokenIdString, srcMethod);\n        return first.timeLastUpdated !== second.timeLastUpdated;\n    });\n}\nfunction refreshContract(config, contractAddress, srcMethod = \"refreshContract\") {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"reingestContract\", srcMethod, {\n            contractAddress\n        });\n        return {\n            contractAddress: response.contractAddress,\n            refreshState: parseReingestionState(response.reingestionState),\n            progress: response.progress\n        };\n    });\n}\nfunction refresh(config, contractAddress, tokenId, srcMethod) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const response = yield requestHttpWithBackoff(config, AlchemyApiType.NFT, \"getNFTMetadata\", srcMethod, {\n            contractAddress,\n            tokenId: bignumber.BigNumber.from(tokenId).toString(),\n            refreshCache: true\n        });\n        return getNftFromRaw(response);\n    });\n}\n/**\r\n * Helper method to convert a NFT response received from Alchemy backend to an\r\n * SDK NFT type.\r\n *\r\n * @internal\r\n */ function nftFromGetNftResponse(ownedNft) {\n    if (isNftWithMetadata(ownedNft)) {\n        return getNftFromRaw(ownedNft);\n    } else {\n        return getBaseNftFromRaw(ownedNft);\n    }\n}\n/**\r\n * Helper method to convert a NFT response received from Alchemy backend to an\r\n * SDK NFT type.\r\n *\r\n * @internal\r\n */ function nftFromGetNftContractResponse(ownedNft, contractAddress) {\n    if (isNftWithMetadata(ownedNft)) {\n        return getNftFromRaw(ownedNft);\n    } else {\n        return getBaseNftFromRaw(ownedNft, contractAddress);\n    }\n}\n/** @internal */ // TODO: more comprehensive type check\nfunction isNftWithMetadata(response) {\n    return response.name !== undefined;\n}\n/**\r\n * Given an AssetTransfersResponse, fetches the NFTs associated with the\r\n * transfers and collates them with transfer metadata.\r\n *\r\n * VISIBLE FOR TESTING\r\n */ function getNftsForTransfers(config, response) {\n    return __awaiter$1(this, void 0, void 0, function*() {\n        const metadataTransfers = response.transfers.filter((transfer)=>transfer.rawContract.address !== null)// Use flatMap to flatten 1155 transfers that contain multiple NFTs.\n        .flatMap((transfer)=>{\n            var _a;\n            const tokens = getTokensFromTransfer(transfer);\n            const metadata = {\n                from: transfer.from,\n                to: (_a = transfer.to) !== null && _a !== void 0 ? _a : undefined,\n                transactionHash: transfer.hash,\n                blockNumber: transfer.blockNum\n            };\n            return tokens.map((token)=>({\n                    metadata,\n                    token\n                }));\n        });\n        if (metadataTransfers.length === 0) {\n            return {\n                nfts: []\n            };\n        }\n        // If we have more than 100 elements after unrolling 1155 transfers, split\n        // transfers into batches of 100 to stay under endpoint batch size limit.\n        const batchSize = 100;\n        const requestBatches = [];\n        for(let i = 0; i < metadataTransfers.length; i += batchSize){\n            requestBatches.push(metadataTransfers.slice(i, i + batchSize));\n        }\n        const responseBatches = yield Promise.all(requestBatches.map((batch)=>getNftMetadataBatch(config, batch.map((transfer)=>transfer.token))));\n        const nfts = responseBatches.map((r)=>r.nfts).flat();\n        // The same NFT can be transferred multiple times in the same transfers response.\n        // We want to return one NFT for each transfer, so we create a mapping for\n        // each NFT to pair with the transfer metadata.\n        const nftsByTokenId = new Map();\n        nfts.forEach((nft)=>{\n            const key = `${nft.contract.address.toLowerCase()}-${bignumber.BigNumber.from(nft.tokenId).toString()}`;\n            nftsByTokenId.set(key, nft);\n        });\n        const transferredNfts = metadataTransfers.map((t)=>{\n            const key = `${t.token.contractAddress.toLowerCase()}-${bignumber.BigNumber.from(t.token.tokenId).toString()}`;\n            return Object.assign(Object.assign({}, nftsByTokenId.get(key)), t.metadata);\n        });\n        return {\n            nfts: transferredNfts,\n            pageKey: response.pageKey\n        };\n    });\n}\n/**\r\n * Returns the underlying NFT tokens from a transfer as the params for a\r\n * `getNftMetadataBatch` call. Handles the 1155 case where multiple NFTs can be\r\n * transferred in a single transaction.\r\n */ function getTokensFromTransfer(transfer) {\n    // ERC1155 NFTs can contain multiple tokens in a single transfer, which\n    // requires special logic.\n    if (transfer.category === exports.AssetTransfersCategory.ERC1155) {\n        return parse1155Transfer(transfer);\n    } else {\n        return [\n            {\n                contractAddress: transfer.rawContract.address,\n                tokenId: transfer.tokenId,\n                tokenType: transfer.category === exports.AssetTransfersCategory.ERC721 ? exports.NftTokenType.ERC721 : undefined\n            }\n        ];\n    }\n}\n/**\r\n * Flips the `omitMetadata` SDK parameter type to the `withMetadata` parameter\r\n * required by the Alchemy API. If `omitMetadata` is undefined, the SDK defaults\r\n * to including metadata.\r\n *\r\n * @internal\r\n */ function omitMetadataToWithMetadata(omitMetadata) {\n    return omitMetadata === undefined ? true : !omitMetadata;\n}\nfunction parseReingestionState(reingestionState) {\n    switch(reingestionState){\n        case \"does_not_exist\":\n            return exports.NftRefreshState.DOES_NOT_EXIST;\n        case \"already_queued\":\n            return exports.NftRefreshState.ALREADY_QUEUED;\n        case \"in_progress\":\n            return exports.NftRefreshState.IN_PROGRESS;\n        case \"finished\":\n            return exports.NftRefreshState.FINISHED;\n        case \"queued\":\n            return exports.NftRefreshState.QUEUED;\n        case \"queue_failed\":\n            return exports.NftRefreshState.QUEUE_FAILED;\n        default:\n            throw new Error(\"Unknown reingestion state: \" + reingestionState);\n    }\n}\n/**\r\n * The NFT namespace contains all the functionality related to NFTs.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the core namespace\r\n * via `alchemy.nft`.\r\n */ class NftNamespace {\n    /** @internal */ constructor(config){\n        this.config = config;\n    }\n    getNftMetadata(contractAddress, tokenId, optionsOrTokenType, tokenUriTimeoutInMs) {\n        let options;\n        if (typeof optionsOrTokenType === \"object\") {\n            options = {\n                tokenType: optionsOrTokenType.tokenType,\n                tokenUriTimeoutInMs: optionsOrTokenType.tokenUriTimeoutInMs,\n                refreshCache: optionsOrTokenType.refreshCache\n            };\n        } else {\n            options = {\n                tokenType: optionsOrTokenType,\n                tokenUriTimeoutInMs\n            };\n        }\n        return getNftMetadata(this.config, contractAddress, tokenId, options);\n    }\n    /**\r\n     * Gets the NFT metadata for multiple NFT tokens.\r\n     *\r\n     * @param tokens An array of NFT tokens to fetch metadata for.\r\n     * @param options Configuration options for making the request.\r\n     */ getNftMetadataBatch(tokens, options) {\n        return getNftMetadataBatch(this.config, tokens, options);\n    }\n    /**\r\n     * Get the NFT contract metadata associated with the provided parameters.\r\n     *\r\n     * @param contractAddress - The contract address of the NFT.\r\n     * @public\r\n     */ getContractMetadata(contractAddress) {\n        return getContractMetadata(this.config, contractAddress);\n    }\n    /**\r\n     * Get the NFT contract metadata for multiple NFT contracts in a single request.\r\n     *\r\n     * @param contractAddresses - An array of contract addresses to fetch metadata for.\r\n     */ getContractMetadataBatch(contractAddresses) {\n        return getContractMetadataBatch(this.config, contractAddresses);\n    }\n    /**\r\n     * Get the NFT collection metadata associated with the provided parameters.\r\n     *\r\n     * @param collectionSlug - The OpenSea collection slug of the NFT.\r\n     * @beta\r\n     */ getCollectionMetadata(collectionSlug) {\n        return getCollectionMetadata(this.config, collectionSlug);\n    }\n    getNftsForOwnerIterator(owner, options) {\n        return getNftsForOwnerIterator(this.config, owner, options);\n    }\n    getNftsForOwner(owner, options) {\n        return getNftsForOwner(this.config, owner, options);\n    }\n    getNftsForContract(contractAddress, options) {\n        return getNftsForContract(this.config, contractAddress, options);\n    }\n    getNftsForContractIterator(contractAddress, options) {\n        return getNftsForContractIterator(this.config, contractAddress, options);\n    }\n    getOwnersForContract(contractAddress, options) {\n        return getOwnersForContract(this.config, contractAddress, options);\n    }\n    /**\r\n     * Gets all the owners for a given NFT contract address and token ID.\r\n     *\r\n     * @param contractAddress - The NFT contract address.\r\n     * @param tokenId - Token id of the NFT.\r\n     * @param options - Optional parameters to use for the request.\r\n     * @beta\r\n     */ getOwnersForNft(contractAddress, tokenId, options) {\n        return getOwnersForNft(this.config, contractAddress, tokenId, options);\n    }\n    /**\r\n     * Gets all NFT contracts held by the specified owner address.\r\n     *\r\n     * @param owner - Address for NFT owner (can be in ENS format!).\r\n     * @param options - The optional parameters to use for the request.\r\n     * @public\r\n     */ // TODO(v3): Add overload for withMetadata=false\n    getContractsForOwner(owner, options) {\n        return getContractsForOwner(this.config, owner, options);\n    }\n    /**\r\n     * Gets all NFT transfers for a given owner's address.\r\n     *\r\n     * @param owner The owner to get transfers for.\r\n     * @param category Whether to get transfers to or from the owner address.\r\n     * @param options Additional options for the request.\r\n     */ getTransfersForOwner(owner, category, options) {\n        return getTransfersForOwner(this.config, owner, category, options);\n    }\n    /**\r\n     * Gets all NFT transfers for a given NFT contract address.\r\n     *\r\n     * Defaults to all transfers for the contract. To get transfers for a specific\r\n     * block range, use {@link GetTransfersForContractOptions}.\r\n     *\r\n     * @param contract The NFT contract to get transfers for.\r\n     * @param options Additional options for the request.\r\n     */ getTransfersForContract(contract, options) {\n        return getTransfersForContract(this.config, contract, options);\n    }\n    /**\r\n     * Get all the NFTs minted by a specified owner address.\r\n     *\r\n     * @param owner - Address for the NFT owner (can be in ENS format).\r\n     * @param options - The optional parameters to use for the request.\r\n     */ getMintedNfts(owner, options) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            return getMintedNfts(this.config, owner, options);\n        });\n    }\n    verifyNftOwnership(owner, contractAddress) {\n        return verifyNftOwnership(this.config, owner, contractAddress);\n    }\n    /**\r\n     * Returns whether a contract is marked as spam or not by Alchemy. For more\r\n     * information on how we classify spam, go to our NFT API FAQ at\r\n     * https://docs.alchemy.com/alchemy/enhanced-apis/nft-api/nft-api-faq#nft-spam-classification.\r\n     *\r\n     * @param contractAddress - The contract address to check.\r\n     * @beta\r\n     */ isSpamContract(contractAddress) {\n        return isSpamContract(this.config, contractAddress);\n    }\n    /**\r\n     * Returns a list of all spam contracts marked by Alchemy. For details on how\r\n     * Alchemy marks spam contracts, go to\r\n     * https://docs.alchemy.com/alchemy/enhanced-apis/nft-api/nft-api-faq#nft-spam-classification.\r\n     *\r\n     * @beta\r\n     */ getSpamContracts() {\n        return getSpamContracts(this.config);\n    }\n    /**\r\n     * Returns the floor prices of a NFT contract by marketplace.\r\n     *\r\n     * @param contractAddress - The contract address for the NFT collection.\r\n     * @beta\r\n     */ getFloorPrice(contractAddress) {\n        return getFloorPrice(this.config, contractAddress);\n    }\n    getNftSales(options) {\n        return getNftSales(this.config, options);\n    }\n    /**\r\n     * Get the rarity of each attribute of an NFT.\r\n     *\r\n     * @param contractAddress - Contract address for the NFT collection.\r\n     * @param tokenId - Token id of the NFT.\r\n     */ computeRarity(contractAddress, tokenId) {\n        return computeRarity(this.config, contractAddress, tokenId);\n    }\n    /**\r\n     * Search for a keyword across metadata of all ERC-721 and ERC-1155 smart contracts.\r\n     *\r\n     * @param query - The search string that you want to search for in contract metadata.\r\n     */ searchContractMetadata(query) {\n        return searchContractMetadata(this.config, query);\n    }\n    /**\r\n     * Get a summary of attribute prevalence for an NFT collection.\r\n     *\r\n     * @param contractAddress - Contract address for the NFT collection.\r\n     */ summarizeNftAttributes(contractAddress) {\n        return summarizeNftAttributes(this.config, contractAddress);\n    }\n    /**\r\n     * Refreshes the cached metadata for a provided NFT contract address and token\r\n     * id. Returns a boolean value indicating whether the metadata was refreshed.\r\n     *\r\n     * This method is useful when you want to refresh the metadata for a NFT that\r\n     * has been updated since the last time it was fetched. Note that the backend\r\n     * only allows one refresh per token every 15 minutes, globally for all users.\r\n     * The last refresh time for an NFT can be accessed on the\r\n     * {@link Nft.timeLastUpdated} field.\r\n     *\r\n     * To trigger a refresh for all NFTs in a contract, use {@link refreshContract} instead.\r\n     *\r\n     * @param contractAddress - The contract address of the NFT.\r\n     * @param tokenId - The token id of the NFT.\r\n     */ refreshNftMetadata(contractAddress, tokenId) {\n        return refreshNftMetadata(this.config, contractAddress, tokenId);\n    }\n    /**\r\n     * Triggers a metadata refresh all NFTs in the provided contract address. This\r\n     * method is useful after an NFT collection is revealed.\r\n     *\r\n     * Refreshes are queued on the Alchemy backend and may take time to fully\r\n     * process. To refresh the metadata for a specific token, use the\r\n     * {@link refreshNftMetadata} method instead.\r\n     *\r\n     * @param contractAddress - The contract address of the NFT collection.\r\n     * @beta\r\n     */ refreshContract(contractAddress) {\n        return refreshContract(this.config, contractAddress);\n    }\n}\n/**\r\n * The Notify namespace contains methods used for creating, reading, updating,\r\n * and deleting webhooks in the Notify API.\r\n *\r\n * To use the methods in the API, you must provide your team's auth token in the\r\n * {@link AlchemySettings.authToken} field when configuring\r\n * {@link AlchemySettings}. The auth token can be found in the Alchemy Dashboard\r\n * on the Notify tab.\r\n *\r\n * Note that not all networks are supported in the Notify API. Please consult\r\n * the documentation for which networks are supported.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the notify\r\n * namespace via `alchemy.notify`.\r\n */ class NotifyNamespace {\n    /** @internal */ constructor(config){\n        this.config = config;\n    }\n    /**\r\n     * Get all webhooks on your team.\r\n     *\r\n     * The team is determined by the `authToken` provided into the {@link AlchemySettings}\r\n     * object when creating a new {@link Alchemy} instance.\r\n     *\r\n     * This method returns a response object containing all the webhooks\r\n     */ getAllWebhooks() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            this.verifyConfig();\n            const response = yield this.sendWebhookRequest(\"team-webhooks\", \"getAllWebhooks\", {});\n            return {\n                webhooks: parseRawWebhookResponse(response),\n                totalCount: response.data.length\n            };\n        });\n    }\n    getAddresses(webhookOrId, options) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            this.verifyConfig();\n            const webhookId = typeof webhookOrId === \"string\" ? webhookOrId : webhookOrId.id;\n            const response = yield this.sendWebhookRequest(\"webhook-addresses\", \"getAddresses\", {\n                webhook_id: webhookId,\n                limit: options === null || options === void 0 ? void 0 : options.limit,\n                after: options === null || options === void 0 ? void 0 : options.pageKey\n            });\n            return parseRawAddressActivityResponse(response);\n        });\n    }\n    getGraphqlQuery(webhookOrId) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            this.verifyConfig();\n            const webhookId = typeof webhookOrId === \"string\" ? webhookOrId : webhookOrId.id;\n            const response = yield this.sendWebhookRequest(\"dashboard-webhook-graphql-query\", \"getGraphqlQuery\", {\n                webhook_id: webhookId\n            });\n            return parseRawCustomGraphqlWebhookResponse(response);\n        });\n    }\n    getNftFilters(webhookOrId, options) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            this.verifyConfig();\n            const webhookId = typeof webhookOrId === \"string\" ? webhookOrId : webhookOrId.id;\n            const response = yield this.sendWebhookRequest(\"webhook-nft-filters\", \"getNftFilters\", {\n                webhook_id: webhookId,\n                limit: options === null || options === void 0 ? void 0 : options.limit,\n                after: options === null || options === void 0 ? void 0 : options.pageKey\n            });\n            return parseRawNftFiltersResponse(response);\n        });\n    }\n    updateWebhook(webhookOrId, update) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const webhookId = typeof webhookOrId === \"string\" ? webhookOrId : webhookOrId.id;\n            let restApiName;\n            let methodName;\n            let method;\n            let data;\n            if (\"isActive\" in update) {\n                restApiName = \"update-webhook\";\n                methodName = \"updateWebhook\";\n                method = \"PUT\";\n                data = {\n                    webhook_id: webhookId,\n                    is_active: update.isActive\n                };\n            } else if (\"addFilters\" in update || \"removeFilters\" in update) {\n                restApiName = \"update-webhook-nft-filters\";\n                methodName = \"updateWebhookNftFilters\";\n                method = \"PATCH\";\n                data = {\n                    webhook_id: webhookId,\n                    nft_filters_to_add: update.addFilters ? update.addFilters.map(nftFilterToParam) : [],\n                    nft_filters_to_remove: update.removeFilters ? update.removeFilters.map(nftFilterToParam) : []\n                };\n            } else if (\"addMetadataFilters\" in update || \"removeMetadataFilters\" in update) {\n                restApiName = \"update-webhook-nft-metadata-filters\";\n                methodName = \"updateWebhookNftMetadataFilters\";\n                method = \"PATCH\";\n                data = {\n                    webhook_id: webhookId,\n                    nft_metadata_filters_to_add: update.addMetadataFilters ? update.addMetadataFilters.map(nftFilterToParam) : [],\n                    nft_metadata_filters_to_remove: update.removeMetadataFilters ? update.removeMetadataFilters.map(nftFilterToParam) : []\n                };\n            } else if (\"addAddresses\" in update || \"removeAddresses\" in update) {\n                restApiName = \"update-webhook-addresses\";\n                methodName = \"webhook:updateWebhookAddresses\";\n                method = \"PATCH\";\n                data = {\n                    webhook_id: webhookId,\n                    addresses_to_add: yield this.resolveAddresses(update.addAddresses),\n                    addresses_to_remove: yield this.resolveAddresses(update.removeAddresses)\n                };\n            } else if (\"newAddresses\" in update) {\n                restApiName = \"update-webhook-addresses\";\n                methodName = \"webhook:updateWebhookAddress\";\n                method = \"PUT\";\n                data = {\n                    webhook_id: webhookId,\n                    addresses: yield this.resolveAddresses(update.newAddresses)\n                };\n            } else {\n                throw new Error(\"Invalid `update` param passed into `updateWebhook`\");\n            }\n            yield this.sendWebhookRequest(restApiName, methodName, {}, {\n                method,\n                data\n            });\n        });\n    }\n    createWebhook(url, type, params) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            let appId;\n            if (type === exports.WebhookType.MINED_TRANSACTION || type === exports.WebhookType.DROPPED_TRANSACTION) {\n                if (!(\"appId\" in params)) {\n                    throw new Error(\"Transaction Webhooks require an app id.\");\n                }\n                appId = params.appId;\n            }\n            let network = NETWORK_TO_WEBHOOK_NETWORK.get(this.config.network);\n            let nftFilterObj;\n            let addresses;\n            let graphqlQuery;\n            if (type === exports.WebhookType.NFT_ACTIVITY || type === exports.WebhookType.NFT_METADATA_UPDATE) {\n                if (!(\"filters\" in params) || params.filters.length === 0) {\n                    throw new Error(\"Nft Activity Webhooks require a non-empty array input.\");\n                }\n                network = params.network ? NETWORK_TO_WEBHOOK_NETWORK.get(params.network) : network;\n                const filters = params.filters.map((filter)=>filter.tokenId ? {\n                        contract_address: filter.contractAddress,\n                        token_id: bignumber.BigNumber.from(filter.tokenId).toString()\n                    } : {\n                        contract_address: filter.contractAddress\n                    });\n                nftFilterObj = type === exports.WebhookType.NFT_ACTIVITY ? {\n                    nft_filters: filters\n                } : {\n                    nft_metadata_filters: filters\n                };\n            } else if (type === exports.WebhookType.ADDRESS_ACTIVITY) {\n                if (params === undefined || !(\"addresses\" in params) || params.addresses.length === 0) {\n                    throw new Error(\"Address Activity Webhooks require a non-empty array input.\");\n                }\n                network = params.network ? NETWORK_TO_WEBHOOK_NETWORK.get(params.network) : network;\n                addresses = yield this.resolveAddresses(params.addresses);\n            } else if (type == exports.WebhookType.GRAPHQL) {\n                if (params === undefined || !(\"graphqlQuery\" in params) || params.graphqlQuery.length === 0) {\n                    throw new Error(\"Custom Webhooks require a non-empty graphql query.\");\n                }\n                network = params.network ? NETWORK_TO_WEBHOOK_NETWORK.get(params.network) : network;\n                graphqlQuery = params.graphqlQuery;\n            }\n            const data = Object.assign(Object.assign(Object.assign(Object.assign({\n                network,\n                webhook_type: type,\n                webhook_url: url\n            }, appId && {\n                app_id: appId\n            }), nftFilterObj), addresses && {\n                addresses\n            }), graphqlQuery && {\n                graphql_query: graphqlQuery\n            });\n            const response = yield this.sendWebhookRequest(\"create-webhook\", \"createWebhook\", {}, {\n                method: \"POST\",\n                data\n            });\n            return parseRawWebhook(response.data);\n        });\n    }\n    deleteWebhook(webhookOrId) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            this.verifyConfig();\n            const webhookId = typeof webhookOrId === \"string\" ? webhookOrId : webhookOrId.id;\n            const response = yield this.sendWebhookRequest(\"delete-webhook\", \"deleteWebhook\", {\n                webhook_id: webhookId\n            }, {\n                method: \"DELETE\"\n            });\n            if (\"message\" in response) {\n                throw new Error(`Webhook not found. Failed to delete webhook: ${webhookId}`);\n            }\n        });\n    }\n    verifyConfig() {\n        if (this.config.authToken === undefined) {\n            throw new Error(\"Using the Notify API requires setting the Alchemy Auth Token in \" + \"the settings object when initializing Alchemy.\");\n        }\n    }\n    sendWebhookRequest(restApiName, methodName, params, overrides) {\n        return requestHttpWithBackoff(this.config, AlchemyApiType.WEBHOOK, restApiName, methodName, params, Object.assign(Object.assign({}, overrides), {\n            headers: Object.assign({\n                \"X-Alchemy-Token\": this.config.authToken\n            }, overrides === null || overrides === void 0 ? void 0 : overrides.headers)\n        }));\n    }\n    /** Resolves ENS addresses to the raw address.\r\n     * @internal */ resolveAddresses(addresses) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            if (addresses === undefined) {\n                return [];\n            }\n            const resolvedAddresses = [];\n            const provider = yield this.config.getProvider();\n            for (const address of addresses){\n                const rawAddress = yield provider.resolveName(address);\n                if (rawAddress === null) {\n                    throw new Error(`Unable to resolve the ENS address: ${address}`);\n                }\n                resolvedAddresses.push(rawAddress);\n            }\n            return resolvedAddresses;\n        });\n    }\n}\n/**\r\n * Mapping of webhook network representations to the SDK's network representation.\r\n *\r\n * @internal\r\n */ const WEBHOOK_NETWORK_TO_NETWORK = {\n    ETH_MAINNET: exports.Network.ETH_MAINNET,\n    ETH_GOERLI: exports.Network.ETH_GOERLI,\n    ETH_SEPOLIA: exports.Network.ETH_SEPOLIA,\n    MATIC_MAINNET: exports.Network.MATIC_MAINNET,\n    MATIC_MUMBAI: exports.Network.MATIC_MUMBAI,\n    ARB_MAINNET: exports.Network.ARB_MAINNET,\n    ARB_GOERLI: exports.Network.ARB_GOERLI,\n    OPT_MAINNET: exports.Network.OPT_MAINNET,\n    OPT_GOERLI: exports.Network.OPT_GOERLI\n};\n/** Mapping of the SDK's network representation the webhook API's network representation. */ const NETWORK_TO_WEBHOOK_NETWORK = Object.keys(exports.Network).reduce((map, key)=>{\n    if (key in WEBHOOK_NETWORK_TO_NETWORK) {\n        map.set(WEBHOOK_NETWORK_TO_NETWORK[key], key);\n    }\n    return map;\n}, new Map());\nfunction parseRawWebhookResponse(response) {\n    return response.data.map(parseRawWebhook);\n}\nfunction parseRawWebhook(rawWebhook) {\n    return Object.assign({\n        id: rawWebhook.id,\n        network: WEBHOOK_NETWORK_TO_NETWORK[rawWebhook.network],\n        type: rawWebhook.webhook_type,\n        url: rawWebhook.webhook_url,\n        isActive: rawWebhook.is_active,\n        timeCreated: new Date(rawWebhook.time_created).toISOString(),\n        signingKey: rawWebhook.signing_key,\n        version: rawWebhook.version\n    }, rawWebhook.app_id !== undefined && {\n        appId: rawWebhook.app_id\n    });\n}\nfunction parseRawAddressActivityResponse(response) {\n    return {\n        addresses: response.data,\n        totalCount: response.pagination.total_count,\n        pageKey: response.pagination.cursors.after\n    };\n}\nfunction parseRawCustomGraphqlWebhookResponse(response) {\n    return {\n        graphqlQuery: response.data.graphql_query\n    };\n}\nfunction parseRawNftFiltersResponse(response) {\n    return {\n        filters: response.data.map((f)=>f.token_id ? {\n                contractAddress: f.contract_address,\n                tokenId: bignumber.BigNumber.from(f.token_id).toString()\n            } : {\n                contractAddress: f.contract_address\n            }),\n        totalCount: response.pagination.total_count,\n        pageKey: response.pagination.cursors.after\n    };\n}\nfunction nftFilterToParam(filter) {\n    return filter.tokenId ? {\n        contract_address: filter.contractAddress,\n        token_id: bignumber.BigNumber.from(filter.tokenId).toString()\n    } : {\n        contract_address: filter.contractAddress\n    };\n}\n/**\r\n * Multiples to increment fee per gas when using\r\n * {@link TransactNamespace.sendGasOptimizedTransaction}.\r\n *\r\n * @internal\r\n */ const GAS_OPTIMIZED_TX_FEE_MULTIPLES = [\n    0.9,\n    1,\n    1.1,\n    1.2,\n    1.3\n];\n/**\r\n * The Transact namespace contains methods used for sending transactions and\r\n * checking on the state of submitted transactions.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the transact\r\n * namespace via `alchemy.transact`.\r\n */ class TransactNamespace {\n    /** @internal */ constructor(config){\n        this.config = config;\n    }\n    /**\r\n     * Used to send a single transaction to Flashbots. Flashbots will attempt to\r\n     * send the transaction to miners for the next 25 blocks.\r\n     *\r\n     * Returns the transaction hash of the submitted transaction.\r\n     *\r\n     * @param signedTransaction The raw, signed transaction as a hash.\r\n     * @param maxBlockNumber Optional highest block number in which the\r\n     *   transaction should be included.\r\n     * @param options Options to configure the request.\r\n     */ sendPrivateTransaction(signedTransaction, maxBlockNumber, options) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const hexBlockNumber = maxBlockNumber ? toHex(maxBlockNumber) : undefined;\n            return provider._send(\"eth_sendPrivateTransaction\", [\n                {\n                    tx: signedTransaction,\n                    maxBlockNumber: hexBlockNumber,\n                    preferences: options\n                }\n            ], \"sendPrivateTransaction\");\n        });\n    }\n    /**\r\n     * Stops the provided private transaction from being submitted for future\r\n     * blocks. A transaction can only be cancelled if the request is signed by the\r\n     * same key as the {@link sendPrivateTransaction} call submitting the\r\n     * transaction in first place.\r\n     *\r\n     * Please note that fast mode transactions cannot be cancelled using this method.\r\n     *\r\n     * Returns a boolean indicating whether the cancellation was successful.\r\n     *\r\n     * @param transactionHash Transaction hash of private tx to be cancelled\r\n     */ cancelPrivateTransaction(transactionHash) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider._send(\"eth_cancelPrivateTransaction\", [\n                {\n                    txHash: transactionHash\n                }\n            ], \"cancelPrivateTransaction\");\n        });\n    }\n    /**\r\n     * Simulates the asset changes resulting from a list of transactions simulated\r\n     * in sequence.\r\n     *\r\n     * Returns a list of asset changes for each transaction during simulation.\r\n     *\r\n     * @param transactions Transactions list of max 3 transactions to simulate.\r\n     * @param blockIdentifier Optional block identifier to simulate the\r\n     * transaction in.\r\n     */ simulateAssetChangesBundle(transactions, blockIdentifier) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const params = blockIdentifier !== undefined ? [\n                transactions,\n                blockIdentifier\n            ] : [\n                transactions\n            ];\n            const res = yield provider._send(\"alchemy_simulateAssetChangesBundle\", params, \"simulateAssetChangesBundle\");\n            return nullsToUndefined(res);\n        });\n    }\n    /**\r\n     * Simulates the asset changes resulting from a single transaction.\r\n     *\r\n     * Returns list of asset changes that occurred during the transaction\r\n     * simulation. Note that this method does not run the transaction on the\r\n     * blockchain.\r\n     *\r\n     * @param transaction The transaction to simulate.\r\n     * @param blockIdentifier Optional block identifier to simulate the\r\n     * transaction in.\r\n     */ simulateAssetChanges(transaction, blockIdentifier) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const params = blockIdentifier !== undefined ? [\n                transaction,\n                blockIdentifier\n            ] : [\n                transaction\n            ];\n            const res = yield provider._send(\"alchemy_simulateAssetChanges\", params, \"simulateAssetChanges\");\n            return nullsToUndefined(res);\n        });\n    }\n    /**\r\n     * Simulates a list of transactions in sequence and returns list of decoded\r\n     * traces and logs that occurred for each transaction during simulation.\r\n     *\r\n     * Note that this method does not run any transactions on the blockchain.\r\n     *\r\n     * @param transactions Transactions list of max 3 transactions to simulate.\r\n     * @param blockIdentifier Optional block identifier to simulate the\r\n     * transaction in.\r\n     */ simulateExecutionBundle(transactions, blockIdentifier) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const params = blockIdentifier !== undefined ? [\n                transactions,\n                blockIdentifier\n            ] : [\n                transactions\n            ];\n            const res = provider._send(\"alchemy_simulateExecutionBundle\", params, \"simulateExecutionBundle\");\n            return nullsToUndefined(res);\n        });\n    }\n    /**\r\n     * Simulates a single transaction and the resulting and returns list of\r\n     * decoded traces and logs that occurred during the transaction simulation.\r\n     *\r\n     * Note that this method does not run the transaction on the blockchain.\r\n     *\r\n     * @param transaction The transaction to simulate.\r\n     * @param blockIdentifier Optional block identifier to simulate the\r\n     * transaction in.\r\n     */ simulateExecution(transaction, blockIdentifier) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const params = blockIdentifier !== undefined ? [\n                transaction,\n                blockIdentifier\n            ] : [\n                transaction\n            ];\n            const res = provider._send(\"alchemy_simulateExecution\", params, \"simulateExecution\");\n            return nullsToUndefined(res);\n        });\n    }\n    /**\r\n     * Returns the transaction with hash or null if the transaction is unknown.\r\n     *\r\n     * If a transaction has not been mined, this method will search the\r\n     * transaction pool. Various backends may have more restrictive transaction\r\n     * pool access (e.g. if the gas price is too low or the transaction was only\r\n     * recently sent and not yet indexed) in which case this method may also return null.\r\n     *\r\n     * NOTE: This is an alias for {@link CoreNamespace.getTransaction}.\r\n     *\r\n     * @param transactionHash The hash of the transaction to get.\r\n     * @public\r\n     */ getTransaction(transactionHash) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.getTransaction(transactionHash);\n        });\n    }\n    /**\r\n     * Submits transaction to the network to be mined. The transaction must be\r\n     * signed, and be valid (i.e. the nonce is correct and the account has\r\n     * sufficient balance to pay for the transaction).\r\n     *\r\n     * NOTE: This is an alias for {@link CoreNamespace.sendTransaction}.\r\n     *\r\n     * @param signedTransaction The signed transaction to send.\r\n     * @public\r\n     */ sendTransaction(signedTransaction) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.sendTransaction(signedTransaction);\n        });\n    }\n    /**\r\n     * Returns an estimate of the amount of gas that would be required to submit\r\n     * transaction to the network.\r\n     *\r\n     * An estimate may not be accurate since there could be another transaction on\r\n     * the network that was not accounted for, but after being mined affects the\r\n     * relevant state.\r\n     *\r\n     * This is an alias for {@link CoreNamespace.estimateGas}.\r\n     *\r\n     * @param transaction The transaction to estimate gas for.\r\n     * @public\r\n     */ estimateGas(transaction) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.estimateGas(transaction);\n        });\n    }\n    /**\r\n     * Returns a fee per gas (in wei) that is an estimate of how much you can pay\r\n     * as a priority fee, or \"tip\", to get a transaction included in the current block.\r\n     *\r\n     * This number is generally used to set the `maxPriorityFeePerGas` field in a\r\n     * transaction request.\r\n     *\r\n     * @public\r\n     */ getMaxPriorityFeePerGas() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const feeHex = yield provider._send(\"eth_maxPriorityFeePerGas\", [], \"getMaxPriorityFeePerGas\");\n            return fromHex(feeHex);\n        });\n    }\n    /**\r\n     * Returns a promise which will not resolve until specified transaction hash is mined.\r\n     *\r\n     * If {@link confirmations} is 0, this method is non-blocking and if the\r\n     * transaction has not been mined returns null. Otherwise, this method will\r\n     * block until the transaction has confirmed blocks mined on top of the block\r\n     * in which it was mined.\r\n     *\r\n     * NOTE: This is an alias for {@link CoreNamespace.waitForTransaction}.\r\n     *\r\n     * @param transactionHash The hash of the transaction to wait for.\r\n     * @param confirmations The number of blocks to wait for.\r\n     * @param timeout The maximum time to wait for the transaction to confirm.\r\n     * @public\r\n     */ waitForTransaction(transactionHash, confirmations, timeout) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider.waitForTransaction(transactionHash, confirmations, timeout);\n        });\n    }\n    sendGasOptimizedTransaction(transactionOrSignedTxs, wallet) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            if (Array.isArray(transactionOrSignedTxs)) {\n                return this._sendGasOptimizedTransaction(transactionOrSignedTxs, \"sendGasOptimizedTransactionPreSigned\");\n            }\n            let gasLimit;\n            let priorityFee;\n            let baseFee;\n            const provider = yield this.config.getProvider();\n            try {\n                gasLimit = yield this.estimateGas(transactionOrSignedTxs);\n                priorityFee = yield this.getMaxPriorityFeePerGas();\n                const currentBlock = yield provider.getBlock(\"latest\");\n                baseFee = currentBlock.baseFeePerGas.toNumber();\n            } catch (e) {\n                throw new Error(`Failed to estimate gas for transaction: ${e}`);\n            }\n            const gasSpreadTransactions = generateGasSpreadTransactions(transactionOrSignedTxs, gasLimit.toNumber(), baseFee, priorityFee);\n            const signedTransactions = yield Promise.all(gasSpreadTransactions.map((tx)=>wallet.signTransaction(tx)));\n            return this._sendGasOptimizedTransaction(signedTransactions, \"sendGasOptimizedTransactionGenerated\");\n        });\n    }\n    /**\r\n     * Returns the state of the transaction job returned by the\r\n     * {@link sendGasOptimizedTransaction}.\r\n     *\r\n     * @param trackingId The tracking id from the response of the sent gas optimized transaction.\r\n     * @internal\r\n     */ // TODO(txjob): Remove internal tag once this feature is released.\n    getGasOptimizedTransactionStatus(trackingId) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider._send(\"alchemy_getGasOptimizedTransactionStatus\", [\n                trackingId\n            ], \"getGasOptimizedTransactionStatus\");\n        });\n    }\n    /** @internal */ _sendGasOptimizedTransaction(signedTransactions, methodName) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            return provider._send(\"alchemy_sendGasOptimizedTransaction\", [\n                {\n                    rawTransactions: signedTransactions\n                }\n            ], methodName);\n        });\n    }\n}\n/**\r\n * Helper method to generate the raw transaction with the given gas limit and\r\n * priority fee across a spread of different gas prices.\r\n *\r\n * @internal\r\n */ // Visible for testing\nfunction generateGasSpreadTransactions(transaction, gasLimit, baseFee, priorityFee) {\n    return GAS_OPTIMIZED_TX_FEE_MULTIPLES.map((feeMultiplier)=>{\n        return Object.assign(Object.assign({}, transaction), {\n            gasLimit,\n            maxFeePerGas: Math.round(baseFee * feeMultiplier + priorityFee * feeMultiplier),\n            maxPriorityFeePerGas: Math.round(feeMultiplier * priorityFee)\n        });\n    });\n}\n/** This file contains internal types used by the SDK and are not exposed to the end user. */ /**\r\n * Prefix for `alchemy_pendingTransactions` subscriptions when serializing to\r\n * ethers events.\r\n *\r\n * This tag is used internally by ethers to track different event filters.\r\n */ const ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE = \"alchemy-pending-transactions\";\n/**\r\n * Prefix for `alchemy_minedTransactions` subscriptions when serializing to ethers events.\r\n *\r\n * This tag is used internally by ethers to track different event filters.\r\n */ const ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE = \"alchemy-mined-transactions\";\n/**\r\n * Array containing all the custom event tags used internally by ethers to track\r\n * event filters.\r\n */ const ALCHEMY_EVENT_TYPES = [\n    ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,\n    ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE\n];\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * Event class copied directly over from ethers.js's `BaseProvider` class.\r\n *\r\n * This class is used to represent events and their corresponding listeners. The\r\n * SDK needs to extend this class in order to support Alchemy's custom\r\n * Subscription API types. The original class is not exported by ethers. Minimal\r\n * changes have been made in order to get TS to compile.\r\n */ class Event {\n    constructor(tag, listener, once){\n        this.listener = listener;\n        this.tag = tag;\n        this.once = once;\n        this._lastBlockNumber = -2;\n        this._inflight = false;\n    }\n    get event() {\n        switch(this.type){\n            case \"tx\":\n                return this.hash;\n            case \"filter\":\n                return this.filter;\n            default:\n                return this.tag;\n        }\n    }\n    get type() {\n        return this.tag.split(\":\")[0];\n    }\n    get hash() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") {\n            throw new Error(\"Not a transaction event\");\n        }\n        return comps[1];\n    }\n    get filter() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") {\n            throw new Error(\"Not a transaction event\");\n        }\n        const address = comps[1];\n        const topics = deserializeTopics(comps[2]);\n        const filter = {};\n        if (topics.length > 0) {\n            filter.topics = topics;\n        }\n        if (address && address !== \"*\") {\n            filter.address = address;\n        }\n        return filter;\n    }\n    pollable() {\n        const PollableEvents = [\n            \"block\",\n            \"network\",\n            \"pending\",\n            \"poll\"\n        ];\n        return this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0;\n    }\n}\n/**\r\n * Wrapper class around the ethers `Event` class in order to add support for\r\n * Alchemy's custom subscriptions types.\r\n *\r\n * The serialization and deserialization mechanism requires the order of the\r\n * fields to be the same across different {@link ALCHEMY_EVENT_TYPES}. Before\r\n * using a getter on a new event filter, make sure that the position of the\r\n * field in serialization is correct.\r\n *\r\n * The getters on this class deserialize the event tag generated by\r\n * {@link getAlchemyEventTag} into the original fields passed into the event.\r\n */ class EthersEvent extends Event {\n    /**\r\n     * Converts the event tag into the original `fromAddress` field in\r\n     * {@link AlchemyPendingTransactionsEventFilter}.\r\n     */ get fromAddress() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n            return undefined;\n        }\n        if (comps[1] && comps[1] !== \"*\") {\n            return deserializeAddressField(comps[1]);\n        } else {\n            return undefined;\n        }\n    }\n    /**\r\n     * Converts the event tag into the original `toAddress` field in\r\n     * {@link AlchemyPendingTransactionsEventFilter}.\r\n     */ get toAddress() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n            return undefined;\n        }\n        if (comps[2] && comps[2] !== \"*\") {\n            return deserializeAddressField(comps[2]);\n        } else {\n            return undefined;\n        }\n    }\n    /**\r\n     * Converts the event tag into the original `hashesOnly` field in\r\n     * {@link AlchemyPendingTransactionsEventFilter} and {@link AlchemyMinedTransactionsEventFilter}.\r\n     */ get hashesOnly() {\n        const comps = this.tag.split(\":\");\n        if (!ALCHEMY_EVENT_TYPES.includes(comps[0])) {\n            return undefined;\n        }\n        if (comps[3] && comps[3] !== \"*\") {\n            return comps[3] === \"true\";\n        } else {\n            return undefined;\n        }\n    }\n    get includeRemoved() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n            return undefined;\n        }\n        if (comps[2] && comps[2] !== \"*\") {\n            return comps[2] === \"true\";\n        } else {\n            return undefined;\n        }\n    }\n    get addresses() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n            return undefined;\n        }\n        if (comps[1] && comps[1] !== \"*\") {\n            return deserializeAddressesField(comps[1]);\n        } else {\n            return undefined;\n        }\n    }\n}\nfunction isAlchemyEvent(event) {\n    return typeof event === \"object\" && \"method\" in event;\n}\n/**\r\n * Creates a string representation of an `alchemy_pendingTransaction`\r\n * subscription filter that is compatible with the ethers implementation of\r\n * `getEventTag()`. The method is not an exported function in ethers, which is\r\n * why the SDK has its own implementation.\r\n *\r\n * The event tag is then deserialized by the SDK's {@link EthersEvent} getters.\r\n *\r\n * @example\r\n *   ```js\r\n *   // Returns 'alchemy-pending-transactions:0xABC:0xDEF|0xGHI:true'\r\n *   const eventTag =  getAlchemyEventTag(\r\n *   {\r\n *     \"method\": \"alchemy_pendingTransactions\",\r\n *     \"fromAddress\": \"0xABC\",\r\n *     \"toAddress\": [\"0xDEF\", \"0xGHI\"],\r\n *     \"hashesOnly: true\r\n *   });\r\n *   ```;\r\n *\r\n * @param event\r\n * @internal\r\n */ function getAlchemyEventTag(event) {\n    if (!isAlchemyEvent(event)) {\n        throw new Error(\"Event tag requires AlchemyEventType\");\n    }\n    if (event.method === exports.AlchemySubscription.PENDING_TRANSACTIONS) {\n        return serializePendingTransactionsEvent(event);\n    } else if (event.method === exports.AlchemySubscription.MINED_TRANSACTIONS) {\n        return serializeMinedTransactionsEvent(event);\n    } else {\n        throw new Error(`Unrecognized AlchemyFilterEvent: ${event}`);\n    }\n}\nfunction verifyAlchemyEventName(eventName) {\n    if (!Object.values(exports.AlchemySubscription).includes(eventName.method)) {\n        throw new Error(`Invalid method name ${eventName.method}. Accepted method names: ${Object.values(exports.AlchemySubscription)}`);\n    }\n}\n/**\r\n * Serializes the provided {@link AlchemyPendingTransactionsEventFilter} into an ethers\r\n * compatible event tag.\r\n *\r\n * For the example event:\r\n * ```\r\n *  {\r\n *     \"method\": \"alchemy_pendingTransactions\",\r\n *     \"fromAddress\": \"0xABC\",\r\n *     \"toAddress\": [\"0xDEF\", \"0xGHI\"],\r\n *     \"hashesOnly: true\r\n *   }\r\n * ```\r\n *\r\n * The resulting serialization is:\r\n * `alchemy_pendingTransactions:0xABC:0xDEF|0xGHI:true`\r\n *\r\n * If a field is omitted, it is replaced with a `*`.\r\n */ function serializePendingTransactionsEvent(event) {\n    const fromAddress = serializeAddressField(event.fromAddress);\n    const toAddress = serializeAddressField(event.toAddress);\n    const hashesOnly = serializeBooleanField(event.hashesOnly);\n    return ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE + \":\" + fromAddress + \":\" + toAddress + \":\" + hashesOnly;\n}\n/**\r\n * Serializes the provided {@link AlchemyPendingTransactionsEventFilter} into an ethers\r\n * compatible event tag.\r\n *\r\n * For the example event:\r\n * ```\r\n *  {\r\n *     \"method\": \"alchemy_minedTransactions\",\r\n *     \"addresses\": [\r\n *       {\r\n *         from: \"0xABC\"\r\n *       },\r\n *       {\r\n *         to: \"0xDEF\",\r\n *         from: \"0x123\"\r\n *       }\r\n *     ]\r\n *     \"includeRemoved\": false\r\n *     \"hashesOnly: true\r\n *   }\r\n * ```\r\n *\r\n * The resulting serialization is:\r\n * `alchemy_minedTransactions:*,0xABC|0xDEF,0x123:false:true`\r\n *\r\n * If a field is omitted, it is replaced with a `*`.\r\n *\r\n * The `addresses` array is split by the '|' character, and each to/from address\r\n * pair is separated by a ',' character.\r\n *\r\n */ function serializeMinedTransactionsEvent(event) {\n    const addresses = serializeAddressesField(event.addresses);\n    const includeRemoved = serializeBooleanField(event.includeRemoved);\n    const hashesOnly = serializeBooleanField(event.hashesOnly);\n    return ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE + \":\" + addresses + \":\" + includeRemoved + \":\" + hashesOnly;\n}\nfunction serializeAddressesField(addresses) {\n    if (addresses === undefined) {\n        return \"*\";\n    }\n    return addresses.map((filter)=>serializeAddressField(filter.to) + \",\" + serializeAddressField(filter.from)).join(\"|\");\n}\nfunction serializeAddressField(field) {\n    if (field === undefined) {\n        return \"*\";\n    } else if (Array.isArray(field)) {\n        return field.join(\"|\");\n    } else {\n        return field;\n    }\n}\nfunction serializeBooleanField(field) {\n    if (field === undefined) {\n        return \"*\";\n    } else {\n        return field.toString();\n    }\n}\nfunction deserializeTopics(data) {\n    if (data === \"\") {\n        return [];\n    }\n    return data.split(/&/g).map((topic)=>{\n        if (topic === \"\") {\n            return [];\n        }\n        const comps = topic.split(\"|\").map((topic)=>{\n            return topic === \"null\" ? null : topic;\n        });\n        return comps.length === 1 ? comps[0] : comps;\n    });\n}\nfunction deserializeAddressField(data) {\n    if (data === \"\") {\n        return undefined;\n    }\n    const addresses = data.split(\"|\");\n    return addresses.length === 1 ? addresses[0] : addresses;\n}\nfunction deserializeAddressesField(data) {\n    if (data === \"\") {\n        return undefined;\n    }\n    // Perform a cast here since TS doesn't know we're guaranteed a non-empty\n    // array from deserializing.\n    return data.split(\"|\").map((addressStr)=>addressStr.split(\",\")).map((addressPair)=>Object.assign(Object.assign({}, addressPair[0] !== \"*\" && {\n            to: addressPair[0]\n        }), addressPair[1] !== \"*\" && {\n            from: addressPair[1]\n        }));\n}\n/**\r\n * The Websocket namespace contains all subscription related functions that\r\n * allow you to subscribe to events and receive updates as they occur. The\r\n * underlying WebSocket provider has additional logic to handle reconnections\r\n * and automatically backfills missed events.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an Alchemy object\r\n * with `const alchemy = new Alchemy(config)` and then access the core namespace\r\n * via `alchemy.ws`.\r\n */ class WebSocketNamespace {\n    /** @internal */ constructor(config){\n        this.config = config;\n    }\n    /**\r\n     * Adds a listener to be triggered for each {@link eventName} event. Also\r\n     * includes Alchemy's Subscription API events. See {@link AlchemyEventType} for\r\n     * how to use them.\r\n     *\r\n     * @param eventName The event to listen for.\r\n     * @param listener The listener to call when the event is triggered.\r\n     * @public\r\n     */ on(eventName, listener) {\n        void (()=>__awaiter$1(this, void 0, void 0, function*() {\n                const provider = yield this.config.getWebSocketProvider();\n                const processedEvent = yield this._resolveEnsAlchemyEvent(eventName);\n                provider.on(processedEvent, listener);\n            }))();\n        return this;\n    }\n    /**\r\n     * Adds a listener to be triggered for only the next {@link eventName} event,\r\n     * after which it will be removed. Also includes Alchemy's Subscription API\r\n     * events. See {@link AlchemyEventType} for how to use them.\r\n     *\r\n     * @param eventName The event to listen for.\r\n     * @param listener The listener to call when the event is triggered.\r\n     * @public\r\n     */ once(eventName, listener) {\n        void (()=>__awaiter$1(this, void 0, void 0, function*() {\n                const provider = yield this.config.getWebSocketProvider();\n                const processedEvent = yield this._resolveEnsAlchemyEvent(eventName);\n                provider.once(processedEvent, listener);\n            }))();\n        return this;\n    }\n    /**\r\n     * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n     * listener is provided, all listeners for the event will be removed.\r\n     *\r\n     * @param eventName The event to unlisten to.\r\n     * @param listener The listener to remove.\r\n     * @public\r\n     */ off(eventName, listener) {\n        void (()=>__awaiter$1(this, void 0, void 0, function*() {\n                const provider = yield this.config.getWebSocketProvider();\n                const processedEvent = yield this._resolveEnsAlchemyEvent(eventName);\n                return provider.off(processedEvent, listener);\n            }))();\n        return this;\n    }\n    /**\r\n     * Remove all listeners for the provided {@link eventName} event. If no event\r\n     * is provided, all events and their listeners are removed.\r\n     *\r\n     * @param eventName The event to remove all listeners for.\r\n     * @public\r\n     */ removeAllListeners(eventName) {\n        void (()=>__awaiter$1(this, void 0, void 0, function*() {\n                const provider = yield this.config.getWebSocketProvider();\n                const processedEvent = eventName ? yield this._resolveEnsAlchemyEvent(eventName) : undefined;\n                provider.removeAllListeners(processedEvent);\n            }))();\n        return this;\n    }\n    /**\r\n     * Returns the number of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, the total number of listeners for all events is returned.\r\n     *\r\n     * @param eventName The event to get the number of listeners for.\r\n     * @public\r\n     */ listenerCount(eventName) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getWebSocketProvider();\n            const processedEvent = eventName ? yield this._resolveEnsAlchemyEvent(eventName) : undefined;\n            return provider.listenerCount(processedEvent);\n        });\n    }\n    /**\r\n     * Returns an array of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, all listeners will be included.\r\n     *\r\n     * @param eventName The event to get the listeners for.\r\n     */ listeners(eventName) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getWebSocketProvider();\n            const processedEvent = eventName ? yield this._resolveEnsAlchemyEvent(eventName) : undefined;\n            return provider.listeners(processedEvent);\n        });\n    }\n    /**\r\n     * Converts ENS addresses in an Alchemy Event to the underlying resolved\r\n     * address.\r\n     *\r\n     * VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */ _resolveEnsAlchemyEvent(eventName) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            if (!isAlchemyEvent(eventName)) {\n                return eventName;\n            }\n            if (eventName.method === exports.AlchemySubscription.MINED_TRANSACTIONS && eventName.addresses) {\n                const processedAddresses = [];\n                for (const address of eventName.addresses){\n                    if (address.to) {\n                        address.to = yield this._resolveNameOrError(address.to);\n                    }\n                    if (address.from) {\n                        address.from = yield this._resolveNameOrError(address.from);\n                    }\n                    processedAddresses.push(address);\n                }\n                eventName.addresses = processedAddresses;\n            } else if (eventName.method === exports.AlchemySubscription.PENDING_TRANSACTIONS) {\n                if (eventName.fromAddress) {\n                    if (typeof eventName.fromAddress === \"string\") {\n                        eventName.fromAddress = yield this._resolveNameOrError(eventName.fromAddress);\n                    } else {\n                        eventName.fromAddress = yield Promise.all(eventName.fromAddress.map((address)=>this._resolveNameOrError(address)));\n                    }\n                }\n                if (eventName.toAddress) {\n                    if (typeof eventName.toAddress === \"string\") {\n                        eventName.toAddress = yield this._resolveNameOrError(eventName.toAddress);\n                    } else {\n                        eventName.toAddress = yield Promise.all(eventName.toAddress.map((address)=>this._resolveNameOrError(address)));\n                    }\n                }\n            }\n            return eventName;\n        });\n    }\n    /**\r\n     * Converts the provided ENS address or throws an error. This improves code\r\n     * readability and type safety in other methods.\r\n     *\r\n     * VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */ _resolveNameOrError(name) {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            const provider = yield this.config.getProvider();\n            const resolved = yield provider.resolveName(name);\n            if (resolved === null) {\n                throw new Error(`Unable to resolve the ENS address: ${name}`);\n            }\n            return resolved;\n        });\n    }\n}\n/**\r\n * The Alchemy SDK client. This class is the main entry point into Alchemy's\r\n * APIs and separates functionality into different namespaces.\r\n *\r\n * Each SDK instance is associated with a specific network and API key. To use a\r\n * different network or API key, create a new instance of {@link Alchemy}.\r\n *\r\n * @public\r\n */ class Alchemy {\n    /**\r\n     * @param {string} [settings.apiKey] - The API key to use for Alchemy\r\n     * @param {Network} [settings.network] - The network to use for Alchemy\r\n     * @param {number} [settings.maxRetries] - The maximum number of retries to attempt\r\n     * @param {number} [settings.requestTimeout] - The timeout after which request should fail\r\n     * @public\r\n     */ constructor(settings){\n        this.config = new AlchemyConfig(settings);\n        this.core = new CoreNamespace(this.config);\n        this.nft = new NftNamespace(this.config);\n        this.ws = new WebSocketNamespace(this.config);\n        this.transact = new TransactNamespace(this.config);\n        this.notify = new NotifyNamespace(this.config);\n        this.debug = new DebugNamespace(this.config);\n    }\n}\n/**\r\n * The Wallet class inherits Signer and can sign transactions and messages using\r\n * a private key as a standard Externally Owned Account (EOA).\r\n *\r\n * SDK's custom implementation of Ethers.js's 'Wallet'.\r\n *\r\n * Primary difference from Ethers.js 'Wallet' is that you can pass in either a\r\n * Provider or an Alchemy object. This implementation will intelligently detect\r\n * the format and set the provider accordingly.\r\n *\r\n * @public\r\n * @override\r\n */ class Wallet extends wallet.Wallet {\n    /**\r\n     * Overload permits users to pass in either a standard Provider or an Alchemy\r\n     * object. The constructor will detect the object type and handle appropriately.\r\n     *\r\n     * @override\r\n     */ constructor(privateKey, alchemyOrProvider){\n        // If object passed in is a provider, send to super\n        let superProvider;\n        if (alchemyOrProvider && abstractProvider.Provider.isProvider(alchemyOrProvider)) {\n            superProvider = alchemyOrProvider;\n        }\n        super(privateKey, superProvider);\n        // If object passed in is an Alchemy object, just set Alchemy\n        if (alchemyOrProvider && !abstractProvider.Provider.isProvider(alchemyOrProvider)) {\n            this.alchemyProviderPromise = alchemyOrProvider.config.getProvider();\n        }\n    }\n    //////////////////////////////////////////////////////////////////\n    // Set of overrides from Signer to handle async provider retrieval.\n    //////////////////////////////////////////////////////////////////\n    /**\r\n     * Returns the balance of this wallet at blockTag.\r\n     *\r\n     * @param blockTag The block to check the balance of\r\n     * @override\r\n     */ getBalance(blockTag) {\n        return this.getWallet().then((wallet)=>wallet.getBalance(blockTag));\n    }\n    /**\r\n     * Returns the number of transactions this account has ever sent. This is the\r\n     * value required to be included in transactions as the nonce.\r\n     *\r\n     * @param blockTag The block to check the transaction count on\r\n     * @override\r\n     */ getTransactionCount(blockTag) {\n        return this.getWallet().then((wallet)=>wallet.getTransactionCount(blockTag));\n    }\n    /**\r\n     * Returns the result of estimating the cost to send the transactionRequest,\r\n     * with this account address being used as the from field.\r\n     *\r\n     * @param transaction Transaction to estimate the gas on\r\n     * @override\r\n     */ estimateGas(transaction) {\n        return this.getWallet().then((wallet)=>wallet.estimateGas(transaction));\n    }\n    /**\r\n     * Returns the result of calling using the transactionRequest, with this\r\n     * account address being used as the from field.\r\n     *\r\n     * @param transaction To make a call on\r\n     * @param blockTag The block to make the call on\r\n     * @override\r\n     */ call(transaction, blockTag) {\n        return this.getWallet().then((wallet)=>wallet.call(transaction, blockTag));\n    }\n    /**\r\n     * Populates ALL keys for a transaction and checks that `from` matches this\r\n     * `Signer`. Resolves ENS names and populates fields like `gasPrice`, `gasLimit`,\r\n     * `nonce`, and `chainId` if they are not provided.\r\n     *\r\n     * @param transaction The transaction to populate.\r\n     * @override\r\n     */ populateTransaction(transaction) {\n        return this.getWallet().then((wallet)=>wallet.populateTransaction(transaction));\n    }\n    /**\r\n     * Populates all fields in a transaction, signs it and sends it to the network\r\n     *\r\n     * @param transaction The transaction to send.\r\n     * @override\r\n     */ sendTransaction(transaction) {\n        return this.getWallet().then((wallet)=>wallet.sendTransaction(transaction));\n    }\n    /**\r\n     * Returns the chain ID this wallet is connected to.\r\n     *\r\n     * @override\r\n     */ getChainId() {\n        return this.getWallet().then((wallet)=>wallet.getChainId());\n    }\n    /**\r\n     * Returns the current gas price.\r\n     *\r\n     * @override\r\n     */ getGasPrice() {\n        return this.getWallet().then((wallet)=>wallet.getGasPrice());\n    }\n    /**\r\n     * Returns the current recommended FeeData to use in a transaction.\r\n     *\r\n     * For an EIP-1559 transaction, the maxFeePerGas and maxPriorityFeePerGas\r\n     * should be used.\r\n     *\r\n     * For legacy transactions and networks which do not support EIP-1559, the\r\n     * gasPrice should be used.\r\n     *\r\n     * @override\r\n     */ getFeeData() {\n        return this.getWallet().then((wallet)=>wallet.getFeeData());\n    }\n    /**\r\n     * Looks up the address of name. If the name is not owned, or does not have a\r\n     * Resolver configured, or the Resolver does not have an address configured,\r\n     * null is returned.\r\n     *\r\n     * @param name Name of the ENS address\r\n     * @override\r\n     */ resolveName(name) {\n        return this.getWallet().then((wallet)=>wallet.resolveName(name));\n    }\n    getWallet() {\n        return __awaiter$1(this, void 0, void 0, function*() {\n            if (!this.alchemyProviderPromise) {\n                return this.connect(this.provider);\n            }\n            return this.connect((yield this.alchemyProviderPromise));\n        });\n    }\n}\n/**\r\n * The Contract class is a wrapper around the Contract class from ethers.js and\r\n * is exported here for convenience.\r\n *\r\n * @public\r\n */ // TODO: support passing in Alchemy instance into the contract.\nclass Contract extends contracts.Contract {\n}\n/**\r\n * The ContractFactory class is a wrapper around the ContractFactory class from\r\n * ethers.js and is exported here for convenience.\r\n *\r\n * @public\r\n */ class ContractFactory extends contracts.ContractFactory {\n}\nexports.ALCHEMY_EVENT_TYPES = ALCHEMY_EVENT_TYPES;\nexports.ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE = ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE;\nexports.ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE = ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE;\nexports.Alchemy = Alchemy;\nexports.Contract = Contract;\nexports.ContractFactory = ContractFactory;\nexports.CustomNetworks = CustomNetworks;\nexports.DEFAULT_ALCHEMY_API_KEY = DEFAULT_ALCHEMY_API_KEY;\nexports.DEFAULT_NETWORK = DEFAULT_NETWORK;\nexports.EthersEvent = EthersEvent;\nexports.EthersNetwork = EthersNetwork;\nexports.IS_BROWSER = IS_BROWSER;\nexports.VERSION = VERSION;\nexports.Wallet = Wallet;\nexports.__awaiter = __awaiter$1;\nexports.deepCopy = deepCopy;\nexports.fromHex = fromHex;\nexports.getAlchemyEventTag = getAlchemyEventTag;\nexports.getAlchemyHttpUrl = getAlchemyHttpUrl;\nexports.getAlchemyWsUrl = getAlchemyWsUrl;\nexports.isAlchemyEvent = isAlchemyEvent;\nexports.isHex = isHex;\nexports.logWarn = logWarn;\nexports.noop = noop;\nexports.setLogLevel = setLogLevel;\nexports.toHex = toHex;\nexports.verifyAlchemyEventName = verifyAlchemyEventName; //# sourceMappingURL=index-b1f4a2d9.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9janMvaW5kZXgtYjFmNGEyZDkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQixJQUFJQyxZQUFZRCxtQkFBT0EsQ0FBQztBQUN4QixJQUFJRSxRQUFRRixtQkFBT0EsQ0FBQztBQUNwQixJQUFJRyxtQkFBbUJILG1CQUFPQSxDQUFDO0FBQy9CLElBQUlJLFNBQVNKLG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlLLFlBQVlMLG1CQUFPQSxDQUFDO0FBRXhCLFNBQVNNLHNCQUF1QkMsQ0FBQztJQUFJLE9BQU9BLEtBQUssT0FBT0EsTUFBTSxZQUFZLGFBQWFBLElBQUlBLElBQUk7UUFBRSxXQUFXQTtJQUFFO0FBQUc7QUFFakgsSUFBSUMsaUJBQWlCLFdBQVcsR0FBRUYsc0JBQXNCSjtBQUV4RDs7Ozs7OztDQU9DLEdBQ0RPLGVBQWUsR0FBRyxLQUFLO0FBQ3RCLFVBQVVDLE9BQU87SUFDZEEsT0FBTyxDQUFDLGNBQWMsR0FBRztJQUN6QkEsT0FBTyxDQUFDLGFBQWEsR0FBRztJQUN4QkEsT0FBTyxDQUFDLGNBQWMsR0FBRztJQUN6QkEsT0FBTyxDQUFDLGNBQWMsR0FBRztJQUN6QkEsT0FBTyxDQUFDLGFBQWEsR0FBRztJQUN4QkEsT0FBTyxDQUFDLGNBQWMsR0FBRztJQUN6QkEsT0FBTyxDQUFDLGNBQWMsR0FBRztJQUN6QkEsT0FBTyxDQUFDLGFBQWEsR0FBRztJQUN4QkEsT0FBTyxDQUFDLGNBQWMsR0FBRztJQUN6QkEsT0FBTyxDQUFDLGdCQUFnQixHQUFHO0lBQzNCQSxPQUFPLENBQUMsZUFBZSxHQUFHO0lBQzFCQSxPQUFPLENBQUMsZ0JBQWdCLEdBQUc7SUFDM0JBLE9BQU8sQ0FBQyx1QkFBdUIsR0FBRztJQUNsQ0EsT0FBTyxDQUFDLHVCQUF1QixHQUFHO0lBQ2xDQSxPQUFPLENBQUMsZUFBZSxHQUFHO0lBQzFCQSxPQUFPLENBQUMsY0FB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akMsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9hbGNoZW15LXNkay9kaXN0L2Nqcy9pbmRleC1iMWY0YTJkOS5qcz9hN2NkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9hcGkvdXRpbHMnKTtcbnZhciBiaWdudW1iZXIgPSByZXF1aXJlKCdAZXRoZXJzcHJvamVjdC9iaWdudW1iZXInKTtcbnZhciBheGlvcyA9IHJlcXVpcmUoJ2F4aW9zJyk7XG52YXIgYWJzdHJhY3RQcm92aWRlciA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyJyk7XG52YXIgd2FsbGV0ID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3Qvd2FsbGV0Jyk7XG52YXIgY29udHJhY3RzID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvY29udHJhY3RzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdExlZ2FjeSAoZSkgeyByZXR1cm4gZSAmJiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGUgPyBlIDogeyAnZGVmYXVsdCc6IGUgfTsgfVxuXG52YXIgYXhpb3NfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KGF4aW9zKTtcblxuLyoqXHJcbiAqIFRoZSBzdXBwb3J0ZWQgbmV0d29ya3MgYnkgQWxjaGVteS4gTm90ZSB0aGF0IHNvbWUgZnVuY3Rpb25zIGFyZSBub3QgYXZhaWxhYmxlXHJcbiAqIG9uIGFsbCBuZXR3b3Jrcy4gUGxlYXNlIHJlZmVyIHRvIHRoZSBBbGNoZW15IGRvY3VtZW50YXRpb24gZm9yIHdoaWNoIEFQSXMgYXJlXHJcbiAqIGF2YWlsYWJsZSBvbiB3aGljaCBuZXR3b3Jrc1xyXG4gKiB7QGxpbmsgaHR0cHM6Ly9kb2NzLmFsY2hlbXkuY29tL2FsY2hlbXkvYXBpcy9mZWF0dXJlLXN1cHBvcnQtYnktY2hhaW59XHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydHMuTmV0d29yayA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChOZXR3b3JrKSB7XHJcbiAgICBOZXR3b3JrW1wiRVRIX01BSU5ORVRcIl0gPSBcImV0aC1tYWlubmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiRVRIX0dPRVJMSVwiXSA9IFwiZXRoLWdvZXJsaVwiO1xyXG4gICAgTmV0d29ya1tcIkVUSF9TRVBPTElBXCJdID0gXCJldGgtc2Vwb2xpYVwiO1xyXG4gICAgTmV0d29ya1tcIk9QVF9NQUlOTkVUXCJdID0gXCJvcHQtbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIk9QVF9HT0VSTElcIl0gPSBcIm9wdC1nb2VybGlcIjtcclxuICAgIE5ldHdvcmtbXCJPUFRfU0VQT0xJQVwiXSA9IFwib3B0LXNlcG9saWFcIjtcclxuICAgIE5ldHdvcmtbXCJBUkJfTUFJTk5FVFwiXSA9IFwiYXJiLW1haW5uZXRcIjtcclxuICAgIE5ldHdvcmtbXCJBUkJfR09FUkxJXCJdID0gXCJhcmItZ29lcmxpXCI7XHJcbiAgICBOZXR3b3JrW1wiQVJCX1NFUE9MSUFcIl0gPSBcImFyYi1zZXBvbGlhXCI7XHJcbiAgICBOZXR3b3JrW1wiTUFUSUNfTUFJTk5FVFwiXSA9IFwicG9seWdvbi1tYWlubmV0XCI7XHJcbiAgICBOZXR3b3JrW1wiTUFUSUNfTVVNQkFJXCJdID0gXCJwb2x5Z29uLW11bWJhaVwiO1xyXG4gICAgTmV0d29ya1tcIkFTVEFSX01BSU5ORVRcIl0gPSBcImFzdGFyLW1haW5uZXRcIjtcclxuICAgIE5ldHdvcmtbXCJQT0xZR09OWktFVk1fTUFJTk5FVFwiXSA9IFwicG9seWdvbnprZXZtLW1haW5uZXRcIjtcclxuICAgIE5ldHdvcmtbXCJQT0xZR09OWktFVk1fVEVTVE5FVFwiXSA9IFwicG9seWdvbnprZXZtLXRlc3RuZXRcIjtcclxuICAgIE5ldHdvcmtbXCJCQVNFX01BSU5ORVRcIl0gPSBcImJhc2UtbWFpbm5ldFwiO1xyXG4gICAgTmV0d29ya1tcIkJBU0VfR09FUkxJXCJdID0gXCJiYXNlLWdvZXJsaVwiO1xyXG4gICAgTmV0d29ya1tcIkJBU0VfU0VQT0xJQVwiXSA9IFwiYmFzZS1zZXBvbGlhXCI7XHJcbn0pKGV4cG9ydHMuTmV0d29yayB8fCAoZXhwb3J0cy5OZXR3b3JrID0ge30pKTtcclxuLyoqIFRva2VuIFR5cGVzIGZvciB0aGUgYGdldFRva2VuQmFsYW5jZXMoKWAgZW5kcG9pbnQuICovXHJcbmV4cG9ydHMuVG9rZW5CYWxhbmNlVHlwZSA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChUb2tlbkJhbGFuY2VUeXBlKSB7XHJcbiAgICAvKipcclxuICAgICAqIE9wdGlvbiB0byBmZXRjaCB0aGUgdG9wIDEwMCB0b2tlbnMgYnkgMjQtaG91ciB2b2x1bWUuIFRoaXMgb3B0aW9uIGlzIG9ubHlcclxuICAgICAqIGF2YWlsYWJsZSBvbiBNYWlubmV0IGluIEV0aGVyZXVtLCBQb2x5Z29uLCBhbmQgQXJiaXRydW0uXHJcbiAgICAgKi9cclxuICAgIFRva2VuQmFsYW5jZVR5cGVbXCJERUZBVUxUX1RPS0VOU1wiXSA9IFwiREVGQVVMVF9UT0tFTlNcIjtcclxuICAgIC8qKlxyXG4gICAgICogT3B0aW9uIHRvIGZldGNoIHRoZSBzZXQgb2YgRVJDLTIwIHRva2VucyB0aGF0IHRoZSBhZGRyZXNzIGFzIGV2ZXIgaGVsZC4gaGlzXHJcbiAgICAgKiBsaXN0IGlzIHByb2R1Y2VkIGJ5IGFuIGFkZHJlc3MncyBoaXN0b3JpY2FsIHRyYW5zZmVyIGFjdGl2aXR5IGFuZCBpbmNsdWRlc1xyXG4gICAgICogYWxsIHRva2VucyB0aGF0IHRoZSBhZGRyZXNzIGhhcyBldmVyIHJlY2VpdmVkLlxyXG4gICAgICovXHJcbiAgICBUb2tlbkJhbGFuY2VUeXBlW1wiRVJDMjBcIl0gPSBcImVyYzIwXCI7XHJcbn0pKGV4cG9ydHMuVG9rZW5CYWxhbmNlVHlwZSB8fCAoZXhwb3J0cy5Ub2tlbkJhbGFuY2VUeXBlID0ge30pKTtcclxuLyoqXHJcbiAqIENhdGVnb3JpZXMgb2YgdHJhbnNmZXJzIHRvIHVzZSB3aXRoIHRoZSB7QGxpbmsgQXNzZXRUcmFuc2ZlcnNQYXJhbXN9IHJlcXVlc3RcclxuICogb2JqZWN0IHdoZW4gdXNpbmcge0BsaW5rIENvcmVOYW1lc3BhY2UuZ2V0QXNzZXRUcmFuc2ZlcnN9LlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnRzLkFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnkgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUb3AgbGV2ZWwgRVRIIHRyYW5zYWN0aW9ucyB0aGF0IG9jY3VyIHdoZXJlIHRoZSBgZnJvbUFkZHJlc3NgIGlzIGFuXHJcbiAgICAgKiBleHRlcm5hbCB1c2VyLWNyZWF0ZWQgYWRkcmVzcy4gRXh0ZXJuYWwgYWRkcmVzc2VzIGhhdmUgcHJpdmF0ZSBrZXlzIGFuZCBhcmVcclxuICAgICAqIGFjY2Vzc2VkIGJ5IHVzZXJzLlxyXG4gICAgICovXHJcbiAgICBBc3NldFRyYW5zZmVyc0NhdGVnb3J5W1wiRVhURVJOQUxcIl0gPSBcImV4dGVybmFsXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRvcCBsZXZlbCBFVEggdHJhbnNhY3Rpb25zIHRoYXQgb2NjdXIgd2hlcmUgdGhlIGBmcm9tQWRkcmVzc2AgaXMgYW5cclxuICAgICAqIGludGVybmFsLCBzbWFydCBjb250cmFjdCBhZGRyZXNzLiBGb3IgZXhhbXBsZSwgYSBzbWFydCBjb250cmFjdCBjYWxsaW5nXHJcbiAgICAgKiBhbm90aGVyIHNtYXJ0IGNvbnRyYWN0IG9yIHNlbmRpbmdcclxuICAgICAqL1xyXG4gICAgQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeVtcIklOVEVSTkFMXCJdID0gXCJpbnRlcm5hbFwiO1xyXG4gICAgLyoqIEVSQzIwIHRyYW5zZmVycy4gKi9cclxuICAgIEFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnlbXCJFUkMyMFwiXSA9IFwiZXJjMjBcIjtcclxuICAgIC8qKiBFUkM3MjEgdHJhbnNmZXJzLiAqL1xyXG4gICAgQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeVtcIkVSQzcyMVwiXSA9IFwiZXJjNzIxXCI7XHJcbiAgICAvKiogRVJDMTE1NSB0cmFuc2ZlcnMuICovXHJcbiAgICBBc3NldFRyYW5zZmVyc0NhdGVnb3J5W1wiRVJDMTE1NVwiXSA9IFwiZXJjMTE1NVwiO1xyXG4gICAgLyoqIFNwZWNpYWwgY29udHJhY3RzIHRoYXQgZG9uJ3QgZm9sbG93IEVSQyA3MjEvMTE1NSwgKGV4OiBDcnlwdG9LaXR0aWVzKS4gKi9cclxuICAgIEFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnlbXCJTUEVDSUFMTkZUXCJdID0gXCJzcGVjaWFsbmZ0XCI7XHJcbn0pKGV4cG9ydHMuQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeSB8fCAoZXhwb3J0cy5Bc3NldFRyYW5zZmVyc0NhdGVnb3J5ID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSB0eXBlIG9mIHRyYW5zZmVyIGZvciB0aGUgcmVxdWVzdC4gTm90ZSB0aGF0IHVzaW5nIGBUT2Agd2lsbCBhbHNvIGluY2x1ZGVcclxuICogTkZUcyB0aGF0IHdlcmUgbWludGVkIGJ5IHRoZSBvd25lci5cclxuICovXHJcbmV4cG9ydHMuR2V0VHJhbnNmZXJzRm9yT3duZXJUcmFuc2ZlclR5cGUgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoR2V0VHJhbnNmZXJzRm9yT3duZXJUcmFuc2ZlclR5cGUpIHtcclxuICAgIEdldFRyYW5zZmVyc0Zvck93bmVyVHJhbnNmZXJUeXBlW1wiVE9cIl0gPSBcIlRPXCI7XHJcbiAgICBHZXRUcmFuc2ZlcnNGb3JPd25lclRyYW5zZmVyVHlwZVtcIkZST01cIl0gPSBcIkZST01cIjtcclxufSkoZXhwb3J0cy5HZXRUcmFuc2ZlcnNGb3JPd25lclRyYW5zZmVyVHlwZSB8fCAoZXhwb3J0cy5HZXRUcmFuc2ZlcnNGb3JPd25lclRyYW5zZmVyVHlwZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBFbnVtIGZvciByZXByZXNlbnRpbmcgdGhlIHN1cHBvcnRlZCBzb3J0aW5nIG9yZGVycyBvZiB0aGUgQVBJLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnRzLlNvcnRpbmdPcmRlciA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChTb3J0aW5nT3JkZXIpIHtcclxuICAgIFNvcnRpbmdPcmRlcltcIkFTQ0VORElOR1wiXSA9IFwiYXNjXCI7XHJcbiAgICBTb3J0aW5nT3JkZXJbXCJERVNDRU5ESU5HXCJdID0gXCJkZXNjXCI7XHJcbn0pKGV4cG9ydHMuU29ydGluZ09yZGVyIHx8IChleHBvcnRzLlNvcnRpbmdPcmRlciA9IHt9KSk7XHJcbi8qKiBBbiBPcGVuU2VhIGNvbGxlY3Rpb24ncyBhcHByb3ZhbCBzdGF0dXMuICovXHJcbmV4cG9ydHMuT3BlblNlYVNhZmVsaXN0UmVxdWVzdFN0YXR1cyA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChPcGVuU2VhU2FmZWxpc3RSZXF1ZXN0U3RhdHVzKSB7XHJcbiAgICAvKiogVmVyaWZpZWQgY29sbGVjdGlvbi4gKi9cclxuICAgIE9wZW5TZWFTYWZlbGlzdFJlcXVlc3RTdGF0dXNbXCJWRVJJRklFRFwiXSA9IFwidmVyaWZpZWRcIjtcclxuICAgIC8qKiBDb2xsZWN0aW9ucyB0aGF0IGFyZSBhcHByb3ZlZCBvbiBvcGVuIHNlYSBhbmQgY2FuIGJlIGZvdW5kIGluIHNlYXJjaCByZXN1bHRzLiAqL1xyXG4gICAgT3BlblNlYVNhZmVsaXN0UmVxdWVzdFN0YXR1c1tcIkFQUFJPVkVEXCJdID0gXCJhcHByb3ZlZFwiO1xyXG4gICAgLyoqIENvbGxlY3Rpb25zIHRoYXQgcmVxdWVzdGVkIHNhZmVsaXN0aW5nIG9uIE9wZW5TZWEuICovXHJcbiAgICBPcGVuU2VhU2FmZWxpc3RSZXF1ZXN0U3RhdHVzW1wiUkVRVUVTVEVEXCJdID0gXCJyZXF1ZXN0ZWRcIjtcclxuICAgIC8qKiBCcmFuZCBuZXcgY29sbGVjdGlvbnMuICovXHJcbiAgICBPcGVuU2VhU2FmZWxpc3RSZXF1ZXN0U3RhdHVzW1wiTk9UX1JFUVVFU1RFRFwiXSA9IFwibm90X3JlcXVlc3RlZFwiO1xyXG59KShleHBvcnRzLk9wZW5TZWFTYWZlbGlzdFJlcXVlc3RTdGF0dXMgfHwgKGV4cG9ydHMuT3BlblNlYVNhZmVsaXN0UmVxdWVzdFN0YXR1cyA9IHt9KSk7XHJcbi8qKlxyXG4gKiBNZXRob2QgbmFtZXMgZm9yIEFsY2hlbXkncyBjdXN0b20gU3Vic2NyaXB0aW9uIEFQSSBlbmRwb2ludHMuXHJcbiAqXHJcbiAqIFRoaXMgdmFsdWUgaXMgcHJvdmlkZWQgaW4gdGhlIGBtZXRob2RgIGZpZWxkIHdoZW4gY3JlYXRpbmcgYW4gZXZlbnQgZmlsdGVyIG9uXHJcbiAqIHRoZSBXZWJzb2NrZXQgTmFtZXNwYWNlLlxyXG4gKi9cclxuZXhwb3J0cy5BbGNoZW15U3Vic2NyaXB0aW9uID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKEFsY2hlbXlTdWJzY3JpcHRpb24pIHtcclxuICAgIEFsY2hlbXlTdWJzY3JpcHRpb25bXCJQRU5ESU5HX1RSQU5TQUNUSU9OU1wiXSA9IFwiYWxjaGVteV9wZW5kaW5nVHJhbnNhY3Rpb25zXCI7XHJcbiAgICBBbGNoZW15U3Vic2NyaXB0aW9uW1wiTUlORURfVFJBTlNBQ1RJT05TXCJdID0gXCJhbGNoZW15X21pbmVkVHJhbnNhY3Rpb25zXCI7XHJcbn0pKGV4cG9ydHMuQWxjaGVteVN1YnNjcmlwdGlvbiB8fCAoZXhwb3J0cy5BbGNoZW15U3Vic2NyaXB0aW9uID0ge30pKTtcclxuLyoqXHJcbiAqIEFzc2V0IHR5cGUgcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHtAbGluayBUcmFuc2FjdE5hbWVzcGFjZS5zaW11bGF0ZUFzc2V0Q2hhbmdlc30uXHJcbiAqIEFsbG93cyB5b3UgdG8gZGV0ZXJtaW5lIGlmIHRoZSBhc3NldHMgYXBwcm92ZWQgb3IgLyBhbmQgdHJhbnNmZXJyZWQgYXJlXHJcbiAqIG5hdGl2ZSwgdG9rZW5zIG9yIE5GVHMuXHJcbiAqL1xyXG5leHBvcnRzLlNpbXVsYXRlQXNzZXRUeXBlID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKFNpbXVsYXRlQXNzZXRUeXBlKSB7XHJcbiAgICAvKipcclxuICAgICAqIE5hdGl2ZSB0cmFuc2ZlcnMgdGhhdCBpbnZvbHZlIHRoZSBjdXJyZW5jeSBvZiB0aGUgY2hhaW4gdGhlIHNpbXVsYXRpb24gaXNcclxuICAgICAqIHJ1biBvbiAoZXg6IEVUSCBmb3IgRXRoZXJldW0sIE1BVElDIGZvciBQb2x5Z29uLCBFVEggZm9yIEFyYml0cnVtKS5cclxuICAgICAqL1xyXG4gICAgU2ltdWxhdGVBc3NldFR5cGVbXCJOQVRJVkVcIl0gPSBcIk5BVElWRVwiO1xyXG4gICAgLyoqIEVSQzIwIGFwcHJvdmFsIG9yIHRyYW5zZmVycy4gKi9cclxuICAgIFNpbXVsYXRlQXNzZXRUeXBlW1wiRVJDMjBcIl0gPSBcIkVSQzIwXCI7XHJcbiAgICAvKiogRVJDNzIxIGFwcHJvdmFsIG9yIHRyYW5zZmVycy4gKi9cclxuICAgIFNpbXVsYXRlQXNzZXRUeXBlW1wiRVJDNzIxXCJdID0gXCJFUkM3MjFcIjtcclxuICAgIC8qKiBFUkMxMTU1IGFwcHJvdmFsIG9yIHRyYW5zZmVycy4gKi9cclxuICAgIFNpbXVsYXRlQXNzZXRUeXBlW1wiRVJDMTE1NVwiXSA9IFwiRVJDMTE1NVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWFsIGNvbnRyYWN0cyB0aGF0IGRvbid0IGZvbGxvdyBFUkMgNzIxLzExNTUuQ3VycmVudGx5IGxpbWl0ZWQgdG9cclxuICAgICAqIENyeXB0b0tpdHRpZXMgYW5kIENyeXB0b1B1bmtzLlxyXG4gICAgICovXHJcbiAgICBTaW11bGF0ZUFzc2V0VHlwZVtcIlNQRUNJQUxfTkZUXCJdID0gXCJTUEVDSUFMX05GVFwiO1xyXG59KShleHBvcnRzLlNpbXVsYXRlQXNzZXRUeXBlIHx8IChleHBvcnRzLlNpbXVsYXRlQXNzZXRUeXBlID0ge30pKTtcclxuLyoqXHJcbiAqIENoYW5nZSB0eXBlIHJldHVybmVkIHdoZW4gY2FsbGluZyB7QGxpbmsgVHJhbnNhY3ROYW1lc3BhY2Uuc2ltdWxhdGVBc3NldENoYW5nZXN9LlxyXG4gKi9cclxuZXhwb3J0cy5TaW11bGF0ZUNoYW5nZVR5cGUgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoU2ltdWxhdGVDaGFuZ2VUeXBlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFJlcHJlc2VudHMgYSB0cmFuc2FjdGlvbiB0aGF0IGFwcHJvdmVkIG9yIGRpc2FwcHJvdmVkIHBlcm1pc3Npb25zIGZvciBhXHJcbiAgICAgKiBjb250cmFjdC5cclxuICAgICAqXHJcbiAgICAgKiBBUFBST1ZFIHdpdGhvdXQgdG9rZW4gSUQg4oaSIGFwcHJvdmUgYWxsIHRva2Vuc1xyXG4gICAgICogQVBQUk9WRSB3aXRob3V0IGFtb3VudCDihpIgYXBwcm92ZSBhbGwgYW1vdW50XHJcbiAgICAgKiBBUFBST1ZFIHdpdGggemVybyBhbW91bnQg4oaSIGFwcHJvdmFsIGJlaW5nIGNsZWFyZWRcclxuICAgICAqL1xyXG4gICAgU2ltdWxhdGVDaGFuZ2VUeXBlW1wiQVBQUk9WRVwiXSA9IFwiQVBQUk9WRVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXByZXNlbnRzIGEgdHJhbnNhY3Rpb24gdGhhdCB0cmFuc2ZlcnJlZCB0b2tlbnMgZnJvbSBvbmUgYWRkcmVzcyB0byBhbm90aGVyLlxyXG4gICAgICovXHJcbiAgICBTaW11bGF0ZUNoYW5nZVR5cGVbXCJUUkFOU0ZFUlwiXSA9IFwiVFJBTlNGRVJcIjtcclxufSkoZXhwb3J0cy5TaW11bGF0ZUNoYW5nZVR5cGUgfHwgKGV4cG9ydHMuU2ltdWxhdGVDaGFuZ2VUeXBlID0ge30pKTtcclxuLyoqXHJcbiAqIEF1dGhvcml0eSB1c2VkIHRvIGRlY29kZSBjYWxscyBhbmQgbG9ncyB3aGVuIHVzaW5nIHRoZVxyXG4gKiB7QGxpbmsgVHJhbnNhY3ROYW1lc3BhY2Uuc2ltdWxhdGVFeGVjdXRpb259IG1ldGhvZC5cclxuICovXHJcbmV4cG9ydHMuRGVjb2RpbmdBdXRob3JpdHkgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoRGVjb2RpbmdBdXRob3JpdHkpIHtcclxuICAgIERlY29kaW5nQXV0aG9yaXR5W1wiRVRIRVJTQ0FOXCJdID0gXCJFVEhFUlNDQU5cIjtcclxufSkoZXhwb3J0cy5EZWNvZGluZ0F1dGhvcml0eSB8fCAoZXhwb3J0cy5EZWNvZGluZ0F1dGhvcml0eSA9IHt9KSk7XHJcbi8qKiBUaGUgdHlwZSBvZiBjYWxsIGluIGEgZGVidWcgY2FsbCB0cmFjZS4gKi9cclxuZXhwb3J0cy5EZWJ1Z0NhbGxUeXBlID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKERlYnVnQ2FsbFR5cGUpIHtcclxuICAgIERlYnVnQ2FsbFR5cGVbXCJDUkVBVEVcIl0gPSBcIkNSRUFURVwiO1xyXG4gICAgRGVidWdDYWxsVHlwZVtcIkNBTExcIl0gPSBcIkNBTExcIjtcclxuICAgIERlYnVnQ2FsbFR5cGVbXCJTVEFUSUNDQUxMXCJdID0gXCJTVEFUSUNDQUxMXCI7XHJcbiAgICBEZWJ1Z0NhbGxUeXBlW1wiREVMRUdBVEVDQUxMXCJdID0gXCJERUxFR0FURUNBTExcIjtcclxufSkoZXhwb3J0cy5EZWJ1Z0NhbGxUeXBlIHx8IChleHBvcnRzLkRlYnVnQ2FsbFR5cGUgPSB7fSkpO1xyXG4vKipcclxuICogUG90ZW50aWFsIHRyYW5zYWN0aW9uIGpvYiBzdGF0dXNlcyBmb3IgYSB7QGxpbmsgR2FzT3B0aW1pemVkVHJhbnNhY3Rpb25SZXNwb25zZX1cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG4vLyBUT0RPKHR4am9iKTogUmVtb3ZlIGludGVybmFsIHRhZyBvbmNlIHRoaXMgZmVhdHVyZSBpcyByZWxlYXNlZC5cclxuZXhwb3J0cy5HYXNPcHRpbWl6ZWRUcmFuc2FjdGlvblN0YXR1cyA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvblN0YXR1cykge1xyXG4gICAgR2FzT3B0aW1pemVkVHJhbnNhY3Rpb25TdGF0dXNbXCJVTlNQRUNJRklFRFwiXSA9IFwiVFJBTlNBQ1RJT05fSk9CX1NUQVRVU19VTlNQRUNJRklFRFwiO1xyXG4gICAgR2FzT3B0aW1pemVkVHJhbnNhY3Rpb25TdGF0dXNbXCJJTl9QUk9HUkVTU1wiXSA9IFwiSU5fUFJPR1JFU1NcIjtcclxuICAgIEdhc09wdGltaXplZFRyYW5zYWN0aW9uU3RhdHVzW1wiQ09NUExFVEVcIl0gPSBcIkNPTVBMRVRFXCI7XHJcbiAgICBHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvblN0YXR1c1tcIkFCQU5ET05FRFwiXSA9IFwiQUJBTkRPTkVEXCI7XHJcbn0pKGV4cG9ydHMuR2FzT3B0aW1pemVkVHJhbnNhY3Rpb25TdGF0dXMgfHwgKGV4cG9ydHMuR2FzT3B0aW1pemVkVHJhbnNhY3Rpb25TdGF0dXMgPSB7fSkpO1xyXG4vKiogVGhlIHZlcnNpb24gb2YgdGhlIHdlYmhvb2suIEFsbCBuZXdseSBjcmVhdGVkIHdlYmhvb2tzIGRlZmF1bHQgdG8gVjIuICovXHJcbmV4cG9ydHMuV2ViaG9va1ZlcnNpb24gPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoV2ViaG9va1ZlcnNpb24pIHtcclxuICAgIFdlYmhvb2tWZXJzaW9uW1wiVjFcIl0gPSBcIlYxXCI7XHJcbiAgICBXZWJob29rVmVyc2lvbltcIlYyXCJdID0gXCJWMlwiO1xyXG59KShleHBvcnRzLldlYmhvb2tWZXJzaW9uIHx8IChleHBvcnRzLldlYmhvb2tWZXJzaW9uID0ge30pKTtcclxuLyoqIFRoZSB0eXBlIG9mIHtAbGluayBXZWJob29rfS4gKi9cclxuZXhwb3J0cy5XZWJob29rVHlwZSA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChXZWJob29rVHlwZSkge1xyXG4gICAgV2ViaG9va1R5cGVbXCJNSU5FRF9UUkFOU0FDVElPTlwiXSA9IFwiTUlORURfVFJBTlNBQ1RJT05cIjtcclxuICAgIFdlYmhvb2tUeXBlW1wiRFJPUFBFRF9UUkFOU0FDVElPTlwiXSA9IFwiRFJPUFBFRF9UUkFOU0FDVElPTlwiO1xyXG4gICAgV2ViaG9va1R5cGVbXCJBRERSRVNTX0FDVElWSVRZXCJdID0gXCJBRERSRVNTX0FDVElWSVRZXCI7XHJcbiAgICBXZWJob29rVHlwZVtcIk5GVF9BQ1RJVklUWVwiXSA9IFwiTkZUX0FDVElWSVRZXCI7XHJcbiAgICBXZWJob29rVHlwZVtcIk5GVF9NRVRBREFUQV9VUERBVEVcIl0gPSBcIk5GVF9NRVRBREFUQV9VUERBVEVcIjtcclxuICAgIFdlYmhvb2tUeXBlW1wiR1JBUEhRTFwiXSA9IFwiR1JBUEhRTFwiO1xyXG59KShleHBvcnRzLldlYmhvb2tUeXBlIHx8IChleHBvcnRzLldlYmhvb2tUeXBlID0ge30pKTtcclxuLyoqXHJcbiAqIENvbW1pdG1lbnQgbGV2ZWwgb2YgdGhlIHRhcmdldCBibG9jayB3aXRoIHVzaW5nIG1ldGhvZHMgaW4gdGhlXHJcbiAqIHtAbGluayBEZWJ1Z05hbWVzcGFjZX1cclxuICovXHJcbmV4cG9ydHMuQ29tbWl0bWVudExldmVsID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKENvbW1pdG1lbnRMZXZlbCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTYW1wbGUgbmV4dCBibG9jayBpbmZlcnJlZCBieSBBbGNoZW15IGJ1aWx0IG9uIHRvcCBvZiB0aGUgbGF0ZXN0IGJsb2NrLlxyXG4gICAgICogVGhpcyBjb250YWlucyB0aGUgc2V0IG9mIHRyYW5zYWN0aW9ucyB0YWtlbiBmcm9tIHRoZSBsb2NhbCBtZW1wb29sIGFuZFxyXG4gICAgICogaXMgYSBwcm94eSBmb3IgYmxvY2tzIHRoYXQgaGF2ZSBub3QgYmVlbiBtaW5lZCB5ZXQuXHJcbiAgICAgKi9cclxuICAgIENvbW1pdG1lbnRMZXZlbFtcIlBFTkRJTkdcIl0gPSBcInBlbmRpbmdcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1vc3QgcmVjZW50IGJsb2NrIGluIHRoZSBjYW5vbmljYWwgY2hhaW4gb2JzZXJ2ZWQgYnkgQWxjaGVteS4gTm90ZSB0aGF0XHJcbiAgICAgKiB0aGlzIGJsb2NrIG1heSBiZSByZS1vcmdlZCBvdXQgb2YgdGhlIGNhbm9uaWNhbCBjaGFpbi5cclxuICAgICAqL1xyXG4gICAgQ29tbWl0bWVudExldmVsW1wiTEFURVNUXCJdID0gXCJsYXRlc3RcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1vc3QgcmVjZW50IGNyeXB0by1lY29ub21pY2FsbHkgc2VjdXJlIGJsb2NrIHRoYXQgY2Fubm90IGJlIHJlLW9yZ2VkXHJcbiAgICAgKiBvdXRzaWRlIG9mIG1hbnVhbCBpbnRlcnZlbnRpb24gZHJpdmVuIGJ5IGNvbW11bml0eSBjb29yZGluYXRpb24uIFRoaXMgaXNcclxuICAgICAqIG9ubHkgYXZhaWxhYmxlIG9uIHtAbGluayBOZXR3b3JrLkVUSF9HT0VSTEl9IGFuZCB7QGxpbmsgTmV0d29yay5FVEhfU0VQT0xJQX0uXHJcbiAgICAgKi9cclxuICAgIENvbW1pdG1lbnRMZXZlbFtcIlNBRkVcIl0gPSBcInNhZmVcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1vc3QgcmVjZW50IHNlY3VyZSBibG9jayB0aGF0IGhhcyBiZWVuIGFjY2VwdGVkIGJ5ID4yLzMgb2YgdmFsaWRhdG9ycy5cclxuICAgICAqIFRoaXMgYmxvY2sgaXMgdmVyeSB1bmxpa2VseSB0byBiZSByZS1vcmdlZC4gVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBvblxyXG4gICAgICoge0BsaW5rIE5ldHdvcmsuRVRIX0dPRVJMSX0gYW5kIHtAbGluayBOZXR3b3JrLkVUSF9TRVBPTElBfS5cclxuICAgICAqL1xyXG4gICAgQ29tbWl0bWVudExldmVsW1wiRklOQUxJWkVEXCJdID0gXCJmaW5hbGl6ZWRcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxvd2VzdCBudW1iZXJlZCBibG9jayBhdmFpbGFibGUgdGhhdCBpcyB1c3VhbGx5IHRoZSBmaXJzdCBibG9jayBjcmVhdGVkLlxyXG4gICAgICovXHJcbiAgICBDb21taXRtZW50TGV2ZWxbXCJFQVJMSUVTVFwiXSA9IFwiZWFybGllc3RcIjtcclxufSkoZXhwb3J0cy5Db21taXRtZW50TGV2ZWwgfHwgKGV4cG9ydHMuQ29tbWl0bWVudExldmVsID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSB0eXBlIG9mIHRyYWNlciB0byB1c2Ugd2hlbiBydW5uaW5nIGRlYnVnIG1ldGhvZHMgaW4gdGhlXHJcbiAqIHtAbGluayBEZWJ1Z05hbWVzcGFjZX0uXHJcbiAqL1xyXG5leHBvcnRzLkRlYnVnVHJhY2VyVHlwZSA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChEZWJ1Z1RyYWNlclR5cGUpIHtcclxuICAgIERlYnVnVHJhY2VyVHlwZVtcIkNBTExfVFJBQ0VSXCJdID0gXCJjYWxsVHJhY2VyXCI7XHJcbiAgICBEZWJ1Z1RyYWNlclR5cGVbXCJQUkVTVEFURV9UUkFDRVJcIl0gPSBcInByZXN0YXRlVHJhY2VyXCI7XHJcbn0pKGV4cG9ydHMuRGVidWdUcmFjZXJUeXBlIHx8IChleHBvcnRzLkRlYnVnVHJhY2VyVHlwZSA9IHt9KSk7XG5cbi8qKlxyXG4gKiBBbiBlbnVtIGZvciBzcGVjaWZ5aW5nIHRoZSB0b2tlbiB0eXBlIG9uIE5GVHMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydHMuTmZ0VG9rZW5UeXBlID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKE5mdFRva2VuVHlwZSkge1xyXG4gICAgTmZ0VG9rZW5UeXBlW1wiRVJDNzIxXCJdID0gXCJFUkM3MjFcIjtcclxuICAgIE5mdFRva2VuVHlwZVtcIkVSQzExNTVcIl0gPSBcIkVSQzExNTVcIjtcclxuICAgIE5mdFRva2VuVHlwZVtcIk5PX1NVUFBPUlRFRF9ORlRfU1RBTkRBUkRcIl0gPSBcIk5PX1NVUFBPUlRFRF9ORlRfU1RBTkRBUkRcIjtcclxuICAgIE5mdFRva2VuVHlwZVtcIk5PVF9BX0NPTlRSQUNUXCJdID0gXCJOT1RfQV9DT05UUkFDVFwiO1xyXG4gICAgTmZ0VG9rZW5UeXBlW1wiVU5LTk9XTlwiXSA9IFwiVU5LTk9XTlwiO1xyXG59KShleHBvcnRzLk5mdFRva2VuVHlwZSB8fCAoZXhwb3J0cy5OZnRUb2tlblR5cGUgPSB7fSkpO1xyXG4vKiogUG90ZW50aWFsIHJlYXNvbnMgd2h5IGFuIE5GVCBjb250cmFjdCB3YXMgY2xhc3NpZmllZCBhcyBzcGFtLiAqL1xyXG5leHBvcnRzLk5mdFNwYW1DbGFzc2lmaWNhdGlvbiA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChOZnRTcGFtQ2xhc3NpZmljYXRpb24pIHtcclxuICAgIE5mdFNwYW1DbGFzc2lmaWNhdGlvbltcIkVyYzcyMVRvb01hbnlPd25lcnNcIl0gPSBcIkVyYzcyMVRvb01hbnlPd25lcnNcIjtcclxuICAgIE5mdFNwYW1DbGFzc2lmaWNhdGlvbltcIkVyYzcyMVRvb01hbnlUb2tlbnNcIl0gPSBcIkVyYzcyMVRvb01hbnlUb2tlbnNcIjtcclxuICAgIE5mdFNwYW1DbGFzc2lmaWNhdGlvbltcIkVyYzcyMURpc2hvbmVzdFRvdGFsU3VwcGx5XCJdID0gXCJFcmM3MjFEaXNob25lc3RUb3RhbFN1cHBseVwiO1xyXG4gICAgTmZ0U3BhbUNsYXNzaWZpY2F0aW9uW1wiTW9zdGx5SG9uZXlQb3RPd25lcnNcIl0gPSBcIk1vc3RseUhvbmV5UG90T3duZXJzXCI7XHJcbiAgICBOZnRTcGFtQ2xhc3NpZmljYXRpb25bXCJPd25lZEJ5TW9zdEhvbmV5UG90c1wiXSA9IFwiT3duZWRCeU1vc3RIb25leVBvdHNcIjtcclxuICAgIE5mdFNwYW1DbGFzc2lmaWNhdGlvbltcIkxvd0Rpc3RpbmN0T3duZXJzUGVyY2VudFwiXSA9IFwiTG93RGlzdGluY3RPd25lcnNQZXJjZW50XCI7XHJcbiAgICBOZnRTcGFtQ2xhc3NpZmljYXRpb25bXCJIaWdoSG9uZXlQb3RPd25lclBlcmNlbnRcIl0gPSBcIkhpZ2hIb25leVBvdE93bmVyUGVyY2VudFwiO1xyXG4gICAgTmZ0U3BhbUNsYXNzaWZpY2F0aW9uW1wiSGlnaEhvbmV5UG90UGVyY2VudFwiXSA9IFwiSGlnaEhvbmV5UG90UGVyY2VudFwiO1xyXG4gICAgTmZ0U3BhbUNsYXNzaWZpY2F0aW9uW1wiSG9uZXlQb3RzT3duTXVsdGlwbGVUb2tlbnNcIl0gPSBcIkhvbmV5UG90c093bk11bHRpcGxlVG9rZW5zXCI7XHJcbiAgICBOZnRTcGFtQ2xhc3NpZmljYXRpb25bXCJOb1NhbGVzQWN0aXZpdHlcIl0gPSBcIk5vU2FsZXNBY3Rpdml0eVwiO1xyXG4gICAgTmZ0U3BhbUNsYXNzaWZpY2F0aW9uW1wiSGlnaEFpcmRyb3BQZXJjZW50XCJdID0gXCJIaWdoQWlyZHJvcFBlcmNlbnRcIjtcclxuICAgIE5mdFNwYW1DbGFzc2lmaWNhdGlvbltcIlVua25vd25cIl0gPSBcIlVua25vd25cIjtcclxufSkoZXhwb3J0cy5OZnRTcGFtQ2xhc3NpZmljYXRpb24gfHwgKGV4cG9ydHMuTmZ0U3BhbUNsYXNzaWZpY2F0aW9uID0ge30pKTtcclxuLyoqXHJcbiAqIEVudW0gb2YgTkZUIGZpbHRlcnMgdGhhdCBjYW4gYmUgYXBwbGllZCB0byBhIHtAbGluayBnZXROZnRzRm9yT3duZXJ9IG9yIGFcclxuICoge0BsaW5rIGdldENvbnRyYWN0c0Zvck93bmVyfSByZXF1ZXN0LlxyXG4gKlxyXG4gKiBAYmV0YVxyXG4gKi9cclxuZXhwb3J0cy5OZnRGaWx0ZXJzID0gdm9pZCAwO1xyXG4oZnVuY3Rpb24gKE5mdEZpbHRlcnMpIHtcclxuICAgIC8qKiBORlRzIHRoYXQgaGF2ZSBiZWVuIGNsYXNzaWZpZWQgYXMgc3BhbS4gKi9cclxuICAgIE5mdEZpbHRlcnNbXCJTUEFNXCJdID0gXCJTUEFNXCI7XHJcbiAgICAvKiogTkZUcyB0aGF0IGhhdmUgYmVlbiBhaXJkcm9wcGVkIHRvIGEgdXNlci4gKi9cclxuICAgIE5mdEZpbHRlcnNbXCJBSVJEUk9QU1wiXSA9IFwiQUlSRFJPUFNcIjtcclxufSkoZXhwb3J0cy5OZnRGaWx0ZXJzIHx8IChleHBvcnRzLk5mdEZpbHRlcnMgPSB7fSkpO1xyXG4vKipcclxuICogRW51bSBvZiBvcmRlcmluZyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIGEge0BsaW5rIGdldE5mdHNGb3JPd25lcn0gb3IgYVxyXG4gKiB7QGxpbmsgZ2V0Q29udHJhY3RzRm9yT3duZXJ9IHJlc3BvbnNlLlxyXG4gKlxyXG4gKiBAYmV0YVxyXG4gKi9cclxuZXhwb3J0cy5OZnRPcmRlcmluZyA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChOZnRPcmRlcmluZykge1xyXG4gICAgTmZ0T3JkZXJpbmdbXCJUUkFOU0ZFUlRJTUVcIl0gPSBcIlRSQU5TRkVSVElNRVwiO1xyXG59KShleHBvcnRzLk5mdE9yZGVyaW5nIHx8IChleHBvcnRzLk5mdE9yZGVyaW5nID0ge30pKTtcclxuLyoqXHJcbiAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBzdXBwb3J0ZWQgTkZUIG1hcmtldHBsYWNlcyBieSB0aGVcclxuICoge0BsaW5rIE5mdE5hbWVzcGFjZS5nZXROZnRTYWxlc30gbWV0aG9kLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnRzLk5mdFNhbGVNYXJrZXRwbGFjZSA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChOZnRTYWxlTWFya2V0cGxhY2UpIHtcclxuICAgIE5mdFNhbGVNYXJrZXRwbGFjZVtcIlNFQVBPUlRcIl0gPSBcInNlYXBvcnRcIjtcclxuICAgIE5mdFNhbGVNYXJrZXRwbGFjZVtcIkxPT0tTUkFSRVwiXSA9IFwibG9va3NyYXJlXCI7XHJcbiAgICBOZnRTYWxlTWFya2V0cGxhY2VbXCJYMlkyXCJdID0gXCJ4MnkyXCI7XHJcbiAgICBOZnRTYWxlTWFya2V0cGxhY2VbXCJXWVZFUk5cIl0gPSBcInd5dmVyblwiO1xyXG4gICAgTmZ0U2FsZU1hcmtldHBsYWNlW1wiQ1JZUFRPUFVOS1NcIl0gPSBcImNyeXB0b3B1bmtzXCI7XHJcbiAgICBOZnRTYWxlTWFya2V0cGxhY2VbXCJCTFVSXCJdID0gXCJibHVyXCI7XHJcbiAgICBOZnRTYWxlTWFya2V0cGxhY2VbXCJVTktOT1dOXCJdID0gXCJ1bmtub3duXCI7XHJcbn0pKGV4cG9ydHMuTmZ0U2FsZU1hcmtldHBsYWNlIHx8IChleHBvcnRzLk5mdFNhbGVNYXJrZXRwbGFjZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBFbnVtIGZvciBzcGVjaWZ5aW5nIHRoZSB0YWtlciB0eXBlIGZvciB0aGUge0BsaW5rIE5mdE5hbWVzcGFjZS5nZXROZnRTYWxlc31cclxuICogbWV0aG9kLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnRzLk5mdFNhbGVUYWtlclR5cGUgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoTmZ0U2FsZVRha2VyVHlwZSkge1xyXG4gICAgTmZ0U2FsZVRha2VyVHlwZVtcIkJVWUVSXCJdID0gXCJidXllclwiO1xyXG4gICAgTmZ0U2FsZVRha2VyVHlwZVtcIlNFTExFUlwiXSA9IFwic2VsbGVyXCI7XHJcbn0pKGV4cG9ydHMuTmZ0U2FsZVRha2VyVHlwZSB8fCAoZXhwb3J0cy5OZnRTYWxlVGFrZXJUeXBlID0ge30pKTtcclxuLyoqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBORlQgY29udHJhY3QgcmVmcmVzaCBwcm9jZXNzLiAqL1xyXG5leHBvcnRzLk5mdFJlZnJlc2hTdGF0ZSA9IHZvaWQgMDtcclxuKGZ1bmN0aW9uIChOZnRSZWZyZXNoU3RhdGUpIHtcclxuICAgIC8qKiBUaGUgcHJvdmlkZWQgY29udHJhY3QgaXMgbm90IGFuIE5GVCBvciBkb2VzIG5vdCBjb250YWluIG1ldGFkYXRhLiAqL1xyXG4gICAgTmZ0UmVmcmVzaFN0YXRlW1wiRE9FU19OT1RfRVhJU1RcIl0gPSBcImRvZXNfbm90X2V4aXN0XCI7XHJcbiAgICAvKiogVGhlIGNvbnRyYWN0IGhhcyBhbHJlYWR5IGJlZW4gcXVldWVkIGZvciByZWZyZXNoLiAqL1xyXG4gICAgTmZ0UmVmcmVzaFN0YXRlW1wiQUxSRUFEWV9RVUVVRURcIl0gPSBcImFscmVhZHlfcXVldWVkXCI7XHJcbiAgICAvKiogVGhlIGNvbnRyYWN0IGlzIGN1cnJlbnRseSBiZWluZyByZWZyZXNoZWQuICovXHJcbiAgICBOZnRSZWZyZXNoU3RhdGVbXCJJTl9QUk9HUkVTU1wiXSA9IFwiaW5fcHJvZ3Jlc3NcIjtcclxuICAgIC8qKiBUaGUgY29udHJhY3QgcmVmcmVzaCBpcyBjb21wbGV0ZS4gKi9cclxuICAgIE5mdFJlZnJlc2hTdGF0ZVtcIkZJTklTSEVEXCJdID0gXCJmaW5pc2hlZFwiO1xyXG4gICAgLyoqIFRoZSBjb250cmFjdCByZWZyZXNoIGhhcyBiZWVuIHF1ZXVlZCBhbmQgYXdhaXQgZXhlY3V0aW9uLiAqL1xyXG4gICAgTmZ0UmVmcmVzaFN0YXRlW1wiUVVFVUVEXCJdID0gXCJxdWV1ZWRcIjtcclxuICAgIC8qKiBUaGUgY29udHJhY3Qgd2FzIHVuYWJsZSB0byBiZSBxdWV1ZWQgZHVlIHRvIGFuIGludGVybmFsIGVycm9yLiAqL1xyXG4gICAgTmZ0UmVmcmVzaFN0YXRlW1wiUVVFVUVfRkFJTEVEXCJdID0gXCJxdWV1ZV9mYWlsZWRcIjtcclxufSkoZXhwb3J0cy5OZnRSZWZyZXNoU3RhdGUgfHwgKGV4cG9ydHMuTmZ0UmVmcmVzaFN0YXRlID0ge30pKTtcclxuLyoqXHJcbiAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBzdXBwb3J0ZWQgTkZUIG1hcmtldHBsYWNlcyBvbiBhXHJcbiAqIHtAbGluayBOZnRDb2xsZWN0aW9uRmxvb3JQcmljZX0gb2JqZWN0LlxyXG4gKi9cclxuZXhwb3J0cy5OZnRDb2xsZWN0aW9uTWFya2V0cGxhY2UgPSB2b2lkIDA7XHJcbihmdW5jdGlvbiAoTmZ0Q29sbGVjdGlvbk1hcmtldHBsYWNlKSB7XHJcbiAgICBOZnRDb2xsZWN0aW9uTWFya2V0cGxhY2VbXCJPUEVOU0VBXCJdID0gXCJPcGVuU2VhXCI7XHJcbn0pKGV4cG9ydHMuTmZ0Q29sbGVjdGlvbk1hcmtldHBsYWNlIHx8IChleHBvcnRzLk5mdENvbGxlY3Rpb25NYXJrZXRwbGFjZSA9IHt9KSk7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIkMSh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XG5cbmNvbnN0IERFRkFVTFRfQUxDSEVNWV9BUElfS0VZID0gJ2RlbW8nO1xyXG5jb25zdCBERUZBVUxUX05FVFdPUksgPSBleHBvcnRzLk5ldHdvcmsuRVRIX01BSU5ORVQ7XHJcbmNvbnN0IERFRkFVTFRfTUFYX1JFVFJJRVMgPSA1O1xyXG5jb25zdCBERUZBVUxUX1JFUVVFU1RfVElNRU9VVCA9IDA7IC8vIDAgPSBubyB0aW1lb3V0XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiYXNlIFVSTCBmb3IgbWFraW5nIEFsY2hlbXkgQVBJIHJlcXVlc3RzLiBUaGUgYGFsY2hlbXkuY29tYFxyXG4gKiBlbmRwb2ludHMgb25seSB3b3JrIHdpdGggbm9uIGV0aCBqc29uLXJwYyByZXF1ZXN0cy5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBbGNoZW15SHR0cFVybChuZXR3b3JrLCBhcGlLZXkpIHtcclxuICAgIHJldHVybiBgaHR0cHM6Ly8ke25ldHdvcmt9LmcuYWxjaGVteS5jb20vdjIvJHthcGlLZXl9YDtcclxufVxyXG5mdW5jdGlvbiBnZXRBbGNoZW15TmZ0SHR0cFVybChuZXR3b3JrLCBhcGlLZXkpIHtcclxuICAgIHJldHVybiBgaHR0cHM6Ly8ke25ldHdvcmt9LmcuYWxjaGVteS5jb20vbmZ0L3YzLyR7YXBpS2V5fWA7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QWxjaGVteVdzVXJsKG5ldHdvcmssIGFwaUtleSkge1xyXG4gICAgcmV0dXJuIGB3c3M6Ly8ke25ldHdvcmt9LmcuYWxjaGVteS5jb20vdjIvJHthcGlLZXl9YDtcclxufVxyXG5mdW5jdGlvbiBnZXRBbGNoZW15V2ViaG9va0h0dHBVcmwoKSB7XHJcbiAgICByZXR1cm4gJ2h0dHBzOi8vZGFzaGJvYXJkLmFsY2hlbXkuY29tL2FwaSc7XHJcbn1cclxudmFyIEFsY2hlbXlBcGlUeXBlO1xyXG4oZnVuY3Rpb24gKEFsY2hlbXlBcGlUeXBlKSB7XHJcbiAgICBBbGNoZW15QXBpVHlwZVtBbGNoZW15QXBpVHlwZVtcIkJBU0VcIl0gPSAwXSA9IFwiQkFTRVwiO1xyXG4gICAgQWxjaGVteUFwaVR5cGVbQWxjaGVteUFwaVR5cGVbXCJORlRcIl0gPSAxXSA9IFwiTkZUXCI7XHJcbiAgICBBbGNoZW15QXBpVHlwZVtBbGNoZW15QXBpVHlwZVtcIldFQkhPT0tcIl0gPSAyXSA9IFwiV0VCSE9PS1wiO1xyXG59KShBbGNoZW15QXBpVHlwZSB8fCAoQWxjaGVteUFwaVR5cGUgPSB7fSkpO1xyXG4vKipcclxuICogTWFwcGluZyBvZiBuZXR3b3JrIG5hbWVzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgTmV0d29yayBzdHJpbmdzIHVzZWQgdG9cclxuICogY3JlYXRlIGFuIEV0aGVycy5qcyBQcm92aWRlciBpbnN0YW5jZS5cclxuICovXHJcbmNvbnN0IEV0aGVyc05ldHdvcmsgPSB7XHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkVUSF9NQUlOTkVUXTogJ21haW5uZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5FVEhfR09FUkxJXTogJ2dvZXJsaScsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkVUSF9TRVBPTElBXTogJ3NlcG9saWEnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5PUFRfTUFJTk5FVF06ICdvcHRpbWlzbScsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLk9QVF9HT0VSTEldOiAnb3B0aW1pc20tZ29lcmxpJyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuT1BUX1NFUE9MSUFdOiAnb3B0aW1pc20tc2Vwb2xpYScsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkFSQl9NQUlOTkVUXTogJ2FyYml0cnVtJyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuQVJCX0dPRVJMSV06ICdhcmJpdHJ1bS1nb2VybGknLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5BUkJfU0VQT0xJQV06ICdhcmJpdHJ1bS1zZXBvbGlhJyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuTUFUSUNfTUFJTk5FVF06ICdtYXRpYycsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLk1BVElDX01VTUJBSV06ICdtYXRpY211bScsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLkFTVEFSX01BSU5ORVRdOiAnYXN0YXItbWFpbm5ldCcsXHJcbiAgICBbZXhwb3J0cy5OZXR3b3JrLlBPTFlHT05aS0VWTV9NQUlOTkVUXTogJ3BvbHlnb256a2V2bS1tYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuUE9MWUdPTlpLRVZNX1RFU1RORVRdOiAncG9seWdvbnprZXZtLXRlc3RuZXQnLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5CQVNFX01BSU5ORVRdOiAnYmFzZS1tYWlubmV0JyxcclxuICAgIFtleHBvcnRzLk5ldHdvcmsuQkFTRV9HT0VSTEldOiAnYmFzZS1nb2VybGknLFxyXG4gICAgW2V4cG9ydHMuTmV0d29yay5CQVNFX1NFUE9MSUFdOiAnYmFzZS1zZXBvbGlhJ1xyXG59O1xyXG4vKipcclxuICogTWFwcGluZyBvZiBuZXR3b3JrIG5hbWVzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgRXRoZXJzIE5ldHdvcmsgb2JqZWN0cy4gVGhlc2VcclxuICogbmV0d29ya3MgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIGJ5IEV0aGVycyBhbmQgYXJlIGxpc3RlZCBoZXJlIHRvIGJlIG92ZXJyaWRlblxyXG4gKiBpbiB0aGUgcHJvdmlkZXIuXHJcbiAqL1xyXG5jb25zdCBDdXN0b21OZXR3b3JrcyA9IHtcclxuICAgICdhcmJpdHJ1bS1nb2VybGknOiB7XHJcbiAgICAgICAgY2hhaW5JZDogNDIxNjEzLFxyXG4gICAgICAgIG5hbWU6ICdhcmJpdHJ1bS1nb2VybGknXHJcbiAgICB9LFxyXG4gICAgJ2FyYml0cnVtLXNlcG9saWEnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogNDIxNjE0LFxyXG4gICAgICAgIG5hbWU6ICdhcmJpdHJ1bS1zZXBvbGlhJ1xyXG4gICAgfSxcclxuICAgICdhc3Rhci1tYWlubmV0Jzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDU5MixcclxuICAgICAgICBuYW1lOiAnYXN0YXItbWFpbm5ldCdcclxuICAgIH0sXHJcbiAgICBzZXBvbGlhOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMTExNTUxMTEsXHJcbiAgICAgICAgbmFtZTogJ3NlcG9saWEnXHJcbiAgICB9LFxyXG4gICAgJ29wdGltaXNtLXNlcG9saWEnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogMTExNTU0MjAsXHJcbiAgICAgICAgbmFtZTogJ29wdGltaXNtLXNlcG9saWEnXHJcbiAgICB9LFxyXG4gICAgJ3BvbHlnb256a2V2bS1tYWlubmV0Jzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDExMDEsXHJcbiAgICAgICAgbmFtZTogJ3BvbHlnb256a2V2bS1tYWlubmV0J1xyXG4gICAgfSxcclxuICAgICdwb2x5Z29uemtldm0tdGVzdG5ldCc6IHtcclxuICAgICAgICBjaGFpbklkOiAxNDQyLFxyXG4gICAgICAgIG5hbWU6ICdwb2x5Z29uemtldm0tdGVzdG5ldCdcclxuICAgIH0sXHJcbiAgICAnYmFzZS1tYWlubmV0Jzoge1xyXG4gICAgICAgIGNoYWluSWQ6IDg0NTMsXHJcbiAgICAgICAgbmFtZTogJ2Jhc2UtbWFpbm5ldCdcclxuICAgIH0sXHJcbiAgICAnYmFzZS1nb2VybGknOiB7XHJcbiAgICAgICAgY2hhaW5JZDogODQ1MzEsXHJcbiAgICAgICAgbmFtZTogJ2Jhc2UtZ29lcmxpJ1xyXG4gICAgfSxcclxuICAgICdiYXNlLXNlcG9saWEnOiB7XHJcbiAgICAgICAgY2hhaW5JZDogODQ1MzIsXHJcbiAgICAgICAgbmFtZTogJ2Jhc2Utc2Vwb2xpYSdcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gbm9vcCgpIHtcclxuICAgIC8vIEl0J3MgYSBuby1vcFxyXG59XHJcbmNvbnN0IEVUSF9OVUxMX1ZBTFVFID0gJzB4JztcclxuY29uc3QgRVRIX05VTExfQUREUkVTUyA9ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnO1xuXG4vKipcclxuICogVGhpcyBjbGFzcyBob2xkcyB0aGUgY29uZmlnIGluZm9ybWF0aW9uIGZvciB0aGUgU0RLIGNsaWVudCBpbnN0YW5jZSBhbmRcclxuICogZXhwb3NlcyB0aGUgdW5kZXJseWluZyBwcm92aWRlcnMgZm9yIG1vcmUgYWR2YW5jZWQgdXNlIGNhc2VzLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBBbGNoZW15Q29uZmlnIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuYXBpS2V5ID0gKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5hcGlLZXkpIHx8IERFRkFVTFRfQUxDSEVNWV9BUElfS0VZO1xyXG4gICAgICAgIHRoaXMubmV0d29yayA9IChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcubmV0d29yaykgfHwgREVGQVVMVF9ORVRXT1JLO1xyXG4gICAgICAgIHRoaXMubWF4UmV0cmllcyA9IChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcubWF4UmV0cmllcykgfHwgREVGQVVMVF9NQVhfUkVUUklFUztcclxuICAgICAgICB0aGlzLnVybCA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy51cmw7XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW4gPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuYXV0aFRva2VuO1xyXG4gICAgICAgIHRoaXMuYmF0Y2hSZXF1ZXN0cyA9IChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuYmF0Y2hSZXF1ZXN0cykgfHwgZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcucmVxdWVzdFRpbWVvdXQpIHx8IERFRkFVTFRfUkVRVUVTVF9USU1FT1VUO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBVUkwgZW5kcG9pbnQgdG8gc2VuZCB0aGUgSFRUUCByZXF1ZXN0IHRvLiBJZiBhIGN1c3RvbSBVUkwgd2FzXHJcbiAgICAgKiBwcm92aWRlZCBpbiB0aGUgY29uZmlnLCB0aGF0IFVSTCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlLCB0aGUgZGVmYXVsdCBVUkwgaXNcclxuICAgICAqIGZyb20gdGhlIG5ldHdvcmsgYW5kIEFQSSBrZXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFwaVR5cGUgLSBUaGUgdHlwZSBvZiBBUEkgdG8gZ2V0IHRoZSBVUkwgZm9yLlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9nZXRSZXF1ZXN0VXJsKGFwaVR5cGUpIHtcclxuICAgICAgICBpZiAodGhpcy51cmwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cmw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFwaVR5cGUgPT09IEFsY2hlbXlBcGlUeXBlLk5GVCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0QWxjaGVteU5mdEh0dHBVcmwodGhpcy5uZXR3b3JrLCB0aGlzLmFwaUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFwaVR5cGUgPT09IEFsY2hlbXlBcGlUeXBlLldFQkhPT0spIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldEFsY2hlbXlXZWJob29rSHR0cFVybCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldEFsY2hlbXlIdHRwVXJsKHRoaXMubmV0d29yaywgdGhpcy5hcGlLZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBBbGNoZW15UHJvdmlkZXIgaW5zdGFuY2UuIE9ubHkgb25lIHByb3ZpZGVyIGlzIGNyZWF0ZWQgcGVyXHJcbiAgICAgKiBBbGNoZW15IGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBBbGNoZW15UHJvdmlkZXIgaXMgYSB3cmFwcGVyIGFyb3VuZCBldGhlcidzIGBBbGNoZW15UHJvdmlkZXJgIGNsYXNzIGFuZFxyXG4gICAgICogaGFzIGJlZW4gZXhwYW5kZWQgdG8gc3VwcG9ydCBBbGNoZW15J3MgRW5oYW5jZWQgQVBJcy5cclxuICAgICAqXHJcbiAgICAgKiBNb3N0IGNvbW1vbiBtZXRob2RzIG9uIHRoZSBwcm92aWRlciBhcmUgYXZhaWxhYmxlIGFzIHRvcC1sZXZlbCBtZXRob2RzIG9uXHJcbiAgICAgKiB0aGUge0BsaW5rIEFsY2hlbXl9IGluc3RhbmNlLCBidXQgdGhlIHByb3ZpZGVyIGlzIGV4cG9zZWQgaGVyZSB0byBhY2Nlc3NcclxuICAgICAqIG90aGVyIGxlc3MtY29tbW9uIG1ldGhvZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRQcm92aWRlcigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2Jhc2VBbGNoZW15UHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fYmFzZUFsY2hlbXlQcm92aWRlciA9ICgoKSA9PiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgQWxjaGVteVByb3ZpZGVyIH0gPSB5aWVsZCBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlcXVpcmUoJy4vYWxjaGVteS1wcm92aWRlci1lNTM5ZTdkMC5qcycpOyB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWxjaGVteVByb3ZpZGVyKHRoaXMpO1xyXG4gICAgICAgICAgICB9KSkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jhc2VBbGNoZW15UHJvdmlkZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gQWxjaGVteVdlYnNvY2tldFByb3ZpZGVyIGluc3RhbmNlLiBPbmx5IG9uZSBwcm92aWRlciBpcyBjcmVhdGVkXHJcbiAgICAgKiBwZXIgQWxjaGVteSBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyIGlzIGEgd3JhcHBlciBhcm91bmQgZXRoZXInc1xyXG4gICAgICogYEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlcmAgY2xhc3MgYW5kIGhhcyBiZWVuIGV4cGFuZGVkIHRvIHN1cHBvcnQgQWxjaGVteSdzXHJcbiAgICAgKiBTdWJzY3JpcHRpb24gQVBJcywgYXV0b21hdGljIGJhY2tmaWxsaW5nLCBhbmQgb3RoZXIgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIE1vc3QgY29tbW9uIG1ldGhvZHMgb24gdGhlIHByb3ZpZGVyIGFyZSBhdmFpbGFibGUgYXMgdG9wLWxldmVsIG1ldGhvZHMgb25cclxuICAgICAqIHRoZSB7QGxpbmsgQWxjaGVteX0gaW5zdGFuY2UsIGJ1dCB0aGUgcHJvdmlkZXIgaXMgZXhwb3NlZCBoZXJlIHRvIGFjY2Vzc1xyXG4gICAgICogb3RoZXIgbGVzcy1jb21tb24gbWV0aG9kcy5cclxuICAgICAqL1xyXG4gICAgZ2V0V2ViU29ja2V0UHJvdmlkZXIoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9iYXNlQWxjaGVteVdzc1Byb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Jhc2VBbGNoZW15V3NzUHJvdmlkZXIgPSAoKCkgPT4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlciB9ID0geWllbGQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiByZXF1aXJlKCcuL2FsY2hlbXktd2Vic29ja2V0LXByb3ZpZGVyLWQ5MjFkYjg0LmpzJyk7IH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIodGhpcyk7XHJcbiAgICAgICAgICAgIH0pKSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fYmFzZUFsY2hlbXlXc3NQcm92aWRlcjtcclxuICAgIH1cclxufVxuXG5jb25zdCB2ZXJzaW9uJDEgPSBcImxvZ2dlci81LjcuMFwiO1xuXG5sZXQgX3Blcm1hbmVudENlbnNvckVycm9ycyA9IGZhbHNlO1xubGV0IF9jZW5zb3JFcnJvcnMgPSBmYWxzZTtcbmNvbnN0IExvZ0xldmVscyA9IHsgZGVidWc6IDEsIFwiZGVmYXVsdFwiOiAyLCBpbmZvOiAyLCB3YXJuaW5nOiAzLCBlcnJvcjogNCwgb2ZmOiA1IH07XG5sZXQgX2xvZ0xldmVsID0gTG9nTGV2ZWxzW1wiZGVmYXVsdFwiXTtcbmxldCBfZ2xvYmFsTG9nZ2VyID0gbnVsbDtcbmZ1bmN0aW9uIF9jaGVja05vcm1hbGl6ZSgpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBtaXNzaW5nID0gW107XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhbGwgZm9ybXMgb2Ygbm9ybWFsaXphdGlvbiBhcmUgc3VwcG9ydGVkXG4gICAgICAgIFtcIk5GRFwiLCBcIk5GQ1wiLCBcIk5GS0RcIiwgXCJORktDXCJdLmZvckVhY2goKGZvcm0pID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKFwidGVzdFwiLm5vcm1hbGl6ZShmb3JtKSAhPT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIG5vcm1hbGl6ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKGZvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG1pc3NpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFwiICsgbWlzc2luZy5qb2luKFwiLCBcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTkpLm5vcm1hbGl6ZShcIk5GRFwiKSAhPT0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDY1LCAweDAzMDEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJicm9rZW4gaW1wbGVtZW50YXRpb25cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IF9ub3JtYWxpemVFcnJvciA9IF9jaGVja05vcm1hbGl6ZSgpO1xudmFyIExvZ0xldmVsJDE7XG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gICAgTG9nTGV2ZWxbXCJERUJVR1wiXSA9IFwiREVCVUdcIjtcbiAgICBMb2dMZXZlbFtcIklORk9cIl0gPSBcIklORk9cIjtcbiAgICBMb2dMZXZlbFtcIldBUk5JTkdcIl0gPSBcIldBUk5JTkdcIjtcbiAgICBMb2dMZXZlbFtcIkVSUk9SXCJdID0gXCJFUlJPUlwiO1xuICAgIExvZ0xldmVsW1wiT0ZGXCJdID0gXCJPRkZcIjtcbn0pKExvZ0xldmVsJDEgfHwgKExvZ0xldmVsJDEgPSB7fSkpO1xudmFyIEVycm9yQ29kZTtcbihmdW5jdGlvbiAoRXJyb3JDb2RlKSB7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEdlbmVyaWMgRXJyb3JzXG4gICAgLy8gVW5rbm93biBFcnJvclxuICAgIEVycm9yQ29kZVtcIlVOS05PV05fRVJST1JcIl0gPSBcIlVOS05PV05fRVJST1JcIjtcbiAgICAvLyBOb3QgSW1wbGVtZW50ZWRcbiAgICBFcnJvckNvZGVbXCJOT1RfSU1QTEVNRU5URURcIl0gPSBcIk5PVF9JTVBMRU1FTlRFRFwiO1xuICAgIC8vIFVuc3VwcG9ydGVkIE9wZXJhdGlvblxuICAgIC8vICAgLSBvcGVyYXRpb25cbiAgICBFcnJvckNvZGVbXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIl0gPSBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiO1xuICAgIC8vIE5ldHdvcmsgRXJyb3IgKGkuZS4gRXRoZXJldW0gTmV0d29yaywgc3VjaCBhcyBhbiBpbnZhbGlkIGNoYWluIElEKVxuICAgIC8vICAgLSBldmVudCAoXCJub05ldHdvcmtcIiBpcyBub3QgcmUtdGhyb3duIGluIHByb3ZpZGVyLnJlYWR5OyBvdGhlcndpc2UgdGhyb3duKVxuICAgIEVycm9yQ29kZVtcIk5FVFdPUktfRVJST1JcIl0gPSBcIk5FVFdPUktfRVJST1JcIjtcbiAgICAvLyBTb21lIHNvcnQgb2YgYmFkIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclxuICAgIEVycm9yQ29kZVtcIlNFUlZFUl9FUlJPUlwiXSA9IFwiU0VSVkVSX0VSUk9SXCI7XG4gICAgLy8gVGltZW91dFxuICAgIEVycm9yQ29kZVtcIlRJTUVPVVRcIl0gPSBcIlRJTUVPVVRcIjtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gT3BlcmF0aW9uYWwgIEVycm9yc1xuICAgIC8vIEJ1ZmZlciBPdmVycnVuXG4gICAgRXJyb3JDb2RlW1wiQlVGRkVSX09WRVJSVU5cIl0gPSBcIkJVRkZFUl9PVkVSUlVOXCI7XG4gICAgLy8gTnVtZXJpYyBGYXVsdFxuICAgIC8vICAgLSBvcGVyYXRpb246IHRoZSBvcGVyYXRpb24gYmVpbmcgZXhlY3V0ZWRcbiAgICAvLyAgIC0gZmF1bHQ6IHRoZSByZWFzb24gdGhpcyBmYXVsdGVkXG4gICAgRXJyb3JDb2RlW1wiTlVNRVJJQ19GQVVMVFwiXSA9IFwiTlVNRVJJQ19GQVVMVFwiO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBBcmd1bWVudCBFcnJvcnNcbiAgICAvLyBNaXNzaW5nIG5ldyBvcGVyYXRvciB0byBhbiBvYmplY3RcbiAgICAvLyAgLSBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgY2xhc3NcbiAgICBFcnJvckNvZGVbXCJNSVNTSU5HX05FV1wiXSA9IFwiTUlTU0lOR19ORVdcIjtcbiAgICAvLyBJbnZhbGlkIGFyZ3VtZW50IChlLmcuIHZhbHVlIGlzIGluY29tcGF0aWJsZSB3aXRoIHR5cGUpIHRvIGEgZnVuY3Rpb246XG4gICAgLy8gICAtIGFyZ3VtZW50OiBUaGUgYXJndW1lbnQgbmFtZSB0aGF0IHdhcyBpbnZhbGlkXG4gICAgLy8gICAtIHZhbHVlOiBUaGUgdmFsdWUgb2YgdGhlIGFyZ3VtZW50XG4gICAgRXJyb3JDb2RlW1wiSU5WQUxJRF9BUkdVTUVOVFwiXSA9IFwiSU5WQUxJRF9BUkdVTUVOVFwiO1xuICAgIC8vIE1pc3NpbmcgYXJndW1lbnQgdG8gYSBmdW5jdGlvbjpcbiAgICAvLyAgIC0gY291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHJlY2VpdmVkXG4gICAgLy8gICAtIGV4cGVjdGVkQ291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGV4cGVjdGVkXG4gICAgRXJyb3JDb2RlW1wiTUlTU0lOR19BUkdVTUVOVFwiXSA9IFwiTUlTU0lOR19BUkdVTUVOVFwiO1xuICAgIC8vIFRvbyBtYW55IGFyZ3VtZW50c1xuICAgIC8vICAgLSBjb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgcmVjZWl2ZWRcbiAgICAvLyAgIC0gZXhwZWN0ZWRDb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgZXhwZWN0ZWRcbiAgICBFcnJvckNvZGVbXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCJdID0gXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCI7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEJsb2NrY2hhaW4gRXJyb3JzXG4gICAgLy8gQ2FsbCBleGNlcHRpb25cbiAgICAvLyAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uXG4gICAgLy8gIC0gYWRkcmVzcz86IHRoZSBjb250cmFjdCBhZGRyZXNzXG4gICAgLy8gIC0gYXJncz86IFRoZSBhcmd1bWVudHMgcGFzc2VkIGludG8gdGhlIGZ1bmN0aW9uXG4gICAgLy8gIC0gbWV0aG9kPzogVGhlIFNvbGlkaXR5IG1ldGhvZCBzaWduYXR1cmVcbiAgICAvLyAgLSBlcnJvclNpZ25hdHVyZT86IFRoZSBFSVA4NDggZXJyb3Igc2lnbmF0dXJlXG4gICAgLy8gIC0gZXJyb3JBcmdzPzogVGhlIEVJUDg0OCBlcnJvciBwYXJhbWV0ZXJzXG4gICAgLy8gIC0gcmVhc29uOiBUaGUgcmVhc29uIChvbmx5IGZvciBFSVA4NDggXCJFcnJvcihzdHJpbmcpXCIpXG4gICAgRXJyb3JDb2RlW1wiQ0FMTF9FWENFUFRJT05cIl0gPSBcIkNBTExfRVhDRVBUSU9OXCI7XG4gICAgLy8gSW5zdWZmaWNpZW50IGZ1bmRzICg8IHZhbHVlICsgZ2FzTGltaXQgKiBnYXNQcmljZSlcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcbiAgICBFcnJvckNvZGVbXCJJTlNVRkZJQ0lFTlRfRlVORFNcIl0gPSBcIklOU1VGRklDSUVOVF9GVU5EU1wiO1xuICAgIC8vIE5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFxuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIGF0dGVtcHRlZFxuICAgIEVycm9yQ29kZVtcIk5PTkNFX0VYUElSRURcIl0gPSBcIk5PTkNFX0VYUElSRURcIjtcbiAgICAvLyBUaGUgcmVwbGFjZW1lbnQgZmVlIGZvciB0aGUgdHJhbnNhY3Rpb24gaXMgdG9vIGxvd1xuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIGF0dGVtcHRlZFxuICAgIEVycm9yQ29kZVtcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCJdID0gXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiO1xuICAgIC8vIFRoZSBnYXMgbGltaXQgY291bGQgbm90IGJlIGVzdGltYXRlZFxuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIHBhc3NlZCB0byBlc3RpbWF0ZUdhc1xuICAgIEVycm9yQ29kZVtcIlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUXCJdID0gXCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVFwiO1xuICAgIC8vIFRoZSB0cmFuc2FjdGlvbiB3YXMgcmVwbGFjZWQgYnkgb25lIHdpdGggYSBoaWdoZXIgZ2FzIHByaWNlXG4gICAgLy8gICAtIHJlYXNvbjogXCJjYW5jZWxsZWRcIiwgXCJyZXBsYWNlZFwiIG9yIFwicmVwcmljZWRcIlxuICAgIC8vICAgLSBjYW5jZWxsZWQ6IHRydWUgaWYgcmVhc29uID09IFwiY2FuY2VsbGVkXCIgb3IgcmVhc29uID09IFwicmVwbGFjZWRcIilcbiAgICAvLyAgIC0gaGFzaDogb3JpZ2luYWwgdHJhbnNhY3Rpb24gaGFzaFxuICAgIC8vICAgLSByZXBsYWNlbWVudDogdGhlIGZ1bGwgVHJhbnNhY3Rpb25zUmVzcG9uc2UgZm9yIHRoZSByZXBsYWNlbWVudFxuICAgIC8vICAgLSByZWNlaXB0OiB0aGUgcmVjZWlwdCBvZiB0aGUgcmVwbGFjZW1lbnRcbiAgICBFcnJvckNvZGVbXCJUUkFOU0FDVElPTl9SRVBMQUNFRFwiXSA9IFwiVFJBTlNBQ1RJT05fUkVQTEFDRURcIjtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gSW50ZXJhY3Rpb24gRXJyb3JzXG4gICAgLy8gVGhlIHVzZXIgcmVqZWN0ZWQgdGhlIGFjdGlvbiwgc3VjaCBhcyBzaWduaW5nIGEgbWVzc2FnZSBvciBzZW5kaW5nXG4gICAgLy8gYSB0cmFuc2FjdGlvblxuICAgIEVycm9yQ29kZVtcIkFDVElPTl9SRUpFQ1RFRFwiXSA9IFwiQUNUSU9OX1JFSkVDVEVEXCI7XG59KShFcnJvckNvZGUgfHwgKEVycm9yQ29kZSA9IHt9KSk7XG5jb25zdCBIRVggPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbmNsYXNzIExvZ2dlciQxIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnNpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2ZXJzaW9uLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfbG9nKGxvZ0xldmVsLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gbG9nTGV2ZWwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKExvZ0xldmVsc1tsZXZlbF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGxvZyBsZXZlbCBuYW1lXCIsIFwibG9nTGV2ZWxcIiwgbG9nTGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfbG9nTGV2ZWwgPiBMb2dMZXZlbHNbbGV2ZWxdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgfVxuICAgIGRlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlciQxLmxldmVscy5ERUJVRywgYXJncyk7XG4gICAgfVxuICAgIGluZm8oLi4uYXJncykge1xuICAgICAgICB0aGlzLl9sb2coTG9nZ2VyJDEubGV2ZWxzLklORk8sIGFyZ3MpO1xuICAgIH1cbiAgICB3YXJuKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlciQxLmxldmVscy5XQVJOSU5HLCBhcmdzKTtcbiAgICB9XG4gICAgbWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcykge1xuICAgICAgICAvLyBFcnJvcnMgYXJlIGJlaW5nIGNlbnNvcmVkXG4gICAgICAgIGlmIChfY2Vuc29yRXJyb3JzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlRXJyb3IoXCJjZW5zb3JlZCBlcnJvclwiLCBjb2RlLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICBjb2RlID0gTG9nZ2VyJDEuZXJyb3JzLlVOS05PV05fRVJST1I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VEZXRhaWxzID0gW107XG4gICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoZXggPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZXggKz0gSEVYW3ZhbHVlW2ldID4+IDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGV4ICs9IEhFWFt2YWx1ZVtpXSAmIDB4MGZdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9VWludDhBcnJheSgweFwiICsgaGV4ICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChrZXkgKyBcIj1cIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChrZXkgKyBcIj1cIiArIEpTT04uc3RyaW5naWZ5KHBhcmFtc1trZXldLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goYGNvZGU9JHtjb2RlfWApO1xuICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGB2ZXJzaW9uPSR7dGhpcy52ZXJzaW9ufWApO1xuICAgICAgICBjb25zdCByZWFzb24gPSBtZXNzYWdlO1xuICAgICAgICBsZXQgdXJsID0gXCJcIjtcbiAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5OVU1FUklDX0ZBVUxUOiB7XG4gICAgICAgICAgICAgICAgdXJsID0gXCJOVU1FUklDX0ZBVUxUXCI7XG4gICAgICAgICAgICAgICAgY29uc3QgZmF1bHQgPSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm92ZXJmbG93XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1bmRlcmZsb3dcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRpdmlzaW9uLWJ5LXplcm9cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi1cIiArIGZhdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJuZWdhdGl2ZS1wb3dlclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmVnYXRpdmUtd2lkdGhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi11bnN1cHBvcnRlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1bmJvdW5kLWJpdHdpc2UtcmVzdWx0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCItdW5ib3VuZC1yZXN1bHRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLkNBTExfRVhDRVBUSU9OOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuSU5TVUZGSUNJRU5UX0ZVTkRTOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuTUlTU0lOR19ORVc6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5OT05DRV9FWFBJUkVEOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQ6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5UUkFOU0FDVElPTl9SRVBMQUNFRDpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUOlxuICAgICAgICAgICAgICAgIHVybCA9IGNvZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiBbIFNlZTogaHR0cHM6L1xcL2xpbmtzLmV0aGVycy5vcmcvdjUtZXJyb3JzLVwiICsgdXJsICsgXCIgXVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlRGV0YWlscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKFwiICsgbWVzc2FnZURldGFpbHMuam9pbihcIiwgXCIpICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IEFueT8/XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5yZWFzb24gPSByZWFzb247XG4gICAgICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgZXJyb3Jba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICB0aHJvd0Vycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcykge1xuICAgICAgICB0aHJvdyB0aGlzLm1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpO1xuICAgIH1cbiAgICB0aHJvd0FyZ3VtZW50RXJyb3IobWVzc2FnZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIkMS5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgYXJndW1lbnQ6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UsIGNvZGUsIHBhcmFtcykge1xuICAgICAgICBpZiAoISFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoY29uZGl0aW9uLCBtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoISFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm93QXJndW1lbnRFcnJvcihtZXNzYWdlLCBuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIGNoZWNrTm9ybWFsaXplKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKF9ub3JtYWxpemVFcnJvcikge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwicGxhdGZvcm0gbWlzc2luZyBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBMb2dnZXIkMS5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIlN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIGZvcm06IF9ub3JtYWxpemVFcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tTYWZlVWludDUzKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcInZhbHVlIG5vdCBzYWZlXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAweDFmZmZmZmZmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyJDEuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiY2hlY2tTYWZlSW50ZWdlclwiLFxuICAgICAgICAgICAgICAgIGZhdWx0OiBcIm91dC1vZi1zYWZlLXJhbmdlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgJSAxKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyJDEuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiY2hlY2tTYWZlSW50ZWdlclwiLFxuICAgICAgICAgICAgICAgIGZhdWx0OiBcIm5vbi1pbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0FyZ3VtZW50Q291bnQoY291bnQsIGV4cGVjdGVkQ291bnQsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIjogXCIgKyBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50IDwgZXhwZWN0ZWRDb3VudCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBhcmd1bWVudFwiICsgbWVzc2FnZSwgTG9nZ2VyJDEuZXJyb3JzLk1JU1NJTkdfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ID4gZXhwZWN0ZWRDb3VudCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwidG9vIG1hbnkgYXJndW1lbnRzXCIgKyBtZXNzYWdlLCBMb2dnZXIkMS5lcnJvcnMuVU5FWFBFQ1RFRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja05ldyh0YXJnZXQsIGtpbmQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gT2JqZWN0IHx8IHRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIG5ld1wiLCBMb2dnZXIkMS5lcnJvcnMuTUlTU0lOR19ORVcsIHsgbmFtZToga2luZC5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrQWJzdHJhY3QodGFyZ2V0LCBraW5kKSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IGtpbmQpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcImNhbm5vdCBpbnN0YW50aWF0ZSBhYnN0cmFjdCBjbGFzcyBcIiArIEpTT04uc3RyaW5naWZ5KGtpbmQubmFtZSkgKyBcIiBkaXJlY3RseTsgdXNlIGEgc3ViLWNsYXNzXCIsIExvZ2dlciQxLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgbmFtZTogdGFyZ2V0Lm5hbWUsIG9wZXJhdGlvbjogXCJuZXdcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0YXJnZXQgPT09IE9iamVjdCB8fCB0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBuZXdcIiwgTG9nZ2VyJDEuZXJyb3JzLk1JU1NJTkdfTkVXLCB7IG5hbWU6IGtpbmQubmFtZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2xvYmFsTG9nZ2VyKCkge1xuICAgICAgICBpZiAoIV9nbG9iYWxMb2dnZXIpIHtcbiAgICAgICAgICAgIF9nbG9iYWxMb2dnZXIgPSBuZXcgTG9nZ2VyJDEodmVyc2lvbiQxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2dsb2JhbExvZ2dlcjtcbiAgICB9XG4gICAgc3RhdGljIHNldENlbnNvcnNoaXAoY2Vuc29yc2hpcCwgcGVybWFuZW50KSB7XG4gICAgICAgIGlmICghY2Vuc29yc2hpcCAmJiBwZXJtYW5lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nZ2VyKCkudGhyb3dFcnJvcihcImNhbm5vdCBwZXJtYW5lbnRseSBkaXNhYmxlIGNlbnNvcnNoaXBcIiwgTG9nZ2VyJDEuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXRDZW5zb3JzaGlwXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfcGVybWFuZW50Q2Vuc29yRXJyb3JzKSB7XG4gICAgICAgICAgICBpZiAoIWNlbnNvcnNoaXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdsb2JhbExvZ2dlcigpLnRocm93RXJyb3IoXCJlcnJvciBjZW5zb3JzaGlwIHBlcm1hbmVudFwiLCBMb2dnZXIkMS5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldENlbnNvcnNoaXBcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX2NlbnNvckVycm9ycyA9ICEhY2Vuc29yc2hpcDtcbiAgICAgICAgX3Blcm1hbmVudENlbnNvckVycm9ycyA9ICEhcGVybWFuZW50O1xuICAgIH1cbiAgICBzdGF0aWMgc2V0TG9nTGV2ZWwobG9nTGV2ZWwpIHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBMb2dMZXZlbHNbbG9nTGV2ZWwudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGlmIChsZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBMb2dnZXIkMS5nbG9iYWxMb2dnZXIoKS53YXJuKFwiaW52YWxpZCBsb2cgbGV2ZWwgLSBcIiArIGxvZ0xldmVsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfbG9nTGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmVyc2lvbikge1xuICAgICAgICByZXR1cm4gbmV3IExvZ2dlciQxKHZlcnNpb24pO1xuICAgIH1cbn1cbkxvZ2dlciQxLmVycm9ycyA9IEVycm9yQ29kZTtcbkxvZ2dlciQxLmxldmVscyA9IExvZ0xldmVsJDE7XG5cbmNvbnN0IHZlcnNpb24gPSBcInByb3BlcnRpZXMvNS43LjBcIjtcblxudmFyIF9fYXdhaXRlciA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlciQxKHZlcnNpb24pO1xuZnVuY3Rpb24gZGVmaW5lUmVhZE9ubHkob2JqZWN0LCBuYW1lLCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgfSk7XG59XG5mdW5jdGlvbiByZXNvbHZlUHJvcGVydGllcyhvYmplY3QpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IE9iamVjdC5rZXlzKG9iamVjdCkubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKCh2KSA9PiAoeyBrZXk6IGtleSwgdmFsdWU6IHYgfSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IHlpZWxkIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHMucmVkdWNlKChhY2N1bSwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBhY2N1bVsocmVzdWx0LmtleSldID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgfSk7XG59XG5jb25zdCBvcGFxdWUgPSB7IGJpZ2ludDogdHJ1ZSwgYm9vbGVhbjogdHJ1ZSwgXCJmdW5jdGlvblwiOiB0cnVlLCBudW1iZXI6IHRydWUsIHN0cmluZzogdHJ1ZSB9O1xuZnVuY3Rpb24gX2lzRnJvemVuKG9iamVjdCkge1xuICAgIC8vIE9wYXF1ZSBvYmplY3RzIGFyZSBub3QgbXV0YWJsZSwgc28gc2FmZSB0byBjb3B5IGJ5IGFzc2lnbm1lbnRcbiAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQgfHwgb2JqZWN0ID09PSBudWxsIHx8IG9wYXF1ZVt0eXBlb2YgKG9iamVjdCldKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpIHx8IHR5cGVvZiAob2JqZWN0KSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoIU9iamVjdC5pc0Zyb3plbihvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5c1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhY2Nlc3NpbmcgYSB2YWx1ZSB0cmlnZ2VycyBhbiBlcnJvciwgaXQgaXMgYSBnZXR0ZXJcbiAgICAgICAgICAgICAgICAvLyBkZXNpZ25lZCB0byBkbyBzbyAoZS5nLiBSZXN1bHQpIGFuZCBpcyB0aGVyZWZvcmUgXCJmcm96ZW5cIlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfaXNGcm96ZW4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgQ2Fubm90IGRlZXBDb3B5ICR7dHlwZW9mIChvYmplY3QpfWAsIFwib2JqZWN0XCIsIG9iamVjdCk7XG59XG4vLyBSZXR1cm5zIGEgbmV3IGNvcHkgb2Ygb2JqZWN0LCBzdWNoIHRoYXQgbm8gcHJvcGVydGllcyBtYXkgYmUgcmVwbGFjZWQuXG4vLyBOZXcgcHJvcGVydGllcyBtYXkgYmUgYWRkZWQgb25seSB0byBvYmplY3RzLlxuZnVuY3Rpb24gX2RlZXBDb3B5KG9iamVjdCkge1xuICAgIGlmIChfaXNGcm96ZW4ob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICAvLyBBcnJheXMgYXJlIG11dGFibGUsIHNvIHdlIG5lZWQgdG8gY3JlYXRlIGEgY29weVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUob2JqZWN0Lm1hcCgoaXRlbSkgPT4gZGVlcENvcHkoaXRlbSkpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAob2JqZWN0KSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHJlc3VsdCwga2V5LCBkZWVwQ29weSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBDYW5ub3QgZGVlcENvcHkgJHt0eXBlb2YgKG9iamVjdCl9YCwgXCJvYmplY3RcIiwgb2JqZWN0KTtcbn1cbmZ1bmN0aW9uIGRlZXBDb3B5KG9iamVjdCkge1xuICAgIHJldHVybiBfZGVlcENvcHkob2JqZWN0KTtcbn1cblxuLyoqXHJcbiAqIENvbnZlcnRzIGEgaGV4IHN0cmluZyB0byBhIGRlY2ltYWwgbnVtYmVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gaGV4U3RyaW5nIC0gVGhlIGhleCBzdHJpbmcgdG8gY29udmVydC5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZnJvbUhleChoZXhTdHJpbmcpIHtcclxuICAgIHJldHVybiBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oaGV4U3RyaW5nKS50b051bWJlcigpO1xyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIG51bWJlciB0byBhIGhleCBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSBudW0gLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gaGV4LlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0hleChudW0pIHtcclxuICAgIHJldHVybiBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20obnVtKS50b0hleFN0cmluZygpO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBhIGhleCBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSBwb3NzaWJsZUhleFN0cmluZyAtIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gaXNIZXgocG9zc2libGVIZXhTdHJpbmcpIHtcclxuICAgIHJldHVybiAvXjB4WzAtOWEtZkEtRl0rJC8udGVzdChwb3NzaWJsZUhleFN0cmluZyk7XHJcbn1cblxuZnVuY3Rpb24gZm9ybWF0QmxvY2soYmxvY2spIHtcclxuICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGJsb2NrO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoTnVtYmVyLmlzSW50ZWdlcihibG9jaykpIHtcclxuICAgICAgICByZXR1cm4gdG9IZXgoYmxvY2spO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJsb2NrLnRvU3RyaW5nKCk7XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5nVG9FbnVtKHgsIGVudW1iKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhlbnVtYikuaW5jbHVkZXMoeCkgPyB4IDogbnVsbDtcclxufVxyXG5mdW5jdGlvbiBnZXROZnRDb250cmFjdEZvck5mdEZyb21SYXcocmF3TmZ0Q29udHJhY3QpIHtcclxuICAgIHJldHVybiBudWxsc1RvVW5kZWZpbmVkKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZ2V0TmZ0Q29udHJhY3RGcm9tUmF3KHJhd05mdENvbnRyYWN0KSksIHsgc3BhbUNsYXNzaWZpY2F0aW9uczogcmF3TmZ0Q29udHJhY3Quc3BhbUNsYXNzaWZpY2F0aW9ucy5tYXAocGFyc2VOZnRTcGFtQ2xhc3NpZmljYXRpb24pIH0pKTtcclxufVxyXG5mdW5jdGlvbiBnZXROZnRDb250cmFjdHNGb3JPd25lckZyb21SYXcocmF3TmZ0Q29udHJhY3QpIHtcclxuICAgIHJldHVybiBudWxsc1RvVW5kZWZpbmVkKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZ2V0TmZ0Q29udHJhY3RGcm9tUmF3KHJhd05mdENvbnRyYWN0KSksIHsgZGlzcGxheU5mdDogcmF3TmZ0Q29udHJhY3QuZGlzcGxheU5mdCwgaW1hZ2U6IHJhd05mdENvbnRyYWN0LmltYWdlLCB0b3RhbEJhbGFuY2U6IHJhd05mdENvbnRyYWN0LnRvdGFsQmFsYW5jZSwgbnVtRGlzdGluY3RUb2tlbnNPd25lZDogcmF3TmZ0Q29udHJhY3QubnVtRGlzdGluY3RUb2tlbnNPd25lZCwgaXNTcGFtOiByYXdOZnRDb250cmFjdC5pc1NwYW0gfSkpO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5mdENvbnRyYWN0RnJvbVJhdyhyYXdOZnRDb250cmFjdCkge1xyXG4gICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByYXdOZnRDb250cmFjdCksIHsgdG9rZW5UeXBlOiBwYXJzZU5mdFRva2VuVHlwZShyYXdOZnRDb250cmFjdC50b2tlblR5cGUpLCBvcGVuU2VhTWV0YWRhdGE6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmF3TmZ0Q29udHJhY3Qub3BlblNlYU1ldGFkYXRhKSwgeyBzYWZlbGlzdFJlcXVlc3RTdGF0dXM6IHJhd05mdENvbnRyYWN0Lm9wZW5TZWFNZXRhZGF0YS5zYWZlbGlzdFJlcXVlc3RTdGF0dXMgIT09IG51bGxcclxuICAgICAgICAgICAgICAgID8gc3RyaW5nVG9FbnVtKHJhd05mdENvbnRyYWN0Lm9wZW5TZWFNZXRhZGF0YS5zYWZlbGlzdFJlcXVlc3RTdGF0dXMsIGV4cG9ydHMuT3BlblNlYVNhZmVsaXN0UmVxdWVzdFN0YXR1cylcclxuICAgICAgICAgICAgICAgIDogbnVsbCB9KSB9KSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmZ0Q29sbGVjdGlvbkZyb21SYXcocmF3TmZ0Q29sbGVjdGlvbikge1xyXG4gICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByYXdOZnRDb2xsZWN0aW9uKSwgeyBmbG9vclByaWNlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJhd05mdENvbGxlY3Rpb24uZmxvb3JQcmljZSksIHsgbWFya2V0cGxhY2U6IHBhcnNlTmZ0Q29sbGVjdGlvbk1hcmtldHBsYWNlKHJhd05mdENvbGxlY3Rpb24uZmxvb3JQcmljZS5tYXJrZXRwbGFjZSkgfSkgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIGdldEJhc2VOZnRGcm9tUmF3KHJhd0Jhc2VOZnQsIGNvbnRyYWN0QWRkcmVzcykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjb250cmFjdEFkZHJlc3M6IGNvbnRyYWN0QWRkcmVzc1xyXG4gICAgICAgICAgICA/IGNvbnRyYWN0QWRkcmVzc1xyXG4gICAgICAgICAgICA6IHJhd0Jhc2VOZnQuY29udHJhY3RBZGRyZXNzLFxyXG4gICAgICAgIHRva2VuSWQ6IHJhd0Jhc2VOZnQudG9rZW5JZFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXROZnRGcm9tUmF3KHJhd05mdCkge1xyXG4gICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByYXdOZnQpLCB7IGNvbnRyYWN0OiBnZXROZnRDb250cmFjdEZvck5mdEZyb21SYXcocmF3TmZ0LmNvbnRyYWN0KSwgdG9rZW5UeXBlOiBwYXJzZU5mdFRva2VuVHlwZShyYXdOZnQudG9rZW5UeXBlKSwgYWNxdWlyZWRBdDogcmF3TmZ0LmFjcXVpcmVkQXQsIGNvbGxlY3Rpb246IHJhd05mdC5jb2xsZWN0aW9uLCBtaW50OiByYXdOZnQubWludCB9KSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmZ0U2FsZXNGcm9tUmF3KHJhd05mdFNhbGVzKSB7XHJcbiAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZCh7XHJcbiAgICAgICAgbmZ0U2FsZXM6IHJhd05mdFNhbGVzLm5mdFNhbGVzLm1hcChyYXdOZnRTYWxlID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJhd05mdFNhbGUpLCB7IG1hcmtldHBsYWNlOiBwYXJzZU5mdFNhbGVNYXJrZXRwbGFjZShyYXdOZnRTYWxlLm1hcmtldHBsYWNlKSwgdGFrZXI6IHBhcnNlTmZ0VGFrZXIocmF3TmZ0U2FsZS50YWtlcikgfSkpKSxcclxuICAgICAgICB2YWxpZEF0OiByYXdOZnRTYWxlcy52YWxpZEF0LFxyXG4gICAgICAgIHBhZ2VLZXk6IHJhd05mdFNhbGVzLnBhZ2VLZXlcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlTmZ0U2FsZU1hcmtldHBsYWNlKG1hcmtldHBsYWNlKSB7XHJcbiAgICBzd2l0Y2ggKG1hcmtldHBsYWNlKSB7XHJcbiAgICAgICAgY2FzZSAnbG9va3NyYXJlJzpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTmZ0U2FsZU1hcmtldHBsYWNlLkxPT0tTUkFSRTtcclxuICAgICAgICBjYXNlICdzZWFwb3J0JzpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTmZ0U2FsZU1hcmtldHBsYWNlLlNFQVBPUlQ7XHJcbiAgICAgICAgY2FzZSAneDJ5Mic6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFNhbGVNYXJrZXRwbGFjZS5YMlkyO1xyXG4gICAgICAgIGNhc2UgJ3d5dmVybic6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFNhbGVNYXJrZXRwbGFjZS5XWVZFUk47XHJcbiAgICAgICAgY2FzZSAnY3J5cHRvcHVua3MnOlxyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5OZnRTYWxlTWFya2V0cGxhY2UuQ1JZUFRPUFVOS1M7XHJcbiAgICAgICAgY2FzZSAnYmx1cic6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFNhbGVNYXJrZXRwbGFjZS5CTFVSO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFNhbGVNYXJrZXRwbGFjZS5VTktOT1dOO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhcnNlTmZ0Q29sbGVjdGlvbk1hcmtldHBsYWNlKG1hcmtldHBsYWNlKSB7XHJcbiAgICBzd2l0Y2ggKG1hcmtldHBsYWNlKSB7XHJcbiAgICAgICAgY2FzZSAnT3BlblNlYSc6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdENvbGxlY3Rpb25NYXJrZXRwbGFjZS5PUEVOU0VBO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VOZnRUYWtlcih0YWtlcikge1xyXG4gICAgLy8gVGhlIGAudG9Mb3dlckNhc2UoKWAgY2FsbCBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgQVBJIHJldHVybnMgdGhlIGNhcGl0YWxpemVkIHZhbHVlc1xyXG4gICAgc3dpdGNoICh0YWtlci50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgY2FzZSAnYnV5ZXInOlxyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5OZnRTYWxlVGFrZXJUeXBlLkJVWUVSO1xyXG4gICAgICAgIGNhc2UgJ3NlbGxlcic6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFNhbGVUYWtlclR5cGUuU0VMTEVSO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgTmZ0U2FsZVRha2VyVHlwZSAke3Rha2VyfWApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhcnNlTmZ0U3BhbUNsYXNzaWZpY2F0aW9uKHMpIHtcclxuICAgIGNvbnN0IHJlcyA9IHN0cmluZ1RvRW51bShzLCBleHBvcnRzLk5mdFNwYW1DbGFzc2lmaWNhdGlvbik7XHJcbiAgICBpZiAocmVzID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZXhwb3J0cy5OZnRTcGFtQ2xhc3NpZmljYXRpb24uVW5rbm93bjtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VOZnRUb2tlblR5cGUodG9rZW5UeXBlKSB7XHJcbiAgICBzd2l0Y2ggKHRva2VuVHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ2VyYzcyMSc6XHJcbiAgICAgICAgY2FzZSAnRVJDNzIxJzpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTmZ0VG9rZW5UeXBlLkVSQzcyMTtcclxuICAgICAgICBjYXNlICdlcmMxMTU1JzpcclxuICAgICAgICBjYXNlICdFUkMxMTU1JzpcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuTmZ0VG9rZW5UeXBlLkVSQzExNTU7XHJcbiAgICAgICAgY2FzZSAnbm9fc3VwcG9ydGVkX25mdF9zdGFuZGFyZCc6XHJcbiAgICAgICAgY2FzZSAnTk9fU1VQUE9SVEVEX05GVF9TVEFOREFSRCc6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFRva2VuVHlwZS5OT19TVVBQT1JURURfTkZUX1NUQU5EQVJEO1xyXG4gICAgICAgIGNhc2UgJ25vdF9hX2NvbnRyYWN0JzpcclxuICAgICAgICBjYXNlICdOT1RfQV9DT05UUkFDVCc6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFRva2VuVHlwZS5OT1RfQV9DT05UUkFDVDtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5OZnRUb2tlblR5cGUuVU5LTk9XTjtcclxuICAgIH1cclxufVxyXG5jb25zdCBJU19CUk9XU0VSID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93ICE9PSBudWxsO1xyXG5mdW5jdGlvbiBudWxsc1RvVW5kZWZpbmVkKG9iaikge1xyXG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBpZiAob2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnIHx8IEFycmF5LmlzQXJyYXkob2JqKSkge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgICAgICBvYmpba2V5XSA9IG51bGxzVG9VbmRlZmluZWQob2JqW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvYmo7XHJcbn1cblxuLyoqXHJcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgdW5kZXJseWluZyBpbXBsZW1lbnRhdGlvbnMgZm9yIGV4cG9zZWQgQVBJIHN1cmZhY2UgaW5cclxuICogdGhlIHtAbGluayBDb3JlTmFtZXNwYWNlfS4gQnkgbW92aW5nIHRoZSBtZXRob2RzIG91dCBpbnRvIGEgc2VwYXJhdGUgZmlsZSxcclxuICogb3RoZXIgbmFtZXNwYWNlcyBjYW4gYWNjZXNzIHRoZXNlIG1ldGhvZHMgd2l0aG91dCBkZXBlbmRpbmcgb24gdGhlIGVudGlyZVxyXG4gKiBDb3JlTmFtZXNwYWNlLCBvciBvdmVycmlkZSB0aGUgYHNyY01ldGhvZGAgcGFyYW0gdXNlZCBmb3IgbG9nZ2luZy5cclxuICovXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBhc3NldCB0cmFuc2ZlcnMgZm9yIHRoZSBwcm92aWRlZCBwYXJhbXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBc3NldFRyYW5zZmVycyhjb25maWcsIHBhcmFtcywgc3JjTWV0aG9kID0gJ2dldEFzc2V0VHJhbnNmZXJzJykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgaWYgKHBhcmFtcy5mcm9tQWRkcmVzcykge1xyXG4gICAgICAgICAgICBwYXJhbXMuZnJvbUFkZHJlc3MgPSB5aWVsZCBwcm92aWRlci5fZ2V0QWRkcmVzcyhwYXJhbXMuZnJvbUFkZHJlc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFyYW1zLnRvQWRkcmVzcykge1xyXG4gICAgICAgICAgICBwYXJhbXMudG9BZGRyZXNzID0geWllbGQgcHJvdmlkZXIuX2dldEFkZHJlc3MocGFyYW1zLnRvQWRkcmVzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm92aWRlci5fc2VuZCgnYWxjaGVteV9nZXRBc3NldFRyYW5zZmVycycsIFtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IGZyb21CbG9jazogcGFyYW1zLmZyb21CbG9jayAhPSBudWxsID8gZm9ybWF0QmxvY2socGFyYW1zLmZyb21CbG9jaykgOiB1bmRlZmluZWQsIHRvQmxvY2s6IHBhcmFtcy50b0Jsb2NrICE9IG51bGwgPyBmb3JtYXRCbG9jayhwYXJhbXMudG9CbG9jaykgOiB1bmRlZmluZWQsIG1heENvdW50OiBwYXJhbXMubWF4Q291bnQgIT0gbnVsbCA/IHRvSGV4KHBhcmFtcy5tYXhDb3VudCkgOiB1bmRlZmluZWQgfSlcclxuICAgICAgICBdLCBzcmNNZXRob2QpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25SZWNlaXB0cyhjb25maWcsIHBhcmFtcywgc3JjTWV0aG9kID0gJ2dldFRyYW5zYWN0aW9uUmVjZWlwdHMnKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCBjb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICByZXR1cm4gcHJvdmlkZXIuX3NlbmQoJ2FsY2hlbXlfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0cycsIFtwYXJhbXNdLCBzcmNNZXRob2QpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZSBldGhlcnMgaW1wbGVtZW50YXRpb24gb2YgZ2V0TG9ncywgYnV0IGlzIGV4cGFuZGVkXHJcbiAqIHRvIHN1cHBvcnQgc3BlY2lmeWluZyBhbiBhZGRyZXNzIGFycmF5IGluIHRoZSBmaWx0ZXIuXHJcbiAqXHJcbiAqIFRoZSBtYWluIG1vZGlmaWNhdGlvbnMgbWFkZSB0byBzdXBwb3J0IGFuIGFkZHJlc3MgYXJyYXkgYXJlOlxyXG4gKiAtIEN1c3RvbSBgZ2V0RmlsdGVyKClgIG1ldGhvZCB0aGF0IHN1cHBvcnRzIGFuIGFkZHJlc3MgYXJyYXlcclxuICogLSBVc2Ugb2YgYGFycmF5T2YoKWAgZm9ybWF0dGVyIHRvIGZvcm1hdCB0aGUgbG9ncyB0byBhdm9pZCB0aGUgYEZvcm1hdHRlcmAgaW1wb3J0LlxyXG4gKiAtIFVzZSBvZiBgcHJvdmlkZXIuc2VuZCgpYCB0byBhdm9pZCBmb3JtYXR0aW5nIGxvZ2ljIGluIGBwcm92aWRlci5wZXJmb3JtKClgLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TG9ncyhjb25maWcsIGZpbHRlcikge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgeWllbGQgcHJvdmlkZXIuZ2V0TmV0d29yaygpO1xyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcclxuICAgICAgICAgICAgZmlsdGVyOiBnZXRGaWx0ZXIoY29uZmlnLCBmaWx0ZXIpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgbG9ncyA9IHlpZWxkIHByb3ZpZGVyLnNlbmQoJ2V0aF9nZXRMb2dzJywgW3BhcmFtcy5maWx0ZXJdKTtcclxuICAgICAgICBsb2dzLmZvckVhY2gobG9nID0+IHtcclxuICAgICAgICAgICAgaWYgKGxvZy5yZW1vdmVkID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGxvZy5yZW1vdmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYXJyYXlPZihwcm92aWRlci5mb3JtYXR0ZXIuZmlsdGVyTG9nLmJpbmQocHJvdmlkZXIuZm9ybWF0dGVyKSkobG9ncyk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gYW5kIGNvcGllZCBmcm9tIHRoZSBldGhlcnMgaW1wbGVtZW50YXRpb24gb2ZcclxuICogYEpzb25ScGNQcm92aWRlci5fZ2V0RmlsdGVyKClgLCBidXQgaXMgZXh0ZW5kZWQgdG8gc3VwcG9ydCBhbiBhZGRyZXNzIGFycmF5LlxyXG4gKlxyXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGEgaGFja3kgd2F5IHRvIGdldCBhcm91bmQgdGhlIGV0aGVycyBmb3JtYXR0ZXIuIFRoZVxyXG4gKiBmb3JtYXR0ZXIgaXMgdXNlZCB0byBjaGVjayB0aGUgdHlwZXMgb2YgdGhlIGBmaWx0ZXJgIHBhcmFtcywgYnV0IGV0aGVycyBkb2VzXHJcbiAqIG5vdCBhbGxvdyBhbiBhcnJheSBpbiB0aGUgYGFkZHJlc3NgIGZpZWxkLiBUbyBwcmVzZXJ2ZSB0aGUgZXRoZXJzIGZvcm1hdHRlclxyXG4gKiBvbiB0aGUgb3RoZXIgZmllbGRzLCB3ZSB1c2UgdGhlIGZvcm1hdHRlciB0byBjaGVjayB0aGUgdHlwZXMgb2YgdGhvc2Ugb3RoZXJcclxuICogZmllbGRzLCBhbmQgdGhlbiBtYW51YWxseSBjaGVjayB0aGUgYGFkZHJlc3NgIGZpZWxkIGxhc3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRGaWx0ZXIoY29uZmlnLCBmaWx0ZXIpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAvLyBTVEFSVCBNT0RJRklFRCBDT0RFXHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCBjb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICBjb25zdCByZXNvbHZlZEZpbHRlciA9IHlpZWxkIGZpbHRlcjtcclxuICAgICAgICBsZXQgcmVzdWx0ID0ge307XHJcbiAgICAgICAgLy8gRU5EIE1PRElGSUVEIENPREVcclxuICAgICAgICBbJ2Jsb2NrSGFzaCcsICd0b3BpY3MnXS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZEZpbHRlcltrZXldID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHJlc29sdmVkRmlsdGVyW2tleV07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgWydmcm9tQmxvY2snLCAndG9CbG9jayddLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgaWYgKHJlc29sdmVkRmlsdGVyW2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gcHJvdmlkZXIuX2dldEJsb2NrVGFnKHJlc29sdmVkRmlsdGVyW2tleV0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIEJFR0lOIE1PRElGSUVEIENPREVcclxuICAgICAgICAvLyBGb3JtYXQgdGhlIGByZXN1bHRgIG9iamVjdCB1c2luZyB0aGUgZXRoZXJzIGZvcm1hdHRlciB3aXRob3V0IHRoZSBgYWRkcmVzc2BcclxuICAgICAgICAvLyBmaWVsZC5cclxuICAgICAgICByZXN1bHQgPSBwcm92aWRlci5mb3JtYXR0ZXIuZmlsdGVyKHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHJlc3VsdCkpO1xyXG4gICAgICAgIC8vIEFmdGVyIGZvcm1hdHRpbmcgdGhlIG90aGVyIGZpZWxkcywgbWFudWFsbHkgZm9ybWF0IHRoZSBgYWRkcmVzc2AgZmllbGRcclxuICAgICAgICAvLyBiZWZvcmUgYWRkaW5nIGl0IHRvIHRoZSBgcmVzdWx0YCBvYmplY3QuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzb2x2ZWRGaWx0ZXIuYWRkcmVzcykpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmFkZHJlc3MgPSB5aWVsZCBQcm9taXNlLmFsbChyZXNvbHZlZEZpbHRlci5hZGRyZXNzLm1hcCgoYWRkcmVzcykgPT4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7IHJldHVybiBwcm92aWRlci5fZ2V0QWRkcmVzcyhhZGRyZXNzKTsgfSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmVzb2x2ZWRGaWx0ZXIuYWRkcmVzcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5hZGRyZXNzID0geWllbGQgcHJvdmlkZXIuX2dldEFkZHJlc3MocmVzb2x2ZWRGaWx0ZXIuYWRkcmVzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgLy8gRU5EIE1PRElGSUVEIENPREVcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBETyBOT1QgTU9ESUZZLlxyXG4gKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGRpcmVjdGx5IGNvcGllZCBvdmVyIGZyb20gZXRoZXJzIGltcGxlbWVudGF0aW9uIG9mXHJcbiAqIGBGb3JtYXR0ZXIuYXJyYXlPZigpYC4gSXQgaXMgY29waWVkIGhlcmUgdG8gYXZvaWQgaGF2aW5nIHRvIGltcG9ydCB0aGVcclxuICogYEZvcm1hdHRlcmAgY2xhc3Mgb3IgYEZvcm1hdHRlckZ1bmNgIHR5cGUgZnJvbSBldGhlcnMsIHRoYXQgYXJlIG5vdCBwYXJ0IG9mXHJcbiAqIHRoZSBkZWZhdWx0IGV4cG9ydC5cclxuICpcclxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhcHBsaWVzIHRoZSBmb3JtYXR0ZXIgdG8gYW4gYXJyYXkgb2ZcclxuICogdmFsdWVzLCBhbmQgaXMgdXNlZCB0byBmb3JtYXQgdGhlIGxvZ3MgcmV0dXJuZWQgYnkgYGdldExvZ3MoKWAuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcnJheU9mKGZvcm1hdCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgYW4gYXJyYXknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgYXJyYXkuZm9yRWFjaCh2YWx1ZSA9PiB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZvcm1hdCh2YWx1ZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBUaGUgY29yZSBuYW1lc3BhY2UgY29udGFpbnMgYWxsIGNvbW1vbmx5LXVzZWQgW0V0aGVycy5qc1xyXG4gKiBQcm92aWRlcl0oaHR0cHM6Ly9kb2NzLmV0aGVycy5pby92NS9hcGkvcHJvdmlkZXJzL2FwaS1wcm92aWRlcnMvI0FsY2hlbXlQcm92aWRlcilcclxuICogbWV0aG9kcy4gSWYgeW91IGFyZSBhbHJlYWR5IHVzaW5nIEV0aGVycy5qcywgeW91IHNob3VsZCBiZSBzaW1wbHkgYWJsZSB0b1xyXG4gKiByZXBsYWNlIHRoZSBFdGhlcnMuanMgUHJvdmlkZXIgb2JqZWN0IHdpdGggYGFsY2hlbXkuY29yZWAgd2hlbiBhY2Nlc3NpbmdcclxuICogcHJvdmlkZXIgbWV0aG9kcyBhbmQgaXQgc2hvdWxkIGp1c3Qgd29yay5cclxuICpcclxuICogRG8gbm90IGNhbGwgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS4gSW5zdGVhZCwgaW5zdGFudGlhdGUgYW4gQWxjaGVteSBvYmplY3RcclxuICogd2l0aCBgY29uc3QgYWxjaGVteSA9IG5ldyBBbGNoZW15KGNvbmZpZylgIGFuZCB0aGVuIGFjY2VzcyB0aGUgY29yZSBuYW1lc3BhY2VcclxuICogdmlhIGBhbGNoZW15LmNvcmVgLlxyXG4gKi9cclxuY2xhc3MgQ29yZU5hbWVzcGFjZSB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYmFsYW5jZSBvZiBhIGdpdmVuIGFkZHJlc3MgYXMgb2YgdGhlIHByb3ZpZGVkIGJsb2NrLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhZGRyZXNzT3JOYW1lIFRoZSBhZGRyZXNzIG9yIG5hbWUgb2YgdGhlIGFjY291bnQgdG8gZ2V0IHRoZSBiYWxhbmNlIGZvci5cclxuICAgICAqIEBwYXJhbSBibG9ja1RhZyBUaGUgb3B0aW9uYWwgYmxvY2sgbnVtYmVyIG9yIGhhc2ggdG8gZ2V0IHRoZSBiYWxhbmNlIGZvci5cclxuICAgICAqICAgRGVmYXVsdHMgdG8gJ2xhdGVzdCcgaWYgdW5zcGVjaWZpZWQuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldEJhbGFuY2UoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldEJhbGFuY2UoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGFkZHJlc3MgaXMgYSBzbWFydCBjb250cmFjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzcyB0byBjaGVjayB0eXBlIGZvci5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgaXNDb250cmFjdEFkZHJlc3MoYWRkcmVzcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBjb2RlID0geWllbGQgcHJvdmlkZXIuZ2V0Q29kZShhZGRyZXNzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvZGUgIT09ICcweCc7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNvbnRyYWN0IGNvZGUgb2YgdGhlIHByb3ZpZGVkIGFkZHJlc3MgYXQgdGhlIGJsb2NrLiBJZiB0aGVyZSBpc1xyXG4gICAgICogbm8gY29udHJhY3QgZGVwbG95ZWQsIHRoZSByZXN1bHQgaXMgYDB4YC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzc09yTmFtZSBUaGUgYWRkcmVzcyBvciBuYW1lIG9mIHRoZSBhY2NvdW50IHRvIGdldCB0aGUgY29kZSBmb3IuXHJcbiAgICAgKiBAcGFyYW0gYmxvY2tUYWcgVGhlIG9wdGlvbmFsIGJsb2NrIG51bWJlciBvciBoYXNoIHRvIGdldCB0aGUgY29kZSBmb3IuXHJcbiAgICAgKiAgIERlZmF1bHRzIHRvICdsYXRlc3QnIGlmIHVuc3BlY2lmaWVkLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRDb2RlKGFkZHJlc3NPck5hbWUsIGJsb2NrVGFnKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5nZXRDb2RlKGFkZHJlc3NPck5hbWUsIGJsb2NrVGFnKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgcHJvdmlkZWQgcG9zaXRpb24gYXQgdGhlIHByb3ZpZGVkIGFkZHJlc3MsIGF0IHRoZVxyXG4gICAgICogcHJvdmlkZWQgYmxvY2sgaW4gYEJ5dGVzMzJgIGZvcm1hdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzc09yTmFtZSBUaGUgYWRkcmVzcyBvciBuYW1lIG9mIHRoZSBhY2NvdW50IHRvIGdldCB0aGUgY29kZSBmb3IuXHJcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIG9mIHRoZSBzdG9yYWdlIHNsb3QgdG8gZ2V0LlxyXG4gICAgICogQHBhcmFtIGJsb2NrVGFnIFRoZSBvcHRpb25hbCBibG9jayBudW1iZXIgb3IgaGFzaCB0byBnZXQgdGhlIGNvZGUgZm9yLlxyXG4gICAgICogICBEZWZhdWx0cyB0byAnbGF0ZXN0JyBpZiB1bnNwZWNpZmllZC5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgZ2V0U3RvcmFnZUF0KGFkZHJlc3NPck5hbWUsIHBvc2l0aW9uLCBibG9ja1RhZykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuZ2V0U3RvcmFnZUF0KGFkZHJlc3NPck5hbWUsIHBvc2l0aW9uLCBibG9ja1RhZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB0cmFuc2FjdGlvbnMgZXZlciBzZW50IGZyb20gdGhlIHByb3ZpZGVkIGFkZHJlc3MsIGFzXHJcbiAgICAgKiBvZiB0aGUgcHJvdmlkZWQgYmxvY2sgdGFnLiBUaGlzIHZhbHVlIGlzIHVzZWQgYXMgdGhlIG5vbmNlIGZvciB0aGUgbmV4dFxyXG4gICAgICogdHJhbnNhY3Rpb24gZnJvbSB0aGUgYWRkcmVzcyBzZW50IHRvIHRoZSBuZXR3b3JrLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhZGRyZXNzT3JOYW1lIFRoZSBhZGRyZXNzIG9yIG5hbWUgb2YgdGhlIGFjY291bnQgdG8gZ2V0IHRoZSBub25jZSBmb3IuXHJcbiAgICAgKiBAcGFyYW0gYmxvY2tUYWcgVGhlIG9wdGlvbmFsIGJsb2NrIG51bWJlciBvciBoYXNoIHRvIGdldCB0aGUgbm9uY2UgZm9yLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRUcmFuc2FjdGlvbkNvdW50KGFkZHJlc3NPck5hbWUsIGJsb2NrVGFnKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5nZXRUcmFuc2FjdGlvbkNvdW50KGFkZHJlc3NPck5hbWUsIGJsb2NrVGFnKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYmxvY2sgZnJvbSB0aGUgbmV0d29yayBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYmxvY2sgbnVtYmVyIG9yXHJcbiAgICAgKiBoYXNoLiBUcmFuc2FjdGlvbnMgb24gdGhlIGJsb2NrIGFyZSByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiB0cmFuc2FjdGlvblxyXG4gICAgICogaGFzaGVzLiBUbyBnZXQgdGhlIGZ1bGwgdHJhbnNhY3Rpb24gZGV0YWlscyBvbiB0aGUgYmxvY2ssIHVzZVxyXG4gICAgICoge0BsaW5rIGdldEJsb2NrV2l0aFRyYW5zYWN0aW9uc30gaW5zdGVhZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYmxvY2tIYXNoT3JCbG9ja1RhZyBUaGUgYmxvY2sgbnVtYmVyIG9yIGhhc2ggdG8gZ2V0IHRoZSBibG9jayBmb3IuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldEJsb2NrKGJsb2NrSGFzaE9yQmxvY2tUYWcpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldEJsb2NrKGJsb2NrSGFzaE9yQmxvY2tUYWcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBibG9jayBmcm9tIHRoZSBuZXR3b3JrIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBibG9jayBudW1iZXIgb3JcclxuICAgICAqIGhhc2guIFRyYW5zYWN0aW9ucyBvbiB0aGUgYmxvY2sgYXJlIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mXHJcbiAgICAgKiB7QGxpbmsgVHJhbnNhY3Rpb25SZXNwb25zZX0gb2JqZWN0cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYmxvY2tIYXNoT3JCbG9ja1RhZyBUaGUgYmxvY2sgbnVtYmVyIG9yIGhhc2ggdG8gZ2V0IHRoZSBibG9jayBmb3IuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldEJsb2NrV2l0aFRyYW5zYWN0aW9ucyhibG9ja0hhc2hPckJsb2NrVGFnKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5nZXRCbG9ja1dpdGhUcmFuc2FjdGlvbnMoYmxvY2tIYXNoT3JCbG9ja1RhZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHtAbGluayBFdGhlcnNOZXR3b3JrQWxpYXN9IEFsY2hlbXkgaXMgY29ubmVjdGVkIHRvLlxyXG4gICAgICpcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgZ2V0TmV0d29yaygpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldE5ldHdvcmsoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYmxvY2sgbnVtYmVyIG9mIHRoZSBtb3N0IHJlY2VudGx5IG1pbmVkIGJsb2NrLlxyXG4gICAgICpcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgZ2V0QmxvY2tOdW1iZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBiZXN0IGd1ZXNzIG9mIHRoZSBjdXJyZW50IGdhcyBwcmljZSB0byB1c2UgaW4gYSB0cmFuc2FjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldEdhc1ByaWNlKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuZ2V0R2FzUHJpY2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVjb21tZW5kZWQgZmVlIGRhdGEgdG8gdXNlIGluIGEgdHJhbnNhY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGFuIEVJUC0xNTU5IHRyYW5zYWN0aW9uLCB0aGUgbWF4RmVlUGVyR2FzIGFuZCBtYXhQcmlvcml0eUZlZVBlckdhc1xyXG4gICAgICogc2hvdWxkIGJlIHVzZWQuXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMgYW5kIG5ldHdvcmtzIHdoaWNoIGRvIG5vdCBzdXBwb3J0IEVJUC0xNTU5LCB0aGVcclxuICAgICAqIGdhc1ByaWNlIHNob3VsZCBiZSB1c2VkLlxyXG4gICAgICpcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgZ2V0RmVlRGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldEZlZURhdGEoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIFByb21pc2Ugd2hpY2ggd2lsbCBzdGFsbCB1bnRpbCB0aGUgbmV0d29yayBoYXMgaGVlbiBlc3RhYmxpc2hlZCxcclxuICAgICAqIGlnbm9yaW5nIGVycm9ycyBkdWUgdG8gdGhlIHRhcmdldCBub2RlIG5vdCBiZWluZyBhY3RpdmUgeWV0LlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgZm9yIHRlc3Rpbmcgb3IgYXR0YWNoaW5nIHNjcmlwdHMgdG8gd2FpdCB1bnRpbCB0aGUgbm9kZSBpc1xyXG4gICAgICogdXAgYW5kIHJ1bm5pbmcgc21vb3RobHkuXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICByZWFkeSgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLnJlYWR5O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIHRoZSB0cmFuc2FjdGlvbiwgdXNpbmcgY2FsbC4gQSBjYWxsIGRvZXNcclxuICAgICAqIG5vdCByZXF1aXJlIGFueSBldGhlciwgYnV0IGNhbm5vdCBjaGFuZ2UgYW55IHN0YXRlLiBUaGlzIGlzIHVzZWZ1bCBmb3JcclxuICAgICAqIGNhbGxpbmcgZ2V0dGVycyBvbiBDb250cmFjdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiB0byBleGVjdXRlLlxyXG4gICAgICogQHBhcmFtIGJsb2NrVGFnIFRoZSBvcHRpb25hbCBibG9jayBudW1iZXIgb3IgaGFzaCB0byBnZXQgdGhlIGNhbGwgZm9yLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBjYWxsKHRyYW5zYWN0aW9uLCBibG9ja1RhZykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuY2FsbCh0cmFuc2FjdGlvbiwgYmxvY2tUYWcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGVzdGltYXRlIG9mIHRoZSBhbW91bnQgb2YgZ2FzIHRoYXQgd291bGQgYmUgcmVxdWlyZWQgdG8gc3VibWl0XHJcbiAgICAgKiB0cmFuc2FjdGlvbiB0byB0aGUgbmV0d29yay5cclxuICAgICAqXHJcbiAgICAgKiBBbiBlc3RpbWF0ZSBtYXkgbm90IGJlIGFjY3VyYXRlIHNpbmNlIHRoZXJlIGNvdWxkIGJlIGFub3RoZXIgdHJhbnNhY3Rpb24gb25cclxuICAgICAqIHRoZSBuZXR3b3JrIHRoYXQgd2FzIG5vdCBhY2NvdW50ZWQgZm9yLCBidXQgYWZ0ZXIgYmVpbmcgbWluZWQgYWZmZWN0cyB0aGVcclxuICAgICAqIHJlbGV2YW50IHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgaXMgYW4gYWxpYXMgZm9yIHtAbGluayBUcmFuc2FjdE5hbWVzcGFjZS5lc3RpbWF0ZUdhc30uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiB0byBlc3RpbWF0ZSBnYXMgZm9yLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBlc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuZXN0aW1hdGVHYXModHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiB3aXRoIGhhc2ggb3IgbnVsbCBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgdW5rbm93bi5cclxuICAgICAqXHJcbiAgICAgKiBJZiBhIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBtaW5lZCwgdGhpcyBtZXRob2Qgd2lsbCBzZWFyY2ggdGhlXHJcbiAgICAgKiB0cmFuc2FjdGlvbiBwb29sLiBWYXJpb3VzIGJhY2tlbmRzIG1heSBoYXZlIG1vcmUgcmVzdHJpY3RpdmUgdHJhbnNhY3Rpb25cclxuICAgICAqIHBvb2wgYWNjZXNzIChlLmcuIGlmIHRoZSBnYXMgcHJpY2UgaXMgdG9vIGxvdyBvciB0aGUgdHJhbnNhY3Rpb24gd2FzIG9ubHlcclxuICAgICAqIHJlY2VudGx5IHNlbnQgYW5kIG5vdCB5ZXQgaW5kZXhlZCkgaW4gd2hpY2ggY2FzZSB0aGlzIG1ldGhvZCBtYXkgYWxzbyByZXR1cm4gbnVsbC5cclxuICAgICAqXHJcbiAgICAgKiBOT1RFOiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgVHJhbnNhY3ROYW1lc3BhY2UuZ2V0VHJhbnNhY3Rpb259LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbkhhc2ggVGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIHRvIGdldC5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgZ2V0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5nZXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0IGZvciBoYXNoIG9yIG51bGwgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBub3RcclxuICAgICAqIGJlZW4gbWluZWQuXHJcbiAgICAgKlxyXG4gICAgICogVG8gc3RhbGwgdW50aWwgdGhlIHRyYW5zYWN0aW9uIGhhcyBiZWVuIG1pbmVkLCBjb25zaWRlciB0aGVcclxuICAgICAqIHdhaXRGb3JUcmFuc2FjdGlvbiBtZXRob2QgYmVsb3cuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uSGFzaCBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gZ2V0LlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3VibWl0cyB0cmFuc2FjdGlvbiB0byB0aGUgbmV0d29yayB0byBiZSBtaW5lZC4gVGhlIHRyYW5zYWN0aW9uIG11c3QgYmVcclxuICAgICAqIHNpZ25lZCwgYW5kIGJlIHZhbGlkIChpLmUuIHRoZSBub25jZSBpcyBjb3JyZWN0IGFuZCB0aGUgYWNjb3VudCBoYXNcclxuICAgICAqIHN1ZmZpY2llbnQgYmFsYW5jZSB0byBwYXkgZm9yIHRoZSB0cmFuc2FjdGlvbikuXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFRyYW5zYWN0TmFtZXNwYWNlLmdldFRyYW5zYWN0aW9ufS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2lnbmVkVHJhbnNhY3Rpb24gVGhlIHNpZ25lZCB0cmFuc2FjdGlvbiB0byBzZW5kLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBzZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHdoaWNoIHdpbGwgbm90IHJlc29sdmUgdW50aWwgc3BlY2lmaWVkIHRyYW5zYWN0aW9uIGhhc2ggaXMgbWluZWQuXHJcbiAgICAgKlxyXG4gICAgICogSWYge0BsaW5rIGNvbmZpcm1hdGlvbnN9IGlzIDAsIHRoaXMgbWV0aG9kIGlzIG5vbi1ibG9ja2luZyBhbmQgaWYgdGhlXHJcbiAgICAgKiB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gbWluZWQgcmV0dXJucyBudWxsLiBPdGhlcndpc2UsIHRoaXMgbWV0aG9kIHdpbGxcclxuICAgICAqIGJsb2NrIHVudGlsIHRoZSB0cmFuc2FjdGlvbiBoYXMgY29uZmlybWVkIGJsb2NrcyBtaW5lZCBvbiB0b3Agb2YgdGhlIGJsb2NrXHJcbiAgICAgKiBpbiB3aGljaCBpdCB3YXMgbWluZWQuXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFRyYW5zYWN0TmFtZXNwYWNlLmdldFRyYW5zYWN0aW9ufS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25IYXNoIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiB0byB3YWl0IGZvci5cclxuICAgICAqIEBwYXJhbSBjb25maXJtYXRpb25zIFRoZSBudW1iZXIgb2YgYmxvY2tzIHRvIHdhaXQgZm9yLlxyXG4gICAgICogQHBhcmFtIHRpbWVvdXQgVGhlIG1heGltdW0gdGltZSB0byB3YWl0IGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gY29uZmlybS5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgd2FpdEZvclRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCwgY29uZmlybWF0aW9ucywgdGltZW91dCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIud2FpdEZvclRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCwgY29uZmlybWF0aW9ucywgdGltZW91dCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbG9ncyB0aGF0IG1hdGNoIHRoZSBwcm92aWRlZCBmaWx0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZpbHRlciBUaGUgZmlsdGVyIG9iamVjdCB0byB1c2UuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldExvZ3MoZmlsdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0TG9ncyh0aGlzLmNvbmZpZywgZmlsdGVyKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWxsb3dzIHNlbmRpbmcgYSByYXcgbWVzc2FnZSB0byB0aGUgQWxjaGVteSBiYWNrZW5kLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtZXRob2QgVGhlIG1ldGhvZCB0byBjYWxsLlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBUaGUgcGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSBtZXRob2QuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLnNlbmQobWV0aG9kLCBwYXJhbXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kcyB0aGUgYWRkcmVzcyB0aGF0IGRlcGxveWVkIHRoZSBwcm92aWRlZCBjb250cmFjdCBhbmQgYmxvY2sgbnVtYmVyIGl0XHJcbiAgICAgKiB3YXMgZGVwbG95ZWQgaW4uXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogVGhpcyBtZXRob2QgcGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIGFjcm9zcyBhbGwgYmxvY2tzIHNpbmNlIGdlbmVzaXNcclxuICAgICAqIGFuZCBjYW4gdGFrZSBhIGxvbmcgdGltZSB0byBjb21wbGV0ZS4gVGhpcyBtZXRob2QgaXMgYSBjb252ZW5pZW5jZSBtZXRob2RcclxuICAgICAqIHRoYXQgd2lsbCBldmVudHVhbGx5IGJlIHJlcGxhY2VkIGJ5IGEgc2luZ2xlIGNhbGwgdG8gYW4gQWxjaGVteSBlbmRwb2ludFxyXG4gICAgICogd2l0aCB0aGlzIGluZm9ybWF0aW9uIGNhY2hlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gVGhlIGNvbnRyYWN0IGFkZHJlc3MgdG8gZmluZCB0aGUgZGVwbG95ZXIgZm9yLlxyXG4gICAgICogQGJldGFcclxuICAgICAqL1xyXG4gICAgZmluZENvbnRyYWN0RGVwbG95ZXIoY29udHJhY3RBZGRyZXNzKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50QmxvY2tOdW0gPSB5aWVsZCBwcm92aWRlci5nZXRCbG9ja051bWJlcigpO1xyXG4gICAgICAgICAgICBpZiAoKHlpZWxkIHByb3ZpZGVyLmdldENvZGUoY29udHJhY3RBZGRyZXNzLCBjdXJyZW50QmxvY2tOdW0pKSA9PT1cclxuICAgICAgICAgICAgICAgIEVUSF9OVUxMX1ZBTFVFKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnRyYWN0ICcke2NvbnRyYWN0QWRkcmVzc30nIGRvZXMgbm90IGV4aXN0YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQmluYXJ5IHNlYXJjaCBmb3IgdGhlIGJsb2NrIG51bWJlciB0aGF0IHRoZSBjb250cmFjdCB3YXMgZGVwbG95ZWQgaW4uXHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0QmxvY2sgPSB5aWVsZCBiaW5hcnlTZWFyY2hGaXJzdEJsb2NrKDAsIGN1cnJlbnRCbG9ja051bSArIDEsIGNvbnRyYWN0QWRkcmVzcywgdGhpcy5jb25maWcpO1xyXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCB0cmFuc2FjdGlvbiBpbiB0aGUgYmxvY2sgdGhhdCBtYXRjaGVzIHRoZSBwcm92aWRlZCBhZGRyZXNzLlxyXG4gICAgICAgICAgICBjb25zdCB0eFJlY2VpcHRzID0geWllbGQgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0cyh0aGlzLmNvbmZpZywge1xyXG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHRvSGV4KGZpcnN0QmxvY2spXHJcbiAgICAgICAgICAgIH0sICdmaW5kQ29udHJhY3REZXBsb3llcicpO1xyXG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZ1JlY2VpcHQgPSAoX2EgPSB0eFJlY2VpcHRzLnJlY2VpcHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZChyZWNlaXB0ID0+IHJlY2VpcHQuY29udHJhY3RBZGRyZXNzID09PSBjb250cmFjdEFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkZXBsb3llckFkZHJlc3M6IG1hdGNoaW5nUmVjZWlwdCA9PT0gbnVsbCB8fCBtYXRjaGluZ1JlY2VpcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdGNoaW5nUmVjZWlwdC5mcm9tLFxyXG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IGZpcnN0QmxvY2tcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldFRva2VuQmFsYW5jZXMoYWRkcmVzc09yTmFtZSwgY29udHJhY3RBZGRyZXNzZXNPck9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHByb3ZpZGVyLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb250cmFjdEFkZHJlc3Nlc09yT3B0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb250cmFjdEFkZHJlc3Nlc09yT3B0aW9ucy5sZW5ndGggPiAxNTAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IHBhc3MgaW4gbW9yZSB0aGFuIDE1MDAgY29udHJhY3QgYWRkcmVzc2VzIHRvIGdldFRva2VuQmFsYW5jZXMoKScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyYWN0QWRkcmVzc2VzT3JPcHRpb25zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0VG9rZW5CYWxhbmNlcygpIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBjb250cmFjdEFkZHJlc3Mgd2hlbiB1c2luZyBhbiBhcnJheScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLl9zZW5kKCdhbGNoZW15X2dldFRva2VuQmFsYW5jZXMnLCBbYWRkcmVzcywgY29udHJhY3RBZGRyZXNzZXNPck9wdGlvbnNdLCAnZ2V0VG9rZW5CYWxhbmNlcycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5UeXBlID0gY29udHJhY3RBZGRyZXNzZXNPck9wdGlvbnMgPT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Ub2tlbkJhbGFuY2VUeXBlLkVSQzIwXHJcbiAgICAgICAgICAgICAgICAgICAgOiBjb250cmFjdEFkZHJlc3Nlc09yT3B0aW9ucy50eXBlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gW2FkZHJlc3MsIHRva2VuVHlwZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoKGNvbnRyYWN0QWRkcmVzc2VzT3JPcHRpb25zID09PSBudWxsIHx8IGNvbnRyYWN0QWRkcmVzc2VzT3JPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250cmFjdEFkZHJlc3Nlc09yT3B0aW9ucy50eXBlKSA9PT0gZXhwb3J0cy5Ub2tlbkJhbGFuY2VUeXBlLkVSQzIwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzZXNPck9wdGlvbnMucGFnZUtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHsgcGFnZUtleTogY29udHJhY3RBZGRyZXNzZXNPck9wdGlvbnMucGFnZUtleSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5fc2VuZCgnYWxjaGVteV9nZXRUb2tlbkJhbGFuY2VzJywgcGFyYW1zLCAnZ2V0VG9rZW5CYWxhbmNlcycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHRva2VucyB0aGF0IHRoZSBzcGVjaWZpZWQgYWRkcmVzcyBvd25zLCBhbG9uZyB3aXRoIHRoZSBhbW91bnRcclxuICAgICAqIG9mIGVhY2ggdG9rZW4gYW5kIHRoZSByZWxldmFudCBtZXRhZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzc09yTmFtZSBUaGUgb3duZXIgYWRkcmVzcyB0byBnZXQgdGhlIHRva2VucyB3aXRoIGJhbGFuY2VzIGZvci5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSByZXF1ZXN0LlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRUb2tlbnNGb3JPd25lcihhZGRyZXNzT3JOYW1lLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0geWllbGQgcHJvdmlkZXIuX2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IFtcclxuICAgICAgICAgICAgICAgIGFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udHJhY3RBZGRyZXNzZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGV4cG9ydHMuVG9rZW5CYWxhbmNlVHlwZS5FUkMyMFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhZ2VLZXkpIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHsgcGFnZUtleTogb3B0aW9ucy5wYWdlS2V5IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gKHlpZWxkIHByb3ZpZGVyLl9zZW5kKCdhbGNoZW15X2dldFRva2VuQmFsYW5jZXMnLCBwYXJhbXMsICdnZXRUb2tlbnNGb3JPd25lcicpKTtcclxuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkQmFsYW5jZXMgPSByZXNwb25zZS50b2tlbkJhbGFuY2VzLm1hcChiYWxhbmNlID0+ICh7XHJcbiAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IGJhbGFuY2UuY29udHJhY3RBZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgcmF3QmFsYW5jZTogYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKGJhbGFuY2UudG9rZW5CYWxhbmNlKS50b1N0cmluZygpXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGFQcm9taXNlcyA9IHlpZWxkIFByb21pc2UuYWxsU2V0dGxlZChyZXNwb25zZS50b2tlbkJhbGFuY2VzLm1hcCh0b2tlbiA9PiBwcm92aWRlci5fc2VuZCgnYWxjaGVteV9nZXRUb2tlbk1ldGFkYXRhJywgW3Rva2VuLmNvbnRyYWN0QWRkcmVzc10sICdnZXRUb2tlbnNGb3JPd25lcicsIFxyXG4gICAgICAgICAgICAvKiBmb3JjZUJhdGNoPSAqLyB0cnVlKSkpO1xyXG4gICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IG1ldGFkYXRhUHJvbWlzZXMubWFwKHAgPT4gcC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnXHJcbiAgICAgICAgICAgICAgICA/IHAudmFsdWVcclxuICAgICAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGxvZ286IG51bGxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBvd25lZFRva2VucyA9IGZvcm1hdHRlZEJhbGFuY2VzLm1hcCgoYmFsYW5jZSwgaW5kZXgpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYmFsYW5jZSksIG1ldGFkYXRhW2luZGV4XSksIHsgYmFsYW5jZTogbWV0YWRhdGFbaW5kZXhdLmRlY2ltYWxzICE9PSBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgPyB1dGlscy5mb3JtYXRVbml0cyhiYWxhbmNlLnJhd0JhbGFuY2UsIG1ldGFkYXRhW2luZGV4XS5kZWNpbWFscylcclxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCB9KSkpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdG9rZW5zOiBvd25lZFRva2Vucy5tYXAodCA9PiBudWxsc1RvVW5kZWZpbmVkKHQpKSxcclxuICAgICAgICAgICAgICAgIHBhZ2VLZXk6IHJlc3BvbnNlLnBhZ2VLZXlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBtZXRhZGF0YSBmb3IgYSBnaXZlbiB0b2tlbiBjb250cmFjdCBhZGRyZXNzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhZGRyZXNzIFRoZSBjb250cmFjdCBhZGRyZXNzIHRvIGdldCBtZXRhZGF0YSBmb3IuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldFRva2VuTWV0YWRhdGEoYWRkcmVzcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuX3NlbmQoJ2FsY2hlbXlfZ2V0VG9rZW5NZXRhZGF0YScsIFthZGRyZXNzXSwgJ2dldFRva2VuTWV0YWRhdGEnKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldEFzc2V0VHJhbnNmZXJzKHBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldEFzc2V0VHJhbnNmZXJzKHRoaXMuY29uZmlnLCBwYXJhbXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFsbCB0cmFuc2FjdGlvbiByZWNlaXB0cyBmb3IgYSBnaXZlbiBibG9jayBieSBudW1iZXIgb3IgYmxvY2sgaGFzaC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1zIEFuIG9iamVjdCBjb250YWluaW5nIGZpZWxkcyBmb3IgdGhlIHRyYW5zYWN0aW9uIHJlY2VpcHQgcXVlcnkuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGdldFRyYW5zYWN0aW9uUmVjZWlwdHMocGFyYW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0VHJhbnNhY3Rpb25SZWNlaXB0cyh0aGlzLmNvbmZpZywgcGFyYW1zKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBvd25lciBhZGRyZXNzIGZvciB0aGUgcHJvdmlkZWQgRU5TIGFkZHJlc3MsIG9yIGBudWxsYFxyXG4gICAgICogaWYgdGhlIEVOUyBuYW1lIGRvZXMgbm90IGhhdmUgYW4gdW5kZXJseWluZyBhZGRyZXNzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBFTlMgYWRkcmVzcyBuYW1lIHRvIHJlc29sdmUuXHJcbiAgICAgKi9cclxuICAgIHJlc29sdmVOYW1lKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLnJlc29sdmVOYW1lKG5hbWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtcyBhIHJldmVyc2UgbG9va3VwIG9mIHRoZSBhZGRyZXNzIGluIEVOUyB1c2luZyB0aGUgUmV2ZXJzZSBSZWdpc3RyYXIuIElmIHRoZSBuYW1lIGRvZXMgbm90IGV4aXN0LCBvciB0aGUgZm9yd2FyZCBsb29rdXAgZG9lcyBub3QgbWF0Y2gsIG51bGwgaXMgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQW4gRU5TIG5hbWUgcmVxdWlyZXMgYWRkaXRpb25hbCBjb25maWd1cmF0aW9uIHRvIHNldHVwIGEgcmV2ZXJzZSByZWNvcmQsIHNvIG5vdCBhbGwgRU5TIGFkZHJlc3NlcyB3aWxsIG1hcCBiYWNrIHRvIHRoZSBvcmlnaW5hbCBFTlMgZG9tYWluLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhZGRyZXNzIFRoZSBhZGRyZXNzIHRvIGxvb2sgdXAgdGhlIEVOUyBkb21haW4gbmFtZSBmb3IuXHJcbiAgICAgKi9cclxuICAgIGxvb2t1cEFkZHJlc3MoYWRkcmVzcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIubG9va3VwQWRkcmVzcyhhZGRyZXNzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggYmV0d2VlbiBhbiBpbnRlZ2VyIHJhbmdlIG9mIGJsb2NrIG51bWJlcnMgdG8gZmluZCB0aGVcclxuICogYmxvY2sgbnVtYmVyIHdoZXJlIHRoZSBjb250cmFjdCB3YXMgZGVwbG95ZWQuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoRmlyc3RCbG9jayhzdGFydCwgZW5kLCBhZGRyZXNzLCBjb25maWcpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBpZiAoc3RhcnQgPj0gZW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgY29uc3QgY29kZSA9IHlpZWxkIHByb3ZpZGVyLmdldENvZGUoYWRkcmVzcywgbWlkKTtcclxuICAgICAgICBpZiAoY29kZSA9PT0gRVRIX05VTExfVkFMVUUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJpbmFyeVNlYXJjaEZpcnN0QmxvY2sobWlkICsgMSwgZW5kLCBhZGRyZXNzLCBjb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmluYXJ5U2VhcmNoRmlyc3RCbG9jayhzdGFydCwgbWlkLCBhZGRyZXNzLCBjb25maWcpO1xyXG4gICAgfSk7XHJcbn1cblxuLyoqXHJcbiAqIFRoZSBEZWJ1ZyBuYW1lc3BhY2UgY29udGFpbnMgbWV0aG9kcyB0byBhY2Nlc3MgdGhlIG5vbi1zdGFuZGFyZCBSUEMgbWV0aG9kc1xyXG4gKiBmb3IgaW5zcGVjdGluZyBhbmQgZGVidWdnaW5nIHRyYW5zYWN0aW9ucy5cclxuICpcclxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlIGRpZmZlcmVudCBtZXRob2RzIGFuZCB1c2UgY2FzZXMgcGxlYXNlIHJlYWQgb3VyXHJcbiAqIFtkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MuYWxjaGVteS5jb20vcmVmZXJlbmNlL2RlYnVnLWFwaS1xdWlja3N0YXJ0KS5cclxuICpcclxuICogRG8gbm90IGNhbGwgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS4gSW5zdGVhZCwgaW5zdGFudGlhdGUgYW4gQWxjaGVteSBvYmplY3RcclxuICogd2l0aCBgY29uc3QgYWxjaGVteSA9IG5ldyBBbGNoZW15KGNvbmZpZylgIGFuZCB0aGVuIGFjY2VzcyB0aGUgZGVidWcgbmFtZXNwYWNlXHJcbiAqIHZpYSBgYWxjaGVteS5kZWJ1Z2AuXHJcbiAqL1xyXG5jbGFzcyBEZWJ1Z05hbWVzcGFjZSB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIH1cclxuICAgIHRyYWNlQ2FsbCh0cmFuc2FjdGlvbiwgYmxvY2tJZGVudGlmaWVyLCB0cmFjZXIpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gW3RyYW5zYWN0aW9uLCBibG9ja0lkZW50aWZpZXIsIHBhcnNlVHJhY2VyUGFyYW1zKHRyYWNlcildO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuX3NlbmQoJ2RlYnVnX3RyYWNlQ2FsbCcsIHBhcmFtcywgJ3RyYWNlQ2FsbCcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdHJhY2VUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gsIHRyYWNlciwgdGltZW91dCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBbdHJhbnNhY3Rpb25IYXNoLCBwYXJzZVRyYWNlclBhcmFtcyh0cmFjZXIsIHRpbWVvdXQpXTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLl9zZW5kKCdkZWJ1Z190cmFjZVRyYW5zYWN0aW9uJywgcGFyYW1zLCAndHJhY2VUcmFuc2FjdGlvbicpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdHJhY2VCbG9jayhibG9ja0lkZW50aWZpZXIsIHRyYWNlcikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBsZXQgbWV0aG9kO1xyXG4gICAgICAgICAgICBsZXQgcGFyYW1zO1xyXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNIZXhTdHJpbmcoYmxvY2tJZGVudGlmaWVyLCAzMikpIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZCA9ICdkZWJ1Z190cmFjZUJsb2NrQnlIYXNoJztcclxuICAgICAgICAgICAgICAgIHBhcmFtcyA9IFtibG9ja0lkZW50aWZpZXIsIHBhcnNlVHJhY2VyUGFyYW1zKHRyYWNlcildO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gJ2RlYnVnX3RyYWNlQmxvY2tCeU51bWJlcic7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IHR5cGVvZiBibG9ja0lkZW50aWZpZXIgPT09ICdudW1iZXInXHJcbiAgICAgICAgICAgICAgICAgICAgPyB1dGlscy5oZXhTdHJpcFplcm9zKHV0aWxzLmhleFZhbHVlKGJsb2NrSWRlbnRpZmllcikpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBibG9ja0lkZW50aWZpZXI7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBbYmxvY2ssIHBhcnNlVHJhY2VyUGFyYW1zKHRyYWNlcildO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5fc2VuZChtZXRob2QsIHBhcmFtcywgJ3RyYWNlQmxvY2snKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXJzZVRyYWNlclBhcmFtcyh0cmFjZXIsIHRpbWVvdXQpIHtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgdHJhY2VyOiB0cmFjZXIudHlwZSB9LCAodHJhY2VyLm9ubHlUb3BDYWxsICE9PSB1bmRlZmluZWQgJiYge1xyXG4gICAgICAgIHRyYWNlckNvbmZpZzoge1xyXG4gICAgICAgICAgICBvbmx5VG9wQ2FsbDogdHJhY2VyLm9ubHlUb3BDYWxsLFxyXG4gICAgICAgICAgICB0aW1lb3V0XHJcbiAgICAgICAgfVxyXG4gICAgfSkpO1xyXG59XG5cbmZ1bmN0aW9uIHNhbml0aXplVG9rZW5UeXBlKHRva2VuVHlwZSkge1xyXG4gICAgaWYgKHRva2VuVHlwZSA9PT0gZXhwb3J0cy5OZnRUb2tlblR5cGUuRVJDMTE1NSB8fCB0b2tlblR5cGUgPT09IGV4cG9ydHMuTmZ0VG9rZW5UeXBlLkVSQzcyMSkge1xyXG4gICAgICAgIHJldHVybiB0b2tlblR5cGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XG5cbi8qKlxyXG4gKiBUaGUgU0RLIGhhcyA0IGxvZyBsZXZlbHMgYW5kIGEgNXRoIG9wdGlvbiBmb3IgZGlzYWJsaW5nIGFsbCBsb2dnaW5nLiBCeVxyXG4gKiBkZWZhdWx0LCB0aGUgbG9nIGxldmVsIGlzIHNldCB0byBJTkZPLlxyXG4gKlxyXG4gKiBUaGUgb3JkZXIgaXMgYSBmb2xsb3dzOiBERUJVRyA8IElORk8gPCBXQVJOIDwgRVJST1JcclxuICpcclxuICogQWxsIGxvZyB0eXBlcyBhYm92ZSB0aGUgY3VycmVudCBsb2cgbGV2ZWwgd2lsbCBiZSBvdXRwdXR0ZWQuXHJcbiAqL1xyXG52YXIgTG9nTGV2ZWw7XHJcbihmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiREVCVUdcIl0gPSAwXSA9IFwiREVCVUdcIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiSU5GT1wiXSA9IDFdID0gXCJJTkZPXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIldBUk5cIl0gPSAyXSA9IFwiV0FSTlwiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJFUlJPUlwiXSA9IDNdID0gXCJFUlJPUlwiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJTSUxFTlRcIl0gPSA0XSA9IFwiU0lMRU5UXCI7XHJcbn0pKExvZ0xldmVsIHx8IChMb2dMZXZlbCA9IHt9KSk7XHJcbmNvbnN0IGxvZ0xldmVsU3RyaW5nVG9FbnVtID0ge1xyXG4gICAgZGVidWc6IExvZ0xldmVsLkRFQlVHLFxyXG4gICAgaW5mbzogTG9nTGV2ZWwuSU5GTyxcclxuICAgIHdhcm46IExvZ0xldmVsLldBUk4sXHJcbiAgICBlcnJvcjogTG9nTGV2ZWwuRVJST1IsXHJcbiAgICBzaWxlbnQ6IExvZ0xldmVsLlNJTEVOVFxyXG59O1xyXG4vLyBIQUNLWTogVXNlIHRoZSBjb25zb2xlIG1ldGhvZCBhcyBhIHN0cmluZyByYXRoZXIgdGhhbiB0aGUgZnVuY3Rpb24gaXRzZWxmXHJcbi8vIGluIG9yZGVyIHRvIGFsbG93IGZvciBtb2NraW5nIGluIHRlc3RzLlxyXG5jb25zdCBsb2dMZXZlbFRvQ29uc29sZUZuID0ge1xyXG4gICAgW0xvZ0xldmVsLkRFQlVHXTogJ2xvZycsXHJcbiAgICBbTG9nTGV2ZWwuSU5GT106ICdpbmZvJyxcclxuICAgIFtMb2dMZXZlbC5XQVJOXTogJ3dhcm4nLFxyXG4gICAgW0xvZ0xldmVsLkVSUk9SXTogJ2Vycm9yJ1xyXG59O1xyXG5jb25zdCBERUZBVUxUX0xPR19MRVZFTCA9IExvZ0xldmVsLklORk87XHJcbi8qKlxyXG4gKiBDb25maWd1cmVzIHRoZSB2ZXJib3NpdHkgb2YgbG9nZ2luZy4gVGhlIGRlZmF1bHQgbG9nIGxldmVsIGlzIGBpbmZvYC5cclxuICpcclxuICogQHBhcmFtIGxvZ0xldmVsIC0gVGhlIHZlcmJvc2l0eSBvZiBsb2dnaW5nLiBDYW4gYmUgYW55IG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxyXG4gKlxyXG4gKiAgIC0gYGRlYnVnYDogVGhlIG1vc3QgdmVyYm9zZSBsb2dnaW5nIGxldmVsLlxyXG4gKiAgIC0gYGluZm9gOiBUaGUgZGVmYXVsdCBsb2dnaW5nIGxldmVsLlxyXG4gKiAgIC0gYHdhcm5gOiBBIGxvZ2dpbmcgbGV2ZWwgZm9yIG5vbi1jcml0aWNhbCBpc3N1ZXMuXHJcbiAqICAgLSBgZXJyb3JgOiBBIGxvZ2dpbmcgbGV2ZWwgZm9yIGNyaXRpY2FsIGlzc3Vlcy5cclxuICogICAtIGBzaWxlbnRgOiBUdXJuIG9mZiBhbGwgbG9nZ2luZy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobG9nTGV2ZWwpIHtcclxuICAgIGxvZ2dlckNsaWVudC5sb2dMZXZlbCA9IGxvZ0xldmVsU3RyaW5nVG9FbnVtW2xvZ0xldmVsXTtcclxufVxyXG5mdW5jdGlvbiBsb2dEZWJ1ZyhtZXNzYWdlLCAuLi5hcmdzKSB7XHJcbiAgICBsb2dnZXJDbGllbnQuZGVidWcobWVzc2FnZSwgYXJncyk7XHJcbn1cclxuZnVuY3Rpb24gbG9nSW5mbyhtZXNzYWdlLCAuLi5hcmdzKSB7XHJcbiAgICBsb2dnZXJDbGllbnQuaW5mbyhtZXNzYWdlLCBhcmdzKTtcclxufVxyXG5mdW5jdGlvbiBsb2dXYXJuKG1lc3NhZ2UsIC4uLmFyZ3MpIHtcclxuICAgIGxvZ2dlckNsaWVudC53YXJuKG1lc3NhZ2UsIGFyZ3MpO1xyXG59XHJcbmNsYXNzIExvZ2dlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKiogVGhlIGxvZyBsZXZlbCBvZiB0aGUgZ2l2ZW4gTG9nZ2VyIGluc3RhbmNlLiAqL1xyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gREVGQVVMVF9MT0dfTEVWRUw7XHJcbiAgICB9XHJcbiAgICBnZXQgbG9nTGV2ZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0xldmVsO1xyXG4gICAgfVxyXG4gICAgc2V0IGxvZ0xldmVsKHZhbCkge1xyXG4gICAgICAgIGlmICghKHZhbCBpbiBMb2dMZXZlbCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2YWx1ZSBcIiR7dmFsfVwiIGFzc2lnbmVkIHRvIFxcYGxvZ0xldmVsXFxgYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gdmFsO1xyXG4gICAgfVxyXG4gICAgZGVidWcoLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX2xvZyhMb2dMZXZlbC5ERUJVRywgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBpbmZvKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl9sb2coTG9nTGV2ZWwuSU5GTywgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICB3YXJuKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl9sb2coTG9nTGV2ZWwuV0FSTiwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBlcnJvciguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nKExvZ0xldmVsLkVSUk9SLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRm9yd2FyZHMgbG9nIG1lc3NhZ2VzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgY29uc29sZSBjb3VudGVycGFydHMgaWYgdGhlXHJcbiAgICAgKiBsb2cgbGV2ZWwgYWxsb3dzIGl0LlxyXG4gICAgICovXHJcbiAgICBfbG9nKGxvZ0xldmVsLCAuLi5hcmdzKSB7XHJcbiAgICAgICAgaWYgKGxvZ0xldmVsIDwgdGhpcy5fbG9nTGV2ZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgICAgICAgY29uc3QgbWV0aG9kID0gbG9nTGV2ZWxUb0NvbnNvbGVGbltsb2dMZXZlbF07XHJcbiAgICAgICAgaWYgKG1ldGhvZCkge1xyXG4gICAgICAgICAgICBjb25zb2xlW21ldGhvZF0oYFske25vd31dIEFsY2hlbXk6YCwgLi4uYXJncy5tYXAoc3RyaW5naWZ5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExvZ2dlciByZWNlaXZlZCBhbiBpbnZhbGlkIGxvZ0xldmVsICh2YWx1ZTogJHtsb2dMZXZlbH0pYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeShvYmopIHtcclxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gRmFpbGVkIHRvIGNvbnZlcnQgdG8gSlNPTiwgbG9nIHRoZSBvYmplY3QgZGlyZWN0bHkuXHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIEluc3RhbnRpYXRlIGRlZmF1bHQgbG9nZ2VyIGZvciB0aGUgU0RLLlxyXG5jb25zdCBsb2dnZXJDbGllbnQgPSBuZXcgTG9nZ2VyKCk7XG5cbi8vIFRoaXMgZmlsZSBpcyBhdXRvZ2VuZXJhdGVkIGJ5IGluamVjdFZlcnNpb24uanMuIEFueSBjaGFuZ2VzIHdpbGwgYmVcclxuLy8gb3ZlcndyaXR0ZW4gb24gY29tbWl0IVxyXG5jb25zdCBWRVJTSU9OID0gJzMuMS4wJztcblxuLyoqXHJcbiAqIEdpdmVuIGEgUkVTVCBlbmRwb2ludCwgbWV0aG9kLCBhbmQgcGFyYW1zLCBzZW5kcyB0aGUgcmVxdWVzdCB3aXRoIGF4aW9zIGFuZFxyXG4gKiByZXR1cm5zIHRoZSByZXNwb25zZS5cclxuICovXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gc2VuZCBodHRwIHJlcXVlc3RzIHVzaW5nIEF4aXMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzZW5kQXhpb3NSZXF1ZXN0KGJhc2VVcmwsIHJlc3RBcGlOYW1lLCBtZXRob2ROYW1lLCBwYXJhbXMsIG92ZXJyaWRlcykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgcmVxdWVzdFVybCA9IGJhc2VVcmwgKyAnLycgKyByZXN0QXBpTmFtZTtcclxuICAgIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3ZlcnJpZGVzKSwgeyBoZWFkZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3ZlcnJpZGVzID09PSBudWxsIHx8IG92ZXJyaWRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3ZlcnJpZGVzLmhlYWRlcnMpLCAoIUlTX0JST1dTRVIgJiYgeyAnQWNjZXB0LUVuY29kaW5nJzogJ2d6aXAnIH0pKSwgeyAnQWxjaGVteS1FdGhlcnMtU2RrLVZlcnNpb24nOiBWRVJTSU9OLCAnQWxjaGVteS1FdGhlcnMtU2RrLU1ldGhvZCc6IG1ldGhvZE5hbWUgfSksIG1ldGhvZDogKF9hID0gb3ZlcnJpZGVzID09PSBudWxsIHx8IG92ZXJyaWRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3ZlcnJpZGVzLm1ldGhvZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ0dFVCcsIHVybDogcmVxdWVzdFVybCwgcGFyYW1zIH0pO1xyXG4gICAgcmV0dXJuIGF4aW9zX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjb25maWcpO1xyXG59XG5cbmNvbnN0IERFRkFVTFRfQkFDS09GRl9JTklUSUFMX0RFTEFZX01TID0gMTAwMDtcclxuY29uc3QgREVGQVVMVF9CQUNLT0ZGX01VTFRJUExJRVIgPSAxLjU7XHJcbmNvbnN0IERFRkFVTFRfQkFDS09GRl9NQVhfREVMQVlfTVMgPSAzMCAqIDEwMDA7XHJcbmNvbnN0IERFRkFVTFRfQkFDS09GRl9NQVhfQVRURU1QVFMgPSA1O1xyXG4vKipcclxuICogSGVscGVyIGNsYXNzIGZvciBpbXBsZW1lbnRpbmcgZXhwb25lbnRpYWwgYmFja29mZiBhbmQgbWF4IHJldHJ5IGF0dGVtcHRzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIEV4cG9uZW50aWFsQmFja29mZiB7XHJcbiAgICBjb25zdHJ1Y3RvcihtYXhBdHRlbXB0cyA9IERFRkFVTFRfQkFDS09GRl9NQVhfQVRURU1QVFMpIHtcclxuICAgICAgICB0aGlzLm1heEF0dGVtcHRzID0gbWF4QXR0ZW1wdHM7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsRGVsYXlNcyA9IERFRkFVTFRfQkFDS09GRl9JTklUSUFMX0RFTEFZX01TO1xyXG4gICAgICAgIHRoaXMuYmFja29mZk11bHRpcGxpZXIgPSBERUZBVUxUX0JBQ0tPRkZfTVVMVElQTElFUjtcclxuICAgICAgICB0aGlzLm1heERlbGF5TXMgPSBERUZBVUxUX0JBQ0tPRkZfTUFYX0RFTEFZX01TO1xyXG4gICAgICAgIHRoaXMubnVtQXR0ZW1wdHMgPSAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudERlbGF5TXMgPSAwO1xyXG4gICAgICAgIHRoaXMuaXNJbkJhY2tvZmYgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB0aGUgdGhlIGJhY2tvZmYgZGVsYXkuIFRoZSBkZWxheSBpc1xyXG4gICAgICogaW5jcmVhc2VkIGZvciBlYWNoIGF0dGVtcHQuIFRoZSBwcm9taXNlIGlzIHJlamVjdGVkIGlmIHRoZSBtYXhpbXVtIG51bWJlclxyXG4gICAgICogb2YgYXR0ZW1wdHMgaXMgZXhjZWVkZWQuXHJcbiAgICAgKi9cclxuICAgIC8vIFRPRE86IGJlYXV0aWZ5IHRoaXMgaW50byBhbiBhc3luYyBpdGVyYXRvci5cclxuICAgIGJhY2tvZmYoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubnVtQXR0ZW1wdHMgPj0gdGhpcy5tYXhBdHRlbXB0cykge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBFeGNlZWRlZCBtYXhpbXVtIG51bWJlciBvZiBhdHRlbXB0czogJHt0aGlzLm1heEF0dGVtcHRzfWApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNJbkJhY2tvZmYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignQSBiYWNrb2ZmIG9wZXJhdGlvbiBpcyBhbHJlYWR5IGluIHByb2dyZXNzJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBiYWNrb2ZmRGVsYXlXaXRoSml0dGVyTXMgPSB0aGlzLndpdGhKaXR0ZXJNcyh0aGlzLmN1cnJlbnREZWxheU1zKTtcclxuICAgICAgICBpZiAoYmFja29mZkRlbGF5V2l0aEppdHRlck1zID4gMCkge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZygnRXhwb25lbnRpYWxCYWNrb2ZmLmJhY2tvZmYnLCBgQmFja2luZyBvZmYgZm9yICR7YmFja29mZkRlbGF5V2l0aEppdHRlck1zfW1zYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbmV4dCBkZWxheS5cclxuICAgICAgICB0aGlzLmN1cnJlbnREZWxheU1zICo9IHRoaXMuYmFja29mZk11bHRpcGxpZXI7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RGVsYXlNcyA9IE1hdGgubWF4KHRoaXMuY3VycmVudERlbGF5TXMsIHRoaXMuaW5pdGlhbERlbGF5TXMpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudERlbGF5TXMgPSBNYXRoLm1pbih0aGlzLmN1cnJlbnREZWxheU1zLCB0aGlzLm1heERlbGF5TXMpO1xyXG4gICAgICAgIHRoaXMubnVtQXR0ZW1wdHMgKz0gMTtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNJbkJhY2tvZmYgPSB0cnVlO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNJbkJhY2tvZmYgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSwgYmFja29mZkRlbGF5V2l0aEppdHRlck1zKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyArLy0gNTAlIGppdHRlciB0byB0aGUgYmFja29mZiBkZWxheSwgdXAgdG8gdGhlIG1heCBkZWxheSBjYXAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSBkZWxheU1zXHJcbiAgICAgKi9cclxuICAgIHdpdGhKaXR0ZXJNcyhkZWxheU1zKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKGRlbGF5TXMgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBkZWxheU1zLCB0aGlzLm1heERlbGF5TXMpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBBIHdyYXBwZXIgZnVuY3Rpb24gdG8gbWFrZSBodHRwIHJlcXVlc3RzIGFuZCByZXRyeSBpZiB0aGUgcmVxdWVzdCBmYWlscy5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG4vLyBUT0RPOiBXcmFwIEF4aW9zIGVycm9yIGluIEFsY2hlbXlFcnJvci5cclxuZnVuY3Rpb24gcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIGFwaVR5cGUsIHJlc3RBcGlOYW1lLCBtZXRob2ROYW1lLCBwYXJhbXMsIG92ZXJyaWRlcykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGxldCBsYXN0RXJyb3IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3QgYmFja29mZiA9IG5ldyBFeHBvbmVudGlhbEJhY2tvZmYoY29uZmlnLm1heFJldHJpZXMpO1xyXG4gICAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgY29uZmlnLm1heFJldHJpZXMgKyAxOyBhdHRlbXB0KyspIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChsYXN0RXJyb3IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0luZm8oJ3JlcXVlc3RIdHRwJywgYFJldHJ5aW5nIGFmdGVyIGVycm9yOiAke2xhc3RFcnJvci5tZXNzYWdlfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCBiYWNrb2ZmLmJhY2tvZmYoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBCYWNrb2ZmIGVycm9ycyB3aGVuIHRoZSBtYXhpbXVtIG51bWJlciBvZiBhdHRlbXB0cyBpcyByZWFjaGVkLiBCcmVha1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG91dCBvZiB0aGUgbG9vcCB0byBwcmVzZXJ2ZSB0aGUgbGFzdCBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgc2VuZEF4aW9zUmVxdWVzdChjb25maWcuX2dldFJlcXVlc3RVcmwoYXBpVHlwZSksIHJlc3RBcGlOYW1lLCBtZXRob2ROYW1lLCBwYXJhbXMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3ZlcnJpZGVzKSwgeyB0aW1lb3V0OiBjb25maWcucmVxdWVzdFRpbWVvdXQgfSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcocmVzdEFwaU5hbWUsIGBTdWNjZXNzZnVsIHJlcXVlc3Q6ICR7cmVzdEFwaU5hbWV9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dJbmZvKHJlc3RBcGlOYW1lLCBgUmVxdWVzdCBmYWlsZWQ6ICR7cmVzdEFwaU5hbWV9LCAke3Jlc3BvbnNlLnN0YXR1c30sICR7cmVzcG9uc2UuZGF0YX1gKTtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPSBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzICsgJzogJyArIHJlc3BvbnNlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghYXhpb3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmlzQXhpb3NFcnJvcihlcnIpIHx8IGVyci5yZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogU3RhbmRhcmRpemUgYWxsIGVycm9ycyBpbnRvIEFsY2hlbXlFcnJvclxyXG4gICAgICAgICAgICAgICAgbGFzdEVycm9yID0gbmV3IEVycm9yKGVyci5yZXNwb25zZS5zdGF0dXMgKyAnOiAnICsgZXJyLnJlc3BvbnNlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1JldHJ5YWJsZUh0dHBFcnJvcihlcnIsIGFwaVR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGxhc3RFcnJvcik7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBpc1JldHJ5YWJsZUh0dHBFcnJvcihlcnIsIGFwaVR5cGUpIHtcclxuICAgIC8vIFRPRE86IHJlbW92ZSA1MDBzIGFmdGVyIHdlYmhvb2tzIGFyZSBtb3JlIHN0YWJsZS5cclxuICAgIGNvbnN0IHJldHJ5YWJsZUNvZGVzID0gYXBpVHlwZSA9PT0gQWxjaGVteUFwaVR5cGUuV0VCSE9PSyA/IFs0MjksIDUwMF0gOiBbNDI5XTtcclxuICAgIHJldHVybiAoZXJyLnJlc3BvbnNlICE9PSB1bmRlZmluZWQgJiYgcmV0cnlhYmxlQ29kZXMuaW5jbHVkZXMoZXJyLnJlc3BvbnNlLnN0YXR1cykpO1xyXG59XHJcbi8qKlxyXG4gKiBGZXRjaGVzIGFsbCBwYWdlcyBpbiBhIHBhZ2luYXRlZCBlbmRwb2ludCwgZ2l2ZW4gYSBgcGFnZUtleWAgZmllbGQgdGhhdFxyXG4gKiByZXByZXNlbnRzIHRoZSBwcm9wZXJ0eSBuYW1lIGNvbnRhaW5pbmcgdGhlIG5leHQgcGFnZSB0b2tlbi5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBwYWdpbmF0ZUVuZHBvaW50KGNvbmZpZywgYXBpVHlwZSwgcmVzdEFwaU5hbWUsIG1ldGhvZE5hbWUsIHJlcVBhZ2VLZXksIHJlc1BhZ2VLZXksIHBhcmFtcykge1xyXG4gICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogcGFnaW5hdGVFbmRwb2ludF8xKCkge1xyXG4gICAgICAgIGxldCBoYXNOZXh0ID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKTtcclxuICAgICAgICB3aGlsZSAoaGFzTmV4dCkge1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIF9fYXdhaXQocmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIGFwaVR5cGUsIHJlc3RBcGlOYW1lLCBtZXRob2ROYW1lLCByZXF1ZXN0UGFyYW1zKSk7XHJcbiAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbcmVzUGFnZUtleV0gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RQYXJhbXNbcmVxUGFnZUtleV0gPSByZXNwb25zZVtyZXNQYWdlS2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhhc05leHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIHVuZGVybHlpbmcgaW1wbGVtZW50YXRpb25zIGZvciBleHBvc2VkIEFQSSBzdXJmYWNlIGluXHJcbiAqIHRoZSB7QGxpbmsgTmZ0TmFtZXNwYWNlfS4gQnkgbW92aW5nIHRoZSBtZXRob2RzIG91dCBpbnRvIGEgc2VwYXJhdGUgZmlsZSxcclxuICogb3RoZXIgbmFtZXNwYWNlcyBjYW4gYWNjZXNzIHRoZXNlIG1ldGhvZHMgd2l0aG91dCBkZXBlbmRpbmcgb24gdGhlIGVudGlyZVxyXG4gKiBOZnROYW1lc3BhY2UuXHJcbiAqL1xyXG4vKipcclxuICogR2V0IHRoZSBORlQgbWV0YWRhdGEgZm9yIHRoZSBwcm92aWRlZCBjb250cmFjdCBhZGRyZXNzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TmZ0TWV0YWRhdGEoY29uZmlnLCBjb250cmFjdEFkZHJlc3MsIHRva2VuSWQsIG9wdGlvbnMsIHNyY01ldGhvZCA9ICdnZXROZnRNZXRhZGF0YScpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5ORlQsICdnZXRORlRNZXRhZGF0YScsIHNyY01ldGhvZCwge1xyXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3MsXHJcbiAgICAgICAgICAgIHRva2VuSWQ6IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbSh0b2tlbklkKS50b1N0cmluZygpLFxyXG4gICAgICAgICAgICB0b2tlblR5cGU6IHNhbml0aXplVG9rZW5UeXBlKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b2tlblR5cGUpLFxyXG4gICAgICAgICAgICB0b2tlblVyaVRpbWVvdXRJbk1zOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudG9rZW5VcmlUaW1lb3V0SW5NcyxcclxuICAgICAgICAgICAgcmVmcmVzaENhY2hlOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVmcmVzaENhY2hlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGdldE5mdEZyb21SYXcocmVzcG9uc2UpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmZ0TWV0YWRhdGFCYXRjaChjb25maWcsIHRva2Vucywgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XHJcbiAgICAgICAgICAgIHRva2VucyxcclxuICAgICAgICAgICAgdG9rZW5VcmlUaW1lb3V0SW5Nczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRva2VuVXJpVGltZW91dEluTXMsXHJcbiAgICAgICAgICAgIHJlZnJlc2hDYWNoZTogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlZnJlc2hDYWNoZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAnZ2V0TkZUTWV0YWRhdGFCYXRjaCcsICdnZXROZnRNZXRhZGF0YUJhdGNoJywge30sIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGRhdGFcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZnRzOiByZXNwb25zZS5uZnRzLm1hcChuZnQgPT4gZ2V0TmZ0RnJvbVJhdyhuZnQpKVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRDb250cmFjdE1ldGFkYXRhKGNvbmZpZywgY29udHJhY3RBZGRyZXNzLCBzcmNNZXRob2QgPSAnZ2V0Q29udHJhY3RNZXRhZGF0YScpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5ORlQsICdnZXRDb250cmFjdE1ldGFkYXRhJywgc3JjTWV0aG9kLCB7XHJcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBnZXROZnRDb250cmFjdEZyb21SYXcocmVzcG9uc2UpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q29udHJhY3RNZXRhZGF0YUJhdGNoKGNvbmZpZywgY29udHJhY3RBZGRyZXNzZXMpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5ORlQsICdnZXRDb250cmFjdE1ldGFkYXRhQmF0Y2gnLCAnZ2V0Q29udHJhY3RNZXRhZGF0YUJhdGNoJywge30sIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGRhdGE6IHsgY29udHJhY3RBZGRyZXNzZXMgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvbnRyYWN0czogcmVzcG9uc2UuY29udHJhY3RzLm1hcChnZXROZnRDb250cmFjdEZyb21SYXcpXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldENvbGxlY3Rpb25NZXRhZGF0YShjb25maWcsIGNvbGxlY3Rpb25TbHVnLCBzcmNNZXRob2QgPSAnZ2V0Q29sbGVjdGlvbk1ldGFkYXRhJykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ2dldENvbGxlY3Rpb25NZXRhZGF0YScsIHNyY01ldGhvZCwge1xyXG4gICAgICAgICAgICBjb2xsZWN0aW9uU2x1Z1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBnZXROZnRDb2xsZWN0aW9uRnJvbVJhdyhyZXNwb25zZSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXROZnRzRm9yT3duZXJJdGVyYXRvcihjb25maWcsIG93bmVyLCBvcHRpb25zLCBzcmNNZXRob2QgPSAnZ2V0TmZ0c0Zvck93bmVySXRlcmF0b3InKSB7XHJcbiAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBnZXROZnRzRm9yT3duZXJJdGVyYXRvcl8xKCkge1xyXG4gICAgICAgIHZhciBlXzEsIF9hO1xyXG4gICAgICAgIGNvbnN0IHdpdGhNZXRhZGF0YSA9IG9taXRNZXRhZGF0YVRvV2l0aE1ldGFkYXRhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vbWl0TWV0YWRhdGEpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX19hc3luY1ZhbHVlcyhwYWdpbmF0ZUVuZHBvaW50KGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAnZ2V0TkZUc0Zvck93bmVyJywgc3JjTWV0aG9kLCAncGFnZUtleScsICdwYWdlS2V5Jywge1xyXG4gICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzZXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb250cmFjdEFkZHJlc3NlcyxcclxuICAgICAgICAgICAgICAgIHBhZ2VLZXk6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYWdlS2V5LFxyXG4gICAgICAgICAgICAgICAgZXhjbHVkZUZpbHRlcnM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5leGNsdWRlRmlsdGVycyxcclxuICAgICAgICAgICAgICAgIGluY2x1ZGVGaWx0ZXJzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaW5jbHVkZUZpbHRlcnMsXHJcbiAgICAgICAgICAgICAgICBvd25lcixcclxuICAgICAgICAgICAgICAgIHdpdGhNZXRhZGF0YSxcclxuICAgICAgICAgICAgICAgIHRva2VuVXJpVGltZW91dEluTXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b2tlblVyaVRpbWVvdXRJbk1zLFxyXG4gICAgICAgICAgICAgICAgb3JkZXJCeTogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9yZGVyQnlcclxuICAgICAgICAgICAgfSkpLCBfYzsgX2MgPSB5aWVsZCBfX2F3YWl0KF9iLm5leHQoKSksICFfYy5kb25lOykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBfYy52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb3duZWROZnQgb2YgcmVzcG9uc2Uub3duZWROZnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5mdEZyb21HZXROZnRSZXNwb25zZShvd25lZE5mdCkpLCB7IGJhbGFuY2U6IG93bmVkTmZ0LmJhbGFuY2UgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYS5jYWxsKF9iKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5mdHNGb3JPd25lcihjb25maWcsIG93bmVyLCBvcHRpb25zLCBzcmNNZXRob2QgPSAnZ2V0TmZ0c0Zvck93bmVyJykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHdpdGhNZXRhZGF0YSA9IG9taXRNZXRhZGF0YVRvV2l0aE1ldGFkYXRhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vbWl0TWV0YWRhdGEpO1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ2dldE5GVHNGb3JPd25lcicsIHNyY01ldGhvZCwge1xyXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3Nlczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvbnRyYWN0QWRkcmVzc2VzLFxyXG4gICAgICAgICAgICBwYWdlS2V5OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFnZUtleSxcclxuICAgICAgICAgICAgZXhjbHVkZUZpbHRlcnM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5leGNsdWRlRmlsdGVycyxcclxuICAgICAgICAgICAgaW5jbHVkZUZpbHRlcnM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pbmNsdWRlRmlsdGVycyxcclxuICAgICAgICAgICAgb3duZXIsXHJcbiAgICAgICAgICAgIHBhZ2VTaXplOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFnZVNpemUsXHJcbiAgICAgICAgICAgIHdpdGhNZXRhZGF0YSxcclxuICAgICAgICAgICAgdG9rZW5VcmlUaW1lb3V0SW5Nczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRva2VuVXJpVGltZW91dEluTXMsXHJcbiAgICAgICAgICAgIG9yZGVyQnk6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vcmRlckJ5XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHdpdGhNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZCh7XHJcbiAgICAgICAgICAgICAgICBvd25lZE5mdHM6IHJlc3BvbnNlLm93bmVkTmZ0cy5tYXAocmVzID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGdldE5mdEZyb21SYXcocmVzKSksIHsgYmFsYW5jZTogcmVzLmJhbGFuY2UgfSkpKSxcclxuICAgICAgICAgICAgICAgIHBhZ2VLZXk6IHJlc3BvbnNlLnBhZ2VLZXksXHJcbiAgICAgICAgICAgICAgICB0b3RhbENvdW50OiByZXNwb25zZS50b3RhbENvdW50LFxyXG4gICAgICAgICAgICAgICAgdmFsaWRBdDogcmVzcG9uc2UudmFsaWRBdFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQoe1xyXG4gICAgICAgICAgICBvd25lZE5mdHM6IHJlc3BvbnNlLm93bmVkTmZ0cy5tYXAocmVzID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGdldEJhc2VOZnRGcm9tUmF3KHJlcykpLCB7IGJhbGFuY2U6IHJlcy5iYWxhbmNlIH0pKSksXHJcbiAgICAgICAgICAgIHBhZ2VLZXk6IHJlc3BvbnNlLnBhZ2VLZXksXHJcbiAgICAgICAgICAgIHRvdGFsQ291bnQ6IHJlc3BvbnNlLnRvdGFsQ291bnQsXHJcbiAgICAgICAgICAgIHZhbGlkQXQ6IHJlc3BvbnNlLnZhbGlkQXRcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5mdHNGb3JDb250cmFjdChjb25maWcsIGNvbnRyYWN0QWRkcmVzcywgb3B0aW9ucywgc3JjTWV0aG9kID0gJ2dldE5mdHNGb3JDb250cmFjdCcpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCB3aXRoTWV0YWRhdGEgPSBvbWl0TWV0YWRhdGFUb1dpdGhNZXRhZGF0YShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub21pdE1ldGFkYXRhKTtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5ORlQsICdnZXRORlRzRm9yQ29udHJhY3QnLCBzcmNNZXRob2QsIHtcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzLFxyXG4gICAgICAgICAgICBwYWdlS2V5OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFnZUtleSxcclxuICAgICAgICAgICAgd2l0aE1ldGFkYXRhLFxyXG4gICAgICAgICAgICBsaW1pdDogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhZ2VTaXplKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHRva2VuVXJpVGltZW91dEluTXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b2tlblVyaVRpbWVvdXRJbk1zXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHdpdGhNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZCh7XHJcbiAgICAgICAgICAgICAgICBuZnRzOiByZXNwb25zZS5uZnRzLm1hcChyZXMgPT4gZ2V0TmZ0RnJvbVJhdyhyZXMpKSxcclxuICAgICAgICAgICAgICAgIHBhZ2VLZXk6IHJlc3BvbnNlLnBhZ2VLZXlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsc1RvVW5kZWZpbmVkKHtcclxuICAgICAgICAgICAgbmZ0czogcmVzcG9uc2UubmZ0cy5tYXAocmVzID0+IGdldEJhc2VOZnRGcm9tUmF3KHJlcywgY29udHJhY3RBZGRyZXNzKSksXHJcbiAgICAgICAgICAgIHBhZ2VLZXk6IHJlc3BvbnNlLnBhZ2VLZXlcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5mdHNGb3JDb250cmFjdEl0ZXJhdG9yKGNvbmZpZywgY29udHJhY3RBZGRyZXNzLCBvcHRpb25zLCBzcmNNZXRob2QgPSAnZ2V0TmZ0c0ZvckNvbnRyYWN0SXRlcmF0b3InKSB7XHJcbiAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBnZXROZnRzRm9yQ29udHJhY3RJdGVyYXRvcl8xKCkge1xyXG4gICAgICAgIHZhciBlXzIsIF9hO1xyXG4gICAgICAgIGNvbnN0IHdpdGhNZXRhZGF0YSA9IG9taXRNZXRhZGF0YVRvV2l0aE1ldGFkYXRhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vbWl0TWV0YWRhdGEpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX19hc3luY1ZhbHVlcyhwYWdpbmF0ZUVuZHBvaW50KGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAnZ2V0TkZUc0ZvckNvbnRyYWN0Jywgc3JjTWV0aG9kLCAncGFnZUtleScsICdwYWdlS2V5Jywge1xyXG4gICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgcGFnZUtleTogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhZ2VLZXksXHJcbiAgICAgICAgICAgICAgICB3aXRoTWV0YWRhdGFcclxuICAgICAgICAgICAgfSkpLCBfYzsgX2MgPSB5aWVsZCBfX2F3YWl0KF9iLm5leHQoKSksICFfYy5kb25lOykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBfYy52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmZ0IG9mIHJlc3BvbnNlLm5mdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KG5mdEZyb21HZXROZnRDb250cmFjdFJlc3BvbnNlKG5mdCwgY29udHJhY3RBZGRyZXNzKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSB5aWVsZCBfX2F3YWl0KF9hLmNhbGwoX2IpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0T3duZXJzRm9yQ29udHJhY3QoY29uZmlnLCBjb250cmFjdEFkZHJlc3MsIG9wdGlvbnMsIHNyY01ldGhvZCA9ICdnZXRPd25lcnNGb3JDb250cmFjdCcpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAvLyBDYXN0IHRvIGBhbnlgIHRvIGF2b2lkIG1vcmUgdHlwZSB3cmFuZ2xpbmcuXHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAnZ2V0T3duZXJzRm9yQ29udHJhY3QnLCBzcmNNZXRob2QsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgY29udHJhY3RBZGRyZXNzIH0pKTtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndpdGhUb2tlbkJhbGFuY2VzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsc1RvVW5kZWZpbmVkKHtcclxuICAgICAgICAgICAgICAgIG93bmVyczogcmVzcG9uc2VcclxuICAgICAgICAgICAgICAgICAgICAub3duZXJzLFxyXG4gICAgICAgICAgICAgICAgcGFnZUtleTogcmVzcG9uc2UucGFnZUtleVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQoe1xyXG4gICAgICAgICAgICBvd25lcnM6IHJlc3BvbnNlLm93bmVycyxcclxuICAgICAgICAgICAgcGFnZUtleTogcmVzcG9uc2UucGFnZUtleVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q29udHJhY3RzRm9yT3duZXIoY29uZmlnLCBvd25lciwgb3B0aW9ucywgc3JjTWV0aG9kID0gJ2dldENvbnRyYWN0c0Zvck93bmVyJykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ2dldENvbnRyYWN0c0Zvck93bmVyJywgc3JjTWV0aG9kLCB7XHJcbiAgICAgICAgICAgIG93bmVyLFxyXG4gICAgICAgICAgICBleGNsdWRlRmlsdGVyczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmV4Y2x1ZGVGaWx0ZXJzLFxyXG4gICAgICAgICAgICBpbmNsdWRlRmlsdGVyczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmluY2x1ZGVGaWx0ZXJzLFxyXG4gICAgICAgICAgICBwYWdlS2V5OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFnZUtleSxcclxuICAgICAgICAgICAgcGFnZVNpemU6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYWdlU2l6ZSxcclxuICAgICAgICAgICAgb3JkZXJCeTogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9yZGVyQnlcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZCh7XHJcbiAgICAgICAgICAgIGNvbnRyYWN0czogcmVzcG9uc2UuY29udHJhY3RzLm1hcChnZXROZnRDb250cmFjdHNGb3JPd25lckZyb21SYXcpLFxyXG4gICAgICAgICAgICBwYWdlS2V5OiByZXNwb25zZS5wYWdlS2V5LFxyXG4gICAgICAgICAgICB0b3RhbENvdW50OiByZXNwb25zZS50b3RhbENvdW50XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRPd25lcnNGb3JOZnQoY29uZmlnLCBjb250cmFjdEFkZHJlc3MsIHRva2VuSWQsIG9wdGlvbnMsIHNyY01ldGhvZCA9ICdnZXRPd25lcnNGb3JOZnQnKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5ORlQsICdnZXRPd25lcnNGb3JORlQnLCBzcmNNZXRob2QsIE9iamVjdC5hc3NpZ24oeyBjb250cmFjdEFkZHJlc3MsIHRva2VuSWQ6IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbSh0b2tlbklkKS50b1N0cmluZygpIH0sIG9wdGlvbnMpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldE1pbnRlZE5mdHMoY29uZmlnLCBvd25lciwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgY29uc3Qgb3duZXJBZGRyZXNzID0geWllbGQgcHJvdmlkZXIuX2dldEFkZHJlc3Mob3duZXIpO1xyXG4gICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gbmZ0VG9rZW5UeXBlVG9DYXRlZ29yeShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudG9rZW5UeXBlKTtcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XHJcbiAgICAgICAgICAgIGZyb21CbG9jazogJzB4MCcsXHJcbiAgICAgICAgICAgIGZyb21BZGRyZXNzOiBFVEhfTlVMTF9BRERSRVNTLFxyXG4gICAgICAgICAgICB0b0FkZHJlc3M6IG93bmVyQWRkcmVzcyxcclxuICAgICAgICAgICAgZXhjbHVkZVplcm9WYWx1ZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzZXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb250cmFjdEFkZHJlc3NlcyxcclxuICAgICAgICAgICAgY2F0ZWdvcnksXHJcbiAgICAgICAgICAgIG1heENvdW50OiAxMDAsXHJcbiAgICAgICAgICAgIHBhZ2VLZXk6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYWdlS2V5XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGdldEFzc2V0VHJhbnNmZXJzKGNvbmZpZywgcGFyYW1zLCAnZ2V0TWludGVkTmZ0cycpO1xyXG4gICAgICAgIHJldHVybiBnZXROZnRzRm9yVHJhbnNmZXJzKGNvbmZpZywgcmVzcG9uc2UpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHJhbnNmZXJzRm9yT3duZXIoY29uZmlnLCBvd25lciwgdHJhbnNmZXJUeXBlLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCBjb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICBjb25zdCBvd25lckFkZHJlc3MgPSB5aWVsZCBwcm92aWRlci5fZ2V0QWRkcmVzcyhvd25lcik7XHJcbiAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSBuZnRUb2tlblR5cGVUb0NhdGVnb3J5KG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b2tlblR5cGUpO1xyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcclxuICAgICAgICAgICAgZnJvbUJsb2NrOiAnMHgwJyxcclxuICAgICAgICAgICAgZXhjbHVkZVplcm9WYWx1ZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzZXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jb250cmFjdEFkZHJlc3NlcyxcclxuICAgICAgICAgICAgY2F0ZWdvcnksXHJcbiAgICAgICAgICAgIG1heENvdW50OiAxMDAsXHJcbiAgICAgICAgICAgIHBhZ2VLZXk6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYWdlS2V5XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodHJhbnNmZXJUeXBlID09PSBleHBvcnRzLkdldFRyYW5zZmVyc0Zvck93bmVyVHJhbnNmZXJUeXBlLlRPKSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy50b0FkZHJlc3MgPSBvd25lckFkZHJlc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJhbXMuZnJvbUFkZHJlc3MgPSBvd25lckFkZHJlc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRyYW5zZmVyc1Jlc3BvbnNlID0geWllbGQgZ2V0QXNzZXRUcmFuc2ZlcnMoY29uZmlnLCBwYXJhbXMsICdnZXRUcmFuc2ZlcnNGb3JPd25lcicpO1xyXG4gICAgICAgIHJldHVybiBnZXROZnRzRm9yVHJhbnNmZXJzKGNvbmZpZywgdHJhbnNmZXJzUmVzcG9uc2UpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHJhbnNmZXJzRm9yQ29udHJhY3QoY29uZmlnLCBjb250cmFjdCwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gW1xyXG4gICAgICAgICAgICBleHBvcnRzLkFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnkuRVJDNzIxLFxyXG4gICAgICAgICAgICBleHBvcnRzLkFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnkuRVJDMTE1NSxcclxuICAgICAgICAgICAgZXhwb3J0cy5Bc3NldFRyYW5zZmVyc0NhdGVnb3J5LlNQRUNJQUxORlRcclxuICAgICAgICBdO1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgY29uc3QgZnJvbUJsb2NrID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mcm9tQmxvY2spXHJcbiAgICAgICAgICAgID8gcHJvdmlkZXIuZm9ybWF0dGVyLmJsb2NrVGFnKHlpZWxkIHByb3ZpZGVyLl9nZXRCbG9ja1RhZyhvcHRpb25zLmZyb21CbG9jaykpXHJcbiAgICAgICAgICAgIDogJzB4MCc7XHJcbiAgICAgICAgY29uc3QgdG9CbG9jayA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudG9CbG9jaylcclxuICAgICAgICAgICAgPyBwcm92aWRlci5mb3JtYXR0ZXIuYmxvY2tUYWcoeWllbGQgcHJvdmlkZXIuX2dldEJsb2NrVGFnKG9wdGlvbnMudG9CbG9jaykpXHJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcclxuICAgICAgICAgICAgZnJvbUJsb2NrLFxyXG4gICAgICAgICAgICB0b0Jsb2NrLFxyXG4gICAgICAgICAgICBleGNsdWRlWmVyb1ZhbHVlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3NlczogW2NvbnRyYWN0XSxcclxuICAgICAgICAgICAgb3JkZXI6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vcmRlcixcclxuICAgICAgICAgICAgY2F0ZWdvcnksXHJcbiAgICAgICAgICAgIG1heENvdW50OiAxMDAsXHJcbiAgICAgICAgICAgIHBhZ2VLZXk6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYWdlS2V5XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCB0cmFuc2ZlcnNSZXNwb25zZSA9IHlpZWxkIGdldEFzc2V0VHJhbnNmZXJzKGNvbmZpZywgcGFyYW1zLCAnZ2V0VHJhbnNmZXJzRm9yQ29udHJhY3QnKTtcclxuICAgICAgICByZXR1cm4gZ2V0TmZ0c0ZvclRyYW5zZmVycyhjb25maWcsIHRyYW5zZmVyc1Jlc3BvbnNlKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIG5mdFRva2VuVHlwZVRvQ2F0ZWdvcnkodG9rZW5UeXBlKSB7XHJcbiAgICBzd2l0Y2ggKHRva2VuVHlwZSkge1xyXG4gICAgICAgIGNhc2UgZXhwb3J0cy5OZnRUb2tlblR5cGUuRVJDNzIxOlxyXG4gICAgICAgICAgICByZXR1cm4gW2V4cG9ydHMuQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeS5FUkM3MjFdO1xyXG4gICAgICAgIGNhc2UgZXhwb3J0cy5OZnRUb2tlblR5cGUuRVJDMTE1NTpcclxuICAgICAgICAgICAgcmV0dXJuIFtleHBvcnRzLkFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnkuRVJDMTE1NV07XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIGV4cG9ydHMuQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeS5FUkM3MjEsXHJcbiAgICAgICAgICAgICAgICBleHBvcnRzLkFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnkuRVJDMTE1NSxcclxuICAgICAgICAgICAgICAgIGV4cG9ydHMuQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeS5TUEVDSUFMTkZUXHJcbiAgICAgICAgICAgIF07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGFyc2UxMTU1VHJhbnNmZXIodHJhbnNmZXIpIHtcclxuICAgIHJldHVybiB0cmFuc2Zlci5lcmMxMTU1TWV0YWRhdGEubWFwKG1ldGFkYXRhID0+ICh7XHJcbiAgICAgICAgY29udHJhY3RBZGRyZXNzOiB0cmFuc2Zlci5yYXdDb250cmFjdC5hZGRyZXNzLFxyXG4gICAgICAgIHRva2VuSWQ6IG1ldGFkYXRhLnRva2VuSWQsXHJcbiAgICAgICAgdG9rZW5UeXBlOiBleHBvcnRzLk5mdFRva2VuVHlwZS5FUkMxMTU1XHJcbiAgICB9KSk7XHJcbn1cclxuZnVuY3Rpb24gdmVyaWZ5TmZ0T3duZXJzaGlwKGNvbmZpZywgb3duZXIsIGNvbnRyYWN0QWRkcmVzc2VzLCBzcmNNZXRob2QgPSAndmVyaWZ5TmZ0T3duZXJzaGlwJykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY29udHJhY3RBZGRyZXNzZXMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZ2V0TmZ0c0Zvck93bmVyKGNvbmZpZywgb3duZXIsIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzc2VzOiBbY29udHJhY3RBZGRyZXNzZXNdLFxyXG4gICAgICAgICAgICAgICAgb21pdE1ldGFkYXRhOiB0cnVlXHJcbiAgICAgICAgICAgIH0sIHNyY01ldGhvZCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5vd25lZE5mdHMubGVuZ3RoID4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChjb250cmFjdEFkZHJlc3Nlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGF0IGxlYXN0IG9uZSBjb250cmFjdCBhZGRyZXNzJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBnZXROZnRzRm9yT3duZXIoY29uZmlnLCBvd25lciwge1xyXG4gICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzZXMsXHJcbiAgICAgICAgICAgICAgICBvbWl0TWV0YWRhdGE6IHRydWVcclxuICAgICAgICAgICAgfSwgc3JjTWV0aG9kKTtcclxuICAgICAgICAgICAgLy8gQ3JlYXRlIG1hcCB3aGVyZSBhbGwgaW5wdXQgY29udHJhY3QgYWRkcmVzc2VzIGFyZSBzZXQgdG8gZmFsc2UsIHRoZW4gZmxpcFxyXG4gICAgICAgICAgICAvLyBvd25lZCBuZnRzIHRvIHRydWUuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbnRyYWN0QWRkcmVzc2VzLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhY2NbY3Vycl0gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgICAgIH0sIHt9KTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBuZnQgb2YgcmVzcG9uc2Uub3duZWROZnRzKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbbmZ0LmNvbnRyYWN0QWRkcmVzc10gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaXNTcGFtQ29udHJhY3QoY29uZmlnLCBjb250cmFjdEFkZHJlc3MsIHNyY01ldGhvZCA9ICdpc1NwYW1Db250cmFjdCcpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICByZXR1cm4gcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ2lzU3BhbUNvbnRyYWN0Jywgc3JjTWV0aG9kLCB7XHJcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U3BhbUNvbnRyYWN0cyhjb25maWcsIHNyY01ldGhvZCA9ICdnZXRTcGFtQ29udHJhY3RzJykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHJldHVybiByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAnZ2V0U3BhbUNvbnRyYWN0cycsIHNyY01ldGhvZCwgdW5kZWZpbmVkKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldEZsb29yUHJpY2UoY29uZmlnLCBjb250cmFjdEFkZHJlc3MsIHNyY01ldGhvZCA9ICdnZXRGbG9vclByaWNlJykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ2dldEZsb29yUHJpY2UnLCBzcmNNZXRob2QsIHtcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQocmVzcG9uc2UpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmZ0U2FsZXMoY29uZmlnLCBvcHRpb25zID0ge30sIHNyY01ldGhvZCA9ICdnZXROZnRTYWxlcycpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAvLyBBdm9pZCB0cyBjb21waWxlciBjb21wbGFpbmluZyBhYm91dCB0aGUgY29udHJhY3RBZGRyZXNzIGZpZWxkLlxyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ2dldE5GVFNhbGVzJywgc3JjTWV0aG9kLCB7XHJcbiAgICAgICAgICAgIGZyb21CbG9jazogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmZyb21CbG9jayxcclxuICAgICAgICAgICAgdG9CbG9jazogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnRvQmxvY2ssXHJcbiAgICAgICAgICAgIG9yZGVyOiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMub3JkZXIsXHJcbiAgICAgICAgICAgIG1hcmtldHBsYWNlOiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMubWFya2V0cGxhY2UsXHJcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvbnRyYWN0QWRkcmVzcyxcclxuICAgICAgICAgICAgdG9rZW5JZDogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy50b2tlbklkKVxyXG4gICAgICAgICAgICAgICAgPyBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20ocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnRva2VuSWQpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBzZWxsZXJBZGRyZXNzOiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuc2VsbGVyQWRkcmVzcyxcclxuICAgICAgICAgICAgYnV5ZXJBZGRyZXNzOiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYnV5ZXJBZGRyZXNzLFxyXG4gICAgICAgICAgICB0YWtlcjogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnRha2VyLFxyXG4gICAgICAgICAgICBsaW1pdDogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmxpbWl0LFxyXG4gICAgICAgICAgICBwYWdlS2V5OiBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGFnZUtleVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBnZXROZnRTYWxlc0Zyb21SYXcocmVzcG9uc2UpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY29tcHV0ZVJhcml0eShjb25maWcsIGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCwgc3JjTWV0aG9kID0gJ2NvbXB1dGVSYXJpdHknKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAnY29tcHV0ZVJhcml0eScsIHNyY01ldGhvZCwge1xyXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3MsXHJcbiAgICAgICAgICAgIHRva2VuSWQ6IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbSh0b2tlbklkKS50b1N0cmluZygpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQocmVzcG9uc2UpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gc2VhcmNoQ29udHJhY3RNZXRhZGF0YShjb25maWcsIHF1ZXJ5LCBzcmNNZXRob2QgPSAnc2VhcmNoQ29udHJhY3RNZXRhZGF0YScpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5ORlQsICdzZWFyY2hDb250cmFjdE1ldGFkYXRhJywgc3JjTWV0aG9kLCB7XHJcbiAgICAgICAgICAgIHF1ZXJ5XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29udHJhY3RzOiByZXNwb25zZS5jb250cmFjdHMubWFwKGdldE5mdENvbnRyYWN0RnJvbVJhdylcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gc3VtbWFyaXplTmZ0QXR0cmlidXRlcyhjb25maWcsIGNvbnRyYWN0QWRkcmVzcywgc3JjTWV0aG9kID0gJ3N1bW1hcml6ZU5mdEF0dHJpYnV0ZXMnKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYoY29uZmlnLCBBbGNoZW15QXBpVHlwZS5ORlQsICdzdW1tYXJpemVORlRBdHRyaWJ1dGVzJywgc3JjTWV0aG9kLCB7XHJcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVmcmVzaE5mdE1ldGFkYXRhKGNvbmZpZywgY29udHJhY3RBZGRyZXNzLCB0b2tlbklkLCBzcmNNZXRob2QgPSAncmVmcmVzaE5mdE1ldGFkYXRhJykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHRva2VuSWRTdHJpbmcgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20odG9rZW5JZCkudG9TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCBmaXJzdCA9IHlpZWxkIGdldE5mdE1ldGFkYXRhKGNvbmZpZywgY29udHJhY3RBZGRyZXNzLCB0b2tlbklkU3RyaW5nLCB1bmRlZmluZWQsIHNyY01ldGhvZCk7XHJcbiAgICAgICAgY29uc3Qgc2Vjb25kID0geWllbGQgcmVmcmVzaChjb25maWcsIGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZFN0cmluZywgc3JjTWV0aG9kKTtcclxuICAgICAgICByZXR1cm4gZmlyc3QudGltZUxhc3RVcGRhdGVkICE9PSBzZWNvbmQudGltZUxhc3RVcGRhdGVkO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVmcmVzaENvbnRyYWN0KGNvbmZpZywgY29udHJhY3RBZGRyZXNzLCBzcmNNZXRob2QgPSAncmVmcmVzaENvbnRyYWN0Jykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcmVxdWVzdEh0dHBXaXRoQmFja29mZihjb25maWcsIEFsY2hlbXlBcGlUeXBlLk5GVCwgJ3JlaW5nZXN0Q29udHJhY3QnLCBzcmNNZXRob2QsIHtcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiByZXNwb25zZS5jb250cmFjdEFkZHJlc3MsXHJcbiAgICAgICAgICAgIHJlZnJlc2hTdGF0ZTogcGFyc2VSZWluZ2VzdGlvblN0YXRlKHJlc3BvbnNlLnJlaW5nZXN0aW9uU3RhdGUpLFxyXG4gICAgICAgICAgICBwcm9ncmVzczogcmVzcG9uc2UucHJvZ3Jlc3NcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVmcmVzaChjb25maWcsIGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCwgc3JjTWV0aG9kKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0SHR0cFdpdGhCYWNrb2ZmKGNvbmZpZywgQWxjaGVteUFwaVR5cGUuTkZULCAnZ2V0TkZUTWV0YWRhdGEnLCBzcmNNZXRob2QsIHtcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzLFxyXG4gICAgICAgICAgICB0b2tlbklkOiBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20odG9rZW5JZCkudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgcmVmcmVzaENhY2hlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGdldE5mdEZyb21SYXcocmVzcG9uc2UpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciBtZXRob2QgdG8gY29udmVydCBhIE5GVCByZXNwb25zZSByZWNlaXZlZCBmcm9tIEFsY2hlbXkgYmFja2VuZCB0byBhblxyXG4gKiBTREsgTkZUIHR5cGUuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gbmZ0RnJvbUdldE5mdFJlc3BvbnNlKG93bmVkTmZ0KSB7XHJcbiAgICBpZiAoaXNOZnRXaXRoTWV0YWRhdGEob3duZWROZnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldE5mdEZyb21SYXcob3duZWROZnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGdldEJhc2VOZnRGcm9tUmF3KG93bmVkTmZ0KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSGVscGVyIG1ldGhvZCB0byBjb252ZXJ0IGEgTkZUIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gQWxjaGVteSBiYWNrZW5kIHRvIGFuXHJcbiAqIFNESyBORlQgdHlwZS5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBuZnRGcm9tR2V0TmZ0Q29udHJhY3RSZXNwb25zZShvd25lZE5mdCwgY29udHJhY3RBZGRyZXNzKSB7XHJcbiAgICBpZiAoaXNOZnRXaXRoTWV0YWRhdGEob3duZWROZnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldE5mdEZyb21SYXcob3duZWROZnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGdldEJhc2VOZnRGcm9tUmF3KG93bmVkTmZ0LCBjb250cmFjdEFkZHJlc3MpO1xyXG4gICAgfVxyXG59XHJcbi8qKiBAaW50ZXJuYWwgKi9cclxuLy8gVE9ETzogbW9yZSBjb21wcmVoZW5zaXZlIHR5cGUgY2hlY2tcclxuZnVuY3Rpb24gaXNOZnRXaXRoTWV0YWRhdGEocmVzcG9uc2UpIHtcclxuICAgIHJldHVybiByZXNwb25zZS5uYW1lICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGFuIEFzc2V0VHJhbnNmZXJzUmVzcG9uc2UsIGZldGNoZXMgdGhlIE5GVHMgYXNzb2NpYXRlZCB3aXRoIHRoZVxyXG4gKiB0cmFuc2ZlcnMgYW5kIGNvbGxhdGVzIHRoZW0gd2l0aCB0cmFuc2ZlciBtZXRhZGF0YS5cclxuICpcclxuICogVklTSUJMRSBGT1IgVEVTVElOR1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TmZ0c0ZvclRyYW5zZmVycyhjb25maWcsIHJlc3BvbnNlKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY29uc3QgbWV0YWRhdGFUcmFuc2ZlcnMgPSByZXNwb25zZS50cmFuc2ZlcnNcclxuICAgICAgICAgICAgLmZpbHRlcih0cmFuc2ZlciA9PiB0cmFuc2Zlci5yYXdDb250cmFjdC5hZGRyZXNzICE9PSBudWxsKVxyXG4gICAgICAgICAgICAvLyBVc2UgZmxhdE1hcCB0byBmbGF0dGVuIDExNTUgdHJhbnNmZXJzIHRoYXQgY29udGFpbiBtdWx0aXBsZSBORlRzLlxyXG4gICAgICAgICAgICAuZmxhdE1hcCh0cmFuc2ZlciA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gZ2V0VG9rZW5zRnJvbVRyYW5zZmVyKHRyYW5zZmVyKTtcclxuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICBmcm9tOiB0cmFuc2Zlci5mcm9tLFxyXG4gICAgICAgICAgICAgICAgdG86IChfYSA9IHRyYW5zZmVyLnRvKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IHRyYW5zZmVyLmhhc2gsXHJcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogdHJhbnNmZXIuYmxvY2tOdW1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHRva2Vucy5tYXAodG9rZW4gPT4gKHsgbWV0YWRhdGEsIHRva2VuIH0pKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAobWV0YWRhdGFUcmFuc2ZlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IG5mdHM6IFtdIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIDEwMCBlbGVtZW50cyBhZnRlciB1bnJvbGxpbmcgMTE1NSB0cmFuc2ZlcnMsIHNwbGl0XHJcbiAgICAgICAgLy8gdHJhbnNmZXJzIGludG8gYmF0Y2hlcyBvZiAxMDAgdG8gc3RheSB1bmRlciBlbmRwb2ludCBiYXRjaCBzaXplIGxpbWl0LlxyXG4gICAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IDEwMDtcclxuICAgICAgICBjb25zdCByZXF1ZXN0QmF0Y2hlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWV0YWRhdGFUcmFuc2ZlcnMubGVuZ3RoOyBpICs9IGJhdGNoU2l6ZSkge1xyXG4gICAgICAgICAgICByZXF1ZXN0QmF0Y2hlcy5wdXNoKG1ldGFkYXRhVHJhbnNmZXJzLnNsaWNlKGksIGkgKyBiYXRjaFNpemUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2VCYXRjaGVzID0geWllbGQgUHJvbWlzZS5hbGwocmVxdWVzdEJhdGNoZXMubWFwKGJhdGNoID0+IGdldE5mdE1ldGFkYXRhQmF0Y2goY29uZmlnLCBiYXRjaC5tYXAodHJhbnNmZXIgPT4gdHJhbnNmZXIudG9rZW4pKSkpO1xyXG4gICAgICAgIGNvbnN0IG5mdHMgPSByZXNwb25zZUJhdGNoZXMubWFwKHIgPT4gci5uZnRzKS5mbGF0KCk7XHJcbiAgICAgICAgLy8gVGhlIHNhbWUgTkZUIGNhbiBiZSB0cmFuc2ZlcnJlZCBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgc2FtZSB0cmFuc2ZlcnMgcmVzcG9uc2UuXHJcbiAgICAgICAgLy8gV2Ugd2FudCB0byByZXR1cm4gb25lIE5GVCBmb3IgZWFjaCB0cmFuc2Zlciwgc28gd2UgY3JlYXRlIGEgbWFwcGluZyBmb3JcclxuICAgICAgICAvLyBlYWNoIE5GVCB0byBwYWlyIHdpdGggdGhlIHRyYW5zZmVyIG1ldGFkYXRhLlxyXG4gICAgICAgIGNvbnN0IG5mdHNCeVRva2VuSWQgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgbmZ0cy5mb3JFYWNoKG5mdCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke25mdC5jb250cmFjdC5hZGRyZXNzLnRvTG93ZXJDYXNlKCl9LSR7YmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKG5mdC50b2tlbklkKS50b1N0cmluZygpfWA7XHJcbiAgICAgICAgICAgIG5mdHNCeVRva2VuSWQuc2V0KGtleSwgbmZ0KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCB0cmFuc2ZlcnJlZE5mdHMgPSBtZXRhZGF0YVRyYW5zZmVycy5tYXAodCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke3QudG9rZW4uY29udHJhY3RBZGRyZXNzLnRvTG93ZXJDYXNlKCl9LSR7YmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKHQudG9rZW4udG9rZW5JZCkudG9TdHJpbmcoKX1gO1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBuZnRzQnlUb2tlbklkLmdldChrZXkpKSwgdC5tZXRhZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmZ0czogdHJhbnNmZXJyZWROZnRzLFxyXG4gICAgICAgICAgICBwYWdlS2V5OiByZXNwb25zZS5wYWdlS2V5XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIE5GVCB0b2tlbnMgZnJvbSBhIHRyYW5zZmVyIGFzIHRoZSBwYXJhbXMgZm9yIGFcclxuICogYGdldE5mdE1ldGFkYXRhQmF0Y2hgIGNhbGwuIEhhbmRsZXMgdGhlIDExNTUgY2FzZSB3aGVyZSBtdWx0aXBsZSBORlRzIGNhbiBiZVxyXG4gKiB0cmFuc2ZlcnJlZCBpbiBhIHNpbmdsZSB0cmFuc2FjdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGdldFRva2Vuc0Zyb21UcmFuc2Zlcih0cmFuc2Zlcikge1xyXG4gICAgLy8gRVJDMTE1NSBORlRzIGNhbiBjb250YWluIG11bHRpcGxlIHRva2VucyBpbiBhIHNpbmdsZSB0cmFuc2Zlciwgd2hpY2hcclxuICAgIC8vIHJlcXVpcmVzIHNwZWNpYWwgbG9naWMuXHJcbiAgICBpZiAodHJhbnNmZXIuY2F0ZWdvcnkgPT09IGV4cG9ydHMuQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeS5FUkMxMTU1KSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlMTE1NVRyYW5zZmVyKHRyYW5zZmVyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogdHJhbnNmZXIucmF3Q29udHJhY3QuYWRkcmVzcyxcclxuICAgICAgICAgICAgICAgIHRva2VuSWQ6IHRyYW5zZmVyLnRva2VuSWQsXHJcbiAgICAgICAgICAgICAgICB0b2tlblR5cGU6IHRyYW5zZmVyLmNhdGVnb3J5ID09PSBleHBvcnRzLkFzc2V0VHJhbnNmZXJzQ2F0ZWdvcnkuRVJDNzIxXHJcbiAgICAgICAgICAgICAgICAgICAgPyBleHBvcnRzLk5mdFRva2VuVHlwZS5FUkM3MjFcclxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRmxpcHMgdGhlIGBvbWl0TWV0YWRhdGFgIFNESyBwYXJhbWV0ZXIgdHlwZSB0byB0aGUgYHdpdGhNZXRhZGF0YWAgcGFyYW1ldGVyXHJcbiAqIHJlcXVpcmVkIGJ5IHRoZSBBbGNoZW15IEFQSS4gSWYgYG9taXRNZXRhZGF0YWAgaXMgdW5kZWZpbmVkLCB0aGUgU0RLIGRlZmF1bHRzXHJcbiAqIHRvIGluY2x1ZGluZyBtZXRhZGF0YS5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBvbWl0TWV0YWRhdGFUb1dpdGhNZXRhZGF0YShvbWl0TWV0YWRhdGEpIHtcclxuICAgIHJldHVybiBvbWl0TWV0YWRhdGEgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhb21pdE1ldGFkYXRhO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlUmVpbmdlc3Rpb25TdGF0ZShyZWluZ2VzdGlvblN0YXRlKSB7XHJcbiAgICBzd2l0Y2ggKHJlaW5nZXN0aW9uU3RhdGUpIHtcclxuICAgICAgICBjYXNlICdkb2VzX25vdF9leGlzdCc6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFJlZnJlc2hTdGF0ZS5ET0VTX05PVF9FWElTVDtcclxuICAgICAgICBjYXNlICdhbHJlYWR5X3F1ZXVlZCc6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFJlZnJlc2hTdGF0ZS5BTFJFQURZX1FVRVVFRDtcclxuICAgICAgICBjYXNlICdpbl9wcm9ncmVzcyc6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFJlZnJlc2hTdGF0ZS5JTl9QUk9HUkVTUztcclxuICAgICAgICBjYXNlICdmaW5pc2hlZCc6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFJlZnJlc2hTdGF0ZS5GSU5JU0hFRDtcclxuICAgICAgICBjYXNlICdxdWV1ZWQnOlxyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5OZnRSZWZyZXNoU3RhdGUuUVVFVUVEO1xyXG4gICAgICAgIGNhc2UgJ3F1ZXVlX2ZhaWxlZCc6XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLk5mdFJlZnJlc2hTdGF0ZS5RVUVVRV9GQUlMRUQ7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHJlaW5nZXN0aW9uIHN0YXRlOiAnICsgcmVpbmdlc3Rpb25TdGF0ZSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIFRoZSBORlQgbmFtZXNwYWNlIGNvbnRhaW5zIGFsbCB0aGUgZnVuY3Rpb25hbGl0eSByZWxhdGVkIHRvIE5GVHMuXHJcbiAqXHJcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIGluc3RhbnRpYXRlIGFuIEFsY2hlbXkgb2JqZWN0XHJcbiAqIHdpdGggYGNvbnN0IGFsY2hlbXkgPSBuZXcgQWxjaGVteShjb25maWcpYCBhbmQgdGhlbiBhY2Nlc3MgdGhlIGNvcmUgbmFtZXNwYWNlXHJcbiAqIHZpYSBgYWxjaGVteS5uZnRgLlxyXG4gKi9cclxuY2xhc3MgTmZ0TmFtZXNwYWNlIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgfVxyXG4gICAgZ2V0TmZ0TWV0YWRhdGEoY29udHJhY3RBZGRyZXNzLCB0b2tlbklkLCBvcHRpb25zT3JUb2tlblR5cGUsIHRva2VuVXJpVGltZW91dEluTXMpIHtcclxuICAgICAgICBsZXQgb3B0aW9ucztcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNPclRva2VuVHlwZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgIHRva2VuVHlwZTogb3B0aW9uc09yVG9rZW5UeXBlLnRva2VuVHlwZSxcclxuICAgICAgICAgICAgICAgIHRva2VuVXJpVGltZW91dEluTXM6IG9wdGlvbnNPclRva2VuVHlwZS50b2tlblVyaVRpbWVvdXRJbk1zLFxyXG4gICAgICAgICAgICAgICAgcmVmcmVzaENhY2hlOiBvcHRpb25zT3JUb2tlblR5cGUucmVmcmVzaENhY2hlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgdG9rZW5UeXBlOiBvcHRpb25zT3JUb2tlblR5cGUsXHJcbiAgICAgICAgICAgICAgICB0b2tlblVyaVRpbWVvdXRJbk1zXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBnZXROZnRNZXRhZGF0YSh0aGlzLmNvbmZpZywgY29udHJhY3RBZGRyZXNzLCB0b2tlbklkLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgTkZUIG1ldGFkYXRhIGZvciBtdWx0aXBsZSBORlQgdG9rZW5zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0b2tlbnMgQW4gYXJyYXkgb2YgTkZUIHRva2VucyB0byBmZXRjaCBtZXRhZGF0YSBmb3IuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIG1ha2luZyB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgZ2V0TmZ0TWV0YWRhdGFCYXRjaCh0b2tlbnMsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0TmZ0TWV0YWRhdGFCYXRjaCh0aGlzLmNvbmZpZywgdG9rZW5zLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBORlQgY29udHJhY3QgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBUaGUgY29udHJhY3QgYWRkcmVzcyBvZiB0aGUgTkZULlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRDb250cmFjdE1ldGFkYXRhKGNvbnRyYWN0QWRkcmVzcykge1xyXG4gICAgICAgIHJldHVybiBnZXRDb250cmFjdE1ldGFkYXRhKHRoaXMuY29uZmlnLCBjb250cmFjdEFkZHJlc3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIE5GVCBjb250cmFjdCBtZXRhZGF0YSBmb3IgbXVsdGlwbGUgTkZUIGNvbnRyYWN0cyBpbiBhIHNpbmdsZSByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3NlcyAtIEFuIGFycmF5IG9mIGNvbnRyYWN0IGFkZHJlc3NlcyB0byBmZXRjaCBtZXRhZGF0YSBmb3IuXHJcbiAgICAgKi9cclxuICAgIGdldENvbnRyYWN0TWV0YWRhdGFCYXRjaChjb250cmFjdEFkZHJlc3Nlcykge1xyXG4gICAgICAgIHJldHVybiBnZXRDb250cmFjdE1ldGFkYXRhQmF0Y2godGhpcy5jb25maWcsIGNvbnRyYWN0QWRkcmVzc2VzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBORlQgY29sbGVjdGlvbiBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkIHBhcmFtZXRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25TbHVnIC0gVGhlIE9wZW5TZWEgY29sbGVjdGlvbiBzbHVnIG9mIHRoZSBORlQuXHJcbiAgICAgKiBAYmV0YVxyXG4gICAgICovXHJcbiAgICBnZXRDb2xsZWN0aW9uTWV0YWRhdGEoY29sbGVjdGlvblNsdWcpIHtcclxuICAgICAgICByZXR1cm4gZ2V0Q29sbGVjdGlvbk1ldGFkYXRhKHRoaXMuY29uZmlnLCBjb2xsZWN0aW9uU2x1Zyk7XHJcbiAgICB9XHJcbiAgICBnZXROZnRzRm9yT3duZXJJdGVyYXRvcihvd25lciwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBnZXROZnRzRm9yT3duZXJJdGVyYXRvcih0aGlzLmNvbmZpZywgb3duZXIsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgZ2V0TmZ0c0Zvck93bmVyKG93bmVyLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldE5mdHNGb3JPd25lcih0aGlzLmNvbmZpZywgb3duZXIsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgZ2V0TmZ0c0ZvckNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBnZXROZnRzRm9yQ29udHJhY3QodGhpcy5jb25maWcsIGNvbnRyYWN0QWRkcmVzcywgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBnZXROZnRzRm9yQ29udHJhY3RJdGVyYXRvcihjb250cmFjdEFkZHJlc3MsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0TmZ0c0ZvckNvbnRyYWN0SXRlcmF0b3IodGhpcy5jb25maWcsIGNvbnRyYWN0QWRkcmVzcywgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBnZXRPd25lcnNGb3JDb250cmFjdChjb250cmFjdEFkZHJlc3MsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0T3duZXJzRm9yQ29udHJhY3QodGhpcy5jb25maWcsIGNvbnRyYWN0QWRkcmVzcywgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYWxsIHRoZSBvd25lcnMgZm9yIGEgZ2l2ZW4gTkZUIGNvbnRyYWN0IGFkZHJlc3MgYW5kIHRva2VuIElELlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBUaGUgTkZUIGNvbnRyYWN0IGFkZHJlc3MuXHJcbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIFRva2VuIGlkIG9mIHRoZSBORlQuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgdG8gdXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqIEBiZXRhXHJcbiAgICAgKi9cclxuICAgIGdldE93bmVyc0Zvck5mdChjb250cmFjdEFkZHJlc3MsIHRva2VuSWQsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0T3duZXJzRm9yTmZ0KHRoaXMuY29uZmlnLCBjb250cmFjdEFkZHJlc3MsIHRva2VuSWQsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFsbCBORlQgY29udHJhY3RzIGhlbGQgYnkgdGhlIHNwZWNpZmllZCBvd25lciBhZGRyZXNzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvd25lciAtIEFkZHJlc3MgZm9yIE5GVCBvd25lciAoY2FuIGJlIGluIEVOUyBmb3JtYXQhKS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbmFsIHBhcmFtZXRlcnMgdG8gdXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgLy8gVE9ETyh2Myk6IEFkZCBvdmVybG9hZCBmb3Igd2l0aE1ldGFkYXRhPWZhbHNlXHJcbiAgICBnZXRDb250cmFjdHNGb3JPd25lcihvd25lciwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBnZXRDb250cmFjdHNGb3JPd25lcih0aGlzLmNvbmZpZywgb3duZXIsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFsbCBORlQgdHJhbnNmZXJzIGZvciBhIGdpdmVuIG93bmVyJ3MgYWRkcmVzcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3duZXIgVGhlIG93bmVyIHRvIGdldCB0cmFuc2ZlcnMgZm9yLlxyXG4gICAgICogQHBhcmFtIGNhdGVnb3J5IFdoZXRoZXIgdG8gZ2V0IHRyYW5zZmVycyB0byBvciBmcm9tIHRoZSBvd25lciBhZGRyZXNzLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgZ2V0VHJhbnNmZXJzRm9yT3duZXIob3duZXIsIGNhdGVnb3J5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFRyYW5zZmVyc0Zvck93bmVyKHRoaXMuY29uZmlnLCBvd25lciwgY2F0ZWdvcnksIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFsbCBORlQgdHJhbnNmZXJzIGZvciBhIGdpdmVuIE5GVCBjb250cmFjdCBhZGRyZXNzLlxyXG4gICAgICpcclxuICAgICAqIERlZmF1bHRzIHRvIGFsbCB0cmFuc2ZlcnMgZm9yIHRoZSBjb250cmFjdC4gVG8gZ2V0IHRyYW5zZmVycyBmb3IgYSBzcGVjaWZpY1xyXG4gICAgICogYmxvY2sgcmFuZ2UsIHVzZSB7QGxpbmsgR2V0VHJhbnNmZXJzRm9yQ29udHJhY3RPcHRpb25zfS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29udHJhY3QgVGhlIE5GVCBjb250cmFjdCB0byBnZXQgdHJhbnNmZXJzIGZvci5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIGdldFRyYW5zZmVyc0ZvckNvbnRyYWN0KGNvbnRyYWN0LCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFRyYW5zZmVyc0ZvckNvbnRyYWN0KHRoaXMuY29uZmlnLCBjb250cmFjdCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgdGhlIE5GVHMgbWludGVkIGJ5IGEgc3BlY2lmaWVkIG93bmVyIGFkZHJlc3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG93bmVyIC0gQWRkcmVzcyBmb3IgdGhlIE5GVCBvd25lciAoY2FuIGJlIGluIEVOUyBmb3JtYXQpLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9uYWwgcGFyYW1ldGVycyB0byB1c2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICBnZXRNaW50ZWROZnRzKG93bmVyLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0TWludGVkTmZ0cyh0aGlzLmNvbmZpZywgb3duZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdmVyaWZ5TmZ0T3duZXJzaGlwKG93bmVyLCBjb250cmFjdEFkZHJlc3MpIHtcclxuICAgICAgICByZXR1cm4gdmVyaWZ5TmZ0T3duZXJzaGlwKHRoaXMuY29uZmlnLCBvd25lciwgY29udHJhY3RBZGRyZXNzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIGEgY29udHJhY3QgaXMgbWFya2VkIGFzIHNwYW0gb3Igbm90IGJ5IEFsY2hlbXkuIEZvciBtb3JlXHJcbiAgICAgKiBpbmZvcm1hdGlvbiBvbiBob3cgd2UgY2xhc3NpZnkgc3BhbSwgZ28gdG8gb3VyIE5GVCBBUEkgRkFRIGF0XHJcbiAgICAgKiBodHRwczovL2RvY3MuYWxjaGVteS5jb20vYWxjaGVteS9lbmhhbmNlZC1hcGlzL25mdC1hcGkvbmZ0LWFwaS1mYXEjbmZ0LXNwYW0tY2xhc3NpZmljYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIFRoZSBjb250cmFjdCBhZGRyZXNzIHRvIGNoZWNrLlxyXG4gICAgICogQGJldGFcclxuICAgICAqL1xyXG4gICAgaXNTcGFtQ29udHJhY3QoY29udHJhY3RBZGRyZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzU3BhbUNvbnRyYWN0KHRoaXMuY29uZmlnLCBjb250cmFjdEFkZHJlc3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgc3BhbSBjb250cmFjdHMgbWFya2VkIGJ5IEFsY2hlbXkuIEZvciBkZXRhaWxzIG9uIGhvd1xyXG4gICAgICogQWxjaGVteSBtYXJrcyBzcGFtIGNvbnRyYWN0cywgZ28gdG9cclxuICAgICAqIGh0dHBzOi8vZG9jcy5hbGNoZW15LmNvbS9hbGNoZW15L2VuaGFuY2VkLWFwaXMvbmZ0LWFwaS9uZnQtYXBpLWZhcSNuZnQtc3BhbS1jbGFzc2lmaWNhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAYmV0YVxyXG4gICAgICovXHJcbiAgICBnZXRTcGFtQ29udHJhY3RzKCkge1xyXG4gICAgICAgIHJldHVybiBnZXRTcGFtQ29udHJhY3RzKHRoaXMuY29uZmlnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZmxvb3IgcHJpY2VzIG9mIGEgTkZUIGNvbnRyYWN0IGJ5IG1hcmtldHBsYWNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBUaGUgY29udHJhY3QgYWRkcmVzcyBmb3IgdGhlIE5GVCBjb2xsZWN0aW9uLlxyXG4gICAgICogQGJldGFcclxuICAgICAqL1xyXG4gICAgZ2V0Rmxvb3JQcmljZShjb250cmFjdEFkZHJlc3MpIHtcclxuICAgICAgICByZXR1cm4gZ2V0Rmxvb3JQcmljZSh0aGlzLmNvbmZpZywgY29udHJhY3RBZGRyZXNzKTtcclxuICAgIH1cclxuICAgIGdldE5mdFNhbGVzKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0TmZ0U2FsZXModGhpcy5jb25maWcsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHJhcml0eSBvZiBlYWNoIGF0dHJpYnV0ZSBvZiBhbiBORlQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIENvbnRyYWN0IGFkZHJlc3MgZm9yIHRoZSBORlQgY29sbGVjdGlvbi5cclxuICAgICAqIEBwYXJhbSB0b2tlbklkIC0gVG9rZW4gaWQgb2YgdGhlIE5GVC5cclxuICAgICAqL1xyXG4gICAgY29tcHV0ZVJhcml0eShjb250cmFjdEFkZHJlc3MsIHRva2VuSWQpIHtcclxuICAgICAgICByZXR1cm4gY29tcHV0ZVJhcml0eSh0aGlzLmNvbmZpZywgY29udHJhY3RBZGRyZXNzLCB0b2tlbklkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VhcmNoIGZvciBhIGtleXdvcmQgYWNyb3NzIG1ldGFkYXRhIG9mIGFsbCBFUkMtNzIxIGFuZCBFUkMtMTE1NSBzbWFydCBjb250cmFjdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHNlYXJjaCBzdHJpbmcgdGhhdCB5b3Ugd2FudCB0byBzZWFyY2ggZm9yIGluIGNvbnRyYWN0IG1ldGFkYXRhLlxyXG4gICAgICovXHJcbiAgICBzZWFyY2hDb250cmFjdE1ldGFkYXRhKHF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIHNlYXJjaENvbnRyYWN0TWV0YWRhdGEodGhpcy5jb25maWcsIHF1ZXJ5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgc3VtbWFyeSBvZiBhdHRyaWJ1dGUgcHJldmFsZW5jZSBmb3IgYW4gTkZUIGNvbGxlY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIENvbnRyYWN0IGFkZHJlc3MgZm9yIHRoZSBORlQgY29sbGVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgc3VtbWFyaXplTmZ0QXR0cmlidXRlcyhjb250cmFjdEFkZHJlc3MpIHtcclxuICAgICAgICByZXR1cm4gc3VtbWFyaXplTmZ0QXR0cmlidXRlcyh0aGlzLmNvbmZpZywgY29udHJhY3RBZGRyZXNzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaGVzIHRoZSBjYWNoZWQgbWV0YWRhdGEgZm9yIGEgcHJvdmlkZWQgTkZUIGNvbnRyYWN0IGFkZHJlc3MgYW5kIHRva2VuXHJcbiAgICAgKiBpZC4gUmV0dXJucyBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBtZXRhZGF0YSB3YXMgcmVmcmVzaGVkLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIHJlZnJlc2ggdGhlIG1ldGFkYXRhIGZvciBhIE5GVCB0aGF0XHJcbiAgICAgKiBoYXMgYmVlbiB1cGRhdGVkIHNpbmNlIHRoZSBsYXN0IHRpbWUgaXQgd2FzIGZldGNoZWQuIE5vdGUgdGhhdCB0aGUgYmFja2VuZFxyXG4gICAgICogb25seSBhbGxvd3Mgb25lIHJlZnJlc2ggcGVyIHRva2VuIGV2ZXJ5IDE1IG1pbnV0ZXMsIGdsb2JhbGx5IGZvciBhbGwgdXNlcnMuXHJcbiAgICAgKiBUaGUgbGFzdCByZWZyZXNoIHRpbWUgZm9yIGFuIE5GVCBjYW4gYmUgYWNjZXNzZWQgb24gdGhlXHJcbiAgICAgKiB7QGxpbmsgTmZ0LnRpbWVMYXN0VXBkYXRlZH0gZmllbGQuXHJcbiAgICAgKlxyXG4gICAgICogVG8gdHJpZ2dlciBhIHJlZnJlc2ggZm9yIGFsbCBORlRzIGluIGEgY29udHJhY3QsIHVzZSB7QGxpbmsgcmVmcmVzaENvbnRyYWN0fSBpbnN0ZWFkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBUaGUgY29udHJhY3QgYWRkcmVzcyBvZiB0aGUgTkZULlxyXG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBUaGUgdG9rZW4gaWQgb2YgdGhlIE5GVC5cclxuICAgICAqL1xyXG4gICAgcmVmcmVzaE5mdE1ldGFkYXRhKGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCkge1xyXG4gICAgICAgIHJldHVybiByZWZyZXNoTmZ0TWV0YWRhdGEodGhpcy5jb25maWcsIGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyaWdnZXJzIGEgbWV0YWRhdGEgcmVmcmVzaCBhbGwgTkZUcyBpbiB0aGUgcHJvdmlkZWQgY29udHJhY3QgYWRkcmVzcy4gVGhpc1xyXG4gICAgICogbWV0aG9kIGlzIHVzZWZ1bCBhZnRlciBhbiBORlQgY29sbGVjdGlvbiBpcyByZXZlYWxlZC5cclxuICAgICAqXHJcbiAgICAgKiBSZWZyZXNoZXMgYXJlIHF1ZXVlZCBvbiB0aGUgQWxjaGVteSBiYWNrZW5kIGFuZCBtYXkgdGFrZSB0aW1lIHRvIGZ1bGx5XHJcbiAgICAgKiBwcm9jZXNzLiBUbyByZWZyZXNoIHRoZSBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyB0b2tlbiwgdXNlIHRoZVxyXG4gICAgICoge0BsaW5rIHJlZnJlc2hOZnRNZXRhZGF0YX0gbWV0aG9kIGluc3RlYWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIFRoZSBjb250cmFjdCBhZGRyZXNzIG9mIHRoZSBORlQgY29sbGVjdGlvbi5cclxuICAgICAqIEBiZXRhXHJcbiAgICAgKi9cclxuICAgIHJlZnJlc2hDb250cmFjdChjb250cmFjdEFkZHJlc3MpIHtcclxuICAgICAgICByZXR1cm4gcmVmcmVzaENvbnRyYWN0KHRoaXMuY29uZmlnLCBjb250cmFjdEFkZHJlc3MpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBUaGUgTm90aWZ5IG5hbWVzcGFjZSBjb250YWlucyBtZXRob2RzIHVzZWQgZm9yIGNyZWF0aW5nLCByZWFkaW5nLCB1cGRhdGluZyxcclxuICogYW5kIGRlbGV0aW5nIHdlYmhvb2tzIGluIHRoZSBOb3RpZnkgQVBJLlxyXG4gKlxyXG4gKiBUbyB1c2UgdGhlIG1ldGhvZHMgaW4gdGhlIEFQSSwgeW91IG11c3QgcHJvdmlkZSB5b3VyIHRlYW0ncyBhdXRoIHRva2VuIGluIHRoZVxyXG4gKiB7QGxpbmsgQWxjaGVteVNldHRpbmdzLmF1dGhUb2tlbn0gZmllbGQgd2hlbiBjb25maWd1cmluZ1xyXG4gKiB7QGxpbmsgQWxjaGVteVNldHRpbmdzfS4gVGhlIGF1dGggdG9rZW4gY2FuIGJlIGZvdW5kIGluIHRoZSBBbGNoZW15IERhc2hib2FyZFxyXG4gKiBvbiB0aGUgTm90aWZ5IHRhYi5cclxuICpcclxuICogTm90ZSB0aGF0IG5vdCBhbGwgbmV0d29ya3MgYXJlIHN1cHBvcnRlZCBpbiB0aGUgTm90aWZ5IEFQSS4gUGxlYXNlIGNvbnN1bHRcclxuICogdGhlIGRvY3VtZW50YXRpb24gZm9yIHdoaWNoIG5ldHdvcmtzIGFyZSBzdXBwb3J0ZWQuXHJcbiAqXHJcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIGluc3RhbnRpYXRlIGFuIEFsY2hlbXkgb2JqZWN0XHJcbiAqIHdpdGggYGNvbnN0IGFsY2hlbXkgPSBuZXcgQWxjaGVteShjb25maWcpYCBhbmQgdGhlbiBhY2Nlc3MgdGhlIG5vdGlmeVxyXG4gKiBuYW1lc3BhY2UgdmlhIGBhbGNoZW15Lm5vdGlmeWAuXHJcbiAqL1xyXG5jbGFzcyBOb3RpZnlOYW1lc3BhY2Uge1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgd2ViaG9va3Mgb24geW91ciB0ZWFtLlxyXG4gICAgICpcclxuICAgICAqIFRoZSB0ZWFtIGlzIGRldGVybWluZWQgYnkgdGhlIGBhdXRoVG9rZW5gIHByb3ZpZGVkIGludG8gdGhlIHtAbGluayBBbGNoZW15U2V0dGluZ3N9XHJcbiAgICAgKiBvYmplY3Qgd2hlbiBjcmVhdGluZyBhIG5ldyB7QGxpbmsgQWxjaGVteX0gaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIHJlc3BvbnNlIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgd2ViaG9va3NcclxuICAgICAqL1xyXG4gICAgZ2V0QWxsV2ViaG9va3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB0aGlzLnZlcmlmeUNvbmZpZygpO1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc2VuZFdlYmhvb2tSZXF1ZXN0KCd0ZWFtLXdlYmhvb2tzJywgJ2dldEFsbFdlYmhvb2tzJywge30pO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgd2ViaG9va3M6IHBhcnNlUmF3V2ViaG9va1Jlc3BvbnNlKHJlc3BvbnNlKSxcclxuICAgICAgICAgICAgICAgIHRvdGFsQ291bnQ6IHJlc3BvbnNlLmRhdGEubGVuZ3RoXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRBZGRyZXNzZXMod2ViaG9va09ySWQsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmVyaWZ5Q29uZmlnKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHdlYmhvb2tJZCA9IHR5cGVvZiB3ZWJob29rT3JJZCA9PT0gJ3N0cmluZycgPyB3ZWJob29rT3JJZCA6IHdlYmhvb2tPcklkLmlkO1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc2VuZFdlYmhvb2tSZXF1ZXN0KCd3ZWJob29rLWFkZHJlc3NlcycsICdnZXRBZGRyZXNzZXMnLCB7XHJcbiAgICAgICAgICAgICAgICB3ZWJob29rX2lkOiB3ZWJob29rSWQsXHJcbiAgICAgICAgICAgICAgICBsaW1pdDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxpbWl0LFxyXG4gICAgICAgICAgICAgICAgYWZ0ZXI6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYWdlS2V5XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VSYXdBZGRyZXNzQWN0aXZpdHlSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRHcmFwaHFsUXVlcnkod2ViaG9va09ySWQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmVyaWZ5Q29uZmlnKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHdlYmhvb2tJZCA9IHR5cGVvZiB3ZWJob29rT3JJZCA9PT0gJ3N0cmluZycgPyB3ZWJob29rT3JJZCA6IHdlYmhvb2tPcklkLmlkO1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc2VuZFdlYmhvb2tSZXF1ZXN0KCdkYXNoYm9hcmQtd2ViaG9vay1ncmFwaHFsLXF1ZXJ5JywgJ2dldEdyYXBocWxRdWVyeScsIHtcclxuICAgICAgICAgICAgICAgIHdlYmhvb2tfaWQ6IHdlYmhvb2tJZFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlUmF3Q3VzdG9tR3JhcGhxbFdlYmhvb2tSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXROZnRGaWx0ZXJzKHdlYmhvb2tPcklkLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB0aGlzLnZlcmlmeUNvbmZpZygpO1xyXG4gICAgICAgICAgICBjb25zdCB3ZWJob29rSWQgPSB0eXBlb2Ygd2ViaG9va09ySWQgPT09ICdzdHJpbmcnID8gd2ViaG9va09ySWQgOiB3ZWJob29rT3JJZC5pZDtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNlbmRXZWJob29rUmVxdWVzdCgnd2ViaG9vay1uZnQtZmlsdGVycycsICdnZXROZnRGaWx0ZXJzJywge1xyXG4gICAgICAgICAgICAgICAgd2ViaG9va19pZDogd2ViaG9va0lkLFxyXG4gICAgICAgICAgICAgICAgbGltaXQ6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5saW1pdCxcclxuICAgICAgICAgICAgICAgIGFmdGVyOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFnZUtleVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlUmF3TmZ0RmlsdGVyc1Jlc3BvbnNlKHJlc3BvbnNlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVdlYmhvb2sod2ViaG9va09ySWQsIHVwZGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3Qgd2ViaG9va0lkID0gdHlwZW9mIHdlYmhvb2tPcklkID09PSAnc3RyaW5nJyA/IHdlYmhvb2tPcklkIDogd2ViaG9va09ySWQuaWQ7XHJcbiAgICAgICAgICAgIGxldCByZXN0QXBpTmFtZTtcclxuICAgICAgICAgICAgbGV0IG1ldGhvZE5hbWU7XHJcbiAgICAgICAgICAgIGxldCBtZXRob2Q7XHJcbiAgICAgICAgICAgIGxldCBkYXRhO1xyXG4gICAgICAgICAgICBpZiAoJ2lzQWN0aXZlJyBpbiB1cGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJlc3RBcGlOYW1lID0gJ3VwZGF0ZS13ZWJob29rJztcclxuICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAndXBkYXRlV2ViaG9vayc7XHJcbiAgICAgICAgICAgICAgICBtZXRob2QgPSAnUFVUJztcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2ViaG9va19pZDogd2ViaG9va0lkLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzX2FjdGl2ZTogdXBkYXRlLmlzQWN0aXZlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCdhZGRGaWx0ZXJzJyBpbiB1cGRhdGUgfHwgJ3JlbW92ZUZpbHRlcnMnIGluIHVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdEFwaU5hbWUgPSAndXBkYXRlLXdlYmhvb2stbmZ0LWZpbHRlcnMnO1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICd1cGRhdGVXZWJob29rTmZ0RmlsdGVycyc7XHJcbiAgICAgICAgICAgICAgICBtZXRob2QgPSAnUEFUQ0gnO1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB3ZWJob29rX2lkOiB3ZWJob29rSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgbmZ0X2ZpbHRlcnNfdG9fYWRkOiB1cGRhdGUuYWRkRmlsdGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHVwZGF0ZS5hZGRGaWx0ZXJzLm1hcChuZnRGaWx0ZXJUb1BhcmFtKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIG5mdF9maWx0ZXJzX3RvX3JlbW92ZTogdXBkYXRlLnJlbW92ZUZpbHRlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB1cGRhdGUucmVtb3ZlRmlsdGVycy5tYXAobmZ0RmlsdGVyVG9QYXJhbSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgnYWRkTWV0YWRhdGFGaWx0ZXJzJyBpbiB1cGRhdGUgfHxcclxuICAgICAgICAgICAgICAgICdyZW1vdmVNZXRhZGF0YUZpbHRlcnMnIGluIHVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdEFwaU5hbWUgPSAndXBkYXRlLXdlYmhvb2stbmZ0LW1ldGFkYXRhLWZpbHRlcnMnO1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICd1cGRhdGVXZWJob29rTmZ0TWV0YWRhdGFGaWx0ZXJzJztcclxuICAgICAgICAgICAgICAgIG1ldGhvZCA9ICdQQVRDSCc7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdlYmhvb2tfaWQ6IHdlYmhvb2tJZCxcclxuICAgICAgICAgICAgICAgICAgICBuZnRfbWV0YWRhdGFfZmlsdGVyc190b19hZGQ6IHVwZGF0ZS5hZGRNZXRhZGF0YUZpbHRlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB1cGRhdGUuYWRkTWV0YWRhdGFGaWx0ZXJzLm1hcChuZnRGaWx0ZXJUb1BhcmFtKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIG5mdF9tZXRhZGF0YV9maWx0ZXJzX3RvX3JlbW92ZTogdXBkYXRlLnJlbW92ZU1ldGFkYXRhRmlsdGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHVwZGF0ZS5yZW1vdmVNZXRhZGF0YUZpbHRlcnMubWFwKG5mdEZpbHRlclRvUGFyYW0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogW11cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoJ2FkZEFkZHJlc3NlcycgaW4gdXBkYXRlIHx8ICdyZW1vdmVBZGRyZXNzZXMnIGluIHVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdEFwaU5hbWUgPSAndXBkYXRlLXdlYmhvb2stYWRkcmVzc2VzJztcclxuICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnd2ViaG9vazp1cGRhdGVXZWJob29rQWRkcmVzc2VzJztcclxuICAgICAgICAgICAgICAgIG1ldGhvZCA9ICdQQVRDSCc7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdlYmhvb2tfaWQ6IHdlYmhvb2tJZCxcclxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXNfdG9fYWRkOiB5aWVsZCB0aGlzLnJlc29sdmVBZGRyZXNzZXModXBkYXRlLmFkZEFkZHJlc3NlcyksXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzX3RvX3JlbW92ZTogeWllbGQgdGhpcy5yZXNvbHZlQWRkcmVzc2VzKHVwZGF0ZS5yZW1vdmVBZGRyZXNzZXMpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCduZXdBZGRyZXNzZXMnIGluIHVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdEFwaU5hbWUgPSAndXBkYXRlLXdlYmhvb2stYWRkcmVzc2VzJztcclxuICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnd2ViaG9vazp1cGRhdGVXZWJob29rQWRkcmVzcyc7XHJcbiAgICAgICAgICAgICAgICBtZXRob2QgPSAnUFVUJztcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2ViaG9va19pZDogd2ViaG9va0lkLFxyXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3NlczogeWllbGQgdGhpcy5yZXNvbHZlQWRkcmVzc2VzKHVwZGF0ZS5uZXdBZGRyZXNzZXMpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGB1cGRhdGVgIHBhcmFtIHBhc3NlZCBpbnRvIGB1cGRhdGVXZWJob29rYCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuc2VuZFdlYmhvb2tSZXF1ZXN0KHJlc3RBcGlOYW1lLCBtZXRob2ROYW1lLCB7fSwge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgZGF0YVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVdlYmhvb2sodXJsLCB0eXBlLCBwYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGxldCBhcHBJZDtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IGV4cG9ydHMuV2ViaG9va1R5cGUuTUlORURfVFJBTlNBQ1RJT04gfHxcclxuICAgICAgICAgICAgICAgIHR5cGUgPT09IGV4cG9ydHMuV2ViaG9va1R5cGUuRFJPUFBFRF9UUkFOU0FDVElPTikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoJ2FwcElkJyBpbiBwYXJhbXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBXZWJob29rcyByZXF1aXJlIGFuIGFwcCBpZC4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFwcElkID0gcGFyYW1zLmFwcElkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBuZXR3b3JrID0gTkVUV09SS19UT19XRUJIT09LX05FVFdPUksuZ2V0KHRoaXMuY29uZmlnLm5ldHdvcmspO1xyXG4gICAgICAgICAgICBsZXQgbmZ0RmlsdGVyT2JqO1xyXG4gICAgICAgICAgICBsZXQgYWRkcmVzc2VzO1xyXG4gICAgICAgICAgICBsZXQgZ3JhcGhxbFF1ZXJ5O1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gZXhwb3J0cy5XZWJob29rVHlwZS5ORlRfQUNUSVZJVFkgfHxcclxuICAgICAgICAgICAgICAgIHR5cGUgPT09IGV4cG9ydHMuV2ViaG9va1R5cGUuTkZUX01FVEFEQVRBX1VQREFURSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoJ2ZpbHRlcnMnIGluIHBhcmFtcykgfHwgcGFyYW1zLmZpbHRlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZnQgQWN0aXZpdHkgV2ViaG9va3MgcmVxdWlyZSBhIG5vbi1lbXB0eSBhcnJheSBpbnB1dC4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5ldHdvcmsgPSBwYXJhbXMubmV0d29ya1xyXG4gICAgICAgICAgICAgICAgICAgID8gTkVUV09SS19UT19XRUJIT09LX05FVFdPUksuZ2V0KHBhcmFtcy5uZXR3b3JrKVxyXG4gICAgICAgICAgICAgICAgICAgIDogbmV0d29yaztcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcnMgPSBwYXJhbXMuZmlsdGVycy5tYXAoZmlsdGVyID0+IGZpbHRlci50b2tlbklkXHJcbiAgICAgICAgICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0X2FkZHJlc3M6IGZpbHRlci5jb250cmFjdEFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuX2lkOiBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oZmlsdGVyLnRva2VuSWQpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0X2FkZHJlc3M6IGZpbHRlci5jb250cmFjdEFkZHJlc3NcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIG5mdEZpbHRlck9iaiA9XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gZXhwb3J0cy5XZWJob29rVHlwZS5ORlRfQUNUSVZJVFlcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IG5mdF9maWx0ZXJzOiBmaWx0ZXJzIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IG5mdF9tZXRhZGF0YV9maWx0ZXJzOiBmaWx0ZXJzIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gZXhwb3J0cy5XZWJob29rVHlwZS5BRERSRVNTX0FDVElWSVRZKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICAhKCdhZGRyZXNzZXMnIGluIHBhcmFtcykgfHxcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuYWRkcmVzc2VzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWRkcmVzcyBBY3Rpdml0eSBXZWJob29rcyByZXF1aXJlIGEgbm9uLWVtcHR5IGFycmF5IGlucHV0LicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV0d29yayA9IHBhcmFtcy5uZXR3b3JrXHJcbiAgICAgICAgICAgICAgICAgICAgPyBORVRXT1JLX1RPX1dFQkhPT0tfTkVUV09SSy5nZXQocGFyYW1zLm5ldHdvcmspXHJcbiAgICAgICAgICAgICAgICAgICAgOiBuZXR3b3JrO1xyXG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzID0geWllbGQgdGhpcy5yZXNvbHZlQWRkcmVzc2VzKHBhcmFtcy5hZGRyZXNzZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gZXhwb3J0cy5XZWJob29rVHlwZS5HUkFQSFFMKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICAhKCdncmFwaHFsUXVlcnknIGluIHBhcmFtcykgfHxcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZ3JhcGhxbFF1ZXJ5Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VzdG9tIFdlYmhvb2tzIHJlcXVpcmUgYSBub24tZW1wdHkgZ3JhcGhxbCBxdWVyeS4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5ldHdvcmsgPSBwYXJhbXMubmV0d29ya1xyXG4gICAgICAgICAgICAgICAgICAgID8gTkVUV09SS19UT19XRUJIT09LX05FVFdPUksuZ2V0KHBhcmFtcy5uZXR3b3JrKVxyXG4gICAgICAgICAgICAgICAgICAgIDogbmV0d29yaztcclxuICAgICAgICAgICAgICAgIGdyYXBocWxRdWVyeSA9IHBhcmFtcy5ncmFwaHFsUXVlcnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBuZXR3b3JrLCB3ZWJob29rX3R5cGU6IHR5cGUsIHdlYmhvb2tfdXJsOiB1cmwgfSwgKGFwcElkICYmIHsgYXBwX2lkOiBhcHBJZCB9KSksIG5mdEZpbHRlck9iaiksIChhZGRyZXNzZXMgJiYgeyBhZGRyZXNzZXMgfSkpLCAoZ3JhcGhxbFF1ZXJ5ICYmIHsgZ3JhcGhxbF9xdWVyeTogZ3JhcGhxbFF1ZXJ5IH0pKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNlbmRXZWJob29rUmVxdWVzdCgnY3JlYXRlLXdlYmhvb2snLCAnY3JlYXRlV2ViaG9vaycsIHt9LCB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgICAgIGRhdGFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVJhd1dlYmhvb2socmVzcG9uc2UuZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBkZWxldGVXZWJob29rKHdlYmhvb2tPcklkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB0aGlzLnZlcmlmeUNvbmZpZygpO1xyXG4gICAgICAgICAgICBjb25zdCB3ZWJob29rSWQgPSB0eXBlb2Ygd2ViaG9va09ySWQgPT09ICdzdHJpbmcnID8gd2ViaG9va09ySWQgOiB3ZWJob29rT3JJZC5pZDtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNlbmRXZWJob29rUmVxdWVzdCgnZGVsZXRlLXdlYmhvb2snLCAnZGVsZXRlV2ViaG9vaycsIHtcclxuICAgICAgICAgICAgICAgIHdlYmhvb2tfaWQ6IHdlYmhvb2tJZFxyXG4gICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoJ21lc3NhZ2UnIGluIHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdlYmhvb2sgbm90IGZvdW5kLiBGYWlsZWQgdG8gZGVsZXRlIHdlYmhvb2s6ICR7d2ViaG9va0lkfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB2ZXJpZnlDb25maWcoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmF1dGhUb2tlbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXNpbmcgdGhlIE5vdGlmeSBBUEkgcmVxdWlyZXMgc2V0dGluZyB0aGUgQWxjaGVteSBBdXRoIFRva2VuIGluICcgK1xyXG4gICAgICAgICAgICAgICAgJ3RoZSBzZXR0aW5ncyBvYmplY3Qgd2hlbiBpbml0aWFsaXppbmcgQWxjaGVteS4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZW5kV2ViaG9va1JlcXVlc3QocmVzdEFwaU5hbWUsIG1ldGhvZE5hbWUsIHBhcmFtcywgb3ZlcnJpZGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RIdHRwV2l0aEJhY2tvZmYodGhpcy5jb25maWcsIEFsY2hlbXlBcGlUeXBlLldFQkhPT0ssIHJlc3RBcGlOYW1lLCBtZXRob2ROYW1lLCBwYXJhbXMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3ZlcnJpZGVzKSwgeyBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHsgJ1gtQWxjaGVteS1Ub2tlbic6IHRoaXMuY29uZmlnLmF1dGhUb2tlbiB9LCBvdmVycmlkZXMgPT09IG51bGwgfHwgb3ZlcnJpZGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdmVycmlkZXMuaGVhZGVycykgfSkpO1xyXG4gICAgfVxyXG4gICAgLyoqIFJlc29sdmVzIEVOUyBhZGRyZXNzZXMgdG8gdGhlIHJhdyBhZGRyZXNzLlxyXG4gICAgICogQGludGVybmFsICovXHJcbiAgICByZXNvbHZlQWRkcmVzc2VzKGFkZHJlc3Nlcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKGFkZHJlc3NlcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRBZGRyZXNzZXMgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgYWRkcmVzc2VzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByYXdBZGRyZXNzID0geWllbGQgcHJvdmlkZXIucmVzb2x2ZU5hbWUoYWRkcmVzcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmF3QWRkcmVzcyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHJlc29sdmUgdGhlIEVOUyBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFkZHJlc3Nlcy5wdXNoKHJhd0FkZHJlc3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZEFkZHJlc3NlcztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTWFwcGluZyBvZiB3ZWJob29rIG5ldHdvcmsgcmVwcmVzZW50YXRpb25zIHRvIHRoZSBTREsncyBuZXR3b3JrIHJlcHJlc2VudGF0aW9uLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IFdFQkhPT0tfTkVUV09SS19UT19ORVRXT1JLID0ge1xyXG4gICAgRVRIX01BSU5ORVQ6IGV4cG9ydHMuTmV0d29yay5FVEhfTUFJTk5FVCxcclxuICAgIEVUSF9HT0VSTEk6IGV4cG9ydHMuTmV0d29yay5FVEhfR09FUkxJLFxyXG4gICAgRVRIX1NFUE9MSUE6IGV4cG9ydHMuTmV0d29yay5FVEhfU0VQT0xJQSxcclxuICAgIE1BVElDX01BSU5ORVQ6IGV4cG9ydHMuTmV0d29yay5NQVRJQ19NQUlOTkVULFxyXG4gICAgTUFUSUNfTVVNQkFJOiBleHBvcnRzLk5ldHdvcmsuTUFUSUNfTVVNQkFJLFxyXG4gICAgQVJCX01BSU5ORVQ6IGV4cG9ydHMuTmV0d29yay5BUkJfTUFJTk5FVCxcclxuICAgIEFSQl9HT0VSTEk6IGV4cG9ydHMuTmV0d29yay5BUkJfR09FUkxJLFxyXG4gICAgT1BUX01BSU5ORVQ6IGV4cG9ydHMuTmV0d29yay5PUFRfTUFJTk5FVCxcclxuICAgIE9QVF9HT0VSTEk6IGV4cG9ydHMuTmV0d29yay5PUFRfR09FUkxJXHJcbn07XHJcbi8qKiBNYXBwaW5nIG9mIHRoZSBTREsncyBuZXR3b3JrIHJlcHJlc2VudGF0aW9uIHRoZSB3ZWJob29rIEFQSSdzIG5ldHdvcmsgcmVwcmVzZW50YXRpb24uICovXHJcbmNvbnN0IE5FVFdPUktfVE9fV0VCSE9PS19ORVRXT1JLID0gT2JqZWN0LmtleXMoZXhwb3J0cy5OZXR3b3JrKS5yZWR1Y2UoKG1hcCwga2V5KSA9PiB7XHJcbiAgICBpZiAoa2V5IGluIFdFQkhPT0tfTkVUV09SS19UT19ORVRXT1JLKSB7XHJcbiAgICAgICAgbWFwLnNldChXRUJIT09LX05FVFdPUktfVE9fTkVUV09SS1trZXldLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hcDtcclxufSwgbmV3IE1hcCgpKTtcclxuZnVuY3Rpb24gcGFyc2VSYXdXZWJob29rUmVzcG9uc2UocmVzcG9uc2UpIHtcclxuICAgIHJldHVybiByZXNwb25zZS5kYXRhLm1hcChwYXJzZVJhd1dlYmhvb2spO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlUmF3V2ViaG9vayhyYXdXZWJob29rKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IGlkOiByYXdXZWJob29rLmlkLCBuZXR3b3JrOiBXRUJIT09LX05FVFdPUktfVE9fTkVUV09SS1tyYXdXZWJob29rLm5ldHdvcmtdLCB0eXBlOiByYXdXZWJob29rLndlYmhvb2tfdHlwZSwgdXJsOiByYXdXZWJob29rLndlYmhvb2tfdXJsLCBpc0FjdGl2ZTogcmF3V2ViaG9vay5pc19hY3RpdmUsIHRpbWVDcmVhdGVkOiBuZXcgRGF0ZShyYXdXZWJob29rLnRpbWVfY3JlYXRlZCkudG9JU09TdHJpbmcoKSwgc2lnbmluZ0tleTogcmF3V2ViaG9vay5zaWduaW5nX2tleSwgdmVyc2lvbjogcmF3V2ViaG9vay52ZXJzaW9uIH0sIChyYXdXZWJob29rLmFwcF9pZCAhPT0gdW5kZWZpbmVkICYmIHsgYXBwSWQ6IHJhd1dlYmhvb2suYXBwX2lkIH0pKTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZVJhd0FkZHJlc3NBY3Rpdml0eVJlc3BvbnNlKHJlc3BvbnNlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFkZHJlc3NlczogcmVzcG9uc2UuZGF0YSxcclxuICAgICAgICB0b3RhbENvdW50OiByZXNwb25zZS5wYWdpbmF0aW9uLnRvdGFsX2NvdW50LFxyXG4gICAgICAgIHBhZ2VLZXk6IHJlc3BvbnNlLnBhZ2luYXRpb24uY3Vyc29ycy5hZnRlclxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZVJhd0N1c3RvbUdyYXBocWxXZWJob29rUmVzcG9uc2UocmVzcG9uc2UpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ3JhcGhxbFF1ZXJ5OiByZXNwb25zZS5kYXRhLmdyYXBocWxfcXVlcnlcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VSYXdOZnRGaWx0ZXJzUmVzcG9uc2UocmVzcG9uc2UpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZmlsdGVyczogcmVzcG9uc2UuZGF0YS5tYXAoZiA9PiBmLnRva2VuX2lkXHJcbiAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBmLmNvbnRyYWN0X2FkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICB0b2tlbklkOiBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oZi50b2tlbl9pZCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBmLmNvbnRyYWN0X2FkZHJlc3NcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgdG90YWxDb3VudDogcmVzcG9uc2UucGFnaW5hdGlvbi50b3RhbF9jb3VudCxcclxuICAgICAgICBwYWdlS2V5OiByZXNwb25zZS5wYWdpbmF0aW9uLmN1cnNvcnMuYWZ0ZXJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gbmZ0RmlsdGVyVG9QYXJhbShmaWx0ZXIpIHtcclxuICAgIHJldHVybiBmaWx0ZXIudG9rZW5JZFxyXG4gICAgICAgID8ge1xyXG4gICAgICAgICAgICBjb250cmFjdF9hZGRyZXNzOiBmaWx0ZXIuY29udHJhY3RBZGRyZXNzLFxyXG4gICAgICAgICAgICB0b2tlbl9pZDogYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKGZpbHRlci50b2tlbklkKS50b1N0cmluZygpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIDoge1xyXG4gICAgICAgICAgICBjb250cmFjdF9hZGRyZXNzOiBmaWx0ZXIuY29udHJhY3RBZGRyZXNzXHJcbiAgICAgICAgfTtcclxufVxuXG4vKipcclxuICogTXVsdGlwbGVzIHRvIGluY3JlbWVudCBmZWUgcGVyIGdhcyB3aGVuIHVzaW5nXHJcbiAqIHtAbGluayBUcmFuc2FjdE5hbWVzcGFjZS5zZW5kR2FzT3B0aW1pemVkVHJhbnNhY3Rpb259LlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IEdBU19PUFRJTUlaRURfVFhfRkVFX01VTFRJUExFUyA9IFswLjksIDEsIDEuMSwgMS4yLCAxLjNdO1xyXG4vKipcclxuICogVGhlIFRyYW5zYWN0IG5hbWVzcGFjZSBjb250YWlucyBtZXRob2RzIHVzZWQgZm9yIHNlbmRpbmcgdHJhbnNhY3Rpb25zIGFuZFxyXG4gKiBjaGVja2luZyBvbiB0aGUgc3RhdGUgb2Ygc3VibWl0dGVkIHRyYW5zYWN0aW9ucy5cclxuICpcclxuICogRG8gbm90IGNhbGwgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS4gSW5zdGVhZCwgaW5zdGFudGlhdGUgYW4gQWxjaGVteSBvYmplY3RcclxuICogd2l0aCBgY29uc3QgYWxjaGVteSA9IG5ldyBBbGNoZW15KGNvbmZpZylgIGFuZCB0aGVuIGFjY2VzcyB0aGUgdHJhbnNhY3RcclxuICogbmFtZXNwYWNlIHZpYSBgYWxjaGVteS50cmFuc2FjdGAuXHJcbiAqL1xyXG5jbGFzcyBUcmFuc2FjdE5hbWVzcGFjZSB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byBzZW5kIGEgc2luZ2xlIHRyYW5zYWN0aW9uIHRvIEZsYXNoYm90cy4gRmxhc2hib3RzIHdpbGwgYXR0ZW1wdCB0b1xyXG4gICAgICogc2VuZCB0aGUgdHJhbnNhY3Rpb24gdG8gbWluZXJzIGZvciB0aGUgbmV4dCAyNSBibG9ja3MuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJucyB0aGUgdHJhbnNhY3Rpb24gaGFzaCBvZiB0aGUgc3VibWl0dGVkIHRyYW5zYWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzaWduZWRUcmFuc2FjdGlvbiBUaGUgcmF3LCBzaWduZWQgdHJhbnNhY3Rpb24gYXMgYSBoYXNoLlxyXG4gICAgICogQHBhcmFtIG1heEJsb2NrTnVtYmVyIE9wdGlvbmFsIGhpZ2hlc3QgYmxvY2sgbnVtYmVyIGluIHdoaWNoIHRoZVxyXG4gICAgICogICB0cmFuc2FjdGlvbiBzaG91bGQgYmUgaW5jbHVkZWQuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgc2VuZFByaXZhdGVUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbiwgbWF4QmxvY2tOdW1iZXIsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgaGV4QmxvY2tOdW1iZXIgPSBtYXhCbG9ja051bWJlciA/IHRvSGV4KG1heEJsb2NrTnVtYmVyKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLl9zZW5kKCdldGhfc2VuZFByaXZhdGVUcmFuc2FjdGlvbicsIFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0eDogc2lnbmVkVHJhbnNhY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4QmxvY2tOdW1iZXI6IGhleEJsb2NrTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzOiBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sICdzZW5kUHJpdmF0ZVRyYW5zYWN0aW9uJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIHRoZSBwcm92aWRlZCBwcml2YXRlIHRyYW5zYWN0aW9uIGZyb20gYmVpbmcgc3VibWl0dGVkIGZvciBmdXR1cmVcclxuICAgICAqIGJsb2Nrcy4gQSB0cmFuc2FjdGlvbiBjYW4gb25seSBiZSBjYW5jZWxsZWQgaWYgdGhlIHJlcXVlc3QgaXMgc2lnbmVkIGJ5IHRoZVxyXG4gICAgICogc2FtZSBrZXkgYXMgdGhlIHtAbGluayBzZW5kUHJpdmF0ZVRyYW5zYWN0aW9ufSBjYWxsIHN1Ym1pdHRpbmcgdGhlXHJcbiAgICAgKiB0cmFuc2FjdGlvbiBpbiBmaXJzdCBwbGFjZS5cclxuICAgICAqXHJcbiAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IGZhc3QgbW9kZSB0cmFuc2FjdGlvbnMgY2Fubm90IGJlIGNhbmNlbGxlZCB1c2luZyB0aGlzIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNhbmNlbGxhdGlvbiB3YXMgc3VjY2Vzc2Z1bC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25IYXNoIFRyYW5zYWN0aW9uIGhhc2ggb2YgcHJpdmF0ZSB0eCB0byBiZSBjYW5jZWxsZWRcclxuICAgICAqL1xyXG4gICAgY2FuY2VsUHJpdmF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuX3NlbmQoJ2V0aF9jYW5jZWxQcml2YXRlVHJhbnNhY3Rpb24nLCBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHhIYXNoOiB0cmFuc2FjdGlvbkhhc2hcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSwgJ2NhbmNlbFByaXZhdGVUcmFuc2FjdGlvbicpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW11bGF0ZXMgdGhlIGFzc2V0IGNoYW5nZXMgcmVzdWx0aW5nIGZyb20gYSBsaXN0IG9mIHRyYW5zYWN0aW9ucyBzaW11bGF0ZWRcclxuICAgICAqIGluIHNlcXVlbmNlLlxyXG4gICAgICpcclxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGFzc2V0IGNoYW5nZXMgZm9yIGVhY2ggdHJhbnNhY3Rpb24gZHVyaW5nIHNpbXVsYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9ucyBUcmFuc2FjdGlvbnMgbGlzdCBvZiBtYXggMyB0cmFuc2FjdGlvbnMgdG8gc2ltdWxhdGUuXHJcbiAgICAgKiBAcGFyYW0gYmxvY2tJZGVudGlmaWVyIE9wdGlvbmFsIGJsb2NrIGlkZW50aWZpZXIgdG8gc2ltdWxhdGUgdGhlXHJcbiAgICAgKiB0cmFuc2FjdGlvbiBpbi5cclxuICAgICAqL1xyXG4gICAgc2ltdWxhdGVBc3NldENoYW5nZXNCdW5kbGUodHJhbnNhY3Rpb25zLCBibG9ja0lkZW50aWZpZXIpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gYmxvY2tJZGVudGlmaWVyICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8gW3RyYW5zYWN0aW9ucywgYmxvY2tJZGVudGlmaWVyXVxyXG4gICAgICAgICAgICAgICAgOiBbdHJhbnNhY3Rpb25zXTtcclxuICAgICAgICAgICAgY29uc3QgcmVzID0geWllbGQgcHJvdmlkZXIuX3NlbmQoJ2FsY2hlbXlfc2ltdWxhdGVBc3NldENoYW5nZXNCdW5kbGUnLCBwYXJhbXMsICdzaW11bGF0ZUFzc2V0Q2hhbmdlc0J1bmRsZScpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZChyZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW11bGF0ZXMgdGhlIGFzc2V0IGNoYW5nZXMgcmVzdWx0aW5nIGZyb20gYSBzaW5nbGUgdHJhbnNhY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJucyBsaXN0IG9mIGFzc2V0IGNoYW5nZXMgdGhhdCBvY2N1cnJlZCBkdXJpbmcgdGhlIHRyYW5zYWN0aW9uXHJcbiAgICAgKiBzaW11bGF0aW9uLiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgZG9lcyBub3QgcnVuIHRoZSB0cmFuc2FjdGlvbiBvbiB0aGVcclxuICAgICAqIGJsb2NrY2hhaW4uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiB0byBzaW11bGF0ZS5cclxuICAgICAqIEBwYXJhbSBibG9ja0lkZW50aWZpZXIgT3B0aW9uYWwgYmxvY2sgaWRlbnRpZmllciB0byBzaW11bGF0ZSB0aGVcclxuICAgICAqIHRyYW5zYWN0aW9uIGluLlxyXG4gICAgICovXHJcbiAgICBzaW11bGF0ZUFzc2V0Q2hhbmdlcyh0cmFuc2FjdGlvbiwgYmxvY2tJZGVudGlmaWVyKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGJsb2NrSWRlbnRpZmllciAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICA/IFt0cmFuc2FjdGlvbiwgYmxvY2tJZGVudGlmaWVyXVxyXG4gICAgICAgICAgICAgICAgOiBbdHJhbnNhY3Rpb25dO1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSB5aWVsZCBwcm92aWRlci5fc2VuZCgnYWxjaGVteV9zaW11bGF0ZUFzc2V0Q2hhbmdlcycsIHBhcmFtcywgJ3NpbXVsYXRlQXNzZXRDaGFuZ2VzJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsc1RvVW5kZWZpbmVkKHJlcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNpbXVsYXRlcyBhIGxpc3Qgb2YgdHJhbnNhY3Rpb25zIGluIHNlcXVlbmNlIGFuZCByZXR1cm5zIGxpc3Qgb2YgZGVjb2RlZFxyXG4gICAgICogdHJhY2VzIGFuZCBsb2dzIHRoYXQgb2NjdXJyZWQgZm9yIGVhY2ggdHJhbnNhY3Rpb24gZHVyaW5nIHNpbXVsYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGRvZXMgbm90IHJ1biBhbnkgdHJhbnNhY3Rpb25zIG9uIHRoZSBibG9ja2NoYWluLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbnMgVHJhbnNhY3Rpb25zIGxpc3Qgb2YgbWF4IDMgdHJhbnNhY3Rpb25zIHRvIHNpbXVsYXRlLlxyXG4gICAgICogQHBhcmFtIGJsb2NrSWRlbnRpZmllciBPcHRpb25hbCBibG9jayBpZGVudGlmaWVyIHRvIHNpbXVsYXRlIHRoZVxyXG4gICAgICogdHJhbnNhY3Rpb24gaW4uXHJcbiAgICAgKi9cclxuICAgIHNpbXVsYXRlRXhlY3V0aW9uQnVuZGxlKHRyYW5zYWN0aW9ucywgYmxvY2tJZGVudGlmaWVyKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGJsb2NrSWRlbnRpZmllciAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICA/IFt0cmFuc2FjdGlvbnMsIGJsb2NrSWRlbnRpZmllcl1cclxuICAgICAgICAgICAgICAgIDogW3RyYW5zYWN0aW9uc107XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHByb3ZpZGVyLl9zZW5kKCdhbGNoZW15X3NpbXVsYXRlRXhlY3V0aW9uQnVuZGxlJywgcGFyYW1zLCAnc2ltdWxhdGVFeGVjdXRpb25CdW5kbGUnKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGxzVG9VbmRlZmluZWQocmVzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2ltdWxhdGVzIGEgc2luZ2xlIHRyYW5zYWN0aW9uIGFuZCB0aGUgcmVzdWx0aW5nIGFuZCByZXR1cm5zIGxpc3Qgb2ZcclxuICAgICAqIGRlY29kZWQgdHJhY2VzIGFuZCBsb2dzIHRoYXQgb2NjdXJyZWQgZHVyaW5nIHRoZSB0cmFuc2FjdGlvbiBzaW11bGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBkb2VzIG5vdCBydW4gdGhlIHRyYW5zYWN0aW9uIG9uIHRoZSBibG9ja2NoYWluLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiBUaGUgdHJhbnNhY3Rpb24gdG8gc2ltdWxhdGUuXHJcbiAgICAgKiBAcGFyYW0gYmxvY2tJZGVudGlmaWVyIE9wdGlvbmFsIGJsb2NrIGlkZW50aWZpZXIgdG8gc2ltdWxhdGUgdGhlXHJcbiAgICAgKiB0cmFuc2FjdGlvbiBpbi5cclxuICAgICAqL1xyXG4gICAgc2ltdWxhdGVFeGVjdXRpb24odHJhbnNhY3Rpb24sIGJsb2NrSWRlbnRpZmllcikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBibG9ja0lkZW50aWZpZXIgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgPyBbdHJhbnNhY3Rpb24sIGJsb2NrSWRlbnRpZmllcl1cclxuICAgICAgICAgICAgICAgIDogW3RyYW5zYWN0aW9uXTtcclxuICAgICAgICAgICAgY29uc3QgcmVzID0gcHJvdmlkZXIuX3NlbmQoJ2FsY2hlbXlfc2ltdWxhdGVFeGVjdXRpb24nLCBwYXJhbXMsICdzaW11bGF0ZUV4ZWN1dGlvbicpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbHNUb1VuZGVmaW5lZChyZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiB3aXRoIGhhc2ggb3IgbnVsbCBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgdW5rbm93bi5cclxuICAgICAqXHJcbiAgICAgKiBJZiBhIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBtaW5lZCwgdGhpcyBtZXRob2Qgd2lsbCBzZWFyY2ggdGhlXHJcbiAgICAgKiB0cmFuc2FjdGlvbiBwb29sLiBWYXJpb3VzIGJhY2tlbmRzIG1heSBoYXZlIG1vcmUgcmVzdHJpY3RpdmUgdHJhbnNhY3Rpb25cclxuICAgICAqIHBvb2wgYWNjZXNzIChlLmcuIGlmIHRoZSBnYXMgcHJpY2UgaXMgdG9vIGxvdyBvciB0aGUgdHJhbnNhY3Rpb24gd2FzIG9ubHlcclxuICAgICAqIHJlY2VudGx5IHNlbnQgYW5kIG5vdCB5ZXQgaW5kZXhlZCkgaW4gd2hpY2ggY2FzZSB0aGlzIG1ldGhvZCBtYXkgYWxzbyByZXR1cm4gbnVsbC5cclxuICAgICAqXHJcbiAgICAgKiBOT1RFOiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgQ29yZU5hbWVzcGFjZS5nZXRUcmFuc2FjdGlvbn0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uSGFzaCBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gZ2V0LlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN1Ym1pdHMgdHJhbnNhY3Rpb24gdG8gdGhlIG5ldHdvcmsgdG8gYmUgbWluZWQuIFRoZSB0cmFuc2FjdGlvbiBtdXN0IGJlXHJcbiAgICAgKiBzaWduZWQsIGFuZCBiZSB2YWxpZCAoaS5lLiB0aGUgbm9uY2UgaXMgY29ycmVjdCBhbmQgdGhlIGFjY291bnQgaGFzXHJcbiAgICAgKiBzdWZmaWNpZW50IGJhbGFuY2UgdG8gcGF5IGZvciB0aGUgdHJhbnNhY3Rpb24pLlxyXG4gICAgICpcclxuICAgICAqIE5PVEU6IFRoaXMgaXMgYW4gYWxpYXMgZm9yIHtAbGluayBDb3JlTmFtZXNwYWNlLnNlbmRUcmFuc2FjdGlvbn0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNpZ25lZFRyYW5zYWN0aW9uIFRoZSBzaWduZWQgdHJhbnNhY3Rpb24gdG8gc2VuZC5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5zZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGVzdGltYXRlIG9mIHRoZSBhbW91bnQgb2YgZ2FzIHRoYXQgd291bGQgYmUgcmVxdWlyZWQgdG8gc3VibWl0XHJcbiAgICAgKiB0cmFuc2FjdGlvbiB0byB0aGUgbmV0d29yay5cclxuICAgICAqXHJcbiAgICAgKiBBbiBlc3RpbWF0ZSBtYXkgbm90IGJlIGFjY3VyYXRlIHNpbmNlIHRoZXJlIGNvdWxkIGJlIGFub3RoZXIgdHJhbnNhY3Rpb24gb25cclxuICAgICAqIHRoZSBuZXR3b3JrIHRoYXQgd2FzIG5vdCBhY2NvdW50ZWQgZm9yLCBidXQgYWZ0ZXIgYmVpbmcgbWluZWQgYWZmZWN0cyB0aGVcclxuICAgICAqIHJlbGV2YW50IHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgaXMgYW4gYWxpYXMgZm9yIHtAbGluayBDb3JlTmFtZXNwYWNlLmVzdGltYXRlR2FzfS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gVGhlIHRyYW5zYWN0aW9uIHRvIGVzdGltYXRlIGdhcyBmb3IuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGVzdGltYXRlR2FzKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5lc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBmZWUgcGVyIGdhcyAoaW4gd2VpKSB0aGF0IGlzIGFuIGVzdGltYXRlIG9mIGhvdyBtdWNoIHlvdSBjYW4gcGF5XHJcbiAgICAgKiBhcyBhIHByaW9yaXR5IGZlZSwgb3IgXCJ0aXBcIiwgdG8gZ2V0IGEgdHJhbnNhY3Rpb24gaW5jbHVkZWQgaW4gdGhlIGN1cnJlbnQgYmxvY2suXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBudW1iZXIgaXMgZ2VuZXJhbGx5IHVzZWQgdG8gc2V0IHRoZSBgbWF4UHJpb3JpdHlGZWVQZXJHYXNgIGZpZWxkIGluIGFcclxuICAgICAqIHRyYW5zYWN0aW9uIHJlcXVlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBnZXRNYXhQcmlvcml0eUZlZVBlckdhcygpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgZmVlSGV4ID0geWllbGQgcHJvdmlkZXIuX3NlbmQoJ2V0aF9tYXhQcmlvcml0eUZlZVBlckdhcycsIFtdLCAnZ2V0TWF4UHJpb3JpdHlGZWVQZXJHYXMnKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21IZXgoZmVlSGV4KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHByb21pc2Ugd2hpY2ggd2lsbCBub3QgcmVzb2x2ZSB1bnRpbCBzcGVjaWZpZWQgdHJhbnNhY3Rpb24gaGFzaCBpcyBtaW5lZC5cclxuICAgICAqXHJcbiAgICAgKiBJZiB7QGxpbmsgY29uZmlybWF0aW9uc30gaXMgMCwgdGhpcyBtZXRob2QgaXMgbm9uLWJsb2NraW5nIGFuZCBpZiB0aGVcclxuICAgICAqIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBtaW5lZCByZXR1cm5zIG51bGwuIE90aGVyd2lzZSwgdGhpcyBtZXRob2Qgd2lsbFxyXG4gICAgICogYmxvY2sgdW50aWwgdGhlIHRyYW5zYWN0aW9uIGhhcyBjb25maXJtZWQgYmxvY2tzIG1pbmVkIG9uIHRvcCBvZiB0aGUgYmxvY2tcclxuICAgICAqIGluIHdoaWNoIGl0IHdhcyBtaW5lZC5cclxuICAgICAqXHJcbiAgICAgKiBOT1RFOiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgQ29yZU5hbWVzcGFjZS53YWl0Rm9yVHJhbnNhY3Rpb259LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbkhhc2ggVGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIHRvIHdhaXQgZm9yLlxyXG4gICAgICogQHBhcmFtIGNvbmZpcm1hdGlvbnMgVGhlIG51bWJlciBvZiBibG9ja3MgdG8gd2FpdCBmb3IuXHJcbiAgICAgKiBAcGFyYW0gdGltZW91dCBUaGUgbWF4aW11bSB0aW1lIHRvIHdhaXQgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBjb25maXJtLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICB3YWl0Rm9yVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoLCBjb25maXJtYXRpb25zLCB0aW1lb3V0KSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci53YWl0Rm9yVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoLCBjb25maXJtYXRpb25zLCB0aW1lb3V0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHNlbmRHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbk9yU2lnbmVkVHhzLCB3YWxsZXQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zYWN0aW9uT3JTaWduZWRUeHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VuZEdhc09wdGltaXplZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uT3JTaWduZWRUeHMsICdzZW5kR2FzT3B0aW1pemVkVHJhbnNhY3Rpb25QcmVTaWduZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgZ2FzTGltaXQ7XHJcbiAgICAgICAgICAgIGxldCBwcmlvcml0eUZlZTtcclxuICAgICAgICAgICAgbGV0IGJhc2VGZWU7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGdhc0xpbWl0ID0geWllbGQgdGhpcy5lc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbk9yU2lnbmVkVHhzKTtcclxuICAgICAgICAgICAgICAgIHByaW9yaXR5RmVlID0geWllbGQgdGhpcy5nZXRNYXhQcmlvcml0eUZlZVBlckdhcygpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEJsb2NrID0geWllbGQgcHJvdmlkZXIuZ2V0QmxvY2soJ2xhdGVzdCcpO1xyXG4gICAgICAgICAgICAgICAgYmFzZUZlZSA9IGN1cnJlbnRCbG9jay5iYXNlRmVlUGVyR2FzLnRvTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGVzdGltYXRlIGdhcyBmb3IgdHJhbnNhY3Rpb246ICR7ZX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBnYXNTcHJlYWRUcmFuc2FjdGlvbnMgPSBnZW5lcmF0ZUdhc1NwcmVhZFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbk9yU2lnbmVkVHhzLCBnYXNMaW1pdC50b051bWJlcigpLCBiYXNlRmVlLCBwcmlvcml0eUZlZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9ucyA9IHlpZWxkIFByb21pc2UuYWxsKGdhc1NwcmVhZFRyYW5zYWN0aW9ucy5tYXAodHggPT4gd2FsbGV0LnNpZ25UcmFuc2FjdGlvbih0eCkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmRHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbnMsICdzZW5kR2FzT3B0aW1pemVkVHJhbnNhY3Rpb25HZW5lcmF0ZWQnKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc3RhdGUgb2YgdGhlIHRyYW5zYWN0aW9uIGpvYiByZXR1cm5lZCBieSB0aGVcclxuICAgICAqIHtAbGluayBzZW5kR2FzT3B0aW1pemVkVHJhbnNhY3Rpb259LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0cmFja2luZ0lkIFRoZSB0cmFja2luZyBpZCBmcm9tIHRoZSByZXNwb25zZSBvZiB0aGUgc2VudCBnYXMgb3B0aW1pemVkIHRyYW5zYWN0aW9uLlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIC8vIFRPRE8odHhqb2IpOiBSZW1vdmUgaW50ZXJuYWwgdGFnIG9uY2UgdGhpcyBmZWF0dXJlIGlzIHJlbGVhc2VkLlxyXG4gICAgZ2V0R2FzT3B0aW1pemVkVHJhbnNhY3Rpb25TdGF0dXModHJhY2tpbmdJZCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuX3NlbmQoJ2FsY2hlbXlfZ2V0R2FzT3B0aW1pemVkVHJhbnNhY3Rpb25TdGF0dXMnLCBbdHJhY2tpbmdJZF0sICdnZXRHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvblN0YXR1cycpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgX3NlbmRHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbnMsIG1ldGhvZE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLl9zZW5kKCdhbGNoZW15X3NlbmRHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvbicsIFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByYXdUcmFuc2FjdGlvbnM6IHNpZ25lZFRyYW5zYWN0aW9uc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdLCBtZXRob2ROYW1lKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSGVscGVyIG1ldGhvZCB0byBnZW5lcmF0ZSB0aGUgcmF3IHRyYW5zYWN0aW9uIHdpdGggdGhlIGdpdmVuIGdhcyBsaW1pdCBhbmRcclxuICogcHJpb3JpdHkgZmVlIGFjcm9zcyBhIHNwcmVhZCBvZiBkaWZmZXJlbnQgZ2FzIHByaWNlcy5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG4vLyBWaXNpYmxlIGZvciB0ZXN0aW5nXHJcbmZ1bmN0aW9uIGdlbmVyYXRlR2FzU3ByZWFkVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9uLCBnYXNMaW1pdCwgYmFzZUZlZSwgcHJpb3JpdHlGZWUpIHtcclxuICAgIHJldHVybiBHQVNfT1BUSU1JWkVEX1RYX0ZFRV9NVUxUSVBMRVMubWFwKGZlZU11bHRpcGxpZXIgPT4ge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRyYW5zYWN0aW9uKSwgeyBnYXNMaW1pdCwgbWF4RmVlUGVyR2FzOiBNYXRoLnJvdW5kKGJhc2VGZWUgKiBmZWVNdWx0aXBsaWVyICsgcHJpb3JpdHlGZWUgKiBmZWVNdWx0aXBsaWVyKSwgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IE1hdGgucm91bmQoZmVlTXVsdGlwbGllciAqIHByaW9yaXR5RmVlKSB9KTtcclxuICAgIH0pO1xyXG59XG5cbi8qKiBUaGlzIGZpbGUgY29udGFpbnMgaW50ZXJuYWwgdHlwZXMgdXNlZCBieSB0aGUgU0RLIGFuZCBhcmUgbm90IGV4cG9zZWQgdG8gdGhlIGVuZCB1c2VyLiAqL1xyXG4vKipcclxuICogUHJlZml4IGZvciBgYWxjaGVteV9wZW5kaW5nVHJhbnNhY3Rpb25zYCBzdWJzY3JpcHRpb25zIHdoZW4gc2VyaWFsaXppbmcgdG9cclxuICogZXRoZXJzIGV2ZW50cy5cclxuICpcclxuICogVGhpcyB0YWcgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IGV0aGVycyB0byB0cmFjayBkaWZmZXJlbnQgZXZlbnQgZmlsdGVycy5cclxuICovXHJcbmNvbnN0IEFMQ0hFTVlfUEVORElOR19UUkFOU0FDVElPTlNfRVZFTlRfVFlQRSA9ICdhbGNoZW15LXBlbmRpbmctdHJhbnNhY3Rpb25zJztcclxuLyoqXHJcbiAqIFByZWZpeCBmb3IgYGFsY2hlbXlfbWluZWRUcmFuc2FjdGlvbnNgIHN1YnNjcmlwdGlvbnMgd2hlbiBzZXJpYWxpemluZyB0byBldGhlcnMgZXZlbnRzLlxyXG4gKlxyXG4gKiBUaGlzIHRhZyBpcyB1c2VkIGludGVybmFsbHkgYnkgZXRoZXJzIHRvIHRyYWNrIGRpZmZlcmVudCBldmVudCBmaWx0ZXJzLlxyXG4gKi9cclxuY29uc3QgQUxDSEVNWV9NSU5FRF9UUkFOU0FDVElPTlNfRVZFTlRfVFlQRSA9ICdhbGNoZW15LW1pbmVkLXRyYW5zYWN0aW9ucyc7XHJcbi8qKlxyXG4gKiBBcnJheSBjb250YWluaW5nIGFsbCB0aGUgY3VzdG9tIGV2ZW50IHRhZ3MgdXNlZCBpbnRlcm5hbGx5IGJ5IGV0aGVycyB0byB0cmFja1xyXG4gKiBldmVudCBmaWx0ZXJzLlxyXG4gKi9cclxuY29uc3QgQUxDSEVNWV9FVkVOVF9UWVBFUyA9IFtcclxuICAgIEFMQ0hFTVlfUEVORElOR19UUkFOU0FDVElPTlNfRVZFTlRfVFlQRSxcclxuICAgIEFMQ0hFTVlfTUlORURfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEVcclxuXTtcblxuLyoqXHJcbiAqIERPIE5PVCBNT0RJRlkuXHJcbiAqXHJcbiAqIEV2ZW50IGNsYXNzIGNvcGllZCBkaXJlY3RseSBvdmVyIGZyb20gZXRoZXJzLmpzJ3MgYEJhc2VQcm92aWRlcmAgY2xhc3MuXHJcbiAqXHJcbiAqIFRoaXMgY2xhc3MgaXMgdXNlZCB0byByZXByZXNlbnQgZXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIGxpc3RlbmVycy4gVGhlXHJcbiAqIFNESyBuZWVkcyB0byBleHRlbmQgdGhpcyBjbGFzcyBpbiBvcmRlciB0byBzdXBwb3J0IEFsY2hlbXkncyBjdXN0b21cclxuICogU3Vic2NyaXB0aW9uIEFQSSB0eXBlcy4gVGhlIG9yaWdpbmFsIGNsYXNzIGlzIG5vdCBleHBvcnRlZCBieSBldGhlcnMuIE1pbmltYWxcclxuICogY2hhbmdlcyBoYXZlIGJlZW4gbWFkZSBpbiBvcmRlciB0byBnZXQgVFMgdG8gY29tcGlsZS5cclxuICovXHJcbmNsYXNzIEV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhZywgbGlzdGVuZXIsIG9uY2UpIHtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XHJcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XHJcbiAgICAgICAgdGhpcy5vbmNlID0gb25jZTtcclxuICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSAtMjtcclxuICAgICAgICB0aGlzLl9pbmZsaWdodCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGV2ZW50KCkge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3R4JzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc2g7XHJcbiAgICAgICAgICAgIGNhc2UgJ2ZpbHRlcic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXI7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YWc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IHR5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnLnNwbGl0KCc6JylbMF07XHJcbiAgICB9XHJcbiAgICBnZXQgaGFzaCgpIHtcclxuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudGFnLnNwbGl0KCc6Jyk7XHJcbiAgICAgICAgaWYgKGNvbXBzWzBdICE9PSAndHgnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgdHJhbnNhY3Rpb24gZXZlbnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbXBzWzFdO1xyXG4gICAgfVxyXG4gICAgZ2V0IGZpbHRlcigpIHtcclxuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudGFnLnNwbGl0KCc6Jyk7XHJcbiAgICAgICAgaWYgKGNvbXBzWzBdICE9PSAnZmlsdGVyJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIHRyYW5zYWN0aW9uIGV2ZW50Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBjb21wc1sxXTtcclxuICAgICAgICBjb25zdCB0b3BpY3MgPSBkZXNlcmlhbGl6ZVRvcGljcyhjb21wc1syXSk7XHJcbiAgICAgICAgY29uc3QgZmlsdGVyID0ge307XHJcbiAgICAgICAgaWYgKHRvcGljcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGZpbHRlci50b3BpY3MgPSB0b3BpY3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhZGRyZXNzICYmIGFkZHJlc3MgIT09ICcqJykge1xyXG4gICAgICAgICAgICBmaWx0ZXIuYWRkcmVzcyA9IGFkZHJlc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaWx0ZXI7XHJcbiAgICB9XHJcbiAgICBwb2xsYWJsZSgpIHtcclxuICAgICAgICBjb25zdCBQb2xsYWJsZUV2ZW50cyA9IFsnYmxvY2snLCAnbmV0d29yaycsICdwZW5kaW5nJywgJ3BvbGwnXTtcclxuICAgICAgICByZXR1cm4gdGhpcy50YWcuaW5kZXhPZignOicpID49IDAgfHwgUG9sbGFibGVFdmVudHMuaW5kZXhPZih0aGlzLnRhZykgPj0gMDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogV3JhcHBlciBjbGFzcyBhcm91bmQgdGhlIGV0aGVycyBgRXZlbnRgIGNsYXNzIGluIG9yZGVyIHRvIGFkZCBzdXBwb3J0IGZvclxyXG4gKiBBbGNoZW15J3MgY3VzdG9tIHN1YnNjcmlwdGlvbnMgdHlwZXMuXHJcbiAqXHJcbiAqIFRoZSBzZXJpYWxpemF0aW9uIGFuZCBkZXNlcmlhbGl6YXRpb24gbWVjaGFuaXNtIHJlcXVpcmVzIHRoZSBvcmRlciBvZiB0aGVcclxuICogZmllbGRzIHRvIGJlIHRoZSBzYW1lIGFjcm9zcyBkaWZmZXJlbnQge0BsaW5rIEFMQ0hFTVlfRVZFTlRfVFlQRVN9LiBCZWZvcmVcclxuICogdXNpbmcgYSBnZXR0ZXIgb24gYSBuZXcgZXZlbnQgZmlsdGVyLCBtYWtlIHN1cmUgdGhhdCB0aGUgcG9zaXRpb24gb2YgdGhlXHJcbiAqIGZpZWxkIGluIHNlcmlhbGl6YXRpb24gaXMgY29ycmVjdC5cclxuICpcclxuICogVGhlIGdldHRlcnMgb24gdGhpcyBjbGFzcyBkZXNlcmlhbGl6ZSB0aGUgZXZlbnQgdGFnIGdlbmVyYXRlZCBieVxyXG4gKiB7QGxpbmsgZ2V0QWxjaGVteUV2ZW50VGFnfSBpbnRvIHRoZSBvcmlnaW5hbCBmaWVsZHMgcGFzc2VkIGludG8gdGhlIGV2ZW50LlxyXG4gKi9cclxuY2xhc3MgRXRoZXJzRXZlbnQgZXh0ZW5kcyBFdmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBldmVudCB0YWcgaW50byB0aGUgb3JpZ2luYWwgYGZyb21BZGRyZXNzYCBmaWVsZCBpblxyXG4gICAgICoge0BsaW5rIEFsY2hlbXlQZW5kaW5nVHJhbnNhY3Rpb25zRXZlbnRGaWx0ZXJ9LlxyXG4gICAgICovXHJcbiAgICBnZXQgZnJvbUFkZHJlc3MoKSB7XHJcbiAgICAgICAgY29uc3QgY29tcHMgPSB0aGlzLnRhZy5zcGxpdCgnOicpO1xyXG4gICAgICAgIGlmIChjb21wc1swXSAhPT0gQUxDSEVNWV9QRU5ESU5HX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wc1sxXSAmJiBjb21wc1sxXSAhPT0gJyonKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZUFkZHJlc3NGaWVsZChjb21wc1sxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIGV2ZW50IHRhZyBpbnRvIHRoZSBvcmlnaW5hbCBgdG9BZGRyZXNzYCBmaWVsZCBpblxyXG4gICAgICoge0BsaW5rIEFsY2hlbXlQZW5kaW5nVHJhbnNhY3Rpb25zRXZlbnRGaWx0ZXJ9LlxyXG4gICAgICovXHJcbiAgICBnZXQgdG9BZGRyZXNzKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50YWcuc3BsaXQoJzonKTtcclxuICAgICAgICBpZiAoY29tcHNbMF0gIT09IEFMQ0hFTVlfUEVORElOR19UUkFOU0FDVElPTlNfRVZFTlRfVFlQRSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcHNbMl0gJiYgY29tcHNbMl0gIT09ICcqJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVBZGRyZXNzRmllbGQoY29tcHNbMl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBldmVudCB0YWcgaW50byB0aGUgb3JpZ2luYWwgYGhhc2hlc09ubHlgIGZpZWxkIGluXHJcbiAgICAgKiB7QGxpbmsgQWxjaGVteVBlbmRpbmdUcmFuc2FjdGlvbnNFdmVudEZpbHRlcn0gYW5kIHtAbGluayBBbGNoZW15TWluZWRUcmFuc2FjdGlvbnNFdmVudEZpbHRlcn0uXHJcbiAgICAgKi9cclxuICAgIGdldCBoYXNoZXNPbmx5KCkge1xyXG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50YWcuc3BsaXQoJzonKTtcclxuICAgICAgICBpZiAoIUFMQ0hFTVlfRVZFTlRfVFlQRVMuaW5jbHVkZXMoY29tcHNbMF0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wc1szXSAmJiBjb21wc1szXSAhPT0gJyonKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wc1szXSA9PT0gJ3RydWUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgaW5jbHVkZVJlbW92ZWQoKSB7XHJcbiAgICAgICAgY29uc3QgY29tcHMgPSB0aGlzLnRhZy5zcGxpdCgnOicpO1xyXG4gICAgICAgIGlmIChjb21wc1swXSAhPT0gQUxDSEVNWV9NSU5FRF9UUkFOU0FDVElPTlNfRVZFTlRfVFlQRSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcHNbMl0gJiYgY29tcHNbMl0gIT09ICcqJykge1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcHNbMl0gPT09ICd0cnVlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGFkZHJlc3NlcygpIHtcclxuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudGFnLnNwbGl0KCc6Jyk7XHJcbiAgICAgICAgaWYgKGNvbXBzWzBdICE9PSBBTENIRU1ZX01JTkVEX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wc1sxXSAmJiBjb21wc1sxXSAhPT0gJyonKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZUFkZHJlc3Nlc0ZpZWxkKGNvbXBzWzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzQWxjaGVteUV2ZW50KGV2ZW50KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGV2ZW50ID09PSAnb2JqZWN0JyAmJiAnbWV0aG9kJyBpbiBldmVudDtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBgYWxjaGVteV9wZW5kaW5nVHJhbnNhY3Rpb25gXHJcbiAqIHN1YnNjcmlwdGlvbiBmaWx0ZXIgdGhhdCBpcyBjb21wYXRpYmxlIHdpdGggdGhlIGV0aGVycyBpbXBsZW1lbnRhdGlvbiBvZlxyXG4gKiBgZ2V0RXZlbnRUYWcoKWAuIFRoZSBtZXRob2QgaXMgbm90IGFuIGV4cG9ydGVkIGZ1bmN0aW9uIGluIGV0aGVycywgd2hpY2ggaXNcclxuICogd2h5IHRoZSBTREsgaGFzIGl0cyBvd24gaW1wbGVtZW50YXRpb24uXHJcbiAqXHJcbiAqIFRoZSBldmVudCB0YWcgaXMgdGhlbiBkZXNlcmlhbGl6ZWQgYnkgdGhlIFNESydzIHtAbGluayBFdGhlcnNFdmVudH0gZ2V0dGVycy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogICBgYGBqc1xyXG4gKiAgIC8vIFJldHVybnMgJ2FsY2hlbXktcGVuZGluZy10cmFuc2FjdGlvbnM6MHhBQkM6MHhERUZ8MHhHSEk6dHJ1ZSdcclxuICogICBjb25zdCBldmVudFRhZyA9ICBnZXRBbGNoZW15RXZlbnRUYWcoXHJcbiAqICAge1xyXG4gKiAgICAgXCJtZXRob2RcIjogXCJhbGNoZW15X3BlbmRpbmdUcmFuc2FjdGlvbnNcIixcclxuICogICAgIFwiZnJvbUFkZHJlc3NcIjogXCIweEFCQ1wiLFxyXG4gKiAgICAgXCJ0b0FkZHJlc3NcIjogW1wiMHhERUZcIiwgXCIweEdISVwiXSxcclxuICogICAgIFwiaGFzaGVzT25seTogdHJ1ZVxyXG4gKiAgIH0pO1xyXG4gKiAgIGBgYDtcclxuICpcclxuICogQHBhcmFtIGV2ZW50XHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QWxjaGVteUV2ZW50VGFnKGV2ZW50KSB7XHJcbiAgICBpZiAoIWlzQWxjaGVteUV2ZW50KGV2ZW50KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnQgdGFnIHJlcXVpcmVzIEFsY2hlbXlFdmVudFR5cGUnKTtcclxuICAgIH1cclxuICAgIGlmIChldmVudC5tZXRob2QgPT09IGV4cG9ydHMuQWxjaGVteVN1YnNjcmlwdGlvbi5QRU5ESU5HX1RSQU5TQUNUSU9OUykge1xyXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVQZW5kaW5nVHJhbnNhY3Rpb25zRXZlbnQoZXZlbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZXZlbnQubWV0aG9kID09PSBleHBvcnRzLkFsY2hlbXlTdWJzY3JpcHRpb24uTUlORURfVFJBTlNBQ1RJT05TKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZU1pbmVkVHJhbnNhY3Rpb25zRXZlbnQoZXZlbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgQWxjaGVteUZpbHRlckV2ZW50OiAke2V2ZW50fWApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZlcmlmeUFsY2hlbXlFdmVudE5hbWUoZXZlbnROYW1lKSB7XHJcbiAgICBpZiAoIU9iamVjdC52YWx1ZXMoZXhwb3J0cy5BbGNoZW15U3Vic2NyaXB0aW9uKS5pbmNsdWRlcyhldmVudE5hbWUubWV0aG9kKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtZXRob2QgbmFtZSAke2V2ZW50TmFtZS5tZXRob2R9LiBBY2NlcHRlZCBtZXRob2QgbmFtZXM6ICR7T2JqZWN0LnZhbHVlcyhleHBvcnRzLkFsY2hlbXlTdWJzY3JpcHRpb24pfWApO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTZXJpYWxpemVzIHRoZSBwcm92aWRlZCB7QGxpbmsgQWxjaGVteVBlbmRpbmdUcmFuc2FjdGlvbnNFdmVudEZpbHRlcn0gaW50byBhbiBldGhlcnNcclxuICogY29tcGF0aWJsZSBldmVudCB0YWcuXHJcbiAqXHJcbiAqIEZvciB0aGUgZXhhbXBsZSBldmVudDpcclxuICogYGBgXHJcbiAqICB7XHJcbiAqICAgICBcIm1ldGhvZFwiOiBcImFsY2hlbXlfcGVuZGluZ1RyYW5zYWN0aW9uc1wiLFxyXG4gKiAgICAgXCJmcm9tQWRkcmVzc1wiOiBcIjB4QUJDXCIsXHJcbiAqICAgICBcInRvQWRkcmVzc1wiOiBbXCIweERFRlwiLCBcIjB4R0hJXCJdLFxyXG4gKiAgICAgXCJoYXNoZXNPbmx5OiB0cnVlXHJcbiAqICAgfVxyXG4gKiBgYGBcclxuICpcclxuICogVGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uIGlzOlxyXG4gKiBgYWxjaGVteV9wZW5kaW5nVHJhbnNhY3Rpb25zOjB4QUJDOjB4REVGfDB4R0hJOnRydWVgXHJcbiAqXHJcbiAqIElmIGEgZmllbGQgaXMgb21pdHRlZCwgaXQgaXMgcmVwbGFjZWQgd2l0aCBhIGAqYC5cclxuICovXHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZVBlbmRpbmdUcmFuc2FjdGlvbnNFdmVudChldmVudCkge1xyXG4gICAgY29uc3QgZnJvbUFkZHJlc3MgPSBzZXJpYWxpemVBZGRyZXNzRmllbGQoZXZlbnQuZnJvbUFkZHJlc3MpO1xyXG4gICAgY29uc3QgdG9BZGRyZXNzID0gc2VyaWFsaXplQWRkcmVzc0ZpZWxkKGV2ZW50LnRvQWRkcmVzcyk7XHJcbiAgICBjb25zdCBoYXNoZXNPbmx5ID0gc2VyaWFsaXplQm9vbGVhbkZpZWxkKGV2ZW50Lmhhc2hlc09ubHkpO1xyXG4gICAgcmV0dXJuIChBTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUgK1xyXG4gICAgICAgICc6JyArXHJcbiAgICAgICAgZnJvbUFkZHJlc3MgK1xyXG4gICAgICAgICc6JyArXHJcbiAgICAgICAgdG9BZGRyZXNzICtcclxuICAgICAgICAnOicgK1xyXG4gICAgICAgIGhhc2hlc09ubHkpO1xyXG59XHJcbi8qKlxyXG4gKiBTZXJpYWxpemVzIHRoZSBwcm92aWRlZCB7QGxpbmsgQWxjaGVteVBlbmRpbmdUcmFuc2FjdGlvbnNFdmVudEZpbHRlcn0gaW50byBhbiBldGhlcnNcclxuICogY29tcGF0aWJsZSBldmVudCB0YWcuXHJcbiAqXHJcbiAqIEZvciB0aGUgZXhhbXBsZSBldmVudDpcclxuICogYGBgXHJcbiAqICB7XHJcbiAqICAgICBcIm1ldGhvZFwiOiBcImFsY2hlbXlfbWluZWRUcmFuc2FjdGlvbnNcIixcclxuICogICAgIFwiYWRkcmVzc2VzXCI6IFtcclxuICogICAgICAge1xyXG4gKiAgICAgICAgIGZyb206IFwiMHhBQkNcIlxyXG4gKiAgICAgICB9LFxyXG4gKiAgICAgICB7XHJcbiAqICAgICAgICAgdG86IFwiMHhERUZcIixcclxuICogICAgICAgICBmcm9tOiBcIjB4MTIzXCJcclxuICogICAgICAgfVxyXG4gKiAgICAgXVxyXG4gKiAgICAgXCJpbmNsdWRlUmVtb3ZlZFwiOiBmYWxzZVxyXG4gKiAgICAgXCJoYXNoZXNPbmx5OiB0cnVlXHJcbiAqICAgfVxyXG4gKiBgYGBcclxuICpcclxuICogVGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uIGlzOlxyXG4gKiBgYWxjaGVteV9taW5lZFRyYW5zYWN0aW9uczoqLDB4QUJDfDB4REVGLDB4MTIzOmZhbHNlOnRydWVgXHJcbiAqXHJcbiAqIElmIGEgZmllbGQgaXMgb21pdHRlZCwgaXQgaXMgcmVwbGFjZWQgd2l0aCBhIGAqYC5cclxuICpcclxuICogVGhlIGBhZGRyZXNzZXNgIGFycmF5IGlzIHNwbGl0IGJ5IHRoZSAnfCcgY2hhcmFjdGVyLCBhbmQgZWFjaCB0by9mcm9tIGFkZHJlc3NcclxuICogcGFpciBpcyBzZXBhcmF0ZWQgYnkgYSAnLCcgY2hhcmFjdGVyLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gc2VyaWFsaXplTWluZWRUcmFuc2FjdGlvbnNFdmVudChldmVudCkge1xyXG4gICAgY29uc3QgYWRkcmVzc2VzID0gc2VyaWFsaXplQWRkcmVzc2VzRmllbGQoZXZlbnQuYWRkcmVzc2VzKTtcclxuICAgIGNvbnN0IGluY2x1ZGVSZW1vdmVkID0gc2VyaWFsaXplQm9vbGVhbkZpZWxkKGV2ZW50LmluY2x1ZGVSZW1vdmVkKTtcclxuICAgIGNvbnN0IGhhc2hlc09ubHkgPSBzZXJpYWxpemVCb29sZWFuRmllbGQoZXZlbnQuaGFzaGVzT25seSk7XHJcbiAgICByZXR1cm4gKEFMQ0hFTVlfTUlORURfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUgK1xyXG4gICAgICAgICc6JyArXHJcbiAgICAgICAgYWRkcmVzc2VzICtcclxuICAgICAgICAnOicgK1xyXG4gICAgICAgIGluY2x1ZGVSZW1vdmVkICtcclxuICAgICAgICAnOicgK1xyXG4gICAgICAgIGhhc2hlc09ubHkpO1xyXG59XHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZUFkZHJlc3Nlc0ZpZWxkKGFkZHJlc3Nlcykge1xyXG4gICAgaWYgKGFkZHJlc3NlcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuICcqJztcclxuICAgIH1cclxuICAgIHJldHVybiBhZGRyZXNzZXNcclxuICAgICAgICAubWFwKGZpbHRlciA9PiBzZXJpYWxpemVBZGRyZXNzRmllbGQoZmlsdGVyLnRvKSArXHJcbiAgICAgICAgJywnICtcclxuICAgICAgICBzZXJpYWxpemVBZGRyZXNzRmllbGQoZmlsdGVyLmZyb20pKVxyXG4gICAgICAgIC5qb2luKCd8Jyk7XHJcbn1cclxuZnVuY3Rpb24gc2VyaWFsaXplQWRkcmVzc0ZpZWxkKGZpZWxkKSB7XHJcbiAgICBpZiAoZmllbGQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiAnKic7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGZpZWxkKSkge1xyXG4gICAgICAgIHJldHVybiBmaWVsZC5qb2luKCd8Jyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmllbGQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2VyaWFsaXplQm9vbGVhbkZpZWxkKGZpZWxkKSB7XHJcbiAgICBpZiAoZmllbGQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiAnKic7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmllbGQudG9TdHJpbmcoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVRvcGljcyhkYXRhKSB7XHJcbiAgICBpZiAoZGF0YSA9PT0gJycpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YS5zcGxpdCgvJi9nKS5tYXAodG9waWMgPT4ge1xyXG4gICAgICAgIGlmICh0b3BpYyA9PT0gJycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb21wcyA9IHRvcGljLnNwbGl0KCd8JykubWFwKHRvcGljID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRvcGljID09PSAnbnVsbCcgPyBudWxsIDogdG9waWM7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBzLmxlbmd0aCA9PT0gMSA/IGNvbXBzWzBdIDogY29tcHM7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUFkZHJlc3NGaWVsZChkYXRhKSB7XHJcbiAgICBpZiAoZGF0YSA9PT0gJycpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYWRkcmVzc2VzID0gZGF0YS5zcGxpdCgnfCcpO1xyXG4gICAgcmV0dXJuIGFkZHJlc3Nlcy5sZW5ndGggPT09IDEgPyBhZGRyZXNzZXNbMF0gOiBhZGRyZXNzZXM7XHJcbn1cclxuZnVuY3Rpb24gZGVzZXJpYWxpemVBZGRyZXNzZXNGaWVsZChkYXRhKSB7XHJcbiAgICBpZiAoZGF0YSA9PT0gJycpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgLy8gUGVyZm9ybSBhIGNhc3QgaGVyZSBzaW5jZSBUUyBkb2Vzbid0IGtub3cgd2UncmUgZ3VhcmFudGVlZCBhIG5vbi1lbXB0eVxyXG4gICAgLy8gYXJyYXkgZnJvbSBkZXNlcmlhbGl6aW5nLlxyXG4gICAgcmV0dXJuIGRhdGFcclxuICAgICAgICAuc3BsaXQoJ3wnKVxyXG4gICAgICAgIC5tYXAoYWRkcmVzc1N0ciA9PiBhZGRyZXNzU3RyLnNwbGl0KCcsJykpXHJcbiAgICAgICAgLm1hcChhZGRyZXNzUGFpciA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoYWRkcmVzc1BhaXJbMF0gIT09ICcqJyAmJiB7IHRvOiBhZGRyZXNzUGFpclswXSB9KSksIChhZGRyZXNzUGFpclsxXSAhPT0gJyonICYmIHsgZnJvbTogYWRkcmVzc1BhaXJbMV0gfSkpKSk7XHJcbn1cblxuLyoqXHJcbiAqIFRoZSBXZWJzb2NrZXQgbmFtZXNwYWNlIGNvbnRhaW5zIGFsbCBzdWJzY3JpcHRpb24gcmVsYXRlZCBmdW5jdGlvbnMgdGhhdFxyXG4gKiBhbGxvdyB5b3UgdG8gc3Vic2NyaWJlIHRvIGV2ZW50cyBhbmQgcmVjZWl2ZSB1cGRhdGVzIGFzIHRoZXkgb2NjdXIuIFRoZVxyXG4gKiB1bmRlcmx5aW5nIFdlYlNvY2tldCBwcm92aWRlciBoYXMgYWRkaXRpb25hbCBsb2dpYyB0byBoYW5kbGUgcmVjb25uZWN0aW9uc1xyXG4gKiBhbmQgYXV0b21hdGljYWxseSBiYWNrZmlsbHMgbWlzc2VkIGV2ZW50cy5cclxuICpcclxuICogRG8gbm90IGNhbGwgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS4gSW5zdGVhZCwgaW5zdGFudGlhdGUgYW4gQWxjaGVteSBvYmplY3RcclxuICogd2l0aCBgY29uc3QgYWxjaGVteSA9IG5ldyBBbGNoZW15KGNvbmZpZylgIGFuZCB0aGVuIGFjY2VzcyB0aGUgY29yZSBuYW1lc3BhY2VcclxuICogdmlhIGBhbGNoZW15LndzYC5cclxuICovXHJcbmNsYXNzIFdlYlNvY2tldE5hbWVzcGFjZSB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRvIGJlIHRyaWdnZXJlZCBmb3IgZWFjaCB7QGxpbmsgZXZlbnROYW1lfSBldmVudC4gQWxzb1xyXG4gICAgICogaW5jbHVkZXMgQWxjaGVteSdzIFN1YnNjcmlwdGlvbiBBUEkgZXZlbnRzLiBTZWUge0BsaW5rIEFsY2hlbXlFdmVudFR5cGV9IGZvclxyXG4gICAgICogaG93IHRvIHVzZSB0aGVtLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIGV2ZW50IHRvIGxpc3RlbiBmb3IuXHJcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdm9pZCAoKCkgPT4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgdGhpcy5jb25maWcuZ2V0V2ViU29ja2V0UHJvdmlkZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkRXZlbnQgPSB5aWVsZCB0aGlzLl9yZXNvbHZlRW5zQWxjaGVteUV2ZW50KGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgIHByb3ZpZGVyLm9uKHByb2Nlc3NlZEV2ZW50LCBsaXN0ZW5lcik7XHJcbiAgICAgICAgfSkpKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0byBiZSB0cmlnZ2VyZWQgZm9yIG9ubHkgdGhlIG5leHQge0BsaW5rIGV2ZW50TmFtZX0gZXZlbnQsXHJcbiAgICAgKiBhZnRlciB3aGljaCBpdCB3aWxsIGJlIHJlbW92ZWQuIEFsc28gaW5jbHVkZXMgQWxjaGVteSdzIFN1YnNjcmlwdGlvbiBBUElcclxuICAgICAqIGV2ZW50cy4gU2VlIHtAbGluayBBbGNoZW15RXZlbnRUeXBlfSBmb3IgaG93IHRvIHVzZSB0aGVtLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIGV2ZW50IHRvIGxpc3RlbiBmb3IuXHJcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBvbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICB2b2lkICgoKSA9PiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRXZWJTb2NrZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRFdmVudCA9IHlpZWxkIHRoaXMuX3Jlc29sdmVFbnNBbGNoZW15RXZlbnQoZXZlbnROYW1lKTtcclxuICAgICAgICAgICAgcHJvdmlkZXIub25jZShwcm9jZXNzZWRFdmVudCwgbGlzdGVuZXIpO1xyXG4gICAgICAgIH0pKSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBwcm92aWRlZCB7QGxpbmsgbGlzdGVuZXJ9IGZvciB0aGUge0BsaW5rIGV2ZW50TmFtZX0gZXZlbnQuIElmIG5vXHJcbiAgICAgKiBsaXN0ZW5lciBpcyBwcm92aWRlZCwgYWxsIGxpc3RlbmVycyBmb3IgdGhlIGV2ZW50IHdpbGwgYmUgcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBldmVudCB0byB1bmxpc3RlbiB0by5cclxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gcmVtb3ZlLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBvZmYoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIHZvaWQgKCgpID0+IF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFdlYlNvY2tldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZEV2ZW50ID0geWllbGQgdGhpcy5fcmVzb2x2ZUVuc0FsY2hlbXlFdmVudChldmVudE5hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIub2ZmKHByb2Nlc3NlZEV2ZW50LCBsaXN0ZW5lcik7XHJcbiAgICAgICAgfSkpKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciB0aGUgcHJvdmlkZWQge0BsaW5rIGV2ZW50TmFtZX0gZXZlbnQuIElmIG5vIGV2ZW50XHJcbiAgICAgKiBpcyBwcm92aWRlZCwgYWxsIGV2ZW50cyBhbmQgdGhlaXIgbGlzdGVuZXJzIGFyZSByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIGV2ZW50IHRvIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvci5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xyXG4gICAgICAgIHZvaWQgKCgpID0+IF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIHRoaXMuY29uZmlnLmdldFdlYlNvY2tldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZEV2ZW50ID0gZXZlbnROYW1lXHJcbiAgICAgICAgICAgICAgICA/IHlpZWxkIHRoaXMuX3Jlc29sdmVFbnNBbGNoZW15RXZlbnQoZXZlbnROYW1lKVxyXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUFsbExpc3RlbmVycyhwcm9jZXNzZWRFdmVudCk7XHJcbiAgICAgICAgfSkpKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgZm9yIHRoZSBwcm92aWRlZCB7QGxpbmsgZXZlbnROYW1lfSBldmVudC4gSWZcclxuICAgICAqIG5vIGV2ZW50IGlzIHByb3ZpZGVkLCB0aGUgdG90YWwgbnVtYmVyIG9mIGxpc3RlbmVycyBmb3IgYWxsIGV2ZW50cyBpcyByZXR1cm5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBldmVudCB0byBnZXQgdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgZm9yLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBsaXN0ZW5lckNvdW50KGV2ZW50TmFtZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRXZWJTb2NrZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRFdmVudCA9IGV2ZW50TmFtZVxyXG4gICAgICAgICAgICAgICAgPyB5aWVsZCB0aGlzLl9yZXNvbHZlRW5zQWxjaGVteUV2ZW50KGV2ZW50TmFtZSlcclxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIubGlzdGVuZXJDb3VudChwcm9jZXNzZWRFdmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIGZvciB0aGUgcHJvdmlkZWQge0BsaW5rIGV2ZW50TmFtZX0gZXZlbnQuIElmXHJcbiAgICAgKiBubyBldmVudCBpcyBwcm92aWRlZCwgYWxsIGxpc3RlbmVycyB3aWxsIGJlIGluY2x1ZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIGV2ZW50IHRvIGdldCB0aGUgbGlzdGVuZXJzIGZvci5cclxuICAgICAqL1xyXG4gICAgbGlzdGVuZXJzKGV2ZW50TmFtZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRXZWJTb2NrZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRFdmVudCA9IGV2ZW50TmFtZVxyXG4gICAgICAgICAgICAgICAgPyB5aWVsZCB0aGlzLl9yZXNvbHZlRW5zQWxjaGVteUV2ZW50KGV2ZW50TmFtZSlcclxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIubGlzdGVuZXJzKHByb2Nlc3NlZEV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgRU5TIGFkZHJlc3NlcyBpbiBhbiBBbGNoZW15IEV2ZW50IHRvIHRoZSB1bmRlcmx5aW5nIHJlc29sdmVkXHJcbiAgICAgKiBhZGRyZXNzLlxyXG4gICAgICpcclxuICAgICAqIFZJU0lCTEUgT05MWSBGT1IgVEVTVElORy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3Jlc29sdmVFbnNBbGNoZW15RXZlbnQoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAoIWlzQWxjaGVteUV2ZW50KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudE5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZS5tZXRob2QgPT09IGV4cG9ydHMuQWxjaGVteVN1YnNjcmlwdGlvbi5NSU5FRF9UUkFOU0FDVElPTlMgJiZcclxuICAgICAgICAgICAgICAgIGV2ZW50TmFtZS5hZGRyZXNzZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZEFkZHJlc3NlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIGV2ZW50TmFtZS5hZGRyZXNzZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcy50bykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLnRvID0geWllbGQgdGhpcy5fcmVzb2x2ZU5hbWVPckVycm9yKGFkZHJlc3MudG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcy5mcm9tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MuZnJvbSA9IHlpZWxkIHRoaXMuX3Jlc29sdmVOYW1lT3JFcnJvcihhZGRyZXNzLmZyb20pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRBZGRyZXNzZXMucHVzaChhZGRyZXNzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV2ZW50TmFtZS5hZGRyZXNzZXMgPVxyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZEFkZHJlc3NlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChldmVudE5hbWUubWV0aG9kID09PSBleHBvcnRzLkFsY2hlbXlTdWJzY3JpcHRpb24uUEVORElOR19UUkFOU0FDVElPTlMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUuZnJvbUFkZHJlc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50TmFtZS5mcm9tQWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lLmZyb21BZGRyZXNzID0geWllbGQgdGhpcy5fcmVzb2x2ZU5hbWVPckVycm9yKGV2ZW50TmFtZS5mcm9tQWRkcmVzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUuZnJvbUFkZHJlc3MgPSB5aWVsZCBQcm9taXNlLmFsbChldmVudE5hbWUuZnJvbUFkZHJlc3MubWFwKGFkZHJlc3MgPT4gdGhpcy5fcmVzb2x2ZU5hbWVPckVycm9yKGFkZHJlc3MpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZS50b0FkZHJlc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50TmFtZS50b0FkZHJlc3MgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZS50b0FkZHJlc3MgPSB5aWVsZCB0aGlzLl9yZXNvbHZlTmFtZU9yRXJyb3IoZXZlbnROYW1lLnRvQWRkcmVzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUudG9BZGRyZXNzID0geWllbGQgUHJvbWlzZS5hbGwoZXZlbnROYW1lLnRvQWRkcmVzcy5tYXAoYWRkcmVzcyA9PiB0aGlzLl9yZXNvbHZlTmFtZU9yRXJyb3IoYWRkcmVzcykpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TmFtZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIHByb3ZpZGVkIEVOUyBhZGRyZXNzIG9yIHRocm93cyBhbiBlcnJvci4gVGhpcyBpbXByb3ZlcyBjb2RlXHJcbiAgICAgKiByZWFkYWJpbGl0eSBhbmQgdHlwZSBzYWZldHkgaW4gb3RoZXIgbWV0aG9kcy5cclxuICAgICAqXHJcbiAgICAgKiBWSVNJQkxFIE9OTFkgRk9SIFRFU1RJTkcuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9yZXNvbHZlTmFtZU9yRXJyb3IobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCB0aGlzLmNvbmZpZy5nZXRQcm92aWRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IHlpZWxkIHByb3ZpZGVyLnJlc29sdmVOYW1lKG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHJlc29sdmUgdGhlIEVOUyBhZGRyZXNzOiAke25hbWV9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBUaGUgQWxjaGVteSBTREsgY2xpZW50LiBUaGlzIGNsYXNzIGlzIHRoZSBtYWluIGVudHJ5IHBvaW50IGludG8gQWxjaGVteSdzXHJcbiAqIEFQSXMgYW5kIHNlcGFyYXRlcyBmdW5jdGlvbmFsaXR5IGludG8gZGlmZmVyZW50IG5hbWVzcGFjZXMuXHJcbiAqXHJcbiAqIEVhY2ggU0RLIGluc3RhbmNlIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHNwZWNpZmljIG5ldHdvcmsgYW5kIEFQSSBrZXkuIFRvIHVzZSBhXHJcbiAqIGRpZmZlcmVudCBuZXR3b3JrIG9yIEFQSSBrZXksIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgQWxjaGVteX0uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIEFsY2hlbXkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NldHRpbmdzLmFwaUtleV0gLSBUaGUgQVBJIGtleSB0byB1c2UgZm9yIEFsY2hlbXlcclxuICAgICAqIEBwYXJhbSB7TmV0d29ya30gW3NldHRpbmdzLm5ldHdvcmtdIC0gVGhlIG5ldHdvcmsgdG8gdXNlIGZvciBBbGNoZW15XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NldHRpbmdzLm1heFJldHJpZXNdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJldHJpZXMgdG8gYXR0ZW1wdFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzZXR0aW5ncy5yZXF1ZXN0VGltZW91dF0gLSBUaGUgdGltZW91dCBhZnRlciB3aGljaCByZXF1ZXN0IHNob3VsZCBmYWlsXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBuZXcgQWxjaGVteUNvbmZpZyhzZXR0aW5ncyk7XHJcbiAgICAgICAgdGhpcy5jb3JlID0gbmV3IENvcmVOYW1lc3BhY2UodGhpcy5jb25maWcpO1xyXG4gICAgICAgIHRoaXMubmZ0ID0gbmV3IE5mdE5hbWVzcGFjZSh0aGlzLmNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy53cyA9IG5ldyBXZWJTb2NrZXROYW1lc3BhY2UodGhpcy5jb25maWcpO1xyXG4gICAgICAgIHRoaXMudHJhbnNhY3QgPSBuZXcgVHJhbnNhY3ROYW1lc3BhY2UodGhpcy5jb25maWcpO1xyXG4gICAgICAgIHRoaXMubm90aWZ5ID0gbmV3IE5vdGlmeU5hbWVzcGFjZSh0aGlzLmNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IG5ldyBEZWJ1Z05hbWVzcGFjZSh0aGlzLmNvbmZpZyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIFRoZSBXYWxsZXQgY2xhc3MgaW5oZXJpdHMgU2lnbmVyIGFuZCBjYW4gc2lnbiB0cmFuc2FjdGlvbnMgYW5kIG1lc3NhZ2VzIHVzaW5nXHJcbiAqIGEgcHJpdmF0ZSBrZXkgYXMgYSBzdGFuZGFyZCBFeHRlcm5hbGx5IE93bmVkIEFjY291bnQgKEVPQSkuXHJcbiAqXHJcbiAqIFNESydzIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiBvZiBFdGhlcnMuanMncyAnV2FsbGV0Jy5cclxuICpcclxuICogUHJpbWFyeSBkaWZmZXJlbmNlIGZyb20gRXRoZXJzLmpzICdXYWxsZXQnIGlzIHRoYXQgeW91IGNhbiBwYXNzIGluIGVpdGhlciBhXHJcbiAqIFByb3ZpZGVyIG9yIGFuIEFsY2hlbXkgb2JqZWN0LiBUaGlzIGltcGxlbWVudGF0aW9uIHdpbGwgaW50ZWxsaWdlbnRseSBkZXRlY3RcclxuICogdGhlIGZvcm1hdCBhbmQgc2V0IHRoZSBwcm92aWRlciBhY2NvcmRpbmdseS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKiBAb3ZlcnJpZGVcclxuICovXHJcbmNsYXNzIFdhbGxldCBleHRlbmRzIHdhbGxldC5XYWxsZXQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVybG9hZCBwZXJtaXRzIHVzZXJzIHRvIHBhc3MgaW4gZWl0aGVyIGEgc3RhbmRhcmQgUHJvdmlkZXIgb3IgYW4gQWxjaGVteVxyXG4gICAgICogb2JqZWN0LiBUaGUgY29uc3RydWN0b3Igd2lsbCBkZXRlY3QgdGhlIG9iamVjdCB0eXBlIGFuZCBoYW5kbGUgYXBwcm9wcmlhdGVseS5cclxuICAgICAqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZUtleSwgYWxjaGVteU9yUHJvdmlkZXIpIHtcclxuICAgICAgICAvLyBJZiBvYmplY3QgcGFzc2VkIGluIGlzIGEgcHJvdmlkZXIsIHNlbmQgdG8gc3VwZXJcclxuICAgICAgICBsZXQgc3VwZXJQcm92aWRlcjtcclxuICAgICAgICBpZiAoYWxjaGVteU9yUHJvdmlkZXIgJiYgYWJzdHJhY3RQcm92aWRlci5Qcm92aWRlci5pc1Byb3ZpZGVyKGFsY2hlbXlPclByb3ZpZGVyKSkge1xyXG4gICAgICAgICAgICBzdXBlclByb3ZpZGVyID0gYWxjaGVteU9yUHJvdmlkZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyKHByaXZhdGVLZXksIHN1cGVyUHJvdmlkZXIpO1xyXG4gICAgICAgIC8vIElmIG9iamVjdCBwYXNzZWQgaW4gaXMgYW4gQWxjaGVteSBvYmplY3QsIGp1c3Qgc2V0IEFsY2hlbXlcclxuICAgICAgICBpZiAoYWxjaGVteU9yUHJvdmlkZXIgJiYgIWFic3RyYWN0UHJvdmlkZXIuUHJvdmlkZXIuaXNQcm92aWRlcihhbGNoZW15T3JQcm92aWRlcikpIHtcclxuICAgICAgICAgICAgdGhpcy5hbGNoZW15UHJvdmlkZXJQcm9taXNlID0gYWxjaGVteU9yUHJvdmlkZXIuY29uZmlnLmdldFByb3ZpZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcbiAgICAvLyBTZXQgb2Ygb3ZlcnJpZGVzIGZyb20gU2lnbmVyIHRvIGhhbmRsZSBhc3luYyBwcm92aWRlciByZXRyaWV2YWwuXHJcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYmFsYW5jZSBvZiB0aGlzIHdhbGxldCBhdCBibG9ja1RhZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYmxvY2tUYWcgVGhlIGJsb2NrIHRvIGNoZWNrIHRoZSBiYWxhbmNlIG9mXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgZ2V0QmFsYW5jZShibG9ja1RhZykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFdhbGxldCgpLnRoZW4od2FsbGV0ID0+IHdhbGxldC5nZXRCYWxhbmNlKGJsb2NrVGFnKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB0cmFuc2FjdGlvbnMgdGhpcyBhY2NvdW50IGhhcyBldmVyIHNlbnQuIFRoaXMgaXMgdGhlXHJcbiAgICAgKiB2YWx1ZSByZXF1aXJlZCB0byBiZSBpbmNsdWRlZCBpbiB0cmFuc2FjdGlvbnMgYXMgdGhlIG5vbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBibG9ja1RhZyBUaGUgYmxvY2sgdG8gY2hlY2sgdGhlIHRyYW5zYWN0aW9uIGNvdW50IG9uXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgZ2V0VHJhbnNhY3Rpb25Db3VudChibG9ja1RhZykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFdhbGxldCgpLnRoZW4od2FsbGV0ID0+IHdhbGxldC5nZXRUcmFuc2FjdGlvbkNvdW50KGJsb2NrVGFnKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBlc3RpbWF0aW5nIHRoZSBjb3N0IHRvIHNlbmQgdGhlIHRyYW5zYWN0aW9uUmVxdWVzdCxcclxuICAgICAqIHdpdGggdGhpcyBhY2NvdW50IGFkZHJlc3MgYmVpbmcgdXNlZCBhcyB0aGUgZnJvbSBmaWVsZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gVHJhbnNhY3Rpb24gdG8gZXN0aW1hdGUgdGhlIGdhcyBvblxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGVzdGltYXRlR2FzKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2FsbGV0KCkudGhlbih3YWxsZXQgPT4gd2FsbGV0LmVzdGltYXRlR2FzKHRyYW5zYWN0aW9uKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHVzaW5nIHRoZSB0cmFuc2FjdGlvblJlcXVlc3QsIHdpdGggdGhpc1xyXG4gICAgICogYWNjb3VudCBhZGRyZXNzIGJlaW5nIHVzZWQgYXMgdGhlIGZyb20gZmllbGQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRvIG1ha2UgYSBjYWxsIG9uXHJcbiAgICAgKiBAcGFyYW0gYmxvY2tUYWcgVGhlIGJsb2NrIHRvIG1ha2UgdGhlIGNhbGwgb25cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBjYWxsKHRyYW5zYWN0aW9uLCBibG9ja1RhZykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFdhbGxldCgpLnRoZW4od2FsbGV0ID0+IHdhbGxldC5jYWxsKHRyYW5zYWN0aW9uLCBibG9ja1RhZykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQb3B1bGF0ZXMgQUxMIGtleXMgZm9yIGEgdHJhbnNhY3Rpb24gYW5kIGNoZWNrcyB0aGF0IGBmcm9tYCBtYXRjaGVzIHRoaXNcclxuICAgICAqIGBTaWduZXJgLiBSZXNvbHZlcyBFTlMgbmFtZXMgYW5kIHBvcHVsYXRlcyBmaWVsZHMgbGlrZSBgZ2FzUHJpY2VgLCBgZ2FzTGltaXRgLFxyXG4gICAgICogYG5vbmNlYCwgYW5kIGBjaGFpbklkYCBpZiB0aGV5IGFyZSBub3QgcHJvdmlkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiB0byBwb3B1bGF0ZS5cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBwb3B1bGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2FsbGV0KCkudGhlbih3YWxsZXQgPT4gd2FsbGV0LnBvcHVsYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUG9wdWxhdGVzIGFsbCBmaWVsZHMgaW4gYSB0cmFuc2FjdGlvbiwgc2lnbnMgaXQgYW5kIHNlbmRzIGl0IHRvIHRoZSBuZXR3b3JrXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiB0byBzZW5kLlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFdhbGxldCgpLnRoZW4od2FsbGV0ID0+IHdhbGxldC5zZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2hhaW4gSUQgdGhpcyB3YWxsZXQgaXMgY29ubmVjdGVkIHRvLlxyXG4gICAgICpcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBnZXRDaGFpbklkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFdhbGxldCgpLnRoZW4od2FsbGV0ID0+IHdhbGxldC5nZXRDaGFpbklkKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGdhcyBwcmljZS5cclxuICAgICAqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgZ2V0R2FzUHJpY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2FsbGV0KCkudGhlbih3YWxsZXQgPT4gd2FsbGV0LmdldEdhc1ByaWNlKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJlY29tbWVuZGVkIEZlZURhdGEgdG8gdXNlIGluIGEgdHJhbnNhY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGFuIEVJUC0xNTU5IHRyYW5zYWN0aW9uLCB0aGUgbWF4RmVlUGVyR2FzIGFuZCBtYXhQcmlvcml0eUZlZVBlckdhc1xyXG4gICAgICogc2hvdWxkIGJlIHVzZWQuXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGxlZ2FjeSB0cmFuc2FjdGlvbnMgYW5kIG5ldHdvcmtzIHdoaWNoIGRvIG5vdCBzdXBwb3J0IEVJUC0xNTU5LCB0aGVcclxuICAgICAqIGdhc1ByaWNlIHNob3VsZCBiZSB1c2VkLlxyXG4gICAgICpcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBnZXRGZWVEYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFdhbGxldCgpLnRoZW4od2FsbGV0ID0+IHdhbGxldC5nZXRGZWVEYXRhKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBMb29rcyB1cCB0aGUgYWRkcmVzcyBvZiBuYW1lLiBJZiB0aGUgbmFtZSBpcyBub3Qgb3duZWQsIG9yIGRvZXMgbm90IGhhdmUgYVxyXG4gICAgICogUmVzb2x2ZXIgY29uZmlndXJlZCwgb3IgdGhlIFJlc29sdmVyIGRvZXMgbm90IGhhdmUgYW4gYWRkcmVzcyBjb25maWd1cmVkLFxyXG4gICAgICogbnVsbCBpcyByZXR1cm5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBFTlMgYWRkcmVzc1xyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIHJlc29sdmVOYW1lKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRXYWxsZXQoKS50aGVuKHdhbGxldCA9PiB3YWxsZXQucmVzb2x2ZU5hbWUobmFtZSkpO1xyXG4gICAgfVxyXG4gICAgZ2V0V2FsbGV0KCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmFsY2hlbXlQcm92aWRlclByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QodGhpcy5wcm92aWRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdCh5aWVsZCB0aGlzLmFsY2hlbXlQcm92aWRlclByb21pc2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBUaGUgQ29udHJhY3QgY2xhc3MgaXMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgQ29udHJhY3QgY2xhc3MgZnJvbSBldGhlcnMuanMgYW5kXHJcbiAqIGlzIGV4cG9ydGVkIGhlcmUgZm9yIGNvbnZlbmllbmNlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG4vLyBUT0RPOiBzdXBwb3J0IHBhc3NpbmcgaW4gQWxjaGVteSBpbnN0YW5jZSBpbnRvIHRoZSBjb250cmFjdC5cclxuY2xhc3MgQ29udHJhY3QgZXh0ZW5kcyBjb250cmFjdHMuQ29udHJhY3Qge1xyXG59XHJcbi8qKlxyXG4gKiBUaGUgQ29udHJhY3RGYWN0b3J5IGNsYXNzIGlzIGEgd3JhcHBlciBhcm91bmQgdGhlIENvbnRyYWN0RmFjdG9yeSBjbGFzcyBmcm9tXHJcbiAqIGV0aGVycy5qcyBhbmQgaXMgZXhwb3J0ZWQgaGVyZSBmb3IgY29udmVuaWVuY2UuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIENvbnRyYWN0RmFjdG9yeSBleHRlbmRzIGNvbnRyYWN0cy5Db250cmFjdEZhY3Rvcnkge1xyXG59XG5cbmV4cG9ydHMuQUxDSEVNWV9FVkVOVF9UWVBFUyA9IEFMQ0hFTVlfRVZFTlRfVFlQRVM7XG5leHBvcnRzLkFMQ0hFTVlfTUlORURfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUgPSBBTENIRU1ZX01JTkVEX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFO1xuZXhwb3J0cy5BTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUgPSBBTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEU7XG5leHBvcnRzLkFsY2hlbXkgPSBBbGNoZW15O1xuZXhwb3J0cy5Db250cmFjdCA9IENvbnRyYWN0O1xuZXhwb3J0cy5Db250cmFjdEZhY3RvcnkgPSBDb250cmFjdEZhY3Rvcnk7XG5leHBvcnRzLkN1c3RvbU5ldHdvcmtzID0gQ3VzdG9tTmV0d29ya3M7XG5leHBvcnRzLkRFRkFVTFRfQUxDSEVNWV9BUElfS0VZID0gREVGQVVMVF9BTENIRU1ZX0FQSV9LRVk7XG5leHBvcnRzLkRFRkFVTFRfTkVUV09SSyA9IERFRkFVTFRfTkVUV09SSztcbmV4cG9ydHMuRXRoZXJzRXZlbnQgPSBFdGhlcnNFdmVudDtcbmV4cG9ydHMuRXRoZXJzTmV0d29yayA9IEV0aGVyc05ldHdvcms7XG5leHBvcnRzLklTX0JST1dTRVIgPSBJU19CUk9XU0VSO1xuZXhwb3J0cy5WRVJTSU9OID0gVkVSU0lPTjtcbmV4cG9ydHMuV2FsbGV0ID0gV2FsbGV0O1xuZXhwb3J0cy5fX2F3YWl0ZXIgPSBfX2F3YWl0ZXIkMTtcbmV4cG9ydHMuZGVlcENvcHkgPSBkZWVwQ29weTtcbmV4cG9ydHMuZnJvbUhleCA9IGZyb21IZXg7XG5leHBvcnRzLmdldEFsY2hlbXlFdmVudFRhZyA9IGdldEFsY2hlbXlFdmVudFRhZztcbmV4cG9ydHMuZ2V0QWxjaGVteUh0dHBVcmwgPSBnZXRBbGNoZW15SHR0cFVybDtcbmV4cG9ydHMuZ2V0QWxjaGVteVdzVXJsID0gZ2V0QWxjaGVteVdzVXJsO1xuZXhwb3J0cy5pc0FsY2hlbXlFdmVudCA9IGlzQWxjaGVteUV2ZW50O1xuZXhwb3J0cy5pc0hleCA9IGlzSGV4O1xuZXhwb3J0cy5sb2dXYXJuID0gbG9nV2FybjtcbmV4cG9ydHMubm9vcCA9IG5vb3A7XG5leHBvcnRzLnNldExvZ0xldmVsID0gc2V0TG9nTGV2ZWw7XG5leHBvcnRzLnRvSGV4ID0gdG9IZXg7XG5leHBvcnRzLnZlcmlmeUFsY2hlbXlFdmVudE5hbWUgPSB2ZXJpZnlBbGNoZW15RXZlbnROYW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgtYjFmNGEyZDkuanMubWFwXG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwiYmlnbnVtYmVyIiwiYXhpb3MiLCJhYnN0cmFjdFByb3ZpZGVyIiwid2FsbGV0IiwiY29udHJhY3RzIiwiX2ludGVyb3BEZWZhdWx0TGVnYWN5IiwiZSIsImF4aW9zX19kZWZhdWx0IiwiZXhwb3J0cyIsIk5ldHdvcmsiLCJUb2tlbkJhbGFuY2VUeXBlIiwiQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeSIsIkdldFRyYW5zZmVyc0Zvck93bmVyVHJhbnNmZXJUeXBlIiwiU29ydGluZ09yZGVyIiwiT3BlblNlYVNhZmVsaXN0UmVxdWVzdFN0YXR1cyIsIkFsY2hlbXlTdWJzY3JpcHRpb24iLCJTaW11bGF0ZUFzc2V0VHlwZSIsIlNpbXVsYXRlQ2hhbmdlVHlwZSIsIkRlY29kaW5nQXV0aG9yaXR5IiwiRGVidWdDYWxsVHlwZSIsIkdhc09wdGltaXplZFRyYW5zYWN0aW9uU3RhdHVzIiwiV2ViaG9va1ZlcnNpb24iLCJXZWJob29rVHlwZSIsIkNvbW1pdG1lbnRMZXZlbCIsIkRlYnVnVHJhY2VyVHlwZSIsIk5mdFRva2VuVHlwZSIsIk5mdFNwYW1DbGFzc2lmaWNhdGlvbiIsIk5mdEZpbHRlcnMiLCJOZnRPcmRlcmluZyIsIk5mdFNhbGVNYXJrZXRwbGFjZSIsIk5mdFNhbGVUYWtlclR5cGUiLCJOZnRSZWZyZXNoU3RhdGUiLCJOZnRDb2xsZWN0aW9uTWFya2V0cGxhY2UiLCJfX2F3YWl0ZXIkMSIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiX192YWx1ZXMiLCJvIiwicyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibSIsImkiLCJjYWxsIiwibGVuZ3RoIiwiVHlwZUVycm9yIiwiX19hd2FpdCIsInYiLCJfX2FzeW5jR2VuZXJhdG9yIiwiYXN5bmNJdGVyYXRvciIsImciLCJxIiwidmVyYiIsIm4iLCJhIiwiYiIsInB1c2giLCJyZXN1bWUiLCJzZXR0bGUiLCJyIiwiZnVsZmlsbCIsImYiLCJzaGlmdCIsIl9fYXN5bmNWYWx1ZXMiLCJkIiwiREVGQVVMVF9BTENIRU1ZX0FQSV9LRVkiLCJERUZBVUxUX05FVFdPUksiLCJFVEhfTUFJTk5FVCIsIkRFRkFVTFRfTUFYX1JFVFJJRVMiLCJERUZBVUxUX1JFUVVFU1RfVElNRU9VVCIsImdldEFsY2hlbXlIdHRwVXJsIiwibmV0d29yayIsImFwaUtleSIsImdldEFsY2hlbXlOZnRIdHRwVXJsIiwiZ2V0QWxjaGVteVdzVXJsIiwiZ2V0QWxjaGVteVdlYmhvb2tIdHRwVXJsIiwiQWxjaGVteUFwaVR5cGUiLCJFdGhlcnNOZXR3b3JrIiwiRVRIX0dPRVJMSSIsIkVUSF9TRVBPTElBIiwiT1BUX01BSU5ORVQiLCJPUFRfR09FUkxJIiwiT1BUX1NFUE9MSUEiLCJBUkJfTUFJTk5FVCIsIkFSQl9HT0VSTEkiLCJBUkJfU0VQT0xJQSIsIk1BVElDX01BSU5ORVQiLCJNQVRJQ19NVU1CQUkiLCJBU1RBUl9NQUlOTkVUIiwiUE9MWUdPTlpLRVZNX01BSU5ORVQiLCJQT0xZR09OWktFVk1fVEVTVE5FVCIsIkJBU0VfTUFJTk5FVCIsIkJBU0VfR09FUkxJIiwiQkFTRV9TRVBPTElBIiwiQ3VzdG9tTmV0d29ya3MiLCJjaGFpbklkIiwibmFtZSIsInNlcG9saWEiLCJub29wIiwiRVRIX05VTExfVkFMVUUiLCJFVEhfTlVMTF9BRERSRVNTIiwiQWxjaGVteUNvbmZpZyIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwibWF4UmV0cmllcyIsInVybCIsImF1dGhUb2tlbiIsImJhdGNoUmVxdWVzdHMiLCJyZXF1ZXN0VGltZW91dCIsIl9nZXRSZXF1ZXN0VXJsIiwiYXBpVHlwZSIsInVuZGVmaW5lZCIsIk5GVCIsIldFQkhPT0siLCJnZXRQcm92aWRlciIsIl9iYXNlQWxjaGVteVByb3ZpZGVyIiwiQWxjaGVteVByb3ZpZGVyIiwiZ2V0V2ViU29ja2V0UHJvdmlkZXIiLCJfYmFzZUFsY2hlbXlXc3NQcm92aWRlciIsIkFsY2hlbXlXZWJTb2NrZXRQcm92aWRlciIsInZlcnNpb24kMSIsIl9wZXJtYW5lbnRDZW5zb3JFcnJvcnMiLCJfY2Vuc29yRXJyb3JzIiwiTG9nTGV2ZWxzIiwiZGVidWciLCJpbmZvIiwid2FybmluZyIsImVycm9yIiwib2ZmIiwiX2xvZ0xldmVsIiwiX2dsb2JhbExvZ2dlciIsIl9jaGVja05vcm1hbGl6ZSIsIm1pc3NpbmciLCJmb3JFYWNoIiwiZm9ybSIsIm5vcm1hbGl6ZSIsIkVycm9yIiwiam9pbiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIm1lc3NhZ2UiLCJfbm9ybWFsaXplRXJyb3IiLCJMb2dMZXZlbCQxIiwiTG9nTGV2ZWwiLCJFcnJvckNvZGUiLCJIRVgiLCJMb2dnZXIkMSIsInZlcnNpb24iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsIl9sb2ciLCJsb2dMZXZlbCIsImFyZ3MiLCJsZXZlbCIsInRvTG93ZXJDYXNlIiwidGhyb3dBcmd1bWVudEVycm9yIiwiY29uc29sZSIsImxvZyIsImxldmVscyIsIkRFQlVHIiwiSU5GTyIsIndhcm4iLCJXQVJOSU5HIiwibWFrZUVycm9yIiwiY29kZSIsInBhcmFtcyIsImVycm9ycyIsIlVOS05PV05fRVJST1IiLCJtZXNzYWdlRGV0YWlscyIsImtleXMiLCJrZXkiLCJVaW50OEFycmF5IiwiaGV4IiwiSlNPTiIsInN0cmluZ2lmeSIsInRvU3RyaW5nIiwicmVhc29uIiwiTlVNRVJJQ19GQVVMVCIsImZhdWx0IiwiQ0FMTF9FWENFUFRJT04iLCJJTlNVRkZJQ0lFTlRfRlVORFMiLCJNSVNTSU5HX05FVyIsIk5PTkNFX0VYUElSRUQiLCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCIsIlRSQU5TQUNUSU9OX1JFUExBQ0VEIiwiVU5QUkVESUNUQUJMRV9HQVNfTElNSVQiLCJ0aHJvd0Vycm9yIiwiSU5WQUxJRF9BUkdVTUVOVCIsImFyZ3VtZW50IiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwiYXNzZXJ0QXJndW1lbnQiLCJjaGVja05vcm1hbGl6ZSIsIlVOU1VQUE9SVEVEX09QRVJBVElPTiIsIm9wZXJhdGlvbiIsImNoZWNrU2FmZVVpbnQ1MyIsImNoZWNrQXJndW1lbnRDb3VudCIsImNvdW50IiwiZXhwZWN0ZWRDb3VudCIsIk1JU1NJTkdfQVJHVU1FTlQiLCJVTkVYUEVDVEVEX0FSR1VNRU5UIiwiY2hlY2tOZXciLCJ0YXJnZXQiLCJraW5kIiwiY2hlY2tBYnN0cmFjdCIsImdsb2JhbExvZ2dlciIsInNldENlbnNvcnNoaXAiLCJjZW5zb3JzaGlwIiwicGVybWFuZW50Iiwic2V0TG9nTGV2ZWwiLCJmcm9tIiwiX19hd2FpdGVyIiwibG9nZ2VyIiwiZGVmaW5lUmVhZE9ubHkiLCJvYmplY3QiLCJyZXNvbHZlUHJvcGVydGllcyIsInByb21pc2VzIiwibWFwIiwicmVzdWx0cyIsImFsbCIsInJlZHVjZSIsImFjY3VtIiwib3BhcXVlIiwiYmlnaW50IiwiYm9vbGVhbiIsIm51bWJlciIsInN0cmluZyIsIl9pc0Zyb3plbiIsIkFycmF5IiwiaXNBcnJheSIsImlzRnJvemVuIiwiX2RlZXBDb3B5IiwiZnJlZXplIiwiaXRlbSIsImRlZXBDb3B5IiwiZnJvbUhleCIsImhleFN0cmluZyIsIkJpZ051bWJlciIsInRvTnVtYmVyIiwidG9IZXgiLCJudW0iLCJ0b0hleFN0cmluZyIsImlzSGV4IiwicG9zc2libGVIZXhTdHJpbmciLCJ0ZXN0IiwiZm9ybWF0QmxvY2siLCJibG9jayIsIk51bWJlciIsImlzSW50ZWdlciIsInN0cmluZ1RvRW51bSIsIngiLCJlbnVtYiIsInZhbHVlcyIsImluY2x1ZGVzIiwiZ2V0TmZ0Q29udHJhY3RGb3JOZnRGcm9tUmF3IiwicmF3TmZ0Q29udHJhY3QiLCJudWxsc1RvVW5kZWZpbmVkIiwiYXNzaWduIiwiZ2V0TmZ0Q29udHJhY3RGcm9tUmF3Iiwic3BhbUNsYXNzaWZpY2F0aW9ucyIsInBhcnNlTmZ0U3BhbUNsYXNzaWZpY2F0aW9uIiwiZ2V0TmZ0Q29udHJhY3RzRm9yT3duZXJGcm9tUmF3IiwiZGlzcGxheU5mdCIsImltYWdlIiwidG90YWxCYWxhbmNlIiwibnVtRGlzdGluY3RUb2tlbnNPd25lZCIsImlzU3BhbSIsInRva2VuVHlwZSIsInBhcnNlTmZ0VG9rZW5UeXBlIiwib3BlblNlYU1ldGFkYXRhIiwic2FmZWxpc3RSZXF1ZXN0U3RhdHVzIiwiZ2V0TmZ0Q29sbGVjdGlvbkZyb21SYXciLCJyYXdOZnRDb2xsZWN0aW9uIiwiZmxvb3JQcmljZSIsIm1hcmtldHBsYWNlIiwicGFyc2VOZnRDb2xsZWN0aW9uTWFya2V0cGxhY2UiLCJnZXRCYXNlTmZ0RnJvbVJhdyIsInJhd0Jhc2VOZnQiLCJjb250cmFjdEFkZHJlc3MiLCJ0b2tlbklkIiwiZ2V0TmZ0RnJvbVJhdyIsInJhd05mdCIsImNvbnRyYWN0IiwiYWNxdWlyZWRBdCIsImNvbGxlY3Rpb24iLCJtaW50IiwiZ2V0TmZ0U2FsZXNGcm9tUmF3IiwicmF3TmZ0U2FsZXMiLCJuZnRTYWxlcyIsInJhd05mdFNhbGUiLCJwYXJzZU5mdFNhbGVNYXJrZXRwbGFjZSIsInRha2VyIiwicGFyc2VOZnRUYWtlciIsInZhbGlkQXQiLCJwYWdlS2V5IiwiTE9PS1NSQVJFIiwiU0VBUE9SVCIsIlgyWTIiLCJXWVZFUk4iLCJDUllQVE9QVU5LUyIsIkJMVVIiLCJVTktOT1dOIiwiT1BFTlNFQSIsIkJVWUVSIiwiU0VMTEVSIiwicmVzIiwiVW5rbm93biIsIkVSQzcyMSIsIkVSQzExNTUiLCJOT19TVVBQT1JURURfTkZUX1NUQU5EQVJEIiwiTk9UX0FfQ09OVFJBQ1QiLCJJU19CUk9XU0VSIiwid2luZG93Iiwib2JqIiwiZ2V0QXNzZXRUcmFuc2ZlcnMiLCJzcmNNZXRob2QiLCJwcm92aWRlciIsImZyb21BZGRyZXNzIiwiX2dldEFkZHJlc3MiLCJ0b0FkZHJlc3MiLCJfc2VuZCIsImZyb21CbG9jayIsInRvQmxvY2siLCJtYXhDb3VudCIsImdldFRyYW5zYWN0aW9uUmVjZWlwdHMiLCJnZXRMb2dzIiwiZmlsdGVyIiwiZ2V0TmV0d29yayIsImdldEZpbHRlciIsImxvZ3MiLCJzZW5kIiwicmVtb3ZlZCIsImFycmF5T2YiLCJmb3JtYXR0ZXIiLCJmaWx0ZXJMb2ciLCJiaW5kIiwicmVzb2x2ZWRGaWx0ZXIiLCJfZ2V0QmxvY2tUYWciLCJhZGRyZXNzIiwiZm9ybWF0IiwiYXJyYXkiLCJDb3JlTmFtZXNwYWNlIiwiZ2V0QmFsYW5jZSIsImFkZHJlc3NPck5hbWUiLCJibG9ja1RhZyIsImlzQ29udHJhY3RBZGRyZXNzIiwiZ2V0Q29kZSIsImdldFN0b3JhZ2VBdCIsInBvc2l0aW9uIiwiZ2V0VHJhbnNhY3Rpb25Db3VudCIsImdldEJsb2NrIiwiYmxvY2tIYXNoT3JCbG9ja1RhZyIsImdldEJsb2NrV2l0aFRyYW5zYWN0aW9ucyIsImdldEJsb2NrTnVtYmVyIiwiZ2V0R2FzUHJpY2UiLCJnZXRGZWVEYXRhIiwicmVhZHkiLCJ0cmFuc2FjdGlvbiIsImVzdGltYXRlR2FzIiwiZ2V0VHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbkhhc2giLCJnZXRUcmFuc2FjdGlvblJlY2VpcHQiLCJzZW5kVHJhbnNhY3Rpb24iLCJzaWduZWRUcmFuc2FjdGlvbiIsIndhaXRGb3JUcmFuc2FjdGlvbiIsImNvbmZpcm1hdGlvbnMiLCJ0aW1lb3V0IiwibWV0aG9kIiwiZmluZENvbnRyYWN0RGVwbG95ZXIiLCJfYSIsImN1cnJlbnRCbG9ja051bSIsImZpcnN0QmxvY2siLCJiaW5hcnlTZWFyY2hGaXJzdEJsb2NrIiwidHhSZWNlaXB0cyIsImJsb2NrTnVtYmVyIiwibWF0Y2hpbmdSZWNlaXB0IiwicmVjZWlwdHMiLCJmaW5kIiwicmVjZWlwdCIsImRlcGxveWVyQWRkcmVzcyIsImdldFRva2VuQmFsYW5jZXMiLCJjb250cmFjdEFkZHJlc3Nlc09yT3B0aW9ucyIsIkVSQzIwIiwidHlwZSIsImdldFRva2Vuc0Zvck93bmVyIiwib3B0aW9ucyIsImNvbnRyYWN0QWRkcmVzc2VzIiwicmVzcG9uc2UiLCJmb3JtYXR0ZWRCYWxhbmNlcyIsInRva2VuQmFsYW5jZXMiLCJiYWxhbmNlIiwicmF3QmFsYW5jZSIsInRva2VuQmFsYW5jZSIsIm1ldGFkYXRhUHJvbWlzZXMiLCJhbGxTZXR0bGVkIiwidG9rZW4iLCJtZXRhZGF0YSIsInAiLCJzdGF0dXMiLCJzeW1ib2wiLCJkZWNpbWFscyIsImxvZ28iLCJvd25lZFRva2VucyIsImluZGV4IiwiZm9ybWF0VW5pdHMiLCJ0b2tlbnMiLCJ0IiwiZ2V0VG9rZW5NZXRhZGF0YSIsInJlc29sdmVOYW1lIiwibG9va3VwQWRkcmVzcyIsInN0YXJ0IiwiZW5kIiwibWlkIiwiTWF0aCIsImZsb29yIiwiRGVidWdOYW1lc3BhY2UiLCJ0cmFjZUNhbGwiLCJibG9ja0lkZW50aWZpZXIiLCJ0cmFjZXIiLCJwYXJzZVRyYWNlclBhcmFtcyIsInRyYWNlVHJhbnNhY3Rpb24iLCJ0cmFjZUJsb2NrIiwiaXNIZXhTdHJpbmciLCJoZXhTdHJpcFplcm9zIiwiaGV4VmFsdWUiLCJvbmx5VG9wQ2FsbCIsInRyYWNlckNvbmZpZyIsInNhbml0aXplVG9rZW5UeXBlIiwibG9nTGV2ZWxTdHJpbmdUb0VudW0iLCJXQVJOIiwiRVJST1IiLCJzaWxlbnQiLCJTSUxFTlQiLCJsb2dMZXZlbFRvQ29uc29sZUZuIiwiREVGQVVMVF9MT0dfTEVWRUwiLCJsb2dnZXJDbGllbnQiLCJsb2dEZWJ1ZyIsImxvZ0luZm8iLCJsb2dXYXJuIiwiTG9nZ2VyIiwidmFsIiwibm93IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiVkVSU0lPTiIsInNlbmRBeGlvc1JlcXVlc3QiLCJiYXNlVXJsIiwicmVzdEFwaU5hbWUiLCJtZXRob2ROYW1lIiwib3ZlcnJpZGVzIiwicmVxdWVzdFVybCIsImhlYWRlcnMiLCJERUZBVUxUX0JBQ0tPRkZfSU5JVElBTF9ERUxBWV9NUyIsIkRFRkFVTFRfQkFDS09GRl9NVUxUSVBMSUVSIiwiREVGQVVMVF9CQUNLT0ZGX01BWF9ERUxBWV9NUyIsIkRFRkFVTFRfQkFDS09GRl9NQVhfQVRURU1QVFMiLCJFeHBvbmVudGlhbEJhY2tvZmYiLCJtYXhBdHRlbXB0cyIsImluaXRpYWxEZWxheU1zIiwiYmFja29mZk11bHRpcGxpZXIiLCJtYXhEZWxheU1zIiwibnVtQXR0ZW1wdHMiLCJjdXJyZW50RGVsYXlNcyIsImlzSW5CYWNrb2ZmIiwiYmFja29mZiIsImJhY2tvZmZEZWxheVdpdGhKaXR0ZXJNcyIsIndpdGhKaXR0ZXJNcyIsIm1heCIsIm1pbiIsInNldFRpbWVvdXQiLCJkZWxheU1zIiwicmFuZG9tIiwicmVxdWVzdEh0dHBXaXRoQmFja29mZiIsImxhc3RFcnJvciIsImF0dGVtcHQiLCJlcnIiLCJkYXRhIiwiaXNBeGlvc0Vycm9yIiwiaXNSZXRyeWFibGVIdHRwRXJyb3IiLCJyZXRyeWFibGVDb2RlcyIsInBhZ2luYXRlRW5kcG9pbnQiLCJyZXFQYWdlS2V5IiwicmVzUGFnZUtleSIsImFyZ3VtZW50cyIsInBhZ2luYXRlRW5kcG9pbnRfMSIsImhhc05leHQiLCJyZXF1ZXN0UGFyYW1zIiwiZ2V0TmZ0TWV0YWRhdGEiLCJ0b2tlblVyaVRpbWVvdXRJbk1zIiwicmVmcmVzaENhY2hlIiwiZ2V0TmZ0TWV0YWRhdGFCYXRjaCIsIm5mdHMiLCJuZnQiLCJnZXRDb250cmFjdE1ldGFkYXRhIiwiZ2V0Q29udHJhY3RNZXRhZGF0YUJhdGNoIiwiZ2V0Q29sbGVjdGlvbk1ldGFkYXRhIiwiY29sbGVjdGlvblNsdWciLCJnZXROZnRzRm9yT3duZXJJdGVyYXRvciIsIm93bmVyIiwiZ2V0TmZ0c0Zvck93bmVySXRlcmF0b3JfMSIsImVfMSIsIndpdGhNZXRhZGF0YSIsIm9taXRNZXRhZGF0YVRvV2l0aE1ldGFkYXRhIiwib21pdE1ldGFkYXRhIiwiX2IiLCJleGNsdWRlRmlsdGVycyIsImluY2x1ZGVGaWx0ZXJzIiwib3JkZXJCeSIsIl9jIiwib3duZWROZnQiLCJvd25lZE5mdHMiLCJuZnRGcm9tR2V0TmZ0UmVzcG9uc2UiLCJlXzFfMSIsInJldHVybiIsImdldE5mdHNGb3JPd25lciIsInBhZ2VTaXplIiwidG90YWxDb3VudCIsImdldE5mdHNGb3JDb250cmFjdCIsImxpbWl0IiwiZ2V0TmZ0c0ZvckNvbnRyYWN0SXRlcmF0b3IiLCJnZXROZnRzRm9yQ29udHJhY3RJdGVyYXRvcl8xIiwiZV8yIiwibmZ0RnJvbUdldE5mdENvbnRyYWN0UmVzcG9uc2UiLCJlXzJfMSIsImdldE93bmVyc0ZvckNvbnRyYWN0Iiwid2l0aFRva2VuQmFsYW5jZXMiLCJvd25lcnMiLCJnZXRDb250cmFjdHNGb3JPd25lciIsImdldE93bmVyc0Zvck5mdCIsImdldE1pbnRlZE5mdHMiLCJvd25lckFkZHJlc3MiLCJjYXRlZ29yeSIsIm5mdFRva2VuVHlwZVRvQ2F0ZWdvcnkiLCJleGNsdWRlWmVyb1ZhbHVlIiwiZ2V0TmZ0c0ZvclRyYW5zZmVycyIsImdldFRyYW5zZmVyc0Zvck93bmVyIiwidHJhbnNmZXJUeXBlIiwiVE8iLCJ0cmFuc2ZlcnNSZXNwb25zZSIsImdldFRyYW5zZmVyc0ZvckNvbnRyYWN0IiwiU1BFQ0lBTE5GVCIsIm9yZGVyIiwicGFyc2UxMTU1VHJhbnNmZXIiLCJ0cmFuc2ZlciIsImVyYzExNTVNZXRhZGF0YSIsInJhd0NvbnRyYWN0IiwidmVyaWZ5TmZ0T3duZXJzaGlwIiwiYWNjIiwiY3VyciIsImlzU3BhbUNvbnRyYWN0IiwiZ2V0U3BhbUNvbnRyYWN0cyIsImdldEZsb29yUHJpY2UiLCJnZXROZnRTYWxlcyIsInNlbGxlckFkZHJlc3MiLCJidXllckFkZHJlc3MiLCJjb21wdXRlUmFyaXR5Iiwic2VhcmNoQ29udHJhY3RNZXRhZGF0YSIsInF1ZXJ5Iiwic3VtbWFyaXplTmZ0QXR0cmlidXRlcyIsInJlZnJlc2hOZnRNZXRhZGF0YSIsInRva2VuSWRTdHJpbmciLCJmaXJzdCIsInNlY29uZCIsInJlZnJlc2giLCJ0aW1lTGFzdFVwZGF0ZWQiLCJyZWZyZXNoQ29udHJhY3QiLCJyZWZyZXNoU3RhdGUiLCJwYXJzZVJlaW5nZXN0aW9uU3RhdGUiLCJyZWluZ2VzdGlvblN0YXRlIiwicHJvZ3Jlc3MiLCJpc05mdFdpdGhNZXRhZGF0YSIsIm1ldGFkYXRhVHJhbnNmZXJzIiwidHJhbnNmZXJzIiwiZmxhdE1hcCIsImdldFRva2Vuc0Zyb21UcmFuc2ZlciIsInRvIiwiaGFzaCIsImJsb2NrTnVtIiwiYmF0Y2hTaXplIiwicmVxdWVzdEJhdGNoZXMiLCJzbGljZSIsInJlc3BvbnNlQmF0Y2hlcyIsImJhdGNoIiwiZmxhdCIsIm5mdHNCeVRva2VuSWQiLCJNYXAiLCJzZXQiLCJ0cmFuc2ZlcnJlZE5mdHMiLCJnZXQiLCJET0VTX05PVF9FWElTVCIsIkFMUkVBRFlfUVVFVUVEIiwiSU5fUFJPR1JFU1MiLCJGSU5JU0hFRCIsIlFVRVVFRCIsIlFVRVVFX0ZBSUxFRCIsIk5mdE5hbWVzcGFjZSIsIm9wdGlvbnNPclRva2VuVHlwZSIsIk5vdGlmeU5hbWVzcGFjZSIsImdldEFsbFdlYmhvb2tzIiwidmVyaWZ5Q29uZmlnIiwic2VuZFdlYmhvb2tSZXF1ZXN0Iiwid2ViaG9va3MiLCJwYXJzZVJhd1dlYmhvb2tSZXNwb25zZSIsImdldEFkZHJlc3NlcyIsIndlYmhvb2tPcklkIiwid2ViaG9va0lkIiwiaWQiLCJ3ZWJob29rX2lkIiwiYWZ0ZXIiLCJwYXJzZVJhd0FkZHJlc3NBY3Rpdml0eVJlc3BvbnNlIiwiZ2V0R3JhcGhxbFF1ZXJ5IiwicGFyc2VSYXdDdXN0b21HcmFwaHFsV2ViaG9va1Jlc3BvbnNlIiwiZ2V0TmZ0RmlsdGVycyIsInBhcnNlUmF3TmZ0RmlsdGVyc1Jlc3BvbnNlIiwidXBkYXRlV2ViaG9vayIsInVwZGF0ZSIsImlzX2FjdGl2ZSIsImlzQWN0aXZlIiwibmZ0X2ZpbHRlcnNfdG9fYWRkIiwiYWRkRmlsdGVycyIsIm5mdEZpbHRlclRvUGFyYW0iLCJuZnRfZmlsdGVyc190b19yZW1vdmUiLCJyZW1vdmVGaWx0ZXJzIiwibmZ0X21ldGFkYXRhX2ZpbHRlcnNfdG9fYWRkIiwiYWRkTWV0YWRhdGFGaWx0ZXJzIiwibmZ0X21ldGFkYXRhX2ZpbHRlcnNfdG9fcmVtb3ZlIiwicmVtb3ZlTWV0YWRhdGFGaWx0ZXJzIiwiYWRkcmVzc2VzX3RvX2FkZCIsInJlc29sdmVBZGRyZXNzZXMiLCJhZGRBZGRyZXNzZXMiLCJhZGRyZXNzZXNfdG9fcmVtb3ZlIiwicmVtb3ZlQWRkcmVzc2VzIiwiYWRkcmVzc2VzIiwibmV3QWRkcmVzc2VzIiwiY3JlYXRlV2ViaG9vayIsImFwcElkIiwiTUlORURfVFJBTlNBQ1RJT04iLCJEUk9QUEVEX1RSQU5TQUNUSU9OIiwiTkVUV09SS19UT19XRUJIT09LX05FVFdPUksiLCJuZnRGaWx0ZXJPYmoiLCJncmFwaHFsUXVlcnkiLCJORlRfQUNUSVZJVFkiLCJORlRfTUVUQURBVEFfVVBEQVRFIiwiZmlsdGVycyIsImNvbnRyYWN0X2FkZHJlc3MiLCJ0b2tlbl9pZCIsIm5mdF9maWx0ZXJzIiwibmZ0X21ldGFkYXRhX2ZpbHRlcnMiLCJBRERSRVNTX0FDVElWSVRZIiwiR1JBUEhRTCIsIndlYmhvb2tfdHlwZSIsIndlYmhvb2tfdXJsIiwiYXBwX2lkIiwiZ3JhcGhxbF9xdWVyeSIsInBhcnNlUmF3V2ViaG9vayIsImRlbGV0ZVdlYmhvb2siLCJyZXNvbHZlZEFkZHJlc3NlcyIsInJhd0FkZHJlc3MiLCJXRUJIT09LX05FVFdPUktfVE9fTkVUV09SSyIsInJhd1dlYmhvb2siLCJ0aW1lQ3JlYXRlZCIsInRpbWVfY3JlYXRlZCIsInNpZ25pbmdLZXkiLCJzaWduaW5nX2tleSIsInBhZ2luYXRpb24iLCJ0b3RhbF9jb3VudCIsImN1cnNvcnMiLCJHQVNfT1BUSU1JWkVEX1RYX0ZFRV9NVUxUSVBMRVMiLCJUcmFuc2FjdE5hbWVzcGFjZSIsInNlbmRQcml2YXRlVHJhbnNhY3Rpb24iLCJtYXhCbG9ja051bWJlciIsImhleEJsb2NrTnVtYmVyIiwidHgiLCJwcmVmZXJlbmNlcyIsImNhbmNlbFByaXZhdGVUcmFuc2FjdGlvbiIsInR4SGFzaCIsInNpbXVsYXRlQXNzZXRDaGFuZ2VzQnVuZGxlIiwidHJhbnNhY3Rpb25zIiwic2ltdWxhdGVBc3NldENoYW5nZXMiLCJzaW11bGF0ZUV4ZWN1dGlvbkJ1bmRsZSIsInNpbXVsYXRlRXhlY3V0aW9uIiwiZ2V0TWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJmZWVIZXgiLCJzZW5kR2FzT3B0aW1pemVkVHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbk9yU2lnbmVkVHhzIiwiX3NlbmRHYXNPcHRpbWl6ZWRUcmFuc2FjdGlvbiIsImdhc0xpbWl0IiwicHJpb3JpdHlGZWUiLCJiYXNlRmVlIiwiY3VycmVudEJsb2NrIiwiYmFzZUZlZVBlckdhcyIsImdhc1NwcmVhZFRyYW5zYWN0aW9ucyIsImdlbmVyYXRlR2FzU3ByZWFkVHJhbnNhY3Rpb25zIiwic2lnbmVkVHJhbnNhY3Rpb25zIiwic2lnblRyYW5zYWN0aW9uIiwiZ2V0R2FzT3B0aW1pemVkVHJhbnNhY3Rpb25TdGF0dXMiLCJ0cmFja2luZ0lkIiwicmF3VHJhbnNhY3Rpb25zIiwiZmVlTXVsdGlwbGllciIsIm1heEZlZVBlckdhcyIsInJvdW5kIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJBTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUiLCJBTENIRU1ZX01JTkVEX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFIiwiQUxDSEVNWV9FVkVOVF9UWVBFUyIsIkV2ZW50IiwidGFnIiwibGlzdGVuZXIiLCJvbmNlIiwiX2xhc3RCbG9ja051bWJlciIsIl9pbmZsaWdodCIsImV2ZW50Iiwic3BsaXQiLCJjb21wcyIsInRvcGljcyIsImRlc2VyaWFsaXplVG9waWNzIiwicG9sbGFibGUiLCJQb2xsYWJsZUV2ZW50cyIsImluZGV4T2YiLCJFdGhlcnNFdmVudCIsImRlc2VyaWFsaXplQWRkcmVzc0ZpZWxkIiwiaGFzaGVzT25seSIsImluY2x1ZGVSZW1vdmVkIiwiZGVzZXJpYWxpemVBZGRyZXNzZXNGaWVsZCIsImlzQWxjaGVteUV2ZW50IiwiZ2V0QWxjaGVteUV2ZW50VGFnIiwiUEVORElOR19UUkFOU0FDVElPTlMiLCJzZXJpYWxpemVQZW5kaW5nVHJhbnNhY3Rpb25zRXZlbnQiLCJNSU5FRF9UUkFOU0FDVElPTlMiLCJzZXJpYWxpemVNaW5lZFRyYW5zYWN0aW9uc0V2ZW50IiwidmVyaWZ5QWxjaGVteUV2ZW50TmFtZSIsImV2ZW50TmFtZSIsInNlcmlhbGl6ZUFkZHJlc3NGaWVsZCIsInNlcmlhbGl6ZUJvb2xlYW5GaWVsZCIsInNlcmlhbGl6ZUFkZHJlc3Nlc0ZpZWxkIiwiZmllbGQiLCJ0b3BpYyIsImFkZHJlc3NTdHIiLCJhZGRyZXNzUGFpciIsIldlYlNvY2tldE5hbWVzcGFjZSIsIm9uIiwicHJvY2Vzc2VkRXZlbnQiLCJfcmVzb2x2ZUVuc0FsY2hlbXlFdmVudCIsInJlbW92ZUFsbExpc3RlbmVycyIsImxpc3RlbmVyQ291bnQiLCJsaXN0ZW5lcnMiLCJwcm9jZXNzZWRBZGRyZXNzZXMiLCJfcmVzb2x2ZU5hbWVPckVycm9yIiwicmVzb2x2ZWQiLCJBbGNoZW15Iiwic2V0dGluZ3MiLCJjb3JlIiwid3MiLCJ0cmFuc2FjdCIsIm5vdGlmeSIsIldhbGxldCIsInByaXZhdGVLZXkiLCJhbGNoZW15T3JQcm92aWRlciIsInN1cGVyUHJvdmlkZXIiLCJQcm92aWRlciIsImlzUHJvdmlkZXIiLCJhbGNoZW15UHJvdmlkZXJQcm9taXNlIiwiZ2V0V2FsbGV0IiwicG9wdWxhdGVUcmFuc2FjdGlvbiIsImdldENoYWluSWQiLCJjb25uZWN0IiwiQ29udHJhY3QiLCJDb250cmFjdEZhY3RvcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/alchemy-sdk/dist/cjs/index-b1f4a2d9.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/alchemy-sdk/dist/cjs/index.js":
/*!****************************************************!*\
  !*** ./node_modules/alchemy-sdk/dist/cjs/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar utils = __webpack_require__(/*! ./api/utils */ \"(ssr)/./node_modules/alchemy-sdk/dist/cjs/api/utils.js\");\nvar index = __webpack_require__(/*! ./index-b1f4a2d9.js */ \"(ssr)/./node_modules/alchemy-sdk/dist/cjs/index-b1f4a2d9.js\");\nvar bignumber = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/index.js\");\n__webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/index.js\");\n__webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/./node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/wallet */ \"(ssr)/./node_modules/@ethersproject/wallet/lib.esm/index.js\");\n__webpack_require__(/*! @ethersproject/contracts */ \"(ssr)/./node_modules/@ethersproject/contracts/lib.esm/index.js\");\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n}\nvar utils__namespace = /*#__PURE__*/ _interopNamespace(utils);\nexports.Utils = utils__namespace;\nexports.Alchemy = index.Alchemy;\nObject.defineProperty(exports, \"AlchemySubscription\", ({\n    enumerable: true,\n    get: function() {\n        return index.AlchemySubscription;\n    }\n}));\nObject.defineProperty(exports, \"AssetTransfersCategory\", ({\n    enumerable: true,\n    get: function() {\n        return index.AssetTransfersCategory;\n    }\n}));\nObject.defineProperty(exports, \"CommitmentLevel\", ({\n    enumerable: true,\n    get: function() {\n        return index.CommitmentLevel;\n    }\n}));\nexports.Contract = index.Contract;\nexports.ContractFactory = index.ContractFactory;\nObject.defineProperty(exports, \"DebugCallType\", ({\n    enumerable: true,\n    get: function() {\n        return index.DebugCallType;\n    }\n}));\nObject.defineProperty(exports, \"DebugTracerType\", ({\n    enumerable: true,\n    get: function() {\n        return index.DebugTracerType;\n    }\n}));\nObject.defineProperty(exports, \"DecodingAuthority\", ({\n    enumerable: true,\n    get: function() {\n        return index.DecodingAuthority;\n    }\n}));\nObject.defineProperty(exports, \"GasOptimizedTransactionStatus\", ({\n    enumerable: true,\n    get: function() {\n        return index.GasOptimizedTransactionStatus;\n    }\n}));\nObject.defineProperty(exports, \"GetTransfersForOwnerTransferType\", ({\n    enumerable: true,\n    get: function() {\n        return index.GetTransfersForOwnerTransferType;\n    }\n}));\nObject.defineProperty(exports, \"Network\", ({\n    enumerable: true,\n    get: function() {\n        return index.Network;\n    }\n}));\nObject.defineProperty(exports, \"NftCollectionMarketplace\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftCollectionMarketplace;\n    }\n}));\nObject.defineProperty(exports, \"NftFilters\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftFilters;\n    }\n}));\nObject.defineProperty(exports, \"NftOrdering\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftOrdering;\n    }\n}));\nObject.defineProperty(exports, \"NftRefreshState\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftRefreshState;\n    }\n}));\nObject.defineProperty(exports, \"NftSaleMarketplace\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftSaleMarketplace;\n    }\n}));\nObject.defineProperty(exports, \"NftSaleTakerType\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftSaleTakerType;\n    }\n}));\nObject.defineProperty(exports, \"NftSpamClassification\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftSpamClassification;\n    }\n}));\nObject.defineProperty(exports, \"NftTokenType\", ({\n    enumerable: true,\n    get: function() {\n        return index.NftTokenType;\n    }\n}));\nObject.defineProperty(exports, \"OpenSeaSafelistRequestStatus\", ({\n    enumerable: true,\n    get: function() {\n        return index.OpenSeaSafelistRequestStatus;\n    }\n}));\nObject.defineProperty(exports, \"SimulateAssetType\", ({\n    enumerable: true,\n    get: function() {\n        return index.SimulateAssetType;\n    }\n}));\nObject.defineProperty(exports, \"SimulateChangeType\", ({\n    enumerable: true,\n    get: function() {\n        return index.SimulateChangeType;\n    }\n}));\nObject.defineProperty(exports, \"SortingOrder\", ({\n    enumerable: true,\n    get: function() {\n        return index.SortingOrder;\n    }\n}));\nObject.defineProperty(exports, \"TokenBalanceType\", ({\n    enumerable: true,\n    get: function() {\n        return index.TokenBalanceType;\n    }\n}));\nexports.Wallet = index.Wallet;\nObject.defineProperty(exports, \"WebhookType\", ({\n    enumerable: true,\n    get: function() {\n        return index.WebhookType;\n    }\n}));\nObject.defineProperty(exports, \"WebhookVersion\", ({\n    enumerable: true,\n    get: function() {\n        return index.WebhookVersion;\n    }\n}));\nexports.fromHex = index.fromHex;\nexports.isHex = index.isHex;\nexports.setLogLevel = index.setLogLevel;\nexports.toHex = index.toHex;\nObject.defineProperty(exports, \"BigNumber\", ({\n    enumerable: true,\n    get: function() {\n        return bignumber.BigNumber;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9janMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFFN0QsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUUsWUFBWUYsbUJBQU9BLENBQUM7QUFDeEJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBRVIsU0FBU0csa0JBQWtCQyxDQUFDO0lBQzNCLElBQUlBLEtBQUtBLEVBQUVDLFVBQVUsRUFBRSxPQUFPRDtJQUM5QixJQUFJRSxJQUFJWCxPQUFPWSxNQUFNLENBQUM7SUFDdEIsSUFBSUgsR0FBRztRQUNOVCxPQUFPYSxJQUFJLENBQUNKLEdBQUdLLE9BQU8sQ0FBQyxTQUFVQyxDQUFDO1lBQ2pDLElBQUlBLE1BQU0sV0FBVztnQkFDcEIsSUFBSUMsSUFBSWhCLE9BQU9pQix3QkFBd0IsQ0FBQ1IsR0FBR007Z0JBQzNDZixPQUFPQyxjQUFjLENBQUNVLEdBQUdJLEdBQUdDLEVBQUVFLEdBQUcsR0FBR0YsSUFBSTtvQkFDdkNHLFlBQVk7b0JBQ1pELEtBQUs7d0JBQWMsT0FBT1QsQ0FBQyxDQUFDTSxFQUFFO29CQUFFO2dCQUNqQztZQUNEO1FBQ0Q7SUFDRDtJQUNBSixDQUFDLENBQUMsVUFBVSxHQUFHRjtJQUNmLE9BQU9ULE9BQU9vQixNQUFNLENBQUNUO0FBQ3RCO0FBRUEsSUFBSVUsbUJBQW1CLFdBQVcsR0FBRWIsa0JBQWtCSjtBQUl0REYsYUFBYSxHQUFHbUI7QUFDaEJuQixlQUFlLEdBQUdJLE1BQU1pQixPQUFPO0FBQy9CdkIsdURBQXNEO0lBQ3JEbUIsWUFBWTtJQUNaRCxLQUFLO1FBQWMsT0FBT1osTUFBTWtCLG1CQUFtQjtJQUFFO0FBQ3RELENBQUMsRUFBQztB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LENBQUMsRUFBQztBQUNGN0MsY0FBYyxHQUFHSSxNQUFNMEMsTUFBTTtBQUM3QmhELCtDQUE4QztJQUM3Q21CLFlBQVk7SUFDWkQsS0FBSztRQUFjLE9BQU9aLE1BQU0yQyxXQUFXO0lBQUU7QUFDOUMsQ0FBQyxFQUFDO0FBQ0ZqRCxrREFBaUQ7SUFDaERtQixZQUFZO0lBQ1pELEtBQUs7UUFBYyxPQUFPWixNQUFNNEMsY0FBYztJQUFFO0FBQ2pELENBQUMsRUFBQztBQUNGaEQsZUFBZSxHQUFHSSxNQUFNNkMsT0FBTztBQUMvQmpELGFBQWEsR0FBR0ksTUFBTThDLEtBQUs7QUFDM0JsRCxtQkFBbUIsR0FBR0ksTUFBTStDLFdBQVc7QUFDdkNuRCxhQUFhLEdBQUdJLE1BQU1nRCxLQUFLO0FBQzNCdEQsNkNBQTRDO0lBQzNDbUIsWUFBWTtJQUNaRCxLQUFLO1FBQWMsT0FBT1gsVUFBVWdELFNBQVM7SUFBRTtBQUNoRCxDQUFDLEVBQUMsRUFDRixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL2FsY2hlbXktc2RrL2Rpc3QvY2pzL2luZGV4LmpzP2NhMWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL2FwaS91dGlscycpO1xudmFyIGluZGV4ID0gcmVxdWlyZSgnLi9pbmRleC1iMWY0YTJkOS5qcycpO1xudmFyIGJpZ251bWJlciA9IHJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2JpZ251bWJlcicpO1xucmVxdWlyZSgnYXhpb3MnKTtcbnJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyJyk7XG5yZXF1aXJlKCdAZXRoZXJzcHJvamVjdC93YWxsZXQnKTtcbnJlcXVpcmUoJ0BldGhlcnNwcm9qZWN0L2NvbnRyYWN0cycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG5cdGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG5cdHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0aWYgKGUpIHtcblx0XHRPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdFx0XHRpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG5cdFx0XHRcdHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXHRuW1wiZGVmYXVsdFwiXSA9IGU7XG5cdHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgdXRpbHNfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZSh1dGlscyk7XG5cblxuXG5leHBvcnRzLlV0aWxzID0gdXRpbHNfX25hbWVzcGFjZTtcbmV4cG9ydHMuQWxjaGVteSA9IGluZGV4LkFsY2hlbXk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0FsY2hlbXlTdWJzY3JpcHRpb24nLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguQWxjaGVteVN1YnNjcmlwdGlvbjsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0Fzc2V0VHJhbnNmZXJzQ2F0ZWdvcnknLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0NvbW1pdG1lbnRMZXZlbCcsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleC5Db21taXRtZW50TGV2ZWw7IH1cbn0pO1xuZXhwb3J0cy5Db250cmFjdCA9IGluZGV4LkNvbnRyYWN0O1xuZXhwb3J0cy5Db250cmFjdEZhY3RvcnkgPSBpbmRleC5Db250cmFjdEZhY3Rvcnk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0RlYnVnQ2FsbFR5cGUnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguRGVidWdDYWxsVHlwZTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0RlYnVnVHJhY2VyVHlwZScsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleC5EZWJ1Z1RyYWNlclR5cGU7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdEZWNvZGluZ0F1dGhvcml0eScsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleC5EZWNvZGluZ0F1dGhvcml0eTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0dhc09wdGltaXplZFRyYW5zYWN0aW9uU3RhdHVzJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4Lkdhc09wdGltaXplZFRyYW5zYWN0aW9uU3RhdHVzOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnR2V0VHJhbnNmZXJzRm9yT3duZXJUcmFuc2ZlclR5cGUnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguR2V0VHJhbnNmZXJzRm9yT3duZXJUcmFuc2ZlclR5cGU7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdOZXR3b3JrJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4Lk5ldHdvcms7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdOZnRDb2xsZWN0aW9uTWFya2V0cGxhY2UnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguTmZ0Q29sbGVjdGlvbk1hcmtldHBsYWNlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTmZ0RmlsdGVycycsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleC5OZnRGaWx0ZXJzOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTmZ0T3JkZXJpbmcnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguTmZ0T3JkZXJpbmc7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdOZnRSZWZyZXNoU3RhdGUnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguTmZ0UmVmcmVzaFN0YXRlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTmZ0U2FsZU1hcmtldHBsYWNlJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4Lk5mdFNhbGVNYXJrZXRwbGFjZTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ05mdFNhbGVUYWtlclR5cGUnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguTmZ0U2FsZVRha2VyVHlwZTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ05mdFNwYW1DbGFzc2lmaWNhdGlvbicsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleC5OZnRTcGFtQ2xhc3NpZmljYXRpb247IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdOZnRUb2tlblR5cGUnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguTmZ0VG9rZW5UeXBlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnT3BlblNlYVNhZmVsaXN0UmVxdWVzdFN0YXR1cycsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleC5PcGVuU2VhU2FmZWxpc3RSZXF1ZXN0U3RhdHVzOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU2ltdWxhdGVBc3NldFR5cGUnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguU2ltdWxhdGVBc3NldFR5cGU7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdTaW11bGF0ZUNoYW5nZVR5cGUnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguU2ltdWxhdGVDaGFuZ2VUeXBlOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU29ydGluZ09yZGVyJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4LlNvcnRpbmdPcmRlcjsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1Rva2VuQmFsYW5jZVR5cGUnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguVG9rZW5CYWxhbmNlVHlwZTsgfVxufSk7XG5leHBvcnRzLldhbGxldCA9IGluZGV4LldhbGxldDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnV2ViaG9va1R5cGUnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5kZXguV2ViaG9va1R5cGU7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdXZWJob29rVmVyc2lvbicsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleC5XZWJob29rVmVyc2lvbjsgfVxufSk7XG5leHBvcnRzLmZyb21IZXggPSBpbmRleC5mcm9tSGV4O1xuZXhwb3J0cy5pc0hleCA9IGluZGV4LmlzSGV4O1xuZXhwb3J0cy5zZXRMb2dMZXZlbCA9IGluZGV4LnNldExvZ0xldmVsO1xuZXhwb3J0cy50b0hleCA9IGluZGV4LnRvSGV4O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdCaWdOdW1iZXInLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmlnbnVtYmVyLkJpZ051bWJlcjsgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInV0aWxzIiwicmVxdWlyZSIsImluZGV4IiwiYmlnbnVtYmVyIiwiX2ludGVyb3BOYW1lc3BhY2UiLCJlIiwiX19lc01vZHVsZSIsIm4iLCJjcmVhdGUiLCJrZXlzIiwiZm9yRWFjaCIsImsiLCJkIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0IiwiZW51bWVyYWJsZSIsImZyZWV6ZSIsInV0aWxzX19uYW1lc3BhY2UiLCJVdGlscyIsIkFsY2hlbXkiLCJBbGNoZW15U3Vic2NyaXB0aW9uIiwiQXNzZXRUcmFuc2ZlcnNDYXRlZ29yeSIsIkNvbW1pdG1lbnRMZXZlbCIsIkNvbnRyYWN0IiwiQ29udHJhY3RGYWN0b3J5IiwiRGVidWdDYWxsVHlwZSIsIkRlYnVnVHJhY2VyVHlwZSIsIkRlY29kaW5nQXV0aG9yaXR5IiwiR2FzT3B0aW1pemVkVHJhbnNhY3Rpb25TdGF0dXMiLCJHZXRUcmFuc2ZlcnNGb3JPd25lclRyYW5zZmVyVHlwZSIsIk5ldHdvcmsiLCJOZnRDb2xsZWN0aW9uTWFya2V0cGxhY2UiLCJOZnRGaWx0ZXJzIiwiTmZ0T3JkZXJpbmciLCJOZnRSZWZyZXNoU3RhdGUiLCJOZnRTYWxlTWFya2V0cGxhY2UiLCJOZnRTYWxlVGFrZXJUeXBlIiwiTmZ0U3BhbUNsYXNzaWZpY2F0aW9uIiwiTmZ0VG9rZW5UeXBlIiwiT3BlblNlYVNhZmVsaXN0UmVxdWVzdFN0YXR1cyIsIlNpbXVsYXRlQXNzZXRUeXBlIiwiU2ltdWxhdGVDaGFuZ2VUeXBlIiwiU29ydGluZ09yZGVyIiwiVG9rZW5CYWxhbmNlVHlwZSIsIldhbGxldCIsIldlYmhvb2tUeXBlIiwiV2ViaG9va1ZlcnNpb24iLCJmcm9tSGV4IiwiaXNIZXgiLCJzZXRMb2dMZXZlbCIsInRvSGV4IiwiQmlnTnVtYmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/alchemy-sdk/dist/cjs/index.js\n");

/***/ })

};
;