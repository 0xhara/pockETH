"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jsonschema";
exports.ids = ["vendor-chunks/jsonschema"];
exports.modules = {

/***/ "(ssr)/./node_modules/jsonschema/lib/attribute.js":
/*!**************************************************!*\
  !*** ./node_modules/jsonschema/lib/attribute.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar helpers = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/jsonschema/lib/helpers.js\");\n/** @type ValidatorResult */ var ValidatorResult = helpers.ValidatorResult;\n/** @type SchemaError */ var SchemaError = helpers.SchemaError;\nvar attribute = {};\nattribute.ignoreProperties = {\n    // informative properties\n    \"id\": true,\n    \"default\": true,\n    \"description\": true,\n    \"title\": true,\n    // arguments to other properties\n    \"additionalItems\": true,\n    \"then\": true,\n    \"else\": true,\n    // special-handled properties\n    \"$schema\": true,\n    \"$ref\": true,\n    \"extends\": true\n};\n/**\n * @name validators\n */ var validators = attribute.validators = {};\n/**\n * Validates whether the instance if of a certain type\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */ validators.type = function validateType(instance, schema, options, ctx) {\n    // Ignore undefined instances\n    if (instance === undefined) {\n        return null;\n    }\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    var types = Array.isArray(schema.type) ? schema.type : [\n        schema.type\n    ];\n    if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {\n        var list = types.map(function(v) {\n            if (!v) return;\n            var id = v.$id || v.id;\n            return id ? \"<\" + id + \">\" : v + \"\";\n        });\n        result.addError({\n            name: \"type\",\n            argument: list,\n            message: \"is not of a type(s) \" + list\n        });\n    }\n    return result;\n};\nfunction testSchemaNoThrow(instance, options, ctx, callback, schema) {\n    var throwError = options.throwError;\n    var throwAll = options.throwAll;\n    options.throwError = false;\n    options.throwAll = false;\n    var res = this.validateSchema(instance, schema, options, ctx);\n    options.throwError = throwError;\n    options.throwAll = throwAll;\n    if (!res.valid && callback instanceof Function) {\n        callback(res);\n    }\n    return res.valid;\n}\n/**\n * Validates whether the instance matches some of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */ validators.anyOf = function validateAnyOf(instance, schema, options, ctx) {\n    // Ignore undefined instances\n    if (instance === undefined) {\n        return null;\n    }\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    var inner = new ValidatorResult(instance, schema, options, ctx);\n    if (!Array.isArray(schema.anyOf)) {\n        throw new SchemaError(\"anyOf must be an array\");\n    }\n    if (!schema.anyOf.some(testSchemaNoThrow.bind(this, instance, options, ctx, function(res) {\n        inner.importErrors(res);\n    }))) {\n        var list = schema.anyOf.map(function(v, i) {\n            var id = v.$id || v.id;\n            if (id) return \"<\" + id + \">\";\n            return v.title && JSON.stringify(v.title) || v[\"$ref\"] && \"<\" + v[\"$ref\"] + \">\" || \"[subschema \" + i + \"]\";\n        });\n        if (options.nestedErrors) {\n            result.importErrors(inner);\n        }\n        result.addError({\n            name: \"anyOf\",\n            argument: list,\n            message: \"is not any of \" + list.join(\",\")\n        });\n    }\n    return result;\n};\n/**\n * Validates whether the instance matches every given schema\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */ validators.allOf = function validateAllOf(instance, schema, options, ctx) {\n    // Ignore undefined instances\n    if (instance === undefined) {\n        return null;\n    }\n    if (!Array.isArray(schema.allOf)) {\n        throw new SchemaError(\"allOf must be an array\");\n    }\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    var self = this;\n    schema.allOf.forEach(function(v, i) {\n        var valid = self.validateSchema(instance, v, options, ctx);\n        if (!valid.valid) {\n            var id = v.$id || v.id;\n            var msg = id || v.title && JSON.stringify(v.title) || v[\"$ref\"] && \"<\" + v[\"$ref\"] + \">\" || \"[subschema \" + i + \"]\";\n            result.addError({\n                name: \"allOf\",\n                argument: {\n                    id: msg,\n                    length: valid.errors.length,\n                    valid: valid\n                },\n                message: \"does not match allOf schema \" + msg + \" with \" + valid.errors.length + \" error[s]:\"\n            });\n            result.importErrors(valid);\n        }\n    });\n    return result;\n};\n/**\n * Validates whether the instance matches exactly one of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */ validators.oneOf = function validateOneOf(instance, schema, options, ctx) {\n    // Ignore undefined instances\n    if (instance === undefined) {\n        return null;\n    }\n    if (!Array.isArray(schema.oneOf)) {\n        throw new SchemaError(\"oneOf must be an array\");\n    }\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    var inner = new ValidatorResult(instance, schema, options, ctx);\n    var count = schema.oneOf.filter(testSchemaNoThrow.bind(this, instance, options, ctx, function(res) {\n        inner.importErrors(res);\n    })).length;\n    var list = schema.oneOf.map(function(v, i) {\n        var id = v.$id || v.id;\n        return id || v.title && JSON.stringify(v.title) || v[\"$ref\"] && \"<\" + v[\"$ref\"] + \">\" || \"[subschema \" + i + \"]\";\n    });\n    if (count !== 1) {\n        if (options.nestedErrors) {\n            result.importErrors(inner);\n        }\n        result.addError({\n            name: \"oneOf\",\n            argument: list,\n            message: \"is not exactly one from \" + list.join(\",\")\n        });\n    }\n    return result;\n};\n/**\n * Validates \"then\" or \"else\" depending on the result of validating \"if\"\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */ validators.if = function validateIf(instance, schema, options, ctx) {\n    // Ignore undefined instances\n    if (instance === undefined) return null;\n    if (!helpers.isSchema(schema.if)) throw new Error('Expected \"if\" keyword to be a schema');\n    var ifValid = testSchemaNoThrow.call(this, instance, options, ctx, null, schema.if);\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    var res;\n    if (ifValid) {\n        if (schema.then === undefined) return;\n        if (!helpers.isSchema(schema.then)) throw new Error('Expected \"then\" keyword to be a schema');\n        res = this.validateSchema(instance, schema.then, options, ctx.makeChild(schema.then));\n        result.importErrors(res);\n    } else {\n        if (schema.else === undefined) return;\n        if (!helpers.isSchema(schema.else)) throw new Error('Expected \"else\" keyword to be a schema');\n        res = this.validateSchema(instance, schema.else, options, ctx.makeChild(schema.else));\n        result.importErrors(res);\n    }\n    return result;\n};\nfunction getEnumerableProperty(object, key) {\n    // Determine if `key` shows up in `for(var key in object)`\n    // First test Object.hasOwnProperty.call as an optimization: that guarantees it does\n    if (Object.hasOwnProperty.call(object, key)) return object[key];\n    // Test `key in object` as an optimization; false means it won't\n    if (!(key in object)) return;\n    while(object = Object.getPrototypeOf(object)){\n        if (Object.propertyIsEnumerable.call(object, key)) return object[key];\n    }\n}\n/**\n * Validates propertyNames\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */ validators.propertyNames = function validatePropertyNames(instance, schema, options, ctx) {\n    if (!this.types.object(instance)) return;\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    var subschema = schema.propertyNames !== undefined ? schema.propertyNames : {};\n    if (!helpers.isSchema(subschema)) throw new SchemaError('Expected \"propertyNames\" to be a schema (object or boolean)');\n    for(var property in instance){\n        if (getEnumerableProperty(instance, property) !== undefined) {\n            var res = this.validateSchema(property, subschema, options, ctx.makeChild(subschema));\n            result.importErrors(res);\n        }\n    }\n    return result;\n};\n/**\n * Validates properties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */ validators.properties = function validateProperties(instance, schema, options, ctx) {\n    if (!this.types.object(instance)) return;\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    var properties = schema.properties || {};\n    for(var property in properties){\n        var subschema = properties[property];\n        if (subschema === undefined) {\n            continue;\n        } else if (subschema === null) {\n            throw new SchemaError('Unexpected null, expected schema in \"properties\"');\n        }\n        if (typeof options.preValidateProperty == \"function\") {\n            options.preValidateProperty(instance, property, subschema, options, ctx);\n        }\n        var prop = getEnumerableProperty(instance, property);\n        var res = this.validateSchema(prop, subschema, options, ctx.makeChild(subschema, property));\n        if (res.instance !== result.instance[property]) result.instance[property] = res.instance;\n        result.importErrors(res);\n    }\n    return result;\n};\n/**\n * Test a specific property within in instance against the additionalProperties schema attribute\n * This ignores properties with definitions in the properties schema attribute, but no other attributes.\n * If too many more types of property-existence tests pop up they may need their own class of tests (like `type` has)\n * @private\n * @return {boolean}\n */ function testAdditionalProperty(instance, schema, options, ctx, property, result) {\n    if (!this.types.object(instance)) return;\n    if (schema.properties && schema.properties[property] !== undefined) {\n        return;\n    }\n    if (schema.additionalProperties === false) {\n        result.addError({\n            name: \"additionalProperties\",\n            argument: property,\n            message: \"is not allowed to have the additional property \" + JSON.stringify(property)\n        });\n    } else {\n        var additionalProperties = schema.additionalProperties || {};\n        if (typeof options.preValidateProperty == \"function\") {\n            options.preValidateProperty(instance, property, additionalProperties, options, ctx);\n        }\n        var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));\n        if (res.instance !== result.instance[property]) result.instance[property] = res.instance;\n        result.importErrors(res);\n    }\n}\n/**\n * Validates patternProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */ validators.patternProperties = function validatePatternProperties(instance, schema, options, ctx) {\n    if (!this.types.object(instance)) return;\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    var patternProperties = schema.patternProperties || {};\n    for(var property in instance){\n        var test = true;\n        for(var pattern in patternProperties){\n            var subschema = patternProperties[pattern];\n            if (subschema === undefined) {\n                continue;\n            } else if (subschema === null) {\n                throw new SchemaError('Unexpected null, expected schema in \"patternProperties\"');\n            }\n            try {\n                var regexp = new RegExp(pattern, \"u\");\n            } catch (_e) {\n                // In the event the stricter handling causes an error, fall back on the forgiving handling\n                // DEPRECATED\n                regexp = new RegExp(pattern);\n            }\n            if (!regexp.test(property)) {\n                continue;\n            }\n            test = false;\n            if (typeof options.preValidateProperty == \"function\") {\n                options.preValidateProperty(instance, property, subschema, options, ctx);\n            }\n            var res = this.validateSchema(instance[property], subschema, options, ctx.makeChild(subschema, property));\n            if (res.instance !== result.instance[property]) result.instance[property] = res.instance;\n            result.importErrors(res);\n        }\n        if (test) {\n            testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n        }\n    }\n    return result;\n};\n/**\n * Validates additionalProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */ validators.additionalProperties = function validateAdditionalProperties(instance, schema, options, ctx) {\n    if (!this.types.object(instance)) return;\n    // if patternProperties is defined then we'll test when that one is called instead\n    if (schema.patternProperties) {\n        return null;\n    }\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    for(var property in instance){\n        testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n    }\n    return result;\n};\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */ validators.minProperties = function validateMinProperties(instance, schema, options, ctx) {\n    if (!this.types.object(instance)) return;\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    var keys = Object.keys(instance);\n    if (!(keys.length >= schema.minProperties)) {\n        result.addError({\n            name: \"minProperties\",\n            argument: schema.minProperties,\n            message: \"does not meet minimum property length of \" + schema.minProperties\n        });\n    }\n    return result;\n};\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */ validators.maxProperties = function validateMaxProperties(instance, schema, options, ctx) {\n    if (!this.types.object(instance)) return;\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    var keys = Object.keys(instance);\n    if (!(keys.length <= schema.maxProperties)) {\n        result.addError({\n            name: \"maxProperties\",\n            argument: schema.maxProperties,\n            message: \"does not meet maximum property length of \" + schema.maxProperties\n        });\n    }\n    return result;\n};\n/**\n * Validates items when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */ validators.items = function validateItems(instance, schema, options, ctx) {\n    var self = this;\n    if (!this.types.array(instance)) return;\n    if (schema.items === undefined) return;\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    instance.every(function(value, i) {\n        if (Array.isArray(schema.items)) {\n            var items = schema.items[i] === undefined ? schema.additionalItems : schema.items[i];\n        } else {\n            var items = schema.items;\n        }\n        if (items === undefined) {\n            return true;\n        }\n        if (items === false) {\n            result.addError({\n                name: \"items\",\n                message: \"additionalItems not permitted\"\n            });\n            return false;\n        }\n        var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));\n        if (res.instance !== result.instance[i]) result.instance[i] = res.instance;\n        result.importErrors(res);\n        return true;\n    });\n    return result;\n};\n/**\n * Validates the \"contains\" keyword\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */ validators.contains = function validateContains(instance, schema, options, ctx) {\n    var self = this;\n    if (!this.types.array(instance)) return;\n    if (schema.contains === undefined) return;\n    if (!helpers.isSchema(schema.contains)) throw new Error('Expected \"contains\" keyword to be a schema');\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    var count = instance.some(function(value, i) {\n        var res = self.validateSchema(value, schema.contains, options, ctx.makeChild(schema.contains, i));\n        return res.errors.length === 0;\n    });\n    if (count === false) {\n        result.addError({\n            name: \"contains\",\n            argument: schema.contains,\n            message: \"must contain an item matching given schema\"\n        });\n    }\n    return result;\n};\n/**\n * Validates minimum and exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */ validators.minimum = function validateMinimum(instance, schema, options, ctx) {\n    if (!this.types.number(instance)) return;\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {\n        if (!(instance > schema.minimum)) {\n            result.addError({\n                name: \"minimum\",\n                argument: schema.minimum,\n                message: \"must be greater than \" + schema.minimum\n            });\n        }\n    } else {\n        if (!(instance >= schema.minimum)) {\n            result.addError({\n                name: \"minimum\",\n                argument: schema.minimum,\n                message: \"must be greater than or equal to \" + schema.minimum\n            });\n        }\n    }\n    return result;\n};\n/**\n * Validates maximum and exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */ validators.maximum = function validateMaximum(instance, schema, options, ctx) {\n    if (!this.types.number(instance)) return;\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {\n        if (!(instance < schema.maximum)) {\n            result.addError({\n                name: \"maximum\",\n                argument: schema.maximum,\n                message: \"must be less than \" + schema.maximum\n            });\n        }\n    } else {\n        if (!(instance <= schema.maximum)) {\n            result.addError({\n                name: \"maximum\",\n                argument: schema.maximum,\n                message: \"must be less than or equal to \" + schema.maximum\n            });\n        }\n    }\n    return result;\n};\n/**\n * Validates the number form of exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */ validators.exclusiveMinimum = function validateExclusiveMinimum(instance, schema, options, ctx) {\n    // Support the boolean form of exclusiveMinimum, which is handled by the \"minimum\" keyword.\n    if (typeof schema.exclusiveMinimum === \"boolean\") return;\n    if (!this.types.number(instance)) return;\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    var valid = instance > schema.exclusiveMinimum;\n    if (!valid) {\n        result.addError({\n            name: \"exclusiveMinimum\",\n            argument: schema.exclusiveMinimum,\n            message: \"must be strictly greater than \" + schema.exclusiveMinimum\n        });\n    }\n    return result;\n};\n/**\n * Validates the number form of exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */ validators.exclusiveMaximum = function validateExclusiveMaximum(instance, schema, options, ctx) {\n    // Support the boolean form of exclusiveMaximum, which is handled by the \"maximum\" keyword.\n    if (typeof schema.exclusiveMaximum === \"boolean\") return;\n    if (!this.types.number(instance)) return;\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    var valid = instance < schema.exclusiveMaximum;\n    if (!valid) {\n        result.addError({\n            name: \"exclusiveMaximum\",\n            argument: schema.exclusiveMaximum,\n            message: \"must be strictly less than \" + schema.exclusiveMaximum\n        });\n    }\n    return result;\n};\n/**\n * Perform validation for multipleOf and divisibleBy, which are essentially the same.\n * @param instance\n * @param schema\n * @param validationType\n * @param errorMessage\n * @returns {String|null}\n */ var validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, validationType, errorMessage) {\n    if (!this.types.number(instance)) return;\n    var validationArgument = schema[validationType];\n    if (validationArgument == 0) {\n        throw new SchemaError(validationType + \" cannot be zero\");\n    }\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    var instanceDecimals = helpers.getDecimalPlaces(instance);\n    var divisorDecimals = helpers.getDecimalPlaces(validationArgument);\n    var maxDecimals = Math.max(instanceDecimals, divisorDecimals);\n    var multiplier = Math.pow(10, maxDecimals);\n    if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {\n        result.addError({\n            name: validationType,\n            argument: validationArgument,\n            message: errorMessage + JSON.stringify(validationArgument)\n        });\n    }\n    return result;\n};\n/**\n * Validates divisibleBy when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */ validators.multipleOf = function validateMultipleOf(instance, schema, options, ctx) {\n    return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"multipleOf\", \"is not a multiple of (divisible by) \");\n};\n/**\n * Validates multipleOf when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */ validators.divisibleBy = function validateDivisibleBy(instance, schema, options, ctx) {\n    return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"divisibleBy\", \"is not divisible by (multiple of) \");\n};\n/**\n * Validates whether the instance value is present.\n * @param instance\n * @param schema\n * @return {String|null}\n */ validators.required = function validateRequired(instance, schema, options, ctx) {\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    if (instance === undefined && schema.required === true) {\n        // A boolean form is implemented for reverse-compatibility with schemas written against older drafts\n        result.addError({\n            name: \"required\",\n            message: \"is required\"\n        });\n    } else if (this.types.object(instance) && Array.isArray(schema.required)) {\n        schema.required.forEach(function(n) {\n            if (getEnumerableProperty(instance, n) === undefined) {\n                result.addError({\n                    name: \"required\",\n                    argument: n,\n                    message: \"requires property \" + JSON.stringify(n)\n                });\n            }\n        });\n    }\n    return result;\n};\n/**\n * Validates whether the instance value matches the regular expression, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */ validators.pattern = function validatePattern(instance, schema, options, ctx) {\n    if (!this.types.string(instance)) return;\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    var pattern = schema.pattern;\n    try {\n        var regexp = new RegExp(pattern, \"u\");\n    } catch (_e) {\n        // In the event the stricter handling causes an error, fall back on the forgiving handling\n        // DEPRECATED\n        regexp = new RegExp(pattern);\n    }\n    if (!instance.match(regexp)) {\n        result.addError({\n            name: \"pattern\",\n            argument: schema.pattern,\n            message: \"does not match pattern \" + JSON.stringify(schema.pattern.toString())\n        });\n    }\n    return result;\n};\n/**\n * Validates whether the instance value is of a certain defined format or a custom\n * format.\n * The following formats are supported for string types:\n *   - date-time\n *   - date\n *   - time\n *   - ip-address\n *   - ipv6\n *   - uri\n *   - color\n *   - host-name\n *   - alpha\n *   - alpha-numeric\n *   - utc-millisec\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {String|null}\n */ validators.format = function validateFormat(instance, schema, options, ctx) {\n    if (instance === undefined) return;\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {\n        result.addError({\n            name: \"format\",\n            argument: schema.format,\n            message: \"does not conform to the \" + JSON.stringify(schema.format) + \" format\"\n        });\n    }\n    return result;\n};\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */ validators.minLength = function validateMinLength(instance, schema, options, ctx) {\n    if (!this.types.string(instance)) return;\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n    var length = instance.length - (hsp ? hsp.length : 0);\n    if (!(length >= schema.minLength)) {\n        result.addError({\n            name: \"minLength\",\n            argument: schema.minLength,\n            message: \"does not meet minimum length of \" + schema.minLength\n        });\n    }\n    return result;\n};\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */ validators.maxLength = function validateMaxLength(instance, schema, options, ctx) {\n    if (!this.types.string(instance)) return;\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    // TODO if this was already computed in \"minLength\", use that value instead of re-computing\n    var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n    var length = instance.length - (hsp ? hsp.length : 0);\n    if (!(length <= schema.maxLength)) {\n        result.addError({\n            name: \"maxLength\",\n            argument: schema.maxLength,\n            message: \"does not meet maximum length of \" + schema.maxLength\n        });\n    }\n    return result;\n};\n/**\n * Validates whether instance contains at least a minimum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */ validators.minItems = function validateMinItems(instance, schema, options, ctx) {\n    if (!this.types.array(instance)) return;\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    if (!(instance.length >= schema.minItems)) {\n        result.addError({\n            name: \"minItems\",\n            argument: schema.minItems,\n            message: \"does not meet minimum length of \" + schema.minItems\n        });\n    }\n    return result;\n};\n/**\n * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */ validators.maxItems = function validateMaxItems(instance, schema, options, ctx) {\n    if (!this.types.array(instance)) return;\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    if (!(instance.length <= schema.maxItems)) {\n        result.addError({\n            name: \"maxItems\",\n            argument: schema.maxItems,\n            message: \"does not meet maximum length of \" + schema.maxItems\n        });\n    }\n    return result;\n};\n/**\n * Deep compares arrays for duplicates\n * @param v\n * @param i\n * @param a\n * @private\n * @return {boolean}\n */ function testArrays(v, i, a) {\n    var j, len = a.length;\n    for(j = i + 1, len; j < len; j++){\n        if (helpers.deepCompareStrict(v, a[j])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Validates whether there are no duplicates, when the instance is an Array.\n * @param instance\n * @return {String|null}\n */ validators.uniqueItems = function validateUniqueItems(instance, schema, options, ctx) {\n    if (schema.uniqueItems !== true) return;\n    if (!this.types.array(instance)) return;\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    if (!instance.every(testArrays)) {\n        result.addError({\n            name: \"uniqueItems\",\n            message: \"contains duplicate item\"\n        });\n    }\n    return result;\n};\n/**\n * Validate for the presence of dependency properties, if the instance is an object.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */ validators.dependencies = function validateDependencies(instance, schema, options, ctx) {\n    if (!this.types.object(instance)) return;\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    for(var property in schema.dependencies){\n        if (instance[property] === undefined) {\n            continue;\n        }\n        var dep = schema.dependencies[property];\n        var childContext = ctx.makeChild(dep, property);\n        if (typeof dep == \"string\") {\n            dep = [\n                dep\n            ];\n        }\n        if (Array.isArray(dep)) {\n            dep.forEach(function(prop) {\n                if (instance[prop] === undefined) {\n                    result.addError({\n                        // FIXME there's two different \"dependencies\" errors here with slightly different outputs\n                        // Can we make these the same? Or should we create different error types?\n                        name: \"dependencies\",\n                        argument: childContext.propertyPath,\n                        message: \"property \" + prop + \" not found, required by \" + childContext.propertyPath\n                    });\n                }\n            });\n        } else {\n            var res = this.validateSchema(instance, dep, options, childContext);\n            if (result.instance !== res.instance) result.instance = res.instance;\n            if (res && res.errors.length) {\n                result.addError({\n                    name: \"dependencies\",\n                    argument: childContext.propertyPath,\n                    message: \"does not meet dependency required by \" + childContext.propertyPath\n                });\n                result.importErrors(res);\n            }\n        }\n    }\n    return result;\n};\n/**\n * Validates whether the instance value is one of the enumerated values.\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */ validators[\"enum\"] = function validateEnum(instance, schema, options, ctx) {\n    if (instance === undefined) {\n        return null;\n    }\n    if (!Array.isArray(schema[\"enum\"])) {\n        throw new SchemaError(\"enum expects an array\", schema);\n    }\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    if (!schema[\"enum\"].some(helpers.deepCompareStrict.bind(null, instance))) {\n        result.addError({\n            name: \"enum\",\n            argument: schema[\"enum\"],\n            message: \"is not one of enum values: \" + schema[\"enum\"].map(String).join(\",\")\n        });\n    }\n    return result;\n};\n/**\n * Validates whether the instance exactly matches a given value\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */ validators[\"const\"] = function validateEnum(instance, schema, options, ctx) {\n    if (instance === undefined) {\n        return null;\n    }\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    if (!helpers.deepCompareStrict(schema[\"const\"], instance)) {\n        result.addError({\n            name: \"const\",\n            argument: schema[\"const\"],\n            message: \"does not exactly match expected constant: \" + schema[\"const\"]\n        });\n    }\n    return result;\n};\n/**\n * Validates whether the instance if of a prohibited type.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */ validators.not = validators.disallow = function validateNot(instance, schema, options, ctx) {\n    var self = this;\n    if (instance === undefined) return null;\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    var notTypes = schema.not || schema.disallow;\n    if (!notTypes) return null;\n    if (!Array.isArray(notTypes)) notTypes = [\n        notTypes\n    ];\n    notTypes.forEach(function(type) {\n        if (self.testType(instance, schema, options, ctx, type)) {\n            var id = type && (type.$id || type.id);\n            var schemaId = id || type;\n            result.addError({\n                name: \"not\",\n                argument: schemaId,\n                message: \"is of prohibited type \" + schemaId\n            });\n        }\n    });\n    return result;\n};\nmodule.exports = attribute;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbnNjaGVtYS9saWIvYXR0cmlidXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsVUFBVUMsbUJBQU9BLENBQUM7QUFFdEIsMEJBQTBCLEdBQzFCLElBQUlDLGtCQUFrQkYsUUFBUUUsZUFBZTtBQUM3QyxzQkFBc0IsR0FDdEIsSUFBSUMsY0FBY0gsUUFBUUcsV0FBVztBQUVyQyxJQUFJQyxZQUFZLENBQUM7QUFFakJBLFVBQVVDLGdCQUFnQixHQUFHO0lBQzNCLHlCQUF5QjtJQUN6QixNQUFNO0lBQ04sV0FBVztJQUNYLGVBQWU7SUFDZixTQUFTO0lBQ1QsZ0NBQWdDO0lBQ2hDLG1CQUFtQjtJQUNuQixRQUFRO0lBQ1IsUUFBUTtJQUNSLDZCQUE2QjtJQUM3QixXQUFXO0lBQ1gsUUFBUTtJQUNSLFdBQVc7QUFDYjtBQUVBOztDQUVDLEdBQ0QsSUFBSUMsYUFBYUYsVUFBVUUsVUFBVSxHQUFHLENBQUM7QUFFekM7Ozs7Ozs7Q0FPQyxHQUNEQSxXQUFXQyxJQUFJLEdBQUcsU0FBU0MsYUFBY0MsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsR0FBRztJQUNyRSw2QkFBNkI7SUFDN0IsSUFBSUgsYUFBYUksV0FBVztRQUMxQixPQUFPO0lBQ1Q7SUFDQSxJQUFJQyxTQUFTLElBQUlaLGdCQUFnQk8sVUFBVUMsUUFBUUMsU0FBU0M7SUFDNUQsSUFBSUcsUUFBUUMsTUFBTUMsT0FBTyxDQUFDUCxPQUFPSCxJQUFJLElBQUlHLE9BQU9ILElBQUksR0FBRztRQUFDRyxPQUFPSCxJQUFJO0tBQUM7SUFDcEUsSUFBSSxDQUFDUSxNQUFNRyxJQUFJLENBQUMsSUFBSSxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQyxJQUFJLEVBQUVYLFVBQVVDLFFBQVFDLFNBQVNDLE9BQU87UUFDekUsSUFBSVMsT0FBT04sTUFBTU8sR0FBRyxDQUFDLFNBQVVDLENBQUM7WUFDOUIsSUFBRyxDQUFDQSxHQUFHO1lBQ1AsSUFBSUMsS0FBS0QsRUFBRUUsR0FBRyxJQUFJRixFQUFFQyxFQUFFO1lBQ3RCLE9BQU9BLEtBQU0sTUFBTUEsS0FBSyxNQUFRRCxJQUFFO1FBQ3BDO1FBQ0FULE9BQU9ZLFFBQVEsQ0FBQztZQUNkQyxNQUFNO1lBQ05DLFVBQVVQO1lBQ1ZRLFNBQVMseUJBQXlCUjtRQUNwQztJQUNGO0lBQ0EsT0FBT1A7QUFDVDtBQUVBLFNBQVNnQixrQkFBa0JyQixRQUFRLEVBQUVFLE9BQU8sRUFBRUMsR0FBRyxFQUFFbUIsUUFBUSxFQUFFckIsTUFBTTtJQUNqRSxJQUFJc0IsYUFBYXJCLFFBQVFxQixVQUFVO0lBQ25DLElBQUlDLFdBQVd0QixRQUFRc0IsUUFBUTtJQUMvQnRCLFFBQVFxQixVQUFVLEdBQUc7SUFDckJyQixRQUFRc0IsUUFBUSxHQUFHO0lBQ25CLElBQUlDLE1BQU0sSUFBSSxDQUFDQyxjQUFjLENBQUMxQixVQUFVQyxRQUFRQyxTQUFTQztJQUN6REQsUUFBUXFCLFVBQVUsR0FBR0E7SUFDckJyQixRQUFRc0IsUUFBUSxHQUFHQTtJQUVuQixJQUFJLENBQUNDLElBQUlFLEtBQUssSUFBSUwsb0JBQW9CTSxVQUFVO1FBQzlDTixTQUFTRztJQUNYO0lBQ0EsT0FBT0EsSUFBSUUsS0FBSztBQUNsQjtBQUVBOzs7Ozs7O0NBT0MsR0FDRDlCLFdBQVdnQyxLQUFLLEdBQUcsU0FBU0MsY0FBZTlCLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLEdBQUc7SUFDdkUsNkJBQTZCO0lBQzdCLElBQUlILGFBQWFJLFdBQVc7UUFDMUIsT0FBTztJQUNUO0lBQ0EsSUFBSUMsU0FBUyxJQUFJWixnQkFBZ0JPLFVBQVVDLFFBQVFDLFNBQVNDO0lBQzVELElBQUk0QixRQUFRLElBQUl0QyxnQkFBZ0JPLFVBQVVDLFFBQVFDLFNBQVNDO0lBQzNELElBQUksQ0FBQ0ksTUFBTUMsT0FBTyxDQUFDUCxPQUFPNEIsS0FBSyxHQUFFO1FBQy9CLE1BQU0sSUFBSW5DLFlBQVk7SUFDeEI7SUFDQSxJQUFJLENBQUNPLE9BQU80QixLQUFLLENBQUNwQixJQUFJLENBQ3BCWSxrQkFBa0JWLElBQUksQ0FDcEIsSUFBSSxFQUFFWCxVQUFVRSxTQUFTQyxLQUFLLFNBQVNzQixHQUFHO1FBQUVNLE1BQU1DLFlBQVksQ0FBQ1A7SUFBSyxLQUNsRTtRQUNKLElBQUliLE9BQU9YLE9BQU80QixLQUFLLENBQUNoQixHQUFHLENBQUMsU0FBVUMsQ0FBQyxFQUFFbUIsQ0FBQztZQUN4QyxJQUFJbEIsS0FBS0QsRUFBRUUsR0FBRyxJQUFJRixFQUFFQyxFQUFFO1lBQ3RCLElBQUdBLElBQUksT0FBTyxNQUFNQSxLQUFLO1lBQ3pCLE9BQU0sRUFBR21CLEtBQUssSUFBSUMsS0FBS0MsU0FBUyxDQUFDdEIsRUFBRW9CLEtBQUssS0FBT3BCLENBQUMsQ0FBQyxPQUFPLElBQUssTUFBTUEsQ0FBQyxDQUFDLE9BQU8sR0FBRyxPQUFTLGdCQUFjbUIsSUFBRTtRQUMxRztRQUNBLElBQUkvQixRQUFRbUMsWUFBWSxFQUFFO1lBQ3hCaEMsT0FBTzJCLFlBQVksQ0FBQ0Q7UUFDdEI7UUFDQTFCLE9BQU9ZLFFBQVEsQ0FBQztZQUNkQyxNQUFNO1lBQ05DLFVBQVVQO1lBQ1ZRLFNBQVMsbUJBQW1CUixLQUFLMEIsSUFBSSxDQUFDO1FBQ3hDO0lBQ0Y7SUFDQSxPQUFPakM7QUFDVDtBQUVBOzs7Ozs7O0NBT0MsR0FDRFIsV0FBVzBDLEtBQUssR0FBRyxTQUFTQyxjQUFleEMsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsR0FBRztJQUN2RSw2QkFBNkI7SUFDN0IsSUFBSUgsYUFBYUksV0FBVztRQUMxQixPQUFPO0lBQ1Q7SUFDQSxJQUFJLENBQUNHLE1BQU1DLE9BQU8sQ0FBQ1AsT0FBT3NDLEtBQUssR0FBRTtRQUMvQixNQUFNLElBQUk3QyxZQUFZO0lBQ3hCO0lBQ0EsSUFBSVcsU0FBUyxJQUFJWixnQkFBZ0JPLFVBQVVDLFFBQVFDLFNBQVNDO0lBQzVELElBQUlzQyxPQUFPLElBQUk7SUFDZnhDLE9BQU9zQyxLQUFLLENBQUNHLE9BQU8sQ0FBQyxTQUFTNUIsQ0FBQyxFQUFFbUIsQ0FBQztRQUNoQyxJQUFJTixRQUFRYyxLQUFLZixjQUFjLENBQUMxQixVQUFVYyxHQUFHWixTQUFTQztRQUN0RCxJQUFHLENBQUN3QixNQUFNQSxLQUFLLEVBQUM7WUFDZCxJQUFJWixLQUFLRCxFQUFFRSxHQUFHLElBQUlGLEVBQUVDLEVBQUU7WUFDdEIsSUFBSTRCLE1BQU01QixNQUFPRCxFQUFFb0IsS0FBSyxJQUFJQyxLQUFLQyxTQUFTLENBQUN0QixFQUFFb0IsS0FBSyxLQUFPcEIsQ0FBQyxDQUFDLE9BQU8sSUFBSyxNQUFNQSxDQUFDLENBQUMsT0FBTyxHQUFHLE9BQVMsZ0JBQWNtQixJQUFFO1lBQ2xINUIsT0FBT1ksUUFBUSxDQUFDO2dCQUNkQyxNQUFNO2dCQUNOQyxVQUFVO29CQUFFSixJQUFJNEI7b0JBQUtDLFFBQVFqQixNQUFNa0IsTUFBTSxDQUFDRCxNQUFNO29CQUFFakIsT0FBT0E7Z0JBQU07Z0JBQy9EUCxTQUFTLGlDQUFpQ3VCLE1BQU0sV0FBV2hCLE1BQU1rQixNQUFNLENBQUNELE1BQU0sR0FBRztZQUNuRjtZQUNBdkMsT0FBTzJCLFlBQVksQ0FBQ0w7UUFDdEI7SUFDRjtJQUNBLE9BQU90QjtBQUNUO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNEUixXQUFXaUQsS0FBSyxHQUFHLFNBQVNDLGNBQWUvQyxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxHQUFHO0lBQ3ZFLDZCQUE2QjtJQUM3QixJQUFJSCxhQUFhSSxXQUFXO1FBQzFCLE9BQU87SUFDVDtJQUNBLElBQUksQ0FBQ0csTUFBTUMsT0FBTyxDQUFDUCxPQUFPNkMsS0FBSyxHQUFFO1FBQy9CLE1BQU0sSUFBSXBELFlBQVk7SUFDeEI7SUFDQSxJQUFJVyxTQUFTLElBQUlaLGdCQUFnQk8sVUFBVUMsUUFBUUMsU0FBU0M7SUFDNUQsSUFBSTRCLFFBQVEsSUFBSXRDLGdCQUFnQk8sVUFBVUMsUUFBUUMsU0FBU0M7SUFDM0QsSUFBSTZDLFFBQVEvQyxPQUFPNkMsS0FBSyxDQUFDRyxNQUFNLENBQzdCNUIsa0JBQWtCVixJQUFJLENBQ3BCLElBQUksRUFBRVgsVUFBVUUsU0FBU0MsS0FBSyxTQUFTc0IsR0FBRztRQUFHTSxNQUFNQyxZQUFZLENBQUNQO0lBQUssSUFDbkVtQixNQUFNO0lBQ1osSUFBSWhDLE9BQU9YLE9BQU82QyxLQUFLLENBQUNqQyxHQUFHLENBQUMsU0FBVUMsQ0FBQyxFQUFFbUIsQ0FBQztRQUN4QyxJQUFJbEIsS0FBS0QsRUFBRUUsR0FBRyxJQUFJRixFQUFFQyxFQUFFO1FBQ3RCLE9BQU9BLE1BQU9ELEVBQUVvQixLQUFLLElBQUlDLEtBQUtDLFNBQVMsQ0FBQ3RCLEVBQUVvQixLQUFLLEtBQU9wQixDQUFDLENBQUMsT0FBTyxJQUFLLE1BQU1BLENBQUMsQ0FBQyxPQUFPLEdBQUcsT0FBUyxnQkFBY21CLElBQUU7SUFDakg7SUFDQSxJQUFJZSxVQUFRLEdBQUc7UUFDYixJQUFJOUMsUUFBUW1DLFlBQVksRUFBRTtZQUN4QmhDLE9BQU8yQixZQUFZLENBQUNEO1FBQ3RCO1FBQ0ExQixPQUFPWSxRQUFRLENBQUM7WUFDZEMsTUFBTTtZQUNOQyxVQUFVUDtZQUNWUSxTQUFTLDZCQUE2QlIsS0FBSzBCLElBQUksQ0FBQztRQUNsRDtJQUNGO0lBQ0EsT0FBT2pDO0FBQ1Q7QUFFQTs7Ozs7OztDQU9DLEdBQ0RSLFdBQVdxRCxFQUFFLEdBQUcsU0FBU0MsV0FBWW5ELFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLEdBQUc7SUFDakUsNkJBQTZCO0lBQzdCLElBQUlILGFBQWFJLFdBQVcsT0FBTztJQUNuQyxJQUFJLENBQUNiLFFBQVE2RCxRQUFRLENBQUNuRCxPQUFPaUQsRUFBRSxHQUFHLE1BQU0sSUFBSUcsTUFBTTtJQUNsRCxJQUFJQyxVQUFVakMsa0JBQWtCa0MsSUFBSSxDQUFDLElBQUksRUFBRXZELFVBQVVFLFNBQVNDLEtBQUssTUFBTUYsT0FBT2lELEVBQUU7SUFDbEYsSUFBSTdDLFNBQVMsSUFBSVosZ0JBQWdCTyxVQUFVQyxRQUFRQyxTQUFTQztJQUM1RCxJQUFJc0I7SUFDSixJQUFHNkIsU0FBUTtRQUNULElBQUlyRCxPQUFPdUQsSUFBSSxLQUFLcEQsV0FBVztRQUMvQixJQUFJLENBQUNiLFFBQVE2RCxRQUFRLENBQUNuRCxPQUFPdUQsSUFBSSxHQUFHLE1BQU0sSUFBSUgsTUFBTTtRQUNwRDVCLE1BQU0sSUFBSSxDQUFDQyxjQUFjLENBQUMxQixVQUFVQyxPQUFPdUQsSUFBSSxFQUFFdEQsU0FBU0MsSUFBSXNELFNBQVMsQ0FBQ3hELE9BQU91RCxJQUFJO1FBQ25GbkQsT0FBTzJCLFlBQVksQ0FBQ1A7SUFDdEIsT0FBSztRQUNILElBQUl4QixPQUFPeUQsSUFBSSxLQUFLdEQsV0FBVztRQUMvQixJQUFJLENBQUNiLFFBQVE2RCxRQUFRLENBQUNuRCxPQUFPeUQsSUFBSSxHQUFHLE1BQU0sSUFBSUwsTUFBTTtRQUNwRDVCLE1BQU0sSUFBSSxDQUFDQyxjQUFjLENBQUMxQixVQUFVQyxPQUFPeUQsSUFBSSxFQUFFeEQsU0FBU0MsSUFBSXNELFNBQVMsQ0FBQ3hELE9BQU95RCxJQUFJO1FBQ25GckQsT0FBTzJCLFlBQVksQ0FBQ1A7SUFDdEI7SUFDQSxPQUFPcEI7QUFDVDtBQUVBLFNBQVNzRCxzQkFBc0JDLE1BQU0sRUFBRUMsR0FBRztJQUN4QywwREFBMEQ7SUFDMUQsb0ZBQW9GO0lBQ3BGLElBQUdDLE9BQU9DLGNBQWMsQ0FBQ1IsSUFBSSxDQUFDSyxRQUFRQyxNQUFNLE9BQU9ELE1BQU0sQ0FBQ0MsSUFBSTtJQUM5RCxnRUFBZ0U7SUFDaEUsSUFBRyxDQUFFQSxDQUFBQSxPQUFPRCxNQUFLLEdBQUk7SUFDckIsTUFBUUEsU0FBU0UsT0FBT0UsY0FBYyxDQUFDSixRQUFVO1FBQy9DLElBQUdFLE9BQU9HLG9CQUFvQixDQUFDVixJQUFJLENBQUNLLFFBQVFDLE1BQU0sT0FBT0QsTUFBTSxDQUFDQyxJQUFJO0lBQ3RFO0FBQ0Y7QUFFQTs7Ozs7OztDQU9DLEdBQ0RoRSxXQUFXcUUsYUFBYSxHQUFHLFNBQVNDLHNCQUF1Qm5FLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLEdBQUc7SUFDdkYsSUFBRyxDQUFDLElBQUksQ0FBQ0csS0FBSyxDQUFDc0QsTUFBTSxDQUFDNUQsV0FBVztJQUNqQyxJQUFJSyxTQUFTLElBQUlaLGdCQUFnQk8sVUFBVUMsUUFBUUMsU0FBU0M7SUFDNUQsSUFBSWlFLFlBQVluRSxPQUFPaUUsYUFBYSxLQUFHOUQsWUFBWUgsT0FBT2lFLGFBQWEsR0FBRyxDQUFDO0lBQzNFLElBQUcsQ0FBQzNFLFFBQVE2RCxRQUFRLENBQUNnQixZQUFZLE1BQU0sSUFBSTFFLFlBQVk7SUFFdkQsSUFBSyxJQUFJMkUsWUFBWXJFLFNBQVU7UUFDN0IsSUFBRzJELHNCQUFzQjNELFVBQVVxRSxjQUFjakUsV0FBVTtZQUN6RCxJQUFJcUIsTUFBTSxJQUFJLENBQUNDLGNBQWMsQ0FBQzJDLFVBQVVELFdBQVdsRSxTQUFTQyxJQUFJc0QsU0FBUyxDQUFDVztZQUMxRS9ELE9BQU8yQixZQUFZLENBQUNQO1FBQ3RCO0lBQ0Y7SUFFQSxPQUFPcEI7QUFDVDtBQUVBOzs7Ozs7O0NBT0MsR0FDRFIsV0FBV3lFLFVBQVUsR0FBRyxTQUFTQyxtQkFBb0J2RSxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxHQUFHO0lBQ2pGLElBQUcsQ0FBQyxJQUFJLENBQUNHLEtBQUssQ0FBQ3NELE1BQU0sQ0FBQzVELFdBQVc7SUFDakMsSUFBSUssU0FBUyxJQUFJWixnQkFBZ0JPLFVBQVVDLFFBQVFDLFNBQVNDO0lBQzVELElBQUltRSxhQUFhckUsT0FBT3FFLFVBQVUsSUFBSSxDQUFDO0lBQ3ZDLElBQUssSUFBSUQsWUFBWUMsV0FBWTtRQUMvQixJQUFJRixZQUFZRSxVQUFVLENBQUNELFNBQVM7UUFDcEMsSUFBR0QsY0FBWWhFLFdBQVU7WUFDdkI7UUFDRixPQUFNLElBQUdnRSxjQUFZLE1BQUs7WUFDeEIsTUFBTSxJQUFJMUUsWUFBWTtRQUN4QjtRQUNBLElBQUksT0FBT1EsUUFBUXNFLG1CQUFtQixJQUFJLFlBQVk7WUFDcER0RSxRQUFRc0UsbUJBQW1CLENBQUN4RSxVQUFVcUUsVUFBVUQsV0FBV2xFLFNBQVNDO1FBQ3RFO1FBQ0EsSUFBSXNFLE9BQU9kLHNCQUFzQjNELFVBQVVxRTtRQUMzQyxJQUFJNUMsTUFBTSxJQUFJLENBQUNDLGNBQWMsQ0FBQytDLE1BQU1MLFdBQVdsRSxTQUFTQyxJQUFJc0QsU0FBUyxDQUFDVyxXQUFXQztRQUNqRixJQUFHNUMsSUFBSXpCLFFBQVEsS0FBS0ssT0FBT0wsUUFBUSxDQUFDcUUsU0FBUyxFQUFFaEUsT0FBT0wsUUFBUSxDQUFDcUUsU0FBUyxHQUFHNUMsSUFBSXpCLFFBQVE7UUFDdkZLLE9BQU8yQixZQUFZLENBQUNQO0lBQ3RCO0lBQ0EsT0FBT3BCO0FBQ1Q7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTcUUsdUJBQXdCMUUsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsR0FBRyxFQUFFa0UsUUFBUSxFQUFFaEUsTUFBTTtJQUMvRSxJQUFHLENBQUMsSUFBSSxDQUFDQyxLQUFLLENBQUNzRCxNQUFNLENBQUM1RCxXQUFXO0lBQ2pDLElBQUlDLE9BQU9xRSxVQUFVLElBQUlyRSxPQUFPcUUsVUFBVSxDQUFDRCxTQUFTLEtBQUtqRSxXQUFXO1FBQ2xFO0lBQ0Y7SUFDQSxJQUFJSCxPQUFPMEUsb0JBQW9CLEtBQUssT0FBTztRQUN6Q3RFLE9BQU9ZLFFBQVEsQ0FBQztZQUNkQyxNQUFNO1lBQ05DLFVBQVVrRDtZQUNWakQsU0FBUyxvREFBb0RlLEtBQUtDLFNBQVMsQ0FBQ2lDO1FBQzlFO0lBQ0YsT0FBTztRQUNMLElBQUlNLHVCQUF1QjFFLE9BQU8wRSxvQkFBb0IsSUFBSSxDQUFDO1FBRTNELElBQUksT0FBT3pFLFFBQVFzRSxtQkFBbUIsSUFBSSxZQUFZO1lBQ3BEdEUsUUFBUXNFLG1CQUFtQixDQUFDeEUsVUFBVXFFLFVBQVVNLHNCQUFzQnpFLFNBQVNDO1FBQ2pGO1FBRUEsSUFBSXNCLE1BQU0sSUFBSSxDQUFDQyxjQUFjLENBQUMxQixRQUFRLENBQUNxRSxTQUFTLEVBQUVNLHNCQUFzQnpFLFNBQVNDLElBQUlzRCxTQUFTLENBQUNrQixzQkFBc0JOO1FBQ3JILElBQUc1QyxJQUFJekIsUUFBUSxLQUFLSyxPQUFPTCxRQUFRLENBQUNxRSxTQUFTLEVBQUVoRSxPQUFPTCxRQUFRLENBQUNxRSxTQUFTLEdBQUc1QyxJQUFJekIsUUFBUTtRQUN2RkssT0FBTzJCLFlBQVksQ0FBQ1A7SUFDdEI7QUFDRjtBQUVBOzs7Ozs7O0NBT0MsR0FDRDVCLFdBQVcrRSxpQkFBaUIsR0FBRyxTQUFTQywwQkFBMkI3RSxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxHQUFHO0lBQy9GLElBQUcsQ0FBQyxJQUFJLENBQUNHLEtBQUssQ0FBQ3NELE1BQU0sQ0FBQzVELFdBQVc7SUFDakMsSUFBSUssU0FBUyxJQUFJWixnQkFBZ0JPLFVBQVVDLFFBQVFDLFNBQVNDO0lBQzVELElBQUl5RSxvQkFBb0IzRSxPQUFPMkUsaUJBQWlCLElBQUksQ0FBQztJQUVyRCxJQUFLLElBQUlQLFlBQVlyRSxTQUFVO1FBQzdCLElBQUk4RSxPQUFPO1FBQ1gsSUFBSyxJQUFJQyxXQUFXSCxrQkFBbUI7WUFDckMsSUFBSVIsWUFBWVEsaUJBQWlCLENBQUNHLFFBQVE7WUFDMUMsSUFBR1gsY0FBWWhFLFdBQVU7Z0JBQ3ZCO1lBQ0YsT0FBTSxJQUFHZ0UsY0FBWSxNQUFLO2dCQUN4QixNQUFNLElBQUkxRSxZQUFZO1lBQ3hCO1lBQ0EsSUFBSTtnQkFDRixJQUFJc0YsU0FBUyxJQUFJQyxPQUFPRixTQUFTO1lBQ25DLEVBQUUsT0FBTUcsSUFBSTtnQkFDViwwRkFBMEY7Z0JBQzFGLGFBQWE7Z0JBQ2JGLFNBQVMsSUFBSUMsT0FBT0Y7WUFDdEI7WUFDQSxJQUFJLENBQUNDLE9BQU9GLElBQUksQ0FBQ1QsV0FBVztnQkFDMUI7WUFDRjtZQUNBUyxPQUFPO1lBRVAsSUFBSSxPQUFPNUUsUUFBUXNFLG1CQUFtQixJQUFJLFlBQVk7Z0JBQ3BEdEUsUUFBUXNFLG1CQUFtQixDQUFDeEUsVUFBVXFFLFVBQVVELFdBQVdsRSxTQUFTQztZQUN0RTtZQUVBLElBQUlzQixNQUFNLElBQUksQ0FBQ0MsY0FBYyxDQUFDMUIsUUFBUSxDQUFDcUUsU0FBUyxFQUFFRCxXQUFXbEUsU0FBU0MsSUFBSXNELFNBQVMsQ0FBQ1csV0FBV0M7WUFDL0YsSUFBRzVDLElBQUl6QixRQUFRLEtBQUtLLE9BQU9MLFFBQVEsQ0FBQ3FFLFNBQVMsRUFBRWhFLE9BQU9MLFFBQVEsQ0FBQ3FFLFNBQVMsR0FBRzVDLElBQUl6QixRQUFRO1lBQ3ZGSyxPQUFPMkIsWUFBWSxDQUFDUDtRQUN0QjtRQUNBLElBQUlxRCxNQUFNO1lBQ1JKLHVCQUF1Qm5CLElBQUksQ0FBQyxJQUFJLEVBQUV2RCxVQUFVQyxRQUFRQyxTQUFTQyxLQUFLa0UsVUFBVWhFO1FBQzlFO0lBQ0Y7SUFFQSxPQUFPQTtBQUNUO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNEUixXQUFXOEUsb0JBQW9CLEdBQUcsU0FBU1EsNkJBQThCbkYsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsR0FBRztJQUNyRyxJQUFHLENBQUMsSUFBSSxDQUFDRyxLQUFLLENBQUNzRCxNQUFNLENBQUM1RCxXQUFXO0lBQ2pDLGtGQUFrRjtJQUNsRixJQUFJQyxPQUFPMkUsaUJBQWlCLEVBQUU7UUFDNUIsT0FBTztJQUNUO0lBQ0EsSUFBSXZFLFNBQVMsSUFBSVosZ0JBQWdCTyxVQUFVQyxRQUFRQyxTQUFTQztJQUM1RCxJQUFLLElBQUlrRSxZQUFZckUsU0FBVTtRQUM3QjBFLHVCQUF1Qm5CLElBQUksQ0FBQyxJQUFJLEVBQUV2RCxVQUFVQyxRQUFRQyxTQUFTQyxLQUFLa0UsVUFBVWhFO0lBQzlFO0lBQ0EsT0FBT0E7QUFDVDtBQUVBOzs7OztDQUtDLEdBQ0RSLFdBQVd1RixhQUFhLEdBQUcsU0FBU0Msc0JBQXVCckYsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsR0FBRztJQUN2RixJQUFJLENBQUMsSUFBSSxDQUFDRyxLQUFLLENBQUNzRCxNQUFNLENBQUM1RCxXQUFXO0lBQ2xDLElBQUlLLFNBQVMsSUFBSVosZ0JBQWdCTyxVQUFVQyxRQUFRQyxTQUFTQztJQUM1RCxJQUFJbUYsT0FBT3hCLE9BQU93QixJQUFJLENBQUN0RjtJQUN2QixJQUFJLENBQUVzRixDQUFBQSxLQUFLMUMsTUFBTSxJQUFJM0MsT0FBT21GLGFBQWEsR0FBRztRQUMxQy9FLE9BQU9ZLFFBQVEsQ0FBQztZQUNkQyxNQUFNO1lBQ05DLFVBQVVsQixPQUFPbUYsYUFBYTtZQUM5QmhFLFNBQVMsOENBQThDbkIsT0FBT21GLGFBQWE7UUFDN0U7SUFDRjtJQUNBLE9BQU8vRTtBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDRFIsV0FBVzBGLGFBQWEsR0FBRyxTQUFTQyxzQkFBdUJ4RixRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxHQUFHO0lBQ3ZGLElBQUksQ0FBQyxJQUFJLENBQUNHLEtBQUssQ0FBQ3NELE1BQU0sQ0FBQzVELFdBQVc7SUFDbEMsSUFBSUssU0FBUyxJQUFJWixnQkFBZ0JPLFVBQVVDLFFBQVFDLFNBQVNDO0lBQzVELElBQUltRixPQUFPeEIsT0FBT3dCLElBQUksQ0FBQ3RGO0lBQ3ZCLElBQUksQ0FBRXNGLENBQUFBLEtBQUsxQyxNQUFNLElBQUkzQyxPQUFPc0YsYUFBYSxHQUFHO1FBQzFDbEYsT0FBT1ksUUFBUSxDQUFDO1lBQ2RDLE1BQU07WUFDTkMsVUFBVWxCLE9BQU9zRixhQUFhO1lBQzlCbkUsU0FBUyw4Q0FBOENuQixPQUFPc0YsYUFBYTtRQUM3RTtJQUNGO0lBQ0EsT0FBT2xGO0FBQ1Q7QUFFQTs7Ozs7OztDQU9DLEdBQ0RSLFdBQVc0RixLQUFLLEdBQUcsU0FBU0MsY0FBZTFGLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLEdBQUc7SUFDdkUsSUFBSXNDLE9BQU8sSUFBSTtJQUNmLElBQUksQ0FBQyxJQUFJLENBQUNuQyxLQUFLLENBQUNxRixLQUFLLENBQUMzRixXQUFXO0lBQ2pDLElBQUlDLE9BQU93RixLQUFLLEtBQUdyRixXQUFXO0lBQzlCLElBQUlDLFNBQVMsSUFBSVosZ0JBQWdCTyxVQUFVQyxRQUFRQyxTQUFTQztJQUM1REgsU0FBUzRGLEtBQUssQ0FBQyxTQUFVQyxLQUFLLEVBQUU1RCxDQUFDO1FBQy9CLElBQUcxQixNQUFNQyxPQUFPLENBQUNQLE9BQU93RixLQUFLLEdBQUU7WUFDN0IsSUFBSUEsUUFBU3hGLE9BQU93RixLQUFLLENBQUN4RCxFQUFFLEtBQUc3QixZQUFZSCxPQUFPNkYsZUFBZSxHQUFHN0YsT0FBT3dGLEtBQUssQ0FBQ3hELEVBQUU7UUFDckYsT0FBSztZQUNILElBQUl3RCxRQUFReEYsT0FBT3dGLEtBQUs7UUFDMUI7UUFDQSxJQUFJQSxVQUFVckYsV0FBVztZQUN2QixPQUFPO1FBQ1Q7UUFDQSxJQUFJcUYsVUFBVSxPQUFPO1lBQ25CcEYsT0FBT1ksUUFBUSxDQUFDO2dCQUNkQyxNQUFNO2dCQUNORSxTQUFTO1lBQ1g7WUFDQSxPQUFPO1FBQ1Q7UUFDQSxJQUFJSyxNQUFNZ0IsS0FBS2YsY0FBYyxDQUFDbUUsT0FBT0osT0FBT3ZGLFNBQVNDLElBQUlzRCxTQUFTLENBQUNnQyxPQUFPeEQ7UUFDMUUsSUFBR1IsSUFBSXpCLFFBQVEsS0FBS0ssT0FBT0wsUUFBUSxDQUFDaUMsRUFBRSxFQUFFNUIsT0FBT0wsUUFBUSxDQUFDaUMsRUFBRSxHQUFHUixJQUFJekIsUUFBUTtRQUN6RUssT0FBTzJCLFlBQVksQ0FBQ1A7UUFDcEIsT0FBTztJQUNUO0lBQ0EsT0FBT3BCO0FBQ1Q7QUFFQTs7Ozs7OztDQU9DLEdBQ0RSLFdBQVdrRyxRQUFRLEdBQUcsU0FBU0MsaUJBQWtCaEcsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsR0FBRztJQUM3RSxJQUFJc0MsT0FBTyxJQUFJO0lBQ2YsSUFBSSxDQUFDLElBQUksQ0FBQ25DLEtBQUssQ0FBQ3FGLEtBQUssQ0FBQzNGLFdBQVc7SUFDakMsSUFBSUMsT0FBTzhGLFFBQVEsS0FBRzNGLFdBQVc7SUFDakMsSUFBSSxDQUFDYixRQUFRNkQsUUFBUSxDQUFDbkQsT0FBTzhGLFFBQVEsR0FBRyxNQUFNLElBQUkxQyxNQUFNO0lBQ3hELElBQUloRCxTQUFTLElBQUlaLGdCQUFnQk8sVUFBVUMsUUFBUUMsU0FBU0M7SUFDNUQsSUFBSTZDLFFBQVFoRCxTQUFTUyxJQUFJLENBQUMsU0FBVW9GLEtBQUssRUFBRTVELENBQUM7UUFDMUMsSUFBSVIsTUFBTWdCLEtBQUtmLGNBQWMsQ0FBQ21FLE9BQU81RixPQUFPOEYsUUFBUSxFQUFFN0YsU0FBU0MsSUFBSXNELFNBQVMsQ0FBQ3hELE9BQU84RixRQUFRLEVBQUU5RDtRQUM5RixPQUFPUixJQUFJb0IsTUFBTSxDQUFDRCxNQUFNLEtBQUc7SUFDN0I7SUFDQSxJQUFHSSxVQUFRLE9BQU07UUFDZjNDLE9BQU9ZLFFBQVEsQ0FBQztZQUNkQyxNQUFNO1lBQ05DLFVBQVVsQixPQUFPOEYsUUFBUTtZQUN6QjNFLFNBQVM7UUFDWDtJQUNGO0lBQ0EsT0FBT2Y7QUFDVDtBQUVBOzs7OztDQUtDLEdBQ0RSLFdBQVdvRyxPQUFPLEdBQUcsU0FBU0MsZ0JBQWlCbEcsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsR0FBRztJQUMzRSxJQUFJLENBQUMsSUFBSSxDQUFDRyxLQUFLLENBQUM2RixNQUFNLENBQUNuRyxXQUFXO0lBQ2xDLElBQUlLLFNBQVMsSUFBSVosZ0JBQWdCTyxVQUFVQyxRQUFRQyxTQUFTQztJQUM1RCxJQUFJRixPQUFPbUcsZ0JBQWdCLElBQUluRyxPQUFPbUcsZ0JBQWdCLEtBQUssTUFBTTtRQUMvRCxJQUFHLENBQUVwRyxDQUFBQSxXQUFXQyxPQUFPZ0csT0FBTyxHQUFFO1lBQzlCNUYsT0FBT1ksUUFBUSxDQUFDO2dCQUNkQyxNQUFNO2dCQUNOQyxVQUFVbEIsT0FBT2dHLE9BQU87Z0JBQ3hCN0UsU0FBUywwQkFBMEJuQixPQUFPZ0csT0FBTztZQUNuRDtRQUNGO0lBQ0YsT0FBTztRQUNMLElBQUcsQ0FBRWpHLENBQUFBLFlBQVlDLE9BQU9nRyxPQUFPLEdBQUU7WUFDL0I1RixPQUFPWSxRQUFRLENBQUM7Z0JBQ2RDLE1BQU07Z0JBQ05DLFVBQVVsQixPQUFPZ0csT0FBTztnQkFDeEI3RSxTQUFTLHNDQUFzQ25CLE9BQU9nRyxPQUFPO1lBQy9EO1FBQ0Y7SUFDRjtJQUNBLE9BQU81RjtBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDRFIsV0FBV3dHLE9BQU8sR0FBRyxTQUFTQyxnQkFBaUJ0RyxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxHQUFHO0lBQzNFLElBQUksQ0FBQyxJQUFJLENBQUNHLEtBQUssQ0FBQzZGLE1BQU0sQ0FBQ25HLFdBQVc7SUFDbEMsSUFBSUssU0FBUyxJQUFJWixnQkFBZ0JPLFVBQVVDLFFBQVFDLFNBQVNDO0lBQzVELElBQUlGLE9BQU9zRyxnQkFBZ0IsSUFBSXRHLE9BQU9zRyxnQkFBZ0IsS0FBSyxNQUFNO1FBQy9ELElBQUcsQ0FBRXZHLENBQUFBLFdBQVdDLE9BQU9vRyxPQUFPLEdBQUU7WUFDOUJoRyxPQUFPWSxRQUFRLENBQUM7Z0JBQ2RDLE1BQU07Z0JBQ05DLFVBQVVsQixPQUFPb0csT0FBTztnQkFDeEJqRixTQUFTLHVCQUF1Qm5CLE9BQU9vRyxPQUFPO1lBQ2hEO1FBQ0Y7SUFDRixPQUFPO1FBQ0wsSUFBRyxDQUFFckcsQ0FBQUEsWUFBWUMsT0FBT29HLE9BQU8sR0FBRTtZQUMvQmhHLE9BQU9ZLFFBQVEsQ0FBQztnQkFDZEMsTUFBTTtnQkFDTkMsVUFBVWxCLE9BQU9vRyxPQUFPO2dCQUN4QmpGLFNBQVMsbUNBQW1DbkIsT0FBT29HLE9BQU87WUFDNUQ7UUFDRjtJQUNGO0lBQ0EsT0FBT2hHO0FBQ1Q7QUFFQTs7Ozs7Q0FLQyxHQUNEUixXQUFXdUcsZ0JBQWdCLEdBQUcsU0FBU0kseUJBQTBCeEcsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsR0FBRztJQUM3RiwyRkFBMkY7SUFDM0YsSUFBRyxPQUFPRixPQUFPbUcsZ0JBQWdCLEtBQUssV0FBVztJQUNqRCxJQUFJLENBQUMsSUFBSSxDQUFDOUYsS0FBSyxDQUFDNkYsTUFBTSxDQUFDbkcsV0FBVztJQUNsQyxJQUFJSyxTQUFTLElBQUlaLGdCQUFnQk8sVUFBVUMsUUFBUUMsU0FBU0M7SUFDNUQsSUFBSXdCLFFBQVEzQixXQUFXQyxPQUFPbUcsZ0JBQWdCO0lBQzlDLElBQUksQ0FBQ3pFLE9BQU87UUFDVnRCLE9BQU9ZLFFBQVEsQ0FBQztZQUNkQyxNQUFNO1lBQ05DLFVBQVVsQixPQUFPbUcsZ0JBQWdCO1lBQ2pDaEYsU0FBUyxtQ0FBbUNuQixPQUFPbUcsZ0JBQWdCO1FBQ3JFO0lBQ0Y7SUFDQSxPQUFPL0Y7QUFDVDtBQUVBOzs7OztDQUtDLEdBQ0RSLFdBQVcwRyxnQkFBZ0IsR0FBRyxTQUFTRSx5QkFBMEJ6RyxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxHQUFHO0lBQzdGLDJGQUEyRjtJQUMzRixJQUFHLE9BQU9GLE9BQU9zRyxnQkFBZ0IsS0FBSyxXQUFXO0lBQ2pELElBQUksQ0FBQyxJQUFJLENBQUNqRyxLQUFLLENBQUM2RixNQUFNLENBQUNuRyxXQUFXO0lBQ2xDLElBQUlLLFNBQVMsSUFBSVosZ0JBQWdCTyxVQUFVQyxRQUFRQyxTQUFTQztJQUM1RCxJQUFJd0IsUUFBUTNCLFdBQVdDLE9BQU9zRyxnQkFBZ0I7SUFDOUMsSUFBSSxDQUFDNUUsT0FBTztRQUNWdEIsT0FBT1ksUUFBUSxDQUFDO1lBQ2RDLE1BQU07WUFDTkMsVUFBVWxCLE9BQU9zRyxnQkFBZ0I7WUFDakNuRixTQUFTLGdDQUFnQ25CLE9BQU9zRyxnQkFBZ0I7UUFDbEU7SUFDRjtJQUNBLE9BQU9sRztBQUNUO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELElBQUlxRyxpQ0FBaUMsU0FBU0EsK0JBQWdDMUcsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsR0FBRyxFQUFFd0csY0FBYyxFQUFFQyxZQUFZO0lBQ3hJLElBQUksQ0FBQyxJQUFJLENBQUN0RyxLQUFLLENBQUM2RixNQUFNLENBQUNuRyxXQUFXO0lBRWxDLElBQUk2RyxxQkFBcUI1RyxNQUFNLENBQUMwRyxlQUFlO0lBQy9DLElBQUlFLHNCQUFzQixHQUFHO1FBQzNCLE1BQU0sSUFBSW5ILFlBQVlpSCxpQkFBaUI7SUFDekM7SUFFQSxJQUFJdEcsU0FBUyxJQUFJWixnQkFBZ0JPLFVBQVVDLFFBQVFDLFNBQVNDO0lBRTVELElBQUkyRyxtQkFBbUJ2SCxRQUFRd0gsZ0JBQWdCLENBQUMvRztJQUNoRCxJQUFJZ0gsa0JBQWtCekgsUUFBUXdILGdCQUFnQixDQUFDRjtJQUUvQyxJQUFJSSxjQUFjQyxLQUFLQyxHQUFHLENBQUNMLGtCQUFtQkU7SUFDOUMsSUFBSUksYUFBYUYsS0FBS0csR0FBRyxDQUFDLElBQUlKO0lBRTlCLElBQUlDLEtBQUtJLEtBQUssQ0FBQ3RILFdBQVdvSCxjQUFjRixLQUFLSSxLQUFLLENBQUNULHFCQUFxQk8sZ0JBQWdCLEdBQUc7UUFDekYvRyxPQUFPWSxRQUFRLENBQUM7WUFDZEMsTUFBTXlGO1lBQ054RixVQUFXMEY7WUFDWHpGLFNBQVN3RixlQUFlekUsS0FBS0MsU0FBUyxDQUFDeUU7UUFDekM7SUFDRjtJQUVBLE9BQU94RztBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDRFIsV0FBVzBILFVBQVUsR0FBRyxTQUFTQyxtQkFBb0J4SCxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxHQUFHO0lBQ2pGLE9BQU91RywrQkFBK0JuRCxJQUFJLENBQUMsSUFBSSxFQUFFdkQsVUFBVUMsUUFBUUMsU0FBU0MsS0FBSyxjQUFjO0FBQ2pHO0FBRUE7Ozs7O0NBS0MsR0FDRE4sV0FBVzRILFdBQVcsR0FBRyxTQUFTQyxvQkFBcUIxSCxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxHQUFHO0lBQ25GLE9BQU91RywrQkFBK0JuRCxJQUFJLENBQUMsSUFBSSxFQUFFdkQsVUFBVUMsUUFBUUMsU0FBU0MsS0FBSyxlQUFlO0FBQ2xHO0FBRUE7Ozs7O0NBS0MsR0FDRE4sV0FBVzhILFFBQVEsR0FBRyxTQUFTQyxpQkFBa0I1SCxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxHQUFHO0lBQzdFLElBQUlFLFNBQVMsSUFBSVosZ0JBQWdCTyxVQUFVQyxRQUFRQyxTQUFTQztJQUM1RCxJQUFJSCxhQUFhSSxhQUFhSCxPQUFPMEgsUUFBUSxLQUFLLE1BQU07UUFDdEQsb0dBQW9HO1FBQ3BHdEgsT0FBT1ksUUFBUSxDQUFDO1lBQ2RDLE1BQU07WUFDTkUsU0FBUztRQUNYO0lBQ0YsT0FBTyxJQUFJLElBQUksQ0FBQ2QsS0FBSyxDQUFDc0QsTUFBTSxDQUFDNUQsYUFBYU8sTUFBTUMsT0FBTyxDQUFDUCxPQUFPMEgsUUFBUSxHQUFHO1FBQ3hFMUgsT0FBTzBILFFBQVEsQ0FBQ2pGLE9BQU8sQ0FBQyxTQUFTbUYsQ0FBQztZQUNoQyxJQUFHbEUsc0JBQXNCM0QsVUFBVTZILE9BQUt6SCxXQUFVO2dCQUNoREMsT0FBT1ksUUFBUSxDQUFDO29CQUNkQyxNQUFNO29CQUNOQyxVQUFVMEc7b0JBQ1Z6RyxTQUFTLHVCQUF1QmUsS0FBS0MsU0FBUyxDQUFDeUY7Z0JBQ2pEO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsT0FBT3hIO0FBQ1Q7QUFFQTs7Ozs7Q0FLQyxHQUNEUixXQUFXa0YsT0FBTyxHQUFHLFNBQVMrQyxnQkFBaUI5SCxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxHQUFHO0lBQzNFLElBQUksQ0FBQyxJQUFJLENBQUNHLEtBQUssQ0FBQ3lILE1BQU0sQ0FBQy9ILFdBQVc7SUFDbEMsSUFBSUssU0FBUyxJQUFJWixnQkFBZ0JPLFVBQVVDLFFBQVFDLFNBQVNDO0lBQzVELElBQUk0RSxVQUFVOUUsT0FBTzhFLE9BQU87SUFDNUIsSUFBSTtRQUNGLElBQUlDLFNBQVMsSUFBSUMsT0FBT0YsU0FBUztJQUNuQyxFQUFFLE9BQU1HLElBQUk7UUFDViwwRkFBMEY7UUFDMUYsYUFBYTtRQUNiRixTQUFTLElBQUlDLE9BQU9GO0lBQ3RCO0lBQ0EsSUFBSSxDQUFDL0UsU0FBU2dJLEtBQUssQ0FBQ2hELFNBQVM7UUFDM0IzRSxPQUFPWSxRQUFRLENBQUM7WUFDZEMsTUFBTTtZQUNOQyxVQUFVbEIsT0FBTzhFLE9BQU87WUFDeEIzRCxTQUFTLDRCQUE0QmUsS0FBS0MsU0FBUyxDQUFDbkMsT0FBTzhFLE9BQU8sQ0FBQ2tELFFBQVE7UUFDN0U7SUFDRjtJQUNBLE9BQU81SDtBQUNUO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBQ0RSLFdBQVdxSSxNQUFNLEdBQUcsU0FBU0MsZUFBZ0JuSSxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxHQUFHO0lBQ3pFLElBQUlILGFBQVdJLFdBQVc7SUFDMUIsSUFBSUMsU0FBUyxJQUFJWixnQkFBZ0JPLFVBQVVDLFFBQVFDLFNBQVNDO0lBQzVELElBQUksQ0FBQ0UsT0FBTytILGFBQWEsSUFBSSxDQUFDN0ksUUFBUThJLFFBQVEsQ0FBQ3JJLFVBQVVDLE9BQU9pSSxNQUFNLEVBQUUsSUFBSSxHQUFHO1FBQzdFN0gsT0FBT1ksUUFBUSxDQUFDO1lBQ2RDLE1BQU07WUFDTkMsVUFBVWxCLE9BQU9pSSxNQUFNO1lBQ3ZCOUcsU0FBUyw2QkFBNkJlLEtBQUtDLFNBQVMsQ0FBQ25DLE9BQU9pSSxNQUFNLElBQUk7UUFDeEU7SUFDRjtJQUNBLE9BQU83SDtBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDRFIsV0FBV3lJLFNBQVMsR0FBRyxTQUFTQyxrQkFBbUJ2SSxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxHQUFHO0lBQy9FLElBQUksQ0FBQyxJQUFJLENBQUNHLEtBQUssQ0FBQ3lILE1BQU0sQ0FBQy9ILFdBQVc7SUFDbEMsSUFBSUssU0FBUyxJQUFJWixnQkFBZ0JPLFVBQVVDLFFBQVFDLFNBQVNDO0lBQzVELElBQUlxSSxNQUFNeEksU0FBU2dJLEtBQUssQ0FBQztJQUN6QixJQUFJcEYsU0FBUzVDLFNBQVM0QyxNQUFNLEdBQUk0RixDQUFBQSxNQUFNQSxJQUFJNUYsTUFBTSxHQUFHO0lBQ25ELElBQUksQ0FBRUEsQ0FBQUEsVUFBVTNDLE9BQU9xSSxTQUFTLEdBQUc7UUFDakNqSSxPQUFPWSxRQUFRLENBQUM7WUFDZEMsTUFBTTtZQUNOQyxVQUFVbEIsT0FBT3FJLFNBQVM7WUFDMUJsSCxTQUFTLHFDQUFxQ25CLE9BQU9xSSxTQUFTO1FBQ2hFO0lBQ0Y7SUFDQSxPQUFPakk7QUFDVDtBQUVBOzs7OztDQUtDLEdBQ0RSLFdBQVc0SSxTQUFTLEdBQUcsU0FBU0Msa0JBQW1CMUksUUFBUSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsR0FBRztJQUMvRSxJQUFJLENBQUMsSUFBSSxDQUFDRyxLQUFLLENBQUN5SCxNQUFNLENBQUMvSCxXQUFXO0lBQ2xDLElBQUlLLFNBQVMsSUFBSVosZ0JBQWdCTyxVQUFVQyxRQUFRQyxTQUFTQztJQUM1RCwyRkFBMkY7SUFDM0YsSUFBSXFJLE1BQU14SSxTQUFTZ0ksS0FBSyxDQUFDO0lBQ3pCLElBQUlwRixTQUFTNUMsU0FBUzRDLE1BQU0sR0FBSTRGLENBQUFBLE1BQU1BLElBQUk1RixNQUFNLEdBQUc7SUFDbkQsSUFBSSxDQUFFQSxDQUFBQSxVQUFVM0MsT0FBT3dJLFNBQVMsR0FBRztRQUNqQ3BJLE9BQU9ZLFFBQVEsQ0FBQztZQUNkQyxNQUFNO1lBQ05DLFVBQVVsQixPQUFPd0ksU0FBUztZQUMxQnJILFNBQVMscUNBQXFDbkIsT0FBT3dJLFNBQVM7UUFDaEU7SUFDRjtJQUNBLE9BQU9wSTtBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDRFIsV0FBVzhJLFFBQVEsR0FBRyxTQUFTQyxpQkFBa0I1SSxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxHQUFHO0lBQzdFLElBQUksQ0FBQyxJQUFJLENBQUNHLEtBQUssQ0FBQ3FGLEtBQUssQ0FBQzNGLFdBQVc7SUFDakMsSUFBSUssU0FBUyxJQUFJWixnQkFBZ0JPLFVBQVVDLFFBQVFDLFNBQVNDO0lBQzVELElBQUksQ0FBRUgsQ0FBQUEsU0FBUzRDLE1BQU0sSUFBSTNDLE9BQU8wSSxRQUFRLEdBQUc7UUFDekN0SSxPQUFPWSxRQUFRLENBQUM7WUFDZEMsTUFBTTtZQUNOQyxVQUFVbEIsT0FBTzBJLFFBQVE7WUFDekJ2SCxTQUFTLHFDQUFxQ25CLE9BQU8wSSxRQUFRO1FBQy9EO0lBQ0Y7SUFDQSxPQUFPdEk7QUFDVDtBQUVBOzs7OztDQUtDLEdBQ0RSLFdBQVdnSixRQUFRLEdBQUcsU0FBU0MsaUJBQWtCOUksUUFBUSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsR0FBRztJQUM3RSxJQUFJLENBQUMsSUFBSSxDQUFDRyxLQUFLLENBQUNxRixLQUFLLENBQUMzRixXQUFXO0lBQ2pDLElBQUlLLFNBQVMsSUFBSVosZ0JBQWdCTyxVQUFVQyxRQUFRQyxTQUFTQztJQUM1RCxJQUFJLENBQUVILENBQUFBLFNBQVM0QyxNQUFNLElBQUkzQyxPQUFPNEksUUFBUSxHQUFHO1FBQ3pDeEksT0FBT1ksUUFBUSxDQUFDO1lBQ2RDLE1BQU07WUFDTkMsVUFBVWxCLE9BQU80SSxRQUFRO1lBQ3pCekgsU0FBUyxxQ0FBcUNuQixPQUFPNEksUUFBUTtRQUMvRDtJQUNGO0lBQ0EsT0FBT3hJO0FBQ1Q7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBUzBJLFdBQVlqSSxDQUFDLEVBQUVtQixDQUFDLEVBQUUrRyxDQUFDO0lBQzFCLElBQUlDLEdBQUdDLE1BQU1GLEVBQUVwRyxNQUFNO0lBQ3JCLElBQUtxRyxJQUFJaEgsSUFBSSxHQUFHaUgsS0FBS0QsSUFBSUMsS0FBS0QsSUFBSztRQUNqQyxJQUFJMUosUUFBUTRKLGlCQUFpQixDQUFDckksR0FBR2tJLENBQUMsQ0FBQ0MsRUFBRSxHQUFHO1lBQ3RDLE9BQU87UUFDVDtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBRUE7Ozs7Q0FJQyxHQUNEcEosV0FBV3VKLFdBQVcsR0FBRyxTQUFTQyxvQkFBcUJySixRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxHQUFHO0lBQ25GLElBQUlGLE9BQU9tSixXQUFXLEtBQUcsTUFBTTtJQUMvQixJQUFJLENBQUMsSUFBSSxDQUFDOUksS0FBSyxDQUFDcUYsS0FBSyxDQUFDM0YsV0FBVztJQUNqQyxJQUFJSyxTQUFTLElBQUlaLGdCQUFnQk8sVUFBVUMsUUFBUUMsU0FBU0M7SUFDNUQsSUFBSSxDQUFDSCxTQUFTNEYsS0FBSyxDQUFDbUQsYUFBYTtRQUMvQjFJLE9BQU9ZLFFBQVEsQ0FBQztZQUNkQyxNQUFNO1lBQ05FLFNBQVM7UUFDWDtJQUNGO0lBQ0EsT0FBT2Y7QUFDVDtBQUVBOzs7Ozs7O0NBT0MsR0FDRFIsV0FBV3lKLFlBQVksR0FBRyxTQUFTQyxxQkFBc0J2SixRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxHQUFHO0lBQ3JGLElBQUksQ0FBQyxJQUFJLENBQUNHLEtBQUssQ0FBQ3NELE1BQU0sQ0FBQzVELFdBQVc7SUFDbEMsSUFBSUssU0FBUyxJQUFJWixnQkFBZ0JPLFVBQVVDLFFBQVFDLFNBQVNDO0lBQzVELElBQUssSUFBSWtFLFlBQVlwRSxPQUFPcUosWUFBWSxDQUFFO1FBQ3hDLElBQUl0SixRQUFRLENBQUNxRSxTQUFTLEtBQUtqRSxXQUFXO1lBQ3BDO1FBQ0Y7UUFDQSxJQUFJb0osTUFBTXZKLE9BQU9xSixZQUFZLENBQUNqRixTQUFTO1FBQ3ZDLElBQUlvRixlQUFldEosSUFBSXNELFNBQVMsQ0FBQytGLEtBQUtuRjtRQUN0QyxJQUFJLE9BQU9tRixPQUFPLFVBQVU7WUFDMUJBLE1BQU07Z0JBQUNBO2FBQUk7UUFDYjtRQUNBLElBQUlqSixNQUFNQyxPQUFPLENBQUNnSixNQUFNO1lBQ3RCQSxJQUFJOUcsT0FBTyxDQUFDLFNBQVUrQixJQUFJO2dCQUN4QixJQUFJekUsUUFBUSxDQUFDeUUsS0FBSyxLQUFLckUsV0FBVztvQkFDaENDLE9BQU9ZLFFBQVEsQ0FBQzt3QkFDZCx5RkFBeUY7d0JBQ3pGLHlFQUF5RTt3QkFDekVDLE1BQU07d0JBQ05DLFVBQVVzSSxhQUFhQyxZQUFZO3dCQUNuQ3RJLFNBQVMsY0FBY3FELE9BQU8sNkJBQTZCZ0YsYUFBYUMsWUFBWTtvQkFDdEY7Z0JBQ0Y7WUFDRjtRQUNGLE9BQU87WUFDTCxJQUFJakksTUFBTSxJQUFJLENBQUNDLGNBQWMsQ0FBQzFCLFVBQVV3SixLQUFLdEosU0FBU3VKO1lBQ3RELElBQUdwSixPQUFPTCxRQUFRLEtBQUt5QixJQUFJekIsUUFBUSxFQUFFSyxPQUFPTCxRQUFRLEdBQUd5QixJQUFJekIsUUFBUTtZQUNuRSxJQUFJeUIsT0FBT0EsSUFBSW9CLE1BQU0sQ0FBQ0QsTUFBTSxFQUFFO2dCQUM1QnZDLE9BQU9ZLFFBQVEsQ0FBQztvQkFDZEMsTUFBTTtvQkFDTkMsVUFBVXNJLGFBQWFDLFlBQVk7b0JBQ25DdEksU0FBUywwQ0FBMENxSSxhQUFhQyxZQUFZO2dCQUM5RTtnQkFDQXJKLE9BQU8yQixZQUFZLENBQUNQO1lBQ3RCO1FBQ0Y7SUFDRjtJQUNBLE9BQU9wQjtBQUNUO0FBRUE7Ozs7OztDQU1DLEdBQ0RSLFVBQVUsQ0FBQyxPQUFPLEdBQUcsU0FBUzhKLGFBQWMzSixRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxHQUFHO0lBQ3hFLElBQUlILGFBQWFJLFdBQVc7UUFDMUIsT0FBTztJQUNUO0lBQ0EsSUFBSSxDQUFDRyxNQUFNQyxPQUFPLENBQUNQLE1BQU0sQ0FBQyxPQUFPLEdBQUc7UUFDbEMsTUFBTSxJQUFJUCxZQUFZLHlCQUF5Qk87SUFDakQ7SUFDQSxJQUFJSSxTQUFTLElBQUlaLGdCQUFnQk8sVUFBVUMsUUFBUUMsU0FBU0M7SUFDNUQsSUFBSSxDQUFDRixNQUFNLENBQUMsT0FBTyxDQUFDUSxJQUFJLENBQUNsQixRQUFRNEosaUJBQWlCLENBQUN4SSxJQUFJLENBQUMsTUFBTVgsWUFBWTtRQUN4RUssT0FBT1ksUUFBUSxDQUFDO1lBQ2RDLE1BQU07WUFDTkMsVUFBVWxCLE1BQU0sQ0FBQyxPQUFPO1lBQ3hCbUIsU0FBUyxnQ0FBZ0NuQixNQUFNLENBQUMsT0FBTyxDQUFDWSxHQUFHLENBQUMrSSxRQUFRdEgsSUFBSSxDQUFDO1FBQzNFO0lBQ0Y7SUFDQSxPQUFPakM7QUFDVDtBQUVBOzs7Ozs7Q0FNQyxHQUNEUixVQUFVLENBQUMsUUFBUSxHQUFHLFNBQVM4SixhQUFjM0osUUFBUSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsR0FBRztJQUN6RSxJQUFJSCxhQUFhSSxXQUFXO1FBQzFCLE9BQU87SUFDVDtJQUNBLElBQUlDLFNBQVMsSUFBSVosZ0JBQWdCTyxVQUFVQyxRQUFRQyxTQUFTQztJQUM1RCxJQUFJLENBQUNaLFFBQVE0SixpQkFBaUIsQ0FBQ2xKLE1BQU0sQ0FBQyxRQUFRLEVBQUVELFdBQVc7UUFDekRLLE9BQU9ZLFFBQVEsQ0FBQztZQUNkQyxNQUFNO1lBQ05DLFVBQVVsQixNQUFNLENBQUMsUUFBUTtZQUN6Qm1CLFNBQVMsK0NBQStDbkIsTUFBTSxDQUFDLFFBQVE7UUFDekU7SUFDRjtJQUNBLE9BQU9JO0FBQ1Q7QUFFQTs7Ozs7OztDQU9DLEdBQ0RSLFdBQVdnSyxHQUFHLEdBQUdoSyxXQUFXaUssUUFBUSxHQUFHLFNBQVNDLFlBQWEvSixRQUFRLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxHQUFHO0lBQ3pGLElBQUlzQyxPQUFPLElBQUk7SUFDZixJQUFHekMsYUFBV0ksV0FBVyxPQUFPO0lBQ2hDLElBQUlDLFNBQVMsSUFBSVosZ0JBQWdCTyxVQUFVQyxRQUFRQyxTQUFTQztJQUM1RCxJQUFJNkosV0FBVy9KLE9BQU80SixHQUFHLElBQUk1SixPQUFPNkosUUFBUTtJQUM1QyxJQUFHLENBQUNFLFVBQVUsT0FBTztJQUNyQixJQUFHLENBQUN6SixNQUFNQyxPQUFPLENBQUN3SixXQUFXQSxXQUFTO1FBQUNBO0tBQVM7SUFDaERBLFNBQVN0SCxPQUFPLENBQUMsU0FBVTVDLElBQUk7UUFDN0IsSUFBSTJDLEtBQUsvQixRQUFRLENBQUNWLFVBQVVDLFFBQVFDLFNBQVNDLEtBQUtMLE9BQU87WUFDdkQsSUFBSWlCLEtBQUtqQixRQUFTQSxDQUFBQSxLQUFLa0IsR0FBRyxJQUFJbEIsS0FBS2lCLEVBQUU7WUFDckMsSUFBSWtKLFdBQVdsSixNQUFNakI7WUFDckJPLE9BQU9ZLFFBQVEsQ0FBQztnQkFDZEMsTUFBTTtnQkFDTkMsVUFBVThJO2dCQUNWN0ksU0FBUywyQkFBMkI2STtZQUN0QztRQUNGO0lBQ0Y7SUFDQSxPQUFPNUo7QUFDVDtBQUVBNkosT0FBT0MsT0FBTyxHQUFHeEsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL2pzb25zY2hlbWEvbGliL2F0dHJpYnV0ZS5qcz9kMGYyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxuLyoqIEB0eXBlIFZhbGlkYXRvclJlc3VsdCAqL1xudmFyIFZhbGlkYXRvclJlc3VsdCA9IGhlbHBlcnMuVmFsaWRhdG9yUmVzdWx0O1xuLyoqIEB0eXBlIFNjaGVtYUVycm9yICovXG52YXIgU2NoZW1hRXJyb3IgPSBoZWxwZXJzLlNjaGVtYUVycm9yO1xuXG52YXIgYXR0cmlidXRlID0ge307XG5cbmF0dHJpYnV0ZS5pZ25vcmVQcm9wZXJ0aWVzID0ge1xuICAvLyBpbmZvcm1hdGl2ZSBwcm9wZXJ0aWVzXG4gICdpZCc6IHRydWUsXG4gICdkZWZhdWx0JzogdHJ1ZSxcbiAgJ2Rlc2NyaXB0aW9uJzogdHJ1ZSxcbiAgJ3RpdGxlJzogdHJ1ZSxcbiAgLy8gYXJndW1lbnRzIHRvIG90aGVyIHByb3BlcnRpZXNcbiAgJ2FkZGl0aW9uYWxJdGVtcyc6IHRydWUsXG4gICd0aGVuJzogdHJ1ZSxcbiAgJ2Vsc2UnOiB0cnVlLFxuICAvLyBzcGVjaWFsLWhhbmRsZWQgcHJvcGVydGllc1xuICAnJHNjaGVtYSc6IHRydWUsXG4gICckcmVmJzogdHJ1ZSxcbiAgJ2V4dGVuZHMnOiB0cnVlLFxufTtcblxuLyoqXG4gKiBAbmFtZSB2YWxpZGF0b3JzXG4gKi9cbnZhciB2YWxpZGF0b3JzID0gYXR0cmlidXRlLnZhbGlkYXRvcnMgPSB7fTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciB0aGUgaW5zdGFuY2UgaWYgb2YgYSBjZXJ0YWluIHR5cGVcbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBjdHhcbiAqIEByZXR1cm4ge1ZhbGlkYXRvclJlc3VsdHxudWxsfVxuICovXG52YWxpZGF0b3JzLnR5cGUgPSBmdW5jdGlvbiB2YWxpZGF0ZVR5cGUgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICAvLyBJZ25vcmUgdW5kZWZpbmVkIGluc3RhbmNlc1xuICBpZiAoaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIHZhciB0eXBlcyA9IEFycmF5LmlzQXJyYXkoc2NoZW1hLnR5cGUpID8gc2NoZW1hLnR5cGUgOiBbc2NoZW1hLnR5cGVdO1xuICBpZiAoIXR5cGVzLnNvbWUodGhpcy50ZXN0VHlwZS5iaW5kKHRoaXMsIGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkpKSB7XG4gICAgdmFyIGxpc3QgPSB0eXBlcy5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIGlmKCF2KSByZXR1cm47XG4gICAgICB2YXIgaWQgPSB2LiRpZCB8fCB2LmlkO1xuICAgICAgcmV0dXJuIGlkID8gKCc8JyArIGlkICsgJz4nKSA6ICh2KycnKTtcbiAgICB9KTtcbiAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgbmFtZTogJ3R5cGUnLFxuICAgICAgYXJndW1lbnQ6IGxpc3QsXG4gICAgICBtZXNzYWdlOiBcImlzIG5vdCBvZiBhIHR5cGUocykgXCIgKyBsaXN0LFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiB0ZXN0U2NoZW1hTm9UaHJvdyhpbnN0YW5jZSwgb3B0aW9ucywgY3R4LCBjYWxsYmFjaywgc2NoZW1hKXtcbiAgdmFyIHRocm93RXJyb3IgPSBvcHRpb25zLnRocm93RXJyb3I7XG4gIHZhciB0aHJvd0FsbCA9IG9wdGlvbnMudGhyb3dBbGw7XG4gIG9wdGlvbnMudGhyb3dFcnJvciA9IGZhbHNlO1xuICBvcHRpb25zLnRocm93QWxsID0gZmFsc2U7XG4gIHZhciByZXMgPSB0aGlzLnZhbGlkYXRlU2NoZW1hKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIG9wdGlvbnMudGhyb3dFcnJvciA9IHRocm93RXJyb3I7XG4gIG9wdGlvbnMudGhyb3dBbGwgPSB0aHJvd0FsbDtcblxuICBpZiAoIXJlcy52YWxpZCAmJiBjYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgY2FsbGJhY2socmVzKTtcbiAgfVxuICByZXR1cm4gcmVzLnZhbGlkO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyB3aGV0aGVyIHRoZSBpbnN0YW5jZSBtYXRjaGVzIHNvbWUgb2YgdGhlIGdpdmVuIHNjaGVtYXNcbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBjdHhcbiAqIEByZXR1cm4ge1ZhbGlkYXRvclJlc3VsdHxudWxsfVxuICovXG52YWxpZGF0b3JzLmFueU9mID0gZnVuY3Rpb24gdmFsaWRhdGVBbnlPZiAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIC8vIElnbm9yZSB1bmRlZmluZWQgaW5zdGFuY2VzXG4gIGlmIChpbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgdmFyIGlubmVyID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hLmFueU9mKSl7XG4gICAgdGhyb3cgbmV3IFNjaGVtYUVycm9yKFwiYW55T2YgbXVzdCBiZSBhbiBhcnJheVwiKTtcbiAgfVxuICBpZiAoIXNjaGVtYS5hbnlPZi5zb21lKFxuICAgIHRlc3RTY2hlbWFOb1Rocm93LmJpbmQoXG4gICAgICB0aGlzLCBpbnN0YW5jZSwgb3B0aW9ucywgY3R4LCBmdW5jdGlvbihyZXMpe2lubmVyLmltcG9ydEVycm9ycyhyZXMpO31cbiAgICApKSkge1xuICAgIHZhciBsaXN0ID0gc2NoZW1hLmFueU9mLm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgdmFyIGlkID0gdi4kaWQgfHwgdi5pZDtcbiAgICAgIGlmKGlkKSByZXR1cm4gJzwnICsgaWQgKyAnPic7XG4gICAgICByZXR1cm4odi50aXRsZSAmJiBKU09OLnN0cmluZ2lmeSh2LnRpdGxlKSkgfHwgKHZbJyRyZWYnXSAmJiAoJzwnICsgdlsnJHJlZiddICsgJz4nKSkgfHwgJ1tzdWJzY2hlbWEgJytpKyddJztcbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucy5uZXN0ZWRFcnJvcnMpIHtcbiAgICAgIHJlc3VsdC5pbXBvcnRFcnJvcnMoaW5uZXIpO1xuICAgIH1cbiAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgbmFtZTogJ2FueU9mJyxcbiAgICAgIGFyZ3VtZW50OiBsaXN0LFxuICAgICAgbWVzc2FnZTogXCJpcyBub3QgYW55IG9mIFwiICsgbGlzdC5qb2luKCcsJyksXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIHdoZXRoZXIgdGhlIGluc3RhbmNlIG1hdGNoZXMgZXZlcnkgZ2l2ZW4gc2NoZW1hXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gY3R4XG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cbiAqL1xudmFsaWRhdG9ycy5hbGxPZiA9IGZ1bmN0aW9uIHZhbGlkYXRlQWxsT2YgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICAvLyBJZ25vcmUgdW5kZWZpbmVkIGluc3RhbmNlc1xuICBpZiAoaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEuYWxsT2YpKXtcbiAgICB0aHJvdyBuZXcgU2NoZW1hRXJyb3IoXCJhbGxPZiBtdXN0IGJlIGFuIGFycmF5XCIpO1xuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2NoZW1hLmFsbE9mLmZvckVhY2goZnVuY3Rpb24odiwgaSl7XG4gICAgdmFyIHZhbGlkID0gc2VsZi52YWxpZGF0ZVNjaGVtYShpbnN0YW5jZSwgdiwgb3B0aW9ucywgY3R4KTtcbiAgICBpZighdmFsaWQudmFsaWQpe1xuICAgICAgdmFyIGlkID0gdi4kaWQgfHwgdi5pZDtcbiAgICAgIHZhciBtc2cgPSBpZCB8fCAodi50aXRsZSAmJiBKU09OLnN0cmluZ2lmeSh2LnRpdGxlKSkgfHwgKHZbJyRyZWYnXSAmJiAoJzwnICsgdlsnJHJlZiddICsgJz4nKSkgfHwgJ1tzdWJzY2hlbWEgJytpKyddJztcbiAgICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICAgIG5hbWU6ICdhbGxPZicsXG4gICAgICAgIGFyZ3VtZW50OiB7IGlkOiBtc2csIGxlbmd0aDogdmFsaWQuZXJyb3JzLmxlbmd0aCwgdmFsaWQ6IHZhbGlkIH0sXG4gICAgICAgIG1lc3NhZ2U6ICdkb2VzIG5vdCBtYXRjaCBhbGxPZiBzY2hlbWEgJyArIG1zZyArICcgd2l0aCAnICsgdmFsaWQuZXJyb3JzLmxlbmd0aCArICcgZXJyb3Jbc106JyxcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0LmltcG9ydEVycm9ycyh2YWxpZCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIHdoZXRoZXIgdGhlIGluc3RhbmNlIG1hdGNoZXMgZXhhY3RseSBvbmUgb2YgdGhlIGdpdmVuIHNjaGVtYXNcbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBjdHhcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxuICovXG52YWxpZGF0b3JzLm9uZU9mID0gZnVuY3Rpb24gdmFsaWRhdGVPbmVPZiAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIC8vIElnbm9yZSB1bmRlZmluZWQgaW5zdGFuY2VzXG4gIGlmIChpbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYS5vbmVPZikpe1xuICAgIHRocm93IG5ldyBTY2hlbWFFcnJvcihcIm9uZU9mIG11c3QgYmUgYW4gYXJyYXlcIik7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgdmFyIGlubmVyID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICB2YXIgY291bnQgPSBzY2hlbWEub25lT2YuZmlsdGVyKFxuICAgIHRlc3RTY2hlbWFOb1Rocm93LmJpbmQoXG4gICAgICB0aGlzLCBpbnN0YW5jZSwgb3B0aW9ucywgY3R4LCBmdW5jdGlvbihyZXMpIHtpbm5lci5pbXBvcnRFcnJvcnMocmVzKTt9XG4gICAgKSApLmxlbmd0aDtcbiAgdmFyIGxpc3QgPSBzY2hlbWEub25lT2YubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgdmFyIGlkID0gdi4kaWQgfHwgdi5pZDtcbiAgICByZXR1cm4gaWQgfHwgKHYudGl0bGUgJiYgSlNPTi5zdHJpbmdpZnkodi50aXRsZSkpIHx8ICh2WyckcmVmJ10gJiYgKCc8JyArIHZbJyRyZWYnXSArICc+JykpIHx8ICdbc3Vic2NoZW1hICcraSsnXSc7XG4gIH0pO1xuICBpZiAoY291bnQhPT0xKSB7XG4gICAgaWYgKG9wdGlvbnMubmVzdGVkRXJyb3JzKSB7XG4gICAgICByZXN1bHQuaW1wb3J0RXJyb3JzKGlubmVyKTtcbiAgICB9XG4gICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgIG5hbWU6ICdvbmVPZicsXG4gICAgICBhcmd1bWVudDogbGlzdCxcbiAgICAgIG1lc3NhZ2U6IFwiaXMgbm90IGV4YWN0bHkgb25lIGZyb20gXCIgKyBsaXN0LmpvaW4oJywnKSxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgXCJ0aGVuXCIgb3IgXCJlbHNlXCIgZGVwZW5kaW5nIG9uIHRoZSByZXN1bHQgb2YgdmFsaWRhdGluZyBcImlmXCJcbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBjdHhcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxuICovXG52YWxpZGF0b3JzLmlmID0gZnVuY3Rpb24gdmFsaWRhdGVJZiAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIC8vIElnbm9yZSB1bmRlZmluZWQgaW5zdGFuY2VzXG4gIGlmIChpbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcbiAgaWYgKCFoZWxwZXJzLmlzU2NoZW1hKHNjaGVtYS5pZikpIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgXCJpZlwiIGtleXdvcmQgdG8gYmUgYSBzY2hlbWEnKTtcbiAgdmFyIGlmVmFsaWQgPSB0ZXN0U2NoZW1hTm9UaHJvdy5jYWxsKHRoaXMsIGluc3RhbmNlLCBvcHRpb25zLCBjdHgsIG51bGwsIHNjaGVtYS5pZik7XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIHZhciByZXM7XG4gIGlmKGlmVmFsaWQpe1xuICAgIGlmIChzY2hlbWEudGhlbiA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgaWYgKCFoZWxwZXJzLmlzU2NoZW1hKHNjaGVtYS50aGVuKSkgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBcInRoZW5cIiBrZXl3b3JkIHRvIGJlIGEgc2NoZW1hJyk7XG4gICAgcmVzID0gdGhpcy52YWxpZGF0ZVNjaGVtYShpbnN0YW5jZSwgc2NoZW1hLnRoZW4sIG9wdGlvbnMsIGN0eC5tYWtlQ2hpbGQoc2NoZW1hLnRoZW4pKTtcbiAgICByZXN1bHQuaW1wb3J0RXJyb3JzKHJlcyk7XG4gIH1lbHNle1xuICAgIGlmIChzY2hlbWEuZWxzZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgaWYgKCFoZWxwZXJzLmlzU2NoZW1hKHNjaGVtYS5lbHNlKSkgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBcImVsc2VcIiBrZXl3b3JkIHRvIGJlIGEgc2NoZW1hJyk7XG4gICAgcmVzID0gdGhpcy52YWxpZGF0ZVNjaGVtYShpbnN0YW5jZSwgc2NoZW1hLmVsc2UsIG9wdGlvbnMsIGN0eC5tYWtlQ2hpbGQoc2NoZW1hLmVsc2UpKTtcbiAgICByZXN1bHQuaW1wb3J0RXJyb3JzKHJlcyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVQcm9wZXJ0eShvYmplY3QsIGtleSl7XG4gIC8vIERldGVybWluZSBpZiBga2V5YCBzaG93cyB1cCBpbiBgZm9yKHZhciBrZXkgaW4gb2JqZWN0KWBcbiAgLy8gRmlyc3QgdGVzdCBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCBhcyBhbiBvcHRpbWl6YXRpb246IHRoYXQgZ3VhcmFudGVlcyBpdCBkb2VzXG4gIGlmKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkgcmV0dXJuIG9iamVjdFtrZXldO1xuICAvLyBUZXN0IGBrZXkgaW4gb2JqZWN0YCBhcyBhbiBvcHRpbWl6YXRpb247IGZhbHNlIG1lYW5zIGl0IHdvbid0XG4gIGlmKCEoa2V5IGluIG9iamVjdCkpIHJldHVybjtcbiAgd2hpbGUoIChvYmplY3QgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KSkgKXtcbiAgICBpZihPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIGtleSkpIHJldHVybiBvYmplY3Rba2V5XTtcbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBwcm9wZXJ0eU5hbWVzXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gY3R4XG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbHxWYWxpZGF0b3JSZXN1bHR9XG4gKi9cbnZhbGlkYXRvcnMucHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHlOYW1lcyAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIGlmKCF0aGlzLnR5cGVzLm9iamVjdChpbnN0YW5jZSkpIHJldHVybjtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgdmFyIHN1YnNjaGVtYSA9IHNjaGVtYS5wcm9wZXJ0eU5hbWVzIT09dW5kZWZpbmVkID8gc2NoZW1hLnByb3BlcnR5TmFtZXMgOiB7fTtcbiAgaWYoIWhlbHBlcnMuaXNTY2hlbWEoc3Vic2NoZW1hKSkgdGhyb3cgbmV3IFNjaGVtYUVycm9yKCdFeHBlY3RlZCBcInByb3BlcnR5TmFtZXNcIiB0byBiZSBhIHNjaGVtYSAob2JqZWN0IG9yIGJvb2xlYW4pJyk7XG5cbiAgZm9yICh2YXIgcHJvcGVydHkgaW4gaW5zdGFuY2UpIHtcbiAgICBpZihnZXRFbnVtZXJhYmxlUHJvcGVydHkoaW5zdGFuY2UsIHByb3BlcnR5KSAhPT0gdW5kZWZpbmVkKXtcbiAgICAgIHZhciByZXMgPSB0aGlzLnZhbGlkYXRlU2NoZW1hKHByb3BlcnR5LCBzdWJzY2hlbWEsIG9wdGlvbnMsIGN0eC5tYWtlQ2hpbGQoc3Vic2NoZW1hKSk7XG4gICAgICByZXN1bHQuaW1wb3J0RXJyb3JzKHJlcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBjdHhcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfFZhbGlkYXRvclJlc3VsdH1cbiAqL1xudmFsaWRhdG9ycy5wcm9wZXJ0aWVzID0gZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgaWYoIXRoaXMudHlwZXMub2JqZWN0KGluc3RhbmNlKSkgcmV0dXJuO1xuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICB2YXIgcHJvcGVydGllcyA9IHNjaGVtYS5wcm9wZXJ0aWVzIHx8IHt9O1xuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIHN1YnNjaGVtYSA9IHByb3BlcnRpZXNbcHJvcGVydHldO1xuICAgIGlmKHN1YnNjaGVtYT09PXVuZGVmaW5lZCl7XG4gICAgICBjb250aW51ZTtcbiAgICB9ZWxzZSBpZihzdWJzY2hlbWE9PT1udWxsKXtcbiAgICAgIHRocm93IG5ldyBTY2hlbWFFcnJvcignVW5leHBlY3RlZCBudWxsLCBleHBlY3RlZCBzY2hlbWEgaW4gXCJwcm9wZXJ0aWVzXCInKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnByZVZhbGlkYXRlUHJvcGVydHkgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3B0aW9ucy5wcmVWYWxpZGF0ZVByb3BlcnR5KGluc3RhbmNlLCBwcm9wZXJ0eSwgc3Vic2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICAgIH1cbiAgICB2YXIgcHJvcCA9IGdldEVudW1lcmFibGVQcm9wZXJ0eShpbnN0YW5jZSwgcHJvcGVydHkpO1xuICAgIHZhciByZXMgPSB0aGlzLnZhbGlkYXRlU2NoZW1hKHByb3AsIHN1YnNjaGVtYSwgb3B0aW9ucywgY3R4Lm1ha2VDaGlsZChzdWJzY2hlbWEsIHByb3BlcnR5KSk7XG4gICAgaWYocmVzLmluc3RhbmNlICE9PSByZXN1bHQuaW5zdGFuY2VbcHJvcGVydHldKSByZXN1bHQuaW5zdGFuY2VbcHJvcGVydHldID0gcmVzLmluc3RhbmNlO1xuICAgIHJlc3VsdC5pbXBvcnRFcnJvcnMocmVzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBUZXN0IGEgc3BlY2lmaWMgcHJvcGVydHkgd2l0aGluIGluIGluc3RhbmNlIGFnYWluc3QgdGhlIGFkZGl0aW9uYWxQcm9wZXJ0aWVzIHNjaGVtYSBhdHRyaWJ1dGVcbiAqIFRoaXMgaWdub3JlcyBwcm9wZXJ0aWVzIHdpdGggZGVmaW5pdGlvbnMgaW4gdGhlIHByb3BlcnRpZXMgc2NoZW1hIGF0dHJpYnV0ZSwgYnV0IG5vIG90aGVyIGF0dHJpYnV0ZXMuXG4gKiBJZiB0b28gbWFueSBtb3JlIHR5cGVzIG9mIHByb3BlcnR5LWV4aXN0ZW5jZSB0ZXN0cyBwb3AgdXAgdGhleSBtYXkgbmVlZCB0aGVpciBvd24gY2xhc3Mgb2YgdGVzdHMgKGxpa2UgYHR5cGVgIGhhcylcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB0ZXN0QWRkaXRpb25hbFByb3BlcnR5IChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgsIHByb3BlcnR5LCByZXN1bHQpIHtcbiAgaWYoIXRoaXMudHlwZXMub2JqZWN0KGluc3RhbmNlKSkgcmV0dXJuO1xuICBpZiAoc2NoZW1hLnByb3BlcnRpZXMgJiYgc2NoZW1hLnByb3BlcnRpZXNbcHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gZmFsc2UpIHtcbiAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgbmFtZTogJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJyxcbiAgICAgIGFyZ3VtZW50OiBwcm9wZXJ0eSxcbiAgICAgIG1lc3NhZ2U6IFwiaXMgbm90IGFsbG93ZWQgdG8gaGF2ZSB0aGUgYWRkaXRpb25hbCBwcm9wZXJ0eSBcIiArIEpTT04uc3RyaW5naWZ5KHByb3BlcnR5KSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYWRkaXRpb25hbFByb3BlcnRpZXMgPSBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgfHwge307XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucHJlVmFsaWRhdGVQcm9wZXJ0eSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRpb25zLnByZVZhbGlkYXRlUHJvcGVydHkoaW5zdGFuY2UsIHByb3BlcnR5LCBhZGRpdGlvbmFsUHJvcGVydGllcywgb3B0aW9ucywgY3R4KTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0gdGhpcy52YWxpZGF0ZVNjaGVtYShpbnN0YW5jZVtwcm9wZXJ0eV0sIGFkZGl0aW9uYWxQcm9wZXJ0aWVzLCBvcHRpb25zLCBjdHgubWFrZUNoaWxkKGFkZGl0aW9uYWxQcm9wZXJ0aWVzLCBwcm9wZXJ0eSkpO1xuICAgIGlmKHJlcy5pbnN0YW5jZSAhPT0gcmVzdWx0Lmluc3RhbmNlW3Byb3BlcnR5XSkgcmVzdWx0Lmluc3RhbmNlW3Byb3BlcnR5XSA9IHJlcy5pbnN0YW5jZTtcbiAgICByZXN1bHQuaW1wb3J0RXJyb3JzKHJlcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgcGF0dGVyblByb3BlcnRpZXNcbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBjdHhcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfFZhbGlkYXRvclJlc3VsdH1cbiAqL1xudmFsaWRhdG9ycy5wYXR0ZXJuUHJvcGVydGllcyA9IGZ1bmN0aW9uIHZhbGlkYXRlUGF0dGVyblByb3BlcnRpZXMgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICBpZighdGhpcy50eXBlcy5vYmplY3QoaW5zdGFuY2UpKSByZXR1cm47XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIHZhciBwYXR0ZXJuUHJvcGVydGllcyA9IHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcyB8fCB7fTtcblxuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBpbnN0YW5jZSkge1xuICAgIHZhciB0ZXN0ID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBwYXR0ZXJuIGluIHBhdHRlcm5Qcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgc3Vic2NoZW1hID0gcGF0dGVyblByb3BlcnRpZXNbcGF0dGVybl07XG4gICAgICBpZihzdWJzY2hlbWE9PT11bmRlZmluZWQpe1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1lbHNlIGlmKHN1YnNjaGVtYT09PW51bGwpe1xuICAgICAgICB0aHJvdyBuZXcgU2NoZW1hRXJyb3IoJ1VuZXhwZWN0ZWQgbnVsbCwgZXhwZWN0ZWQgc2NoZW1hIGluIFwicGF0dGVyblByb3BlcnRpZXNcIicpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAocGF0dGVybiwgJ3UnKTtcbiAgICAgIH0gY2F0Y2goX2UpIHtcbiAgICAgICAgLy8gSW4gdGhlIGV2ZW50IHRoZSBzdHJpY3RlciBoYW5kbGluZyBjYXVzZXMgYW4gZXJyb3IsIGZhbGwgYmFjayBvbiB0aGUgZm9yZ2l2aW5nIGhhbmRsaW5nXG4gICAgICAgIC8vIERFUFJFQ0FURURcbiAgICAgICAgcmVnZXhwID0gbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgICAgIH1cbiAgICAgIGlmICghcmVnZXhwLnRlc3QocHJvcGVydHkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGVzdCA9IGZhbHNlO1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMucHJlVmFsaWRhdGVQcm9wZXJ0eSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9wdGlvbnMucHJlVmFsaWRhdGVQcm9wZXJ0eShpbnN0YW5jZSwgcHJvcGVydHksIHN1YnNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcyA9IHRoaXMudmFsaWRhdGVTY2hlbWEoaW5zdGFuY2VbcHJvcGVydHldLCBzdWJzY2hlbWEsIG9wdGlvbnMsIGN0eC5tYWtlQ2hpbGQoc3Vic2NoZW1hLCBwcm9wZXJ0eSkpO1xuICAgICAgaWYocmVzLmluc3RhbmNlICE9PSByZXN1bHQuaW5zdGFuY2VbcHJvcGVydHldKSByZXN1bHQuaW5zdGFuY2VbcHJvcGVydHldID0gcmVzLmluc3RhbmNlO1xuICAgICAgcmVzdWx0LmltcG9ydEVycm9ycyhyZXMpO1xuICAgIH1cbiAgICBpZiAodGVzdCkge1xuICAgICAgdGVzdEFkZGl0aW9uYWxQcm9wZXJ0eS5jYWxsKHRoaXMsIGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCwgcHJvcGVydHksIHJlc3VsdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gY3R4XG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbHxWYWxpZGF0b3JSZXN1bHR9XG4gKi9cbnZhbGlkYXRvcnMuYWRkaXRpb25hbFByb3BlcnRpZXMgPSBmdW5jdGlvbiB2YWxpZGF0ZUFkZGl0aW9uYWxQcm9wZXJ0aWVzIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgaWYoIXRoaXMudHlwZXMub2JqZWN0KGluc3RhbmNlKSkgcmV0dXJuO1xuICAvLyBpZiBwYXR0ZXJuUHJvcGVydGllcyBpcyBkZWZpbmVkIHRoZW4gd2UnbGwgdGVzdCB3aGVuIHRoYXQgb25lIGlzIGNhbGxlZCBpbnN0ZWFkXG4gIGlmIChzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBpbnN0YW5jZSkge1xuICAgIHRlc3RBZGRpdGlvbmFsUHJvcGVydHkuY2FsbCh0aGlzLCBpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgsIHByb3BlcnR5LCByZXN1bHQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB3aGV0aGVyIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBhdCBsZWFzdCBvZiBhIGNlcnRhaW4gbGVuZ3RoLCB3aGVuIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cbnZhbGlkYXRvcnMubWluUHJvcGVydGllcyA9IGZ1bmN0aW9uIHZhbGlkYXRlTWluUHJvcGVydGllcyAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIGlmICghdGhpcy50eXBlcy5vYmplY3QoaW5zdGFuY2UpKSByZXR1cm47XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoaW5zdGFuY2UpO1xuICBpZiAoIShrZXlzLmxlbmd0aCA+PSBzY2hlbWEubWluUHJvcGVydGllcykpIHtcbiAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgbmFtZTogJ21pblByb3BlcnRpZXMnLFxuICAgICAgYXJndW1lbnQ6IHNjaGVtYS5taW5Qcm9wZXJ0aWVzLFxuICAgICAgbWVzc2FnZTogXCJkb2VzIG5vdCBtZWV0IG1pbmltdW0gcHJvcGVydHkgbGVuZ3RoIG9mIFwiICsgc2NoZW1hLm1pblByb3BlcnRpZXMsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIHdoZXRoZXIgdGhlIGluc3RhbmNlIHZhbHVlIGlzIGF0IG1vc3Qgb2YgYSBjZXJ0YWluIGxlbmd0aCwgd2hlbiB0aGUgaW5zdGFuY2UgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxuICovXG52YWxpZGF0b3JzLm1heFByb3BlcnRpZXMgPSBmdW5jdGlvbiB2YWxpZGF0ZU1heFByb3BlcnRpZXMgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICBpZiAoIXRoaXMudHlwZXMub2JqZWN0KGluc3RhbmNlKSkgcmV0dXJuO1xuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGluc3RhbmNlKTtcbiAgaWYgKCEoa2V5cy5sZW5ndGggPD0gc2NoZW1hLm1heFByb3BlcnRpZXMpKSB7XG4gICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgIG5hbWU6ICdtYXhQcm9wZXJ0aWVzJyxcbiAgICAgIGFyZ3VtZW50OiBzY2hlbWEubWF4UHJvcGVydGllcyxcbiAgICAgIG1lc3NhZ2U6IFwiZG9lcyBub3QgbWVldCBtYXhpbXVtIHByb3BlcnR5IGxlbmd0aCBvZiBcIiArIHNjaGVtYS5tYXhQcm9wZXJ0aWVzLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyBpdGVtcyB3aGVuIGluc3RhbmNlIGlzIGFuIGFycmF5XG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gY3R4XG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbHxWYWxpZGF0b3JSZXN1bHR9XG4gKi9cbnZhbGlkYXRvcnMuaXRlbXMgPSBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoIXRoaXMudHlwZXMuYXJyYXkoaW5zdGFuY2UpKSByZXR1cm47XG4gIGlmIChzY2hlbWEuaXRlbXM9PT11bmRlZmluZWQpIHJldHVybjtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgaW5zdGFuY2UuZXZlcnkoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgaWYoQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpKXtcbiAgICAgIHZhciBpdGVtcyA9ICBzY2hlbWEuaXRlbXNbaV09PT11bmRlZmluZWQgPyBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zIDogc2NoZW1hLml0ZW1zW2ldO1xuICAgIH1lbHNle1xuICAgICAgdmFyIGl0ZW1zID0gc2NoZW1hLml0ZW1zO1xuICAgIH1cbiAgICBpZiAoaXRlbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpdGVtcyA9PT0gZmFsc2UpIHtcbiAgICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICAgIG5hbWU6ICdpdGVtcycsXG4gICAgICAgIG1lc3NhZ2U6IFwiYWRkaXRpb25hbEl0ZW1zIG5vdCBwZXJtaXR0ZWRcIixcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgcmVzID0gc2VsZi52YWxpZGF0ZVNjaGVtYSh2YWx1ZSwgaXRlbXMsIG9wdGlvbnMsIGN0eC5tYWtlQ2hpbGQoaXRlbXMsIGkpKTtcbiAgICBpZihyZXMuaW5zdGFuY2UgIT09IHJlc3VsdC5pbnN0YW5jZVtpXSkgcmVzdWx0Lmluc3RhbmNlW2ldID0gcmVzLmluc3RhbmNlO1xuICAgIHJlc3VsdC5pbXBvcnRFcnJvcnMocmVzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgXCJjb250YWluc1wiIGtleXdvcmRcbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBjdHhcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfFZhbGlkYXRvclJlc3VsdH1cbiAqL1xudmFsaWRhdG9ycy5jb250YWlucyA9IGZ1bmN0aW9uIHZhbGlkYXRlQ29udGFpbnMgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICghdGhpcy50eXBlcy5hcnJheShpbnN0YW5jZSkpIHJldHVybjtcbiAgaWYgKHNjaGVtYS5jb250YWlucz09PXVuZGVmaW5lZCkgcmV0dXJuO1xuICBpZiAoIWhlbHBlcnMuaXNTY2hlbWEoc2NoZW1hLmNvbnRhaW5zKSkgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBcImNvbnRhaW5zXCIga2V5d29yZCB0byBiZSBhIHNjaGVtYScpO1xuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICB2YXIgY291bnQgPSBpbnN0YW5jZS5zb21lKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgIHZhciByZXMgPSBzZWxmLnZhbGlkYXRlU2NoZW1hKHZhbHVlLCBzY2hlbWEuY29udGFpbnMsIG9wdGlvbnMsIGN0eC5tYWtlQ2hpbGQoc2NoZW1hLmNvbnRhaW5zLCBpKSk7XG4gICAgcmV0dXJuIHJlcy5lcnJvcnMubGVuZ3RoPT09MDtcbiAgfSk7XG4gIGlmKGNvdW50PT09ZmFsc2Upe1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAnY29udGFpbnMnLFxuICAgICAgYXJndW1lbnQ6IHNjaGVtYS5jb250YWlucyxcbiAgICAgIG1lc3NhZ2U6IFwibXVzdCBjb250YWluIGFuIGl0ZW0gbWF0Y2hpbmcgZ2l2ZW4gc2NoZW1hXCIsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIG1pbmltdW0gYW5kIGV4Y2x1c2l2ZU1pbmltdW0gd2hlbiB0aGUgdHlwZSBvZiB0aGUgaW5zdGFuY2UgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxuICovXG52YWxpZGF0b3JzLm1pbmltdW0gPSBmdW5jdGlvbiB2YWxpZGF0ZU1pbmltdW0gKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICBpZiAoIXRoaXMudHlwZXMubnVtYmVyKGluc3RhbmNlKSkgcmV0dXJuO1xuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICBpZiAoc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0gJiYgc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0gPT09IHRydWUpIHtcbiAgICBpZighKGluc3RhbmNlID4gc2NoZW1hLm1pbmltdW0pKXtcbiAgICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICAgIG5hbWU6ICdtaW5pbXVtJyxcbiAgICAgICAgYXJndW1lbnQ6IHNjaGVtYS5taW5pbXVtLFxuICAgICAgICBtZXNzYWdlOiBcIm11c3QgYmUgZ3JlYXRlciB0aGFuIFwiICsgc2NoZW1hLm1pbmltdW0sXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYoIShpbnN0YW5jZSA+PSBzY2hlbWEubWluaW11bSkpe1xuICAgICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgICAgbmFtZTogJ21pbmltdW0nLFxuICAgICAgICBhcmd1bWVudDogc2NoZW1hLm1pbmltdW0sXG4gICAgICAgIG1lc3NhZ2U6IFwibXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gXCIgKyBzY2hlbWEubWluaW11bSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgbWF4aW11bSBhbmQgZXhjbHVzaXZlTWF4aW11bSB3aGVuIHRoZSB0eXBlIG9mIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cbnZhbGlkYXRvcnMubWF4aW11bSA9IGZ1bmN0aW9uIHZhbGlkYXRlTWF4aW11bSAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIGlmICghdGhpcy50eXBlcy5udW1iZXIoaW5zdGFuY2UpKSByZXR1cm47XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIGlmIChzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSAmJiBzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSA9PT0gdHJ1ZSkge1xuICAgIGlmKCEoaW5zdGFuY2UgPCBzY2hlbWEubWF4aW11bSkpe1xuICAgICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgICAgbmFtZTogJ21heGltdW0nLFxuICAgICAgICBhcmd1bWVudDogc2NoZW1hLm1heGltdW0sXG4gICAgICAgIG1lc3NhZ2U6IFwibXVzdCBiZSBsZXNzIHRoYW4gXCIgKyBzY2hlbWEubWF4aW11bSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZighKGluc3RhbmNlIDw9IHNjaGVtYS5tYXhpbXVtKSl7XG4gICAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgICBuYW1lOiAnbWF4aW11bScsXG4gICAgICAgIGFyZ3VtZW50OiBzY2hlbWEubWF4aW11bSxcbiAgICAgICAgbWVzc2FnZTogXCJtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBcIiArIHNjaGVtYS5tYXhpbXVtLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgbnVtYmVyIGZvcm0gb2YgZXhjbHVzaXZlTWluaW11bSB3aGVuIHRoZSB0eXBlIG9mIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cbnZhbGlkYXRvcnMuZXhjbHVzaXZlTWluaW11bSA9IGZ1bmN0aW9uIHZhbGlkYXRlRXhjbHVzaXZlTWluaW11bSAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIC8vIFN1cHBvcnQgdGhlIGJvb2xlYW4gZm9ybSBvZiBleGNsdXNpdmVNaW5pbXVtLCB3aGljaCBpcyBoYW5kbGVkIGJ5IHRoZSBcIm1pbmltdW1cIiBrZXl3b3JkLlxuICBpZih0eXBlb2Ygc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0gPT09ICdib29sZWFuJykgcmV0dXJuO1xuICBpZiAoIXRoaXMudHlwZXMubnVtYmVyKGluc3RhbmNlKSkgcmV0dXJuO1xuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICB2YXIgdmFsaWQgPSBpbnN0YW5jZSA+IHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtO1xuICBpZiAoIXZhbGlkKSB7XG4gICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgIG5hbWU6ICdleGNsdXNpdmVNaW5pbXVtJyxcbiAgICAgIGFyZ3VtZW50OiBzY2hlbWEuZXhjbHVzaXZlTWluaW11bSxcbiAgICAgIG1lc3NhZ2U6IFwibXVzdCBiZSBzdHJpY3RseSBncmVhdGVyIHRoYW4gXCIgKyBzY2hlbWEuZXhjbHVzaXZlTWluaW11bSxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIG51bWJlciBmb3JtIG9mIGV4Y2x1c2l2ZU1heGltdW0gd2hlbiB0aGUgdHlwZSBvZiB0aGUgaW5zdGFuY2UgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxuICovXG52YWxpZGF0b3JzLmV4Y2x1c2l2ZU1heGltdW0gPSBmdW5jdGlvbiB2YWxpZGF0ZUV4Y2x1c2l2ZU1heGltdW0gKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICAvLyBTdXBwb3J0IHRoZSBib29sZWFuIGZvcm0gb2YgZXhjbHVzaXZlTWF4aW11bSwgd2hpY2ggaXMgaGFuZGxlZCBieSB0aGUgXCJtYXhpbXVtXCIga2V5d29yZC5cbiAgaWYodHlwZW9mIHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtID09PSAnYm9vbGVhbicpIHJldHVybjtcbiAgaWYgKCF0aGlzLnR5cGVzLm51bWJlcihpbnN0YW5jZSkpIHJldHVybjtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgdmFyIHZhbGlkID0gaW5zdGFuY2UgPCBzY2hlbWEuZXhjbHVzaXZlTWF4aW11bTtcbiAgaWYgKCF2YWxpZCkge1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAnZXhjbHVzaXZlTWF4aW11bScsXG4gICAgICBhcmd1bWVudDogc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0sXG4gICAgICBtZXNzYWdlOiBcIm11c3QgYmUgc3RyaWN0bHkgbGVzcyB0aGFuIFwiICsgc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0sXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUGVyZm9ybSB2YWxpZGF0aW9uIGZvciBtdWx0aXBsZU9mIGFuZCBkaXZpc2libGVCeSwgd2hpY2ggYXJlIGVzc2VudGlhbGx5IHRoZSBzYW1lLlxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcGFyYW0gdmFsaWRhdGlvblR5cGVcbiAqIEBwYXJhbSBlcnJvck1lc3NhZ2VcbiAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH1cbiAqL1xudmFyIHZhbGlkYXRlTXVsdGlwbGVPZk9yRGl2aXNibGVCeSA9IGZ1bmN0aW9uIHZhbGlkYXRlTXVsdGlwbGVPZk9yRGl2aXNibGVCeSAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4LCB2YWxpZGF0aW9uVHlwZSwgZXJyb3JNZXNzYWdlKSB7XG4gIGlmICghdGhpcy50eXBlcy5udW1iZXIoaW5zdGFuY2UpKSByZXR1cm47XG5cbiAgdmFyIHZhbGlkYXRpb25Bcmd1bWVudCA9IHNjaGVtYVt2YWxpZGF0aW9uVHlwZV07XG4gIGlmICh2YWxpZGF0aW9uQXJndW1lbnQgPT0gMCkge1xuICAgIHRocm93IG5ldyBTY2hlbWFFcnJvcih2YWxpZGF0aW9uVHlwZSArIFwiIGNhbm5vdCBiZSB6ZXJvXCIpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcblxuICB2YXIgaW5zdGFuY2VEZWNpbWFscyA9IGhlbHBlcnMuZ2V0RGVjaW1hbFBsYWNlcyhpbnN0YW5jZSk7XG4gIHZhciBkaXZpc29yRGVjaW1hbHMgPSBoZWxwZXJzLmdldERlY2ltYWxQbGFjZXModmFsaWRhdGlvbkFyZ3VtZW50KTtcblxuICB2YXIgbWF4RGVjaW1hbHMgPSBNYXRoLm1heChpbnN0YW5jZURlY2ltYWxzICwgZGl2aXNvckRlY2ltYWxzKTtcbiAgdmFyIG11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgbWF4RGVjaW1hbHMpO1xuXG4gIGlmIChNYXRoLnJvdW5kKGluc3RhbmNlICogbXVsdGlwbGllcikgJSBNYXRoLnJvdW5kKHZhbGlkYXRpb25Bcmd1bWVudCAqIG11bHRpcGxpZXIpICE9PSAwKSB7XG4gICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgIG5hbWU6IHZhbGlkYXRpb25UeXBlLFxuICAgICAgYXJndW1lbnQ6ICB2YWxpZGF0aW9uQXJndW1lbnQsXG4gICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UgKyBKU09OLnN0cmluZ2lmeSh2YWxpZGF0aW9uQXJndW1lbnQpLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIGRpdmlzaWJsZUJ5IHdoZW4gdGhlIHR5cGUgb2YgdGhlIGluc3RhbmNlIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cbiAqL1xudmFsaWRhdG9ycy5tdWx0aXBsZU9mID0gZnVuY3Rpb24gdmFsaWRhdGVNdWx0aXBsZU9mIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgcmV0dXJuIHZhbGlkYXRlTXVsdGlwbGVPZk9yRGl2aXNibGVCeS5jYWxsKHRoaXMsIGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCwgXCJtdWx0aXBsZU9mXCIsIFwiaXMgbm90IGEgbXVsdGlwbGUgb2YgKGRpdmlzaWJsZSBieSkgXCIpO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgbXVsdGlwbGVPZiB3aGVuIHRoZSB0eXBlIG9mIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cbnZhbGlkYXRvcnMuZGl2aXNpYmxlQnkgPSBmdW5jdGlvbiB2YWxpZGF0ZURpdmlzaWJsZUJ5IChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgcmV0dXJuIHZhbGlkYXRlTXVsdGlwbGVPZk9yRGl2aXNibGVCeS5jYWxsKHRoaXMsIGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCwgXCJkaXZpc2libGVCeVwiLCBcImlzIG5vdCBkaXZpc2libGUgYnkgKG11bHRpcGxlIG9mKSBcIik7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB3aGV0aGVyIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBwcmVzZW50LlxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cbiAqL1xudmFsaWRhdG9ycy5yZXF1aXJlZCA9IGZ1bmN0aW9uIHZhbGlkYXRlUmVxdWlyZWQgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICBpZiAoaW5zdGFuY2UgPT09IHVuZGVmaW5lZCAmJiBzY2hlbWEucmVxdWlyZWQgPT09IHRydWUpIHtcbiAgICAvLyBBIGJvb2xlYW4gZm9ybSBpcyBpbXBsZW1lbnRlZCBmb3IgcmV2ZXJzZS1jb21wYXRpYmlsaXR5IHdpdGggc2NoZW1hcyB3cml0dGVuIGFnYWluc3Qgb2xkZXIgZHJhZnRzXG4gICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgIG5hbWU6ICdyZXF1aXJlZCcsXG4gICAgICBtZXNzYWdlOiBcImlzIHJlcXVpcmVkXCIsXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodGhpcy50eXBlcy5vYmplY3QoaW5zdGFuY2UpICYmIEFycmF5LmlzQXJyYXkoc2NoZW1hLnJlcXVpcmVkKSkge1xuICAgIHNjaGVtYS5yZXF1aXJlZC5mb3JFYWNoKGZ1bmN0aW9uKG4pe1xuICAgICAgaWYoZ2V0RW51bWVyYWJsZVByb3BlcnR5KGluc3RhbmNlLCBuKT09PXVuZGVmaW5lZCl7XG4gICAgICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICAgICAgbmFtZTogJ3JlcXVpcmVkJyxcbiAgICAgICAgICBhcmd1bWVudDogbixcbiAgICAgICAgICBtZXNzYWdlOiBcInJlcXVpcmVzIHByb3BlcnR5IFwiICsgSlNPTi5zdHJpbmdpZnkobiksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB3aGV0aGVyIHRoZSBpbnN0YW5jZSB2YWx1ZSBtYXRjaGVzIHRoZSByZWd1bGFyIGV4cHJlc3Npb24sIHdoZW4gdGhlIGluc3RhbmNlIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cbiAqL1xudmFsaWRhdG9ycy5wYXR0ZXJuID0gZnVuY3Rpb24gdmFsaWRhdGVQYXR0ZXJuIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgaWYgKCF0aGlzLnR5cGVzLnN0cmluZyhpbnN0YW5jZSkpIHJldHVybjtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgdmFyIHBhdHRlcm4gPSBzY2hlbWEucGF0dGVybjtcbiAgdHJ5IHtcbiAgICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCAndScpO1xuICB9IGNhdGNoKF9lKSB7XG4gICAgLy8gSW4gdGhlIGV2ZW50IHRoZSBzdHJpY3RlciBoYW5kbGluZyBjYXVzZXMgYW4gZXJyb3IsIGZhbGwgYmFjayBvbiB0aGUgZm9yZ2l2aW5nIGhhbmRsaW5nXG4gICAgLy8gREVQUkVDQVRFRFxuICAgIHJlZ2V4cCA9IG5ldyBSZWdFeHAocGF0dGVybik7XG4gIH1cbiAgaWYgKCFpbnN0YW5jZS5tYXRjaChyZWdleHApKSB7XG4gICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgIG5hbWU6ICdwYXR0ZXJuJyxcbiAgICAgIGFyZ3VtZW50OiBzY2hlbWEucGF0dGVybixcbiAgICAgIG1lc3NhZ2U6IFwiZG9lcyBub3QgbWF0Y2ggcGF0dGVybiBcIiArIEpTT04uc3RyaW5naWZ5KHNjaGVtYS5wYXR0ZXJuLnRvU3RyaW5nKCkpLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB3aGV0aGVyIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBvZiBhIGNlcnRhaW4gZGVmaW5lZCBmb3JtYXQgb3IgYSBjdXN0b21cbiAqIGZvcm1hdC5cbiAqIFRoZSBmb2xsb3dpbmcgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIGZvciBzdHJpbmcgdHlwZXM6XG4gKiAgIC0gZGF0ZS10aW1lXG4gKiAgIC0gZGF0ZVxuICogICAtIHRpbWVcbiAqICAgLSBpcC1hZGRyZXNzXG4gKiAgIC0gaXB2NlxuICogICAtIHVyaVxuICogICAtIGNvbG9yXG4gKiAgIC0gaG9zdC1uYW1lXG4gKiAgIC0gYWxwaGFcbiAqICAgLSBhbHBoYS1udW1lcmljXG4gKiAgIC0gdXRjLW1pbGxpc2VjXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSBbb3B0aW9uc11cbiAqIEBwYXJhbSBbY3R4XVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cbnZhbGlkYXRvcnMuZm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICBpZiAoaW5zdGFuY2U9PT11bmRlZmluZWQpIHJldHVybjtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgaWYgKCFyZXN1bHQuZGlzYWJsZUZvcm1hdCAmJiAhaGVscGVycy5pc0Zvcm1hdChpbnN0YW5jZSwgc2NoZW1hLmZvcm1hdCwgdGhpcykpIHtcbiAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgbmFtZTogJ2Zvcm1hdCcsXG4gICAgICBhcmd1bWVudDogc2NoZW1hLmZvcm1hdCxcbiAgICAgIG1lc3NhZ2U6IFwiZG9lcyBub3QgY29uZm9ybSB0byB0aGUgXCIgKyBKU09OLnN0cmluZ2lmeShzY2hlbWEuZm9ybWF0KSArIFwiIGZvcm1hdFwiLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB3aGV0aGVyIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBhdCBsZWFzdCBvZiBhIGNlcnRhaW4gbGVuZ3RoLCB3aGVuIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cbnZhbGlkYXRvcnMubWluTGVuZ3RoID0gZnVuY3Rpb24gdmFsaWRhdGVNaW5MZW5ndGggKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICBpZiAoIXRoaXMudHlwZXMuc3RyaW5nKGluc3RhbmNlKSkgcmV0dXJuO1xuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICB2YXIgaHNwID0gaW5zdGFuY2UubWF0Y2goL1tcXHVEQzAwLVxcdURGRkZdL2cpO1xuICB2YXIgbGVuZ3RoID0gaW5zdGFuY2UubGVuZ3RoIC0gKGhzcCA/IGhzcC5sZW5ndGggOiAwKTtcbiAgaWYgKCEobGVuZ3RoID49IHNjaGVtYS5taW5MZW5ndGgpKSB7XG4gICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgIG5hbWU6ICdtaW5MZW5ndGgnLFxuICAgICAgYXJndW1lbnQ6IHNjaGVtYS5taW5MZW5ndGgsXG4gICAgICBtZXNzYWdlOiBcImRvZXMgbm90IG1lZXQgbWluaW11bSBsZW5ndGggb2YgXCIgKyBzY2hlbWEubWluTGVuZ3RoLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB3aGV0aGVyIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBhdCBtb3N0IG9mIGEgY2VydGFpbiBsZW5ndGgsIHdoZW4gdGhlIGluc3RhbmNlIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cbiAqL1xudmFsaWRhdG9ycy5tYXhMZW5ndGggPSBmdW5jdGlvbiB2YWxpZGF0ZU1heExlbmd0aCAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIGlmICghdGhpcy50eXBlcy5zdHJpbmcoaW5zdGFuY2UpKSByZXR1cm47XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIC8vIFRPRE8gaWYgdGhpcyB3YXMgYWxyZWFkeSBjb21wdXRlZCBpbiBcIm1pbkxlbmd0aFwiLCB1c2UgdGhhdCB2YWx1ZSBpbnN0ZWFkIG9mIHJlLWNvbXB1dGluZ1xuICB2YXIgaHNwID0gaW5zdGFuY2UubWF0Y2goL1tcXHVEQzAwLVxcdURGRkZdL2cpO1xuICB2YXIgbGVuZ3RoID0gaW5zdGFuY2UubGVuZ3RoIC0gKGhzcCA/IGhzcC5sZW5ndGggOiAwKTtcbiAgaWYgKCEobGVuZ3RoIDw9IHNjaGVtYS5tYXhMZW5ndGgpKSB7XG4gICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgIG5hbWU6ICdtYXhMZW5ndGgnLFxuICAgICAgYXJndW1lbnQ6IHNjaGVtYS5tYXhMZW5ndGgsXG4gICAgICBtZXNzYWdlOiBcImRvZXMgbm90IG1lZXQgbWF4aW11bSBsZW5ndGggb2YgXCIgKyBzY2hlbWEubWF4TGVuZ3RoLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB3aGV0aGVyIGluc3RhbmNlIGNvbnRhaW5zIGF0IGxlYXN0IGEgbWluaW11bSBudW1iZXIgb2YgaXRlbXMsIHdoZW4gdGhlIGluc3RhbmNlIGlzIGFuIEFycmF5LlxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cbiAqL1xudmFsaWRhdG9ycy5taW5JdGVtcyA9IGZ1bmN0aW9uIHZhbGlkYXRlTWluSXRlbXMgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICBpZiAoIXRoaXMudHlwZXMuYXJyYXkoaW5zdGFuY2UpKSByZXR1cm47XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIGlmICghKGluc3RhbmNlLmxlbmd0aCA+PSBzY2hlbWEubWluSXRlbXMpKSB7XG4gICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgIG5hbWU6ICdtaW5JdGVtcycsXG4gICAgICBhcmd1bWVudDogc2NoZW1hLm1pbkl0ZW1zLFxuICAgICAgbWVzc2FnZTogXCJkb2VzIG5vdCBtZWV0IG1pbmltdW0gbGVuZ3RoIG9mIFwiICsgc2NoZW1hLm1pbkl0ZW1zLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB3aGV0aGVyIGluc3RhbmNlIGNvbnRhaW5zIG5vIG1vcmUgdGhhbiBhIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zLCB3aGVuIHRoZSBpbnN0YW5jZSBpcyBhbiBBcnJheS5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cbnZhbGlkYXRvcnMubWF4SXRlbXMgPSBmdW5jdGlvbiB2YWxpZGF0ZU1heEl0ZW1zIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgaWYgKCF0aGlzLnR5cGVzLmFycmF5KGluc3RhbmNlKSkgcmV0dXJuO1xuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICBpZiAoIShpbnN0YW5jZS5sZW5ndGggPD0gc2NoZW1hLm1heEl0ZW1zKSkge1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAnbWF4SXRlbXMnLFxuICAgICAgYXJndW1lbnQ6IHNjaGVtYS5tYXhJdGVtcyxcbiAgICAgIG1lc3NhZ2U6IFwiZG9lcyBub3QgbWVldCBtYXhpbXVtIGxlbmd0aCBvZiBcIiArIHNjaGVtYS5tYXhJdGVtcyxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBEZWVwIGNvbXBhcmVzIGFycmF5cyBmb3IgZHVwbGljYXRlc1xuICogQHBhcmFtIHZcbiAqIEBwYXJhbSBpXG4gKiBAcGFyYW0gYVxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHRlc3RBcnJheXMgKHYsIGksIGEpIHtcbiAgdmFyIGosIGxlbiA9IGEubGVuZ3RoO1xuICBmb3IgKGogPSBpICsgMSwgbGVuOyBqIDwgbGVuOyBqKyspIHtcbiAgICBpZiAoaGVscGVycy5kZWVwQ29tcGFyZVN0cmljdCh2LCBhW2pdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciB0aGVyZSBhcmUgbm8gZHVwbGljYXRlcywgd2hlbiB0aGUgaW5zdGFuY2UgaXMgYW4gQXJyYXkuXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxuICovXG52YWxpZGF0b3JzLnVuaXF1ZUl0ZW1zID0gZnVuY3Rpb24gdmFsaWRhdGVVbmlxdWVJdGVtcyAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIGlmIChzY2hlbWEudW5pcXVlSXRlbXMhPT10cnVlKSByZXR1cm47XG4gIGlmICghdGhpcy50eXBlcy5hcnJheShpbnN0YW5jZSkpIHJldHVybjtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgaWYgKCFpbnN0YW5jZS5ldmVyeSh0ZXN0QXJyYXlzKSkge1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAndW5pcXVlSXRlbXMnLFxuICAgICAgbWVzc2FnZTogXCJjb250YWlucyBkdXBsaWNhdGUgaXRlbVwiLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIGZvciB0aGUgcHJlc2VuY2Ugb2YgZGVwZW5kZW5jeSBwcm9wZXJ0aWVzLCBpZiB0aGUgaW5zdGFuY2UgaXMgYW4gb2JqZWN0LlxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIGN0eFxuICogQHJldHVybiB7bnVsbHxWYWxpZGF0b3JSZXN1bHR9XG4gKi9cbnZhbGlkYXRvcnMuZGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gdmFsaWRhdGVEZXBlbmRlbmNpZXMgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICBpZiAoIXRoaXMudHlwZXMub2JqZWN0KGluc3RhbmNlKSkgcmV0dXJuO1xuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzY2hlbWEuZGVwZW5kZW5jaWVzKSB7XG4gICAgaWYgKGluc3RhbmNlW3Byb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGRlcCA9IHNjaGVtYS5kZXBlbmRlbmNpZXNbcHJvcGVydHldO1xuICAgIHZhciBjaGlsZENvbnRleHQgPSBjdHgubWFrZUNoaWxkKGRlcCwgcHJvcGVydHkpO1xuICAgIGlmICh0eXBlb2YgZGVwID09ICdzdHJpbmcnKSB7XG4gICAgICBkZXAgPSBbZGVwXTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVwKSkge1xuICAgICAgZGVwLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgaWYgKGluc3RhbmNlW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgICAgICAgLy8gRklYTUUgdGhlcmUncyB0d28gZGlmZmVyZW50IFwiZGVwZW5kZW5jaWVzXCIgZXJyb3JzIGhlcmUgd2l0aCBzbGlnaHRseSBkaWZmZXJlbnQgb3V0cHV0c1xuICAgICAgICAgICAgLy8gQ2FuIHdlIG1ha2UgdGhlc2UgdGhlIHNhbWU/IE9yIHNob3VsZCB3ZSBjcmVhdGUgZGlmZmVyZW50IGVycm9yIHR5cGVzP1xuICAgICAgICAgICAgbmFtZTogJ2RlcGVuZGVuY2llcycsXG4gICAgICAgICAgICBhcmd1bWVudDogY2hpbGRDb250ZXh0LnByb3BlcnR5UGF0aCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwicHJvcGVydHkgXCIgKyBwcm9wICsgXCIgbm90IGZvdW5kLCByZXF1aXJlZCBieSBcIiArIGNoaWxkQ29udGV4dC5wcm9wZXJ0eVBhdGgsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzID0gdGhpcy52YWxpZGF0ZVNjaGVtYShpbnN0YW5jZSwgZGVwLCBvcHRpb25zLCBjaGlsZENvbnRleHQpO1xuICAgICAgaWYocmVzdWx0Lmluc3RhbmNlICE9PSByZXMuaW5zdGFuY2UpIHJlc3VsdC5pbnN0YW5jZSA9IHJlcy5pbnN0YW5jZTtcbiAgICAgIGlmIChyZXMgJiYgcmVzLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgICAgICBuYW1lOiAnZGVwZW5kZW5jaWVzJyxcbiAgICAgICAgICBhcmd1bWVudDogY2hpbGRDb250ZXh0LnByb3BlcnR5UGF0aCxcbiAgICAgICAgICBtZXNzYWdlOiBcImRvZXMgbm90IG1lZXQgZGVwZW5kZW5jeSByZXF1aXJlZCBieSBcIiArIGNoaWxkQ29udGV4dC5wcm9wZXJ0eVBhdGgsXG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQuaW1wb3J0RXJyb3JzKHJlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB3aGV0aGVyIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBvbmUgb2YgdGhlIGVudW1lcmF0ZWQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybiB7VmFsaWRhdG9yUmVzdWx0fG51bGx9XG4gKi9cbnZhbGlkYXRvcnNbJ2VudW0nXSA9IGZ1bmN0aW9uIHZhbGlkYXRlRW51bSAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIGlmIChpbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYVsnZW51bSddKSkge1xuICAgIHRocm93IG5ldyBTY2hlbWFFcnJvcihcImVudW0gZXhwZWN0cyBhbiBhcnJheVwiLCBzY2hlbWEpO1xuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIGlmICghc2NoZW1hWydlbnVtJ10uc29tZShoZWxwZXJzLmRlZXBDb21wYXJlU3RyaWN0LmJpbmQobnVsbCwgaW5zdGFuY2UpKSkge1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAnZW51bScsXG4gICAgICBhcmd1bWVudDogc2NoZW1hWydlbnVtJ10sXG4gICAgICBtZXNzYWdlOiBcImlzIG5vdCBvbmUgb2YgZW51bSB2YWx1ZXM6IFwiICsgc2NoZW1hWydlbnVtJ10ubWFwKFN0cmluZykuam9pbignLCcpLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB3aGV0aGVyIHRoZSBpbnN0YW5jZSBleGFjdGx5IG1hdGNoZXMgYSBnaXZlbiB2YWx1ZVxuICpcbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybiB7VmFsaWRhdG9yUmVzdWx0fG51bGx9XG4gKi9cbnZhbGlkYXRvcnNbJ2NvbnN0J10gPSBmdW5jdGlvbiB2YWxpZGF0ZUVudW0gKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICBpZiAoaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIGlmICghaGVscGVycy5kZWVwQ29tcGFyZVN0cmljdChzY2hlbWFbJ2NvbnN0J10sIGluc3RhbmNlKSkge1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAnY29uc3QnLFxuICAgICAgYXJndW1lbnQ6IHNjaGVtYVsnY29uc3QnXSxcbiAgICAgIG1lc3NhZ2U6IFwiZG9lcyBub3QgZXhhY3RseSBtYXRjaCBleHBlY3RlZCBjb25zdGFudDogXCIgKyBzY2hlbWFbJ2NvbnN0J10sXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIHdoZXRoZXIgdGhlIGluc3RhbmNlIGlmIG9mIGEgcHJvaGliaXRlZCB0eXBlLlxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIGN0eFxuICogQHJldHVybiB7bnVsbHxWYWxpZGF0b3JSZXN1bHR9XG4gKi9cbnZhbGlkYXRvcnMubm90ID0gdmFsaWRhdG9ycy5kaXNhbGxvdyA9IGZ1bmN0aW9uIHZhbGlkYXRlTm90IChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZihpbnN0YW5jZT09PXVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIHZhciBub3RUeXBlcyA9IHNjaGVtYS5ub3QgfHwgc2NoZW1hLmRpc2FsbG93O1xuICBpZighbm90VHlwZXMpIHJldHVybiBudWxsO1xuICBpZighQXJyYXkuaXNBcnJheShub3RUeXBlcykpIG5vdFR5cGVzPVtub3RUeXBlc107XG4gIG5vdFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAoc2VsZi50ZXN0VHlwZShpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgsIHR5cGUpKSB7XG4gICAgICB2YXIgaWQgPSB0eXBlICYmICh0eXBlLiRpZCB8fCB0eXBlLmlkKTtcbiAgICAgIHZhciBzY2hlbWFJZCA9IGlkIHx8IHR5cGU7XG4gICAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgICBuYW1lOiAnbm90JyxcbiAgICAgICAgYXJndW1lbnQ6IHNjaGVtYUlkLFxuICAgICAgICBtZXNzYWdlOiBcImlzIG9mIHByb2hpYml0ZWQgdHlwZSBcIiArIHNjaGVtYUlkLFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYXR0cmlidXRlO1xuIl0sIm5hbWVzIjpbImhlbHBlcnMiLCJyZXF1aXJlIiwiVmFsaWRhdG9yUmVzdWx0IiwiU2NoZW1hRXJyb3IiLCJhdHRyaWJ1dGUiLCJpZ25vcmVQcm9wZXJ0aWVzIiwidmFsaWRhdG9ycyIsInR5cGUiLCJ2YWxpZGF0ZVR5cGUiLCJpbnN0YW5jZSIsInNjaGVtYSIsIm9wdGlvbnMiLCJjdHgiLCJ1bmRlZmluZWQiLCJyZXN1bHQiLCJ0eXBlcyIsIkFycmF5IiwiaXNBcnJheSIsInNvbWUiLCJ0ZXN0VHlwZSIsImJpbmQiLCJsaXN0IiwibWFwIiwidiIsImlkIiwiJGlkIiwiYWRkRXJyb3IiLCJuYW1lIiwiYXJndW1lbnQiLCJtZXNzYWdlIiwidGVzdFNjaGVtYU5vVGhyb3ciLCJjYWxsYmFjayIsInRocm93RXJyb3IiLCJ0aHJvd0FsbCIsInJlcyIsInZhbGlkYXRlU2NoZW1hIiwidmFsaWQiLCJGdW5jdGlvbiIsImFueU9mIiwidmFsaWRhdGVBbnlPZiIsImlubmVyIiwiaW1wb3J0RXJyb3JzIiwiaSIsInRpdGxlIiwiSlNPTiIsInN0cmluZ2lmeSIsIm5lc3RlZEVycm9ycyIsImpvaW4iLCJhbGxPZiIsInZhbGlkYXRlQWxsT2YiLCJzZWxmIiwiZm9yRWFjaCIsIm1zZyIsImxlbmd0aCIsImVycm9ycyIsIm9uZU9mIiwidmFsaWRhdGVPbmVPZiIsImNvdW50IiwiZmlsdGVyIiwiaWYiLCJ2YWxpZGF0ZUlmIiwiaXNTY2hlbWEiLCJFcnJvciIsImlmVmFsaWQiLCJjYWxsIiwidGhlbiIsIm1ha2VDaGlsZCIsImVsc2UiLCJnZXRFbnVtZXJhYmxlUHJvcGVydHkiLCJvYmplY3QiLCJrZXkiLCJPYmplY3QiLCJoYXNPd25Qcm9wZXJ0eSIsImdldFByb3RvdHlwZU9mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJwcm9wZXJ0eU5hbWVzIiwidmFsaWRhdGVQcm9wZXJ0eU5hbWVzIiwic3Vic2NoZW1hIiwicHJvcGVydHkiLCJwcm9wZXJ0aWVzIiwidmFsaWRhdGVQcm9wZXJ0aWVzIiwicHJlVmFsaWRhdGVQcm9wZXJ0eSIsInByb3AiLCJ0ZXN0QWRkaXRpb25hbFByb3BlcnR5IiwiYWRkaXRpb25hbFByb3BlcnRpZXMiLCJwYXR0ZXJuUHJvcGVydGllcyIsInZhbGlkYXRlUGF0dGVyblByb3BlcnRpZXMiLCJ0ZXN0IiwicGF0dGVybiIsInJlZ2V4cCIsIlJlZ0V4cCIsIl9lIiwidmFsaWRhdGVBZGRpdGlvbmFsUHJvcGVydGllcyIsIm1pblByb3BlcnRpZXMiLCJ2YWxpZGF0ZU1pblByb3BlcnRpZXMiLCJrZXlzIiwibWF4UHJvcGVydGllcyIsInZhbGlkYXRlTWF4UHJvcGVydGllcyIsIml0ZW1zIiwidmFsaWRhdGVJdGVtcyIsImFycmF5IiwiZXZlcnkiLCJ2YWx1ZSIsImFkZGl0aW9uYWxJdGVtcyIsImNvbnRhaW5zIiwidmFsaWRhdGVDb250YWlucyIsIm1pbmltdW0iLCJ2YWxpZGF0ZU1pbmltdW0iLCJudW1iZXIiLCJleGNsdXNpdmVNaW5pbXVtIiwibWF4aW11bSIsInZhbGlkYXRlTWF4aW11bSIsImV4Y2x1c2l2ZU1heGltdW0iLCJ2YWxpZGF0ZUV4Y2x1c2l2ZU1pbmltdW0iLCJ2YWxpZGF0ZUV4Y2x1c2l2ZU1heGltdW0iLCJ2YWxpZGF0ZU11bHRpcGxlT2ZPckRpdmlzYmxlQnkiLCJ2YWxpZGF0aW9uVHlwZSIsImVycm9yTWVzc2FnZSIsInZhbGlkYXRpb25Bcmd1bWVudCIsImluc3RhbmNlRGVjaW1hbHMiLCJnZXREZWNpbWFsUGxhY2VzIiwiZGl2aXNvckRlY2ltYWxzIiwibWF4RGVjaW1hbHMiLCJNYXRoIiwibWF4IiwibXVsdGlwbGllciIsInBvdyIsInJvdW5kIiwibXVsdGlwbGVPZiIsInZhbGlkYXRlTXVsdGlwbGVPZiIsImRpdmlzaWJsZUJ5IiwidmFsaWRhdGVEaXZpc2libGVCeSIsInJlcXVpcmVkIiwidmFsaWRhdGVSZXF1aXJlZCIsIm4iLCJ2YWxpZGF0ZVBhdHRlcm4iLCJzdHJpbmciLCJtYXRjaCIsInRvU3RyaW5nIiwiZm9ybWF0IiwidmFsaWRhdGVGb3JtYXQiLCJkaXNhYmxlRm9ybWF0IiwiaXNGb3JtYXQiLCJtaW5MZW5ndGgiLCJ2YWxpZGF0ZU1pbkxlbmd0aCIsImhzcCIsIm1heExlbmd0aCIsInZhbGlkYXRlTWF4TGVuZ3RoIiwibWluSXRlbXMiLCJ2YWxpZGF0ZU1pbkl0ZW1zIiwibWF4SXRlbXMiLCJ2YWxpZGF0ZU1heEl0ZW1zIiwidGVzdEFycmF5cyIsImEiLCJqIiwibGVuIiwiZGVlcENvbXBhcmVTdHJpY3QiLCJ1bmlxdWVJdGVtcyIsInZhbGlkYXRlVW5pcXVlSXRlbXMiLCJkZXBlbmRlbmNpZXMiLCJ2YWxpZGF0ZURlcGVuZGVuY2llcyIsImRlcCIsImNoaWxkQ29udGV4dCIsInByb3BlcnR5UGF0aCIsInZhbGlkYXRlRW51bSIsIlN0cmluZyIsIm5vdCIsImRpc2FsbG93IiwidmFsaWRhdGVOb3QiLCJub3RUeXBlcyIsInNjaGVtYUlkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonschema/lib/attribute.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonschema/lib/helpers.js":
/*!************************************************!*\
  !*** ./node_modules/jsonschema/lib/helpers.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nvar uri = __webpack_require__(/*! url */ \"url\");\nvar ValidationError = exports.ValidationError = function ValidationError(message, instance, schema, path, name, argument) {\n    if (Array.isArray(path)) {\n        this.path = path;\n        this.property = path.reduce(function(sum, item) {\n            return sum + makeSuffix(item);\n        }, \"instance\");\n    } else if (path !== undefined) {\n        this.property = path;\n    }\n    if (message) {\n        this.message = message;\n    }\n    if (schema) {\n        var id = schema.$id || schema.id;\n        this.schema = id || schema;\n    }\n    if (instance !== undefined) {\n        this.instance = instance;\n    }\n    this.name = name;\n    this.argument = argument;\n    this.stack = this.toString();\n};\nValidationError.prototype.toString = function toString() {\n    return this.property + \" \" + this.message;\n};\nvar ValidatorResult = exports.ValidatorResult = function ValidatorResult(instance, schema, options, ctx) {\n    this.instance = instance;\n    this.schema = schema;\n    this.options = options;\n    this.path = ctx.path;\n    this.propertyPath = ctx.propertyPath;\n    this.errors = [];\n    this.throwError = options && options.throwError;\n    this.throwFirst = options && options.throwFirst;\n    this.throwAll = options && options.throwAll;\n    this.disableFormat = options && options.disableFormat === true;\n};\nValidatorResult.prototype.addError = function addError(detail) {\n    var err;\n    if (typeof detail == \"string\") {\n        err = new ValidationError(detail, this.instance, this.schema, this.path);\n    } else {\n        if (!detail) throw new Error(\"Missing error detail\");\n        if (!detail.message) throw new Error(\"Missing error message\");\n        if (!detail.name) throw new Error(\"Missing validator type\");\n        err = new ValidationError(detail.message, this.instance, this.schema, this.path, detail.name, detail.argument);\n    }\n    this.errors.push(err);\n    if (this.throwFirst) {\n        throw new ValidatorResultError(this);\n    } else if (this.throwError) {\n        throw err;\n    }\n    return err;\n};\nValidatorResult.prototype.importErrors = function importErrors(res) {\n    if (typeof res == \"string\" || res && res.validatorType) {\n        this.addError(res);\n    } else if (res && res.errors) {\n        this.errors = this.errors.concat(res.errors);\n    }\n};\nfunction stringizer(v, i) {\n    return i + \": \" + v.toString() + \"\\n\";\n}\nValidatorResult.prototype.toString = function toString(res) {\n    return this.errors.map(stringizer).join(\"\");\n};\nObject.defineProperty(ValidatorResult.prototype, \"valid\", {\n    get: function() {\n        return !this.errors.length;\n    }\n});\nmodule.exports.ValidatorResultError = ValidatorResultError;\nfunction ValidatorResultError(result) {\n    if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, ValidatorResultError);\n    }\n    this.instance = result.instance;\n    this.schema = result.schema;\n    this.options = result.options;\n    this.errors = result.errors;\n}\nValidatorResultError.prototype = new Error();\nValidatorResultError.prototype.constructor = ValidatorResultError;\nValidatorResultError.prototype.name = \"Validation Error\";\n/**\n * Describes a problem with a Schema which prevents validation of an instance\n * @name SchemaError\n * @constructor\n */ var SchemaError = exports.SchemaError = function SchemaError(msg, schema) {\n    this.message = msg;\n    this.schema = schema;\n    Error.call(this, msg);\n    Error.captureStackTrace(this, SchemaError);\n};\nSchemaError.prototype = Object.create(Error.prototype, {\n    constructor: {\n        value: SchemaError,\n        enumerable: false\n    },\n    name: {\n        value: \"SchemaError\",\n        enumerable: false\n    }\n});\nvar SchemaContext = exports.SchemaContext = function SchemaContext(schema, options, path, base, schemas) {\n    this.schema = schema;\n    this.options = options;\n    if (Array.isArray(path)) {\n        this.path = path;\n        this.propertyPath = path.reduce(function(sum, item) {\n            return sum + makeSuffix(item);\n        }, \"instance\");\n    } else {\n        this.propertyPath = path;\n    }\n    this.base = base;\n    this.schemas = schemas;\n};\nSchemaContext.prototype.resolve = function resolve(target) {\n    return uri.resolve(this.base, target);\n};\nSchemaContext.prototype.makeChild = function makeChild(schema, propertyName) {\n    var path = propertyName === undefined ? this.path : this.path.concat([\n        propertyName\n    ]);\n    var id = schema.$id || schema.id;\n    var base = uri.resolve(this.base, id || \"\");\n    var ctx = new SchemaContext(schema, this.options, path, base, Object.create(this.schemas));\n    if (id && !ctx.schemas[base]) {\n        ctx.schemas[base] = schema;\n    }\n    return ctx;\n};\nvar FORMAT_REGEXPS = exports.FORMAT_REGEXPS = {\n    // 7.3.1. Dates, Times, and Duration\n    \"date-time\": /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])[tT ](2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])(\\.\\d+)?([zZ]|[+-]([0-5][0-9]):(60|[0-5][0-9]))$/,\n    \"date\": /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])$/,\n    \"time\": /^(2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])$/,\n    \"duration\": /P(T\\d+(H(\\d+M(\\d+S)?)?|M(\\d+S)?|S)|\\d+(D|M(\\d+D)?|Y(\\d+M(\\d+D)?)?)(T\\d+(H(\\d+M(\\d+S)?)?|M(\\d+S)?|S))?|\\d+W)/i,\n    // 7.3.2. Email Addresses\n    // TODO: fix the email production\n    \"email\": /^(?:[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+\\.)*[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!\\.)){0,61}[a-zA-Z0-9]?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\\[(?:(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\.){3}(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\]))$/,\n    \"idn-email\": /^(\"(?:[!#-\\[\\]-\\u{10FFFF}]|\\\\[\\t -\\u{10FFFF}])*\"|[!#-'*+\\-/-9=?A-Z\\^-\\u{10FFFF}](?:\\.?[!#-'*+\\-/-9=?A-Z\\^-\\u{10FFFF}])*)@([!#-'*+\\-/-9=?A-Z\\^-\\u{10FFFF}](?:\\.?[!#-'*+\\-/-9=?A-Z\\^-\\u{10FFFF}])*|\\[[!-Z\\^-\\u{10FFFF}]*\\])$/u,\n    // 7.3.3. Hostnames\n    // 7.3.4. IP Addresses\n    \"ip-address\": /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,\n    // FIXME whitespace is invalid\n    \"ipv6\": /^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/,\n    // 7.3.5. Resource Identifiers\n    // TODO: A more accurate regular expression for \"uri\" goes:\n    // [A-Za-z][+\\-.0-9A-Za-z]*:((/(/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\\])?)(:\\d*)?)?)?#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|(/(/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\\])?)(:\\d*)?[/?]|[!$&-.0-;=?-Z_a-z~])|/?%[0-9A-Fa-f]{2}|[!$&-.0-;=?-Z_a-z~])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*(#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*)?|/(/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+(:\\d*)?|(\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\\])?:\\d*|\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\\])?)?)?\n    \"uri\": /^[a-zA-Z][a-zA-Z0-9+.-]*:[^\\s]*$/,\n    \"uri-reference\": /^(((([A-Za-z][+\\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~]|[/?])|\\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|([A-Za-z][+\\-.0-9A-Za-z]*:?)?)|([A-Za-z][+\\-.0-9A-Za-z]*:)?\\/((%[0-9A-Fa-f]{2}|\\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\\])?)(:\\d*)?[/?]|[!$&-.0-;=?-Z_a-z~])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|(\\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\\])?)(:\\d*)?)?))#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|(([A-Za-z][+\\-.0-9A-Za-z]*)?%[0-9A-Fa-f]{2}|[!$&-.0-9;=@_~]|[A-Za-z][+\\-.0-9A-Za-z]*[!$&-*,;=@_~])(%[0-9A-Fa-f]{2}|[!$&-.0-9;=@-Z_a-z~])*((([/?](%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*)?#|[/?])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*)?|([A-Za-z][+\\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~]|[/?])|\\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|([A-Za-z][+\\-.0-9A-Za-z]*:)?\\/((%[0-9A-Fa-f]{2}|\\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\\])?)(:\\d*)?[/?]|[!$&-.0-;=?-Z_a-z~])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|\\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+(:\\d*)?|(\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\\])?:\\d*|\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\\])?)?|[A-Za-z][+\\-.0-9A-Za-z]*:?)?$/,\n    \"iri\": /^[a-zA-Z][a-zA-Z0-9+.-]*:[^\\s]*$/,\n    \"iri-reference\": /^(((([A-Za-z][+\\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~-\\u{10FFFF}]|[/?])|\\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\\u{10FFFF}])*|([A-Za-z][+\\-.0-9A-Za-z]*:?)?)|([A-Za-z][+\\-.0-9A-Za-z]*:)?\\/((%[0-9A-Fa-f]{2}|\\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\\u{10FFFF}])+|(\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~-\\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\\])?)(:\\d*)?[/?]|[!$&-.0-;=?-Z_a-z~-\\u{10FFFF}])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\\u{10FFFF}])*|(\\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\\u{10FFFF}])+|(\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~-\\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\\])?)(:\\d*)?)?))#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\\u{10FFFF}])*|(([A-Za-z][+\\-.0-9A-Za-z]*)?%[0-9A-Fa-f]{2}|[!$&-.0-9;=@_~-\\u{10FFFF}]|[A-Za-z][+\\-.0-9A-Za-z]*[!$&-*,;=@_~-\\u{10FFFF}])(%[0-9A-Fa-f]{2}|[!$&-.0-9;=@-Z_a-z~-\\u{10FFFF}])*((([/?](%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\\u{10FFFF}])*)?#|[/?])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\\u{10FFFF}])*)?|([A-Za-z][+\\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~-\\u{10FFFF}]|[/?])|\\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\\u{10FFFF}])*|([A-Za-z][+\\-.0-9A-Za-z]*:)?\\/((%[0-9A-Fa-f]{2}|\\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\\u{10FFFF}])+|(\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~-\\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\\])?)(:\\d*)?[/?]|[!$&-.0-;=?-Z_a-z~-\\u{10FFFF}])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\\u{10FFFF}])*|\\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\\u{10FFFF}])+(:\\d*)?|(\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~-\\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\\])?:\\d*|\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~-\\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\\])?)?|[A-Za-z][+\\-.0-9A-Za-z]*:?)?$/u,\n    \"uuid\": /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i,\n    // 7.3.6. uri-template\n    \"uri-template\": /(%[0-9a-f]{2}|[!#$&(-;=?@\\[\\]_a-z~]|\\{[!#&+,./;=?@|]?(%[0-9a-f]{2}|[0-9_a-z])(\\.?(%[0-9a-f]{2}|[0-9_a-z]))*(:[1-9]\\d{0,3}|\\*)?(,(%[0-9a-f]{2}|[0-9_a-z])(\\.?(%[0-9a-f]{2}|[0-9_a-z]))*(:[1-9]\\d{0,3}|\\*)?)*\\})*/iu,\n    // 7.3.7. JSON Pointers\n    \"json-pointer\": /^(\\/([\\x00-\\x2e0-@\\[-}\\x7f]|~[01])*)*$/iu,\n    \"relative-json-pointer\": /^\\d+(#|(\\/([\\x00-\\x2e0-@\\[-}\\x7f]|~[01])*)*)$/iu,\n    // hostname regex from: http://stackoverflow.com/a/1420225/5628\n    \"hostname\": /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/,\n    \"host-name\": /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/,\n    \"utc-millisec\": function(input) {\n        return typeof input === \"string\" && parseFloat(input) === parseInt(input, 10) && !isNaN(input);\n    },\n    // 7.3.8. regex\n    \"regex\": function(input) {\n        var result = true;\n        try {\n            new RegExp(input);\n        } catch (e) {\n            result = false;\n        }\n        return result;\n    },\n    // Other definitions\n    // \"style\" was removed from JSON Schema in draft-4 and is deprecated\n    \"style\": /[\\r\\n\\t ]*[^\\r\\n\\t ][^:]*:[\\r\\n\\t ]*[^\\r\\n\\t ;]*[\\r\\n\\t ]*;?/,\n    // \"color\" was removed from JSON Schema in draft-4 and is deprecated\n    \"color\": /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/,\n    \"phone\": /^\\+(?:[0-9] ?){6,14}[0-9]$/,\n    \"alpha\": /^[a-zA-Z]+$/,\n    \"alphanumeric\": /^[a-zA-Z0-9]+$/\n};\nFORMAT_REGEXPS.regexp = FORMAT_REGEXPS.regex;\nFORMAT_REGEXPS.pattern = FORMAT_REGEXPS.regex;\nFORMAT_REGEXPS.ipv4 = FORMAT_REGEXPS[\"ip-address\"];\nexports.isFormat = function isFormat(input, format, validator) {\n    if (typeof input === \"string\" && FORMAT_REGEXPS[format] !== undefined) {\n        if (FORMAT_REGEXPS[format] instanceof RegExp) {\n            return FORMAT_REGEXPS[format].test(input);\n        }\n        if (typeof FORMAT_REGEXPS[format] === \"function\") {\n            return FORMAT_REGEXPS[format](input);\n        }\n    } else if (validator && validator.customFormats && typeof validator.customFormats[format] === \"function\") {\n        return validator.customFormats[format](input);\n    }\n    return true;\n};\nvar makeSuffix = exports.makeSuffix = function makeSuffix(key) {\n    key = key.toString();\n    // This function could be capable of outputting valid a ECMAScript string, but the\n    // resulting code for testing which form to use would be tens of thousands of characters long\n    // That means this will use the name form for some illegal forms\n    if (!key.match(/[.\\s\\[\\]]/) && !key.match(/^[\\d]/)) {\n        return \".\" + key;\n    }\n    if (key.match(/^\\d+$/)) {\n        return \"[\" + key + \"]\";\n    }\n    return \"[\" + JSON.stringify(key) + \"]\";\n};\nexports.deepCompareStrict = function deepCompareStrict(a, b) {\n    if (typeof a !== typeof b) {\n        return false;\n    }\n    if (Array.isArray(a)) {\n        if (!Array.isArray(b)) {\n            return false;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        return a.every(function(v, i) {\n            return deepCompareStrict(a[i], b[i]);\n        });\n    }\n    if (typeof a === \"object\") {\n        if (!a || !b) {\n            return a === b;\n        }\n        var aKeys = Object.keys(a);\n        var bKeys = Object.keys(b);\n        if (aKeys.length !== bKeys.length) {\n            return false;\n        }\n        return aKeys.every(function(v) {\n            return deepCompareStrict(a[v], b[v]);\n        });\n    }\n    return a === b;\n};\nfunction deepMerger(target, dst, e, i) {\n    if (typeof e === \"object\") {\n        dst[i] = deepMerge(target[i], e);\n    } else {\n        if (target.indexOf(e) === -1) {\n            dst.push(e);\n        }\n    }\n}\nfunction copyist(src, dst, key) {\n    dst[key] = src[key];\n}\nfunction copyistWithDeepMerge(target, src, dst, key) {\n    if (typeof src[key] !== \"object\" || !src[key]) {\n        dst[key] = src[key];\n    } else {\n        if (!target[key]) {\n            dst[key] = src[key];\n        } else {\n            dst[key] = deepMerge(target[key], src[key]);\n        }\n    }\n}\nfunction deepMerge(target, src) {\n    var array = Array.isArray(src);\n    var dst = array && [] || {};\n    if (array) {\n        target = target || [];\n        dst = dst.concat(target);\n        src.forEach(deepMerger.bind(null, target, dst));\n    } else {\n        if (target && typeof target === \"object\") {\n            Object.keys(target).forEach(copyist.bind(null, target, dst));\n        }\n        Object.keys(src).forEach(copyistWithDeepMerge.bind(null, target, src, dst));\n    }\n    return dst;\n}\nmodule.exports.deepMerge = deepMerge;\n/**\n * Validates instance against the provided schema\n * Implements URI+JSON Pointer encoding, e.g. \"%7e\"=\"~0\"=>\"~\", \"~1\"=\"%2f\"=>\"/\"\n * @param o\n * @param s The path to walk o along\n * @return any\n */ exports.objectGetPath = function objectGetPath(o, s) {\n    var parts = s.split(\"/\").slice(1);\n    var k;\n    while(typeof (k = parts.shift()) == \"string\"){\n        var n = decodeURIComponent(k.replace(/~0/, \"~\").replace(/~1/g, \"/\"));\n        if (!(n in o)) return;\n        o = o[n];\n    }\n    return o;\n};\nfunction pathEncoder(v) {\n    return \"/\" + encodeURIComponent(v).replace(/~/g, \"%7E\");\n}\n/**\n * Accept an Array of property names and return a JSON Pointer URI fragment\n * @param Array a\n * @return {String}\n */ exports.encodePath = function encodePointer(a) {\n    // ~ must be encoded explicitly because hacks\n    // the slash is encoded by encodeURIComponent\n    return a.map(pathEncoder).join(\"\");\n};\n/**\n * Calculate the number of decimal places a number uses\n * We need this to get correct results out of multipleOf and divisibleBy\n * when either figure is has decimal places, due to IEEE-754 float issues.\n * @param number\n * @returns {number}\n */ exports.getDecimalPlaces = function getDecimalPlaces(number) {\n    var decimalPlaces = 0;\n    if (isNaN(number)) return decimalPlaces;\n    if (typeof number !== \"number\") {\n        number = Number(number);\n    }\n    var parts = number.toString().split(\"e\");\n    if (parts.length === 2) {\n        if (parts[1][0] !== \"-\") {\n            return decimalPlaces;\n        } else {\n            decimalPlaces = Number(parts[1].slice(1));\n        }\n    }\n    var decimalParts = parts[0].split(\".\");\n    if (decimalParts.length === 2) {\n        decimalPlaces += decimalParts[1].length;\n    }\n    return decimalPlaces;\n};\nexports.isSchema = function isSchema(val) {\n    return typeof val === \"object\" && val || typeof val === \"boolean\";\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbnNjaGVtYS9saWIvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLE1BQU1DLG1CQUFPQSxDQUFDO0FBRWxCLElBQUlDLGtCQUFrQkMsdUJBQXVCLEdBQUcsU0FBU0QsZ0JBQWlCRSxPQUFPLEVBQUVDLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsUUFBUTtJQUN2SCxJQUFHQyxNQUFNQyxPQUFPLENBQUNKLE9BQU07UUFDckIsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDSyxRQUFRLEdBQUdMLEtBQUtNLE1BQU0sQ0FBQyxTQUFTQyxHQUFHLEVBQUVDLElBQUk7WUFDNUMsT0FBT0QsTUFBTUUsV0FBV0Q7UUFDMUIsR0FBRztJQUNMLE9BQU0sSUFBR1IsU0FBU1UsV0FBVTtRQUMxQixJQUFJLENBQUNMLFFBQVEsR0FBR0w7SUFDbEI7SUFDQSxJQUFJSCxTQUFTO1FBQ1gsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ2pCO0lBQ0EsSUFBSUUsUUFBUTtRQUNWLElBQUlZLEtBQUtaLE9BQU9hLEdBQUcsSUFBSWIsT0FBT1ksRUFBRTtRQUNoQyxJQUFJLENBQUNaLE1BQU0sR0FBR1ksTUFBTVo7SUFDdEI7SUFDQSxJQUFJRCxhQUFhWSxXQUFXO1FBQzFCLElBQUksQ0FBQ1osUUFBUSxHQUFHQTtJQUNsQjtJQUNBLElBQUksQ0FBQ0csSUFBSSxHQUFHQTtJQUNaLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtJQUNoQixJQUFJLENBQUNXLEtBQUssR0FBRyxJQUFJLENBQUNDLFFBQVE7QUFDNUI7QUFFQW5CLGdCQUFnQm9CLFNBQVMsQ0FBQ0QsUUFBUSxHQUFHLFNBQVNBO0lBQzVDLE9BQU8sSUFBSSxDQUFDVCxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUNSLE9BQU87QUFDM0M7QUFFQSxJQUFJbUIsa0JBQWtCcEIsdUJBQXVCLEdBQUcsU0FBU29CLGdCQUFn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Oi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9qc29uc2NoZW1hL2xpYi9oZWxwZXJzLmpzP2ZiNjYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXJpID0gcmVxdWlyZSgndXJsJyk7XG5cbnZhciBWYWxpZGF0aW9uRXJyb3IgPSBleHBvcnRzLlZhbGlkYXRpb25FcnJvciA9IGZ1bmN0aW9uIFZhbGlkYXRpb25FcnJvciAobWVzc2FnZSwgaW5zdGFuY2UsIHNjaGVtYSwgcGF0aCwgbmFtZSwgYXJndW1lbnQpIHtcbiAgaWYoQXJyYXkuaXNBcnJheShwYXRoKSl7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLnByb3BlcnR5ID0gcGF0aC5yZWR1Y2UoZnVuY3Rpb24oc3VtLCBpdGVtKXtcbiAgICAgIHJldHVybiBzdW0gKyBtYWtlU3VmZml4KGl0ZW0pO1xuICAgIH0sICdpbnN0YW5jZScpO1xuICB9ZWxzZSBpZihwYXRoICE9PSB1bmRlZmluZWQpe1xuICAgIHRoaXMucHJvcGVydHkgPSBwYXRoO1xuICB9XG4gIGlmIChtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuICBpZiAoc2NoZW1hKSB7XG4gICAgdmFyIGlkID0gc2NoZW1hLiRpZCB8fCBzY2hlbWEuaWQ7XG4gICAgdGhpcy5zY2hlbWEgPSBpZCB8fCBzY2hlbWE7XG4gIH1cbiAgaWYgKGluc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gIH1cbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICB0aGlzLnN0YWNrID0gdGhpcy50b1N0cmluZygpO1xufTtcblxuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdGhpcy5wcm9wZXJ0eSArICcgJyArIHRoaXMubWVzc2FnZTtcbn07XG5cbnZhciBWYWxpZGF0b3JSZXN1bHQgPSBleHBvcnRzLlZhbGlkYXRvclJlc3VsdCA9IGZ1bmN0aW9uIFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5wYXRoID0gY3R4LnBhdGg7XG4gIHRoaXMucHJvcGVydHlQYXRoID0gY3R4LnByb3BlcnR5UGF0aDtcbiAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgdGhpcy50aHJvd0Vycm9yID0gb3B0aW9ucyAmJiBvcHRpb25zLnRocm93RXJyb3I7XG4gIHRoaXMudGhyb3dGaXJzdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy50aHJvd0ZpcnN0O1xuICB0aGlzLnRocm93QWxsID0gb3B0aW9ucyAmJiBvcHRpb25zLnRocm93QWxsO1xuICB0aGlzLmRpc2FibGVGb3JtYXQgPSBvcHRpb25zICYmIG9wdGlvbnMuZGlzYWJsZUZvcm1hdCA9PT0gdHJ1ZTtcbn07XG5cblZhbGlkYXRvclJlc3VsdC5wcm90b3R5cGUuYWRkRXJyb3IgPSBmdW5jdGlvbiBhZGRFcnJvcihkZXRhaWwpIHtcbiAgdmFyIGVycjtcbiAgaWYgKHR5cGVvZiBkZXRhaWwgPT0gJ3N0cmluZycpIHtcbiAgICBlcnIgPSBuZXcgVmFsaWRhdGlvbkVycm9yKGRldGFpbCwgdGhpcy5pbnN0YW5jZSwgdGhpcy5zY2hlbWEsIHRoaXMucGF0aCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFkZXRhaWwpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBlcnJvciBkZXRhaWwnKTtcbiAgICBpZiAoIWRldGFpbC5tZXNzYWdlKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZXJyb3IgbWVzc2FnZScpO1xuICAgIGlmICghZGV0YWlsLm5hbWUpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB2YWxpZGF0b3IgdHlwZScpO1xuICAgIGVyciA9IG5ldyBWYWxpZGF0aW9uRXJyb3IoZGV0YWlsLm1lc3NhZ2UsIHRoaXMuaW5zdGFuY2UsIHRoaXMuc2NoZW1hLCB0aGlzLnBhdGgsIGRldGFpbC5uYW1lLCBkZXRhaWwuYXJndW1lbnQpO1xuICB9XG5cbiAgdGhpcy5lcnJvcnMucHVzaChlcnIpO1xuICBpZiAodGhpcy50aHJvd0ZpcnN0KSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRvclJlc3VsdEVycm9yKHRoaXMpO1xuICB9ZWxzZSBpZih0aGlzLnRocm93RXJyb3Ipe1xuICAgIHRocm93IGVycjtcbiAgfVxuICByZXR1cm4gZXJyO1xufTtcblxuVmFsaWRhdG9yUmVzdWx0LnByb3RvdHlwZS5pbXBvcnRFcnJvcnMgPSBmdW5jdGlvbiBpbXBvcnRFcnJvcnMocmVzKSB7XG4gIGlmICh0eXBlb2YgcmVzID09ICdzdHJpbmcnIHx8IChyZXMgJiYgcmVzLnZhbGlkYXRvclR5cGUpKSB7XG4gICAgdGhpcy5hZGRFcnJvcihyZXMpO1xuICB9IGVsc2UgaWYgKHJlcyAmJiByZXMuZXJyb3JzKSB7XG4gICAgdGhpcy5lcnJvcnMgPSB0aGlzLmVycm9ycy5jb25jYXQocmVzLmVycm9ycyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHN0cmluZ2l6ZXIgKHYsaSl7XG4gIHJldHVybiBpKyc6ICcrdi50b1N0cmluZygpKydcXG4nO1xufVxuVmFsaWRhdG9yUmVzdWx0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHJlcykge1xuICByZXR1cm4gdGhpcy5lcnJvcnMubWFwKHN0cmluZ2l6ZXIpLmpvaW4oJycpO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZhbGlkYXRvclJlc3VsdC5wcm90b3R5cGUsIFwidmFsaWRcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMuZXJyb3JzLmxlbmd0aDtcbn0gfSk7XG5cbm1vZHVsZS5leHBvcnRzLlZhbGlkYXRvclJlc3VsdEVycm9yID0gVmFsaWRhdG9yUmVzdWx0RXJyb3I7XG5mdW5jdGlvbiBWYWxpZGF0b3JSZXN1bHRFcnJvcihyZXN1bHQpIHtcbiAgaWYoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2Upe1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFZhbGlkYXRvclJlc3VsdEVycm9yKTtcbiAgfVxuICB0aGlzLmluc3RhbmNlID0gcmVzdWx0Lmluc3RhbmNlO1xuICB0aGlzLnNjaGVtYSA9IHJlc3VsdC5zY2hlbWE7XG4gIHRoaXMub3B0aW9ucyA9IHJlc3VsdC5vcHRpb25zO1xuICB0aGlzLmVycm9ycyA9IHJlc3VsdC5lcnJvcnM7XG59XG5WYWxpZGF0b3JSZXN1bHRFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblZhbGlkYXRvclJlc3VsdEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFZhbGlkYXRvclJlc3VsdEVycm9yO1xuVmFsaWRhdG9yUmVzdWx0RXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIlZhbGlkYXRpb24gRXJyb3JcIjtcblxuLyoqXG4gKiBEZXNjcmliZXMgYSBwcm9ibGVtIHdpdGggYSBTY2hlbWEgd2hpY2ggcHJldmVudHMgdmFsaWRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICogQG5hbWUgU2NoZW1hRXJyb3JcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU2NoZW1hRXJyb3IgPSBleHBvcnRzLlNjaGVtYUVycm9yID0gZnVuY3Rpb24gU2NoZW1hRXJyb3IgKG1zZywgc2NoZW1hKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1zZztcbiAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gIEVycm9yLmNhbGwodGhpcywgbXNnKTtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgU2NoZW1hRXJyb3IpO1xufTtcblNjaGVtYUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlLFxuICB7XG4gICAgY29uc3RydWN0b3I6IHt2YWx1ZTogU2NoZW1hRXJyb3IsIGVudW1lcmFibGU6IGZhbHNlfSxcbiAgICBuYW1lOiB7dmFsdWU6ICdTY2hlbWFFcnJvcicsIGVudW1lcmFibGU6IGZhbHNlfSxcbiAgfSk7XG5cbnZhciBTY2hlbWFDb250ZXh0ID0gZXhwb3J0cy5TY2hlbWFDb250ZXh0ID0gZnVuY3Rpb24gU2NoZW1hQ29udGV4dCAoc2NoZW1hLCBvcHRpb25zLCBwYXRoLCBiYXNlLCBzY2hlbWFzKSB7XG4gIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICBpZihBcnJheS5pc0FycmF5KHBhdGgpKXtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMucHJvcGVydHlQYXRoID0gcGF0aC5yZWR1Y2UoZnVuY3Rpb24oc3VtLCBpdGVtKXtcbiAgICAgIHJldHVybiBzdW0gKyBtYWtlU3VmZml4KGl0ZW0pO1xuICAgIH0sICdpbnN0YW5jZScpO1xuICB9ZWxzZXtcbiAgICB0aGlzLnByb3BlcnR5UGF0aCA9IHBhdGg7XG4gIH1cbiAgdGhpcy5iYXNlID0gYmFzZTtcbiAgdGhpcy5zY2hlbWFzID0gc2NoZW1hcztcbn07XG5cblNjaGVtYUNvbnRleHQucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlICh0YXJnZXQpIHtcbiAgcmV0dXJuIHVyaS5yZXNvbHZlKHRoaXMuYmFzZSwgdGFyZ2V0KTtcbn07XG5cblNjaGVtYUNvbnRleHQucHJvdG90eXBlLm1ha2VDaGlsZCA9IGZ1bmN0aW9uIG1ha2VDaGlsZChzY2hlbWEsIHByb3BlcnR5TmFtZSl7XG4gIHZhciBwYXRoID0gKHByb3BlcnR5TmFtZT09PXVuZGVmaW5lZCkgPyB0aGlzLnBhdGggOiB0aGlzLnBhdGguY29uY2F0KFtwcm9wZXJ0eU5hbWVdKTtcbiAgdmFyIGlkID0gc2NoZW1hLiRpZCB8fCBzY2hlbWEuaWQ7XG4gIHZhciBiYXNlID0gdXJpLnJlc29sdmUodGhpcy5iYXNlLCBpZHx8JycpO1xuICB2YXIgY3R4ID0gbmV3IFNjaGVtYUNvbnRleHQoc2NoZW1hLCB0aGlzLm9wdGlvbnMsIHBhdGgsIGJhc2UsIE9iamVjdC5jcmVhdGUodGhpcy5zY2hlbWFzKSk7XG4gIGlmKGlkICYmICFjdHguc2NoZW1hc1tiYXNlXSl7XG4gICAgY3R4LnNjaGVtYXNbYmFzZV0gPSBzY2hlbWE7XG4gIH1cbiAgcmV0dXJuIGN0eDtcbn07XG5cbnZhciBGT1JNQVRfUkVHRVhQUyA9IGV4cG9ydHMuRk9STUFUX1JFR0VYUFMgPSB7XG4gIC8vIDcuMy4xLiBEYXRlcywgVGltZXMsIGFuZCBEdXJhdGlvblxuICAnZGF0ZS10aW1lJzogL15cXGR7NH0tKD86MFswLTldezF9fDFbMC0yXXsxfSktKDNbMDFdfDBbMS05XXxbMTJdWzAtOV0pW3RUIF0oMlswLTRdfFswMV1bMC05XSk6KFswLTVdWzAtOV0pOig2MHxbMC01XVswLTldKShcXC5cXGQrKT8oW3paXXxbKy1dKFswLTVdWzAtOV0pOig2MHxbMC01XVswLTldKSkkLyxcbiAgJ2RhdGUnOiAvXlxcZHs0fS0oPzowWzAtOV17MX18MVswLTJdezF9KS0oM1swMV18MFsxLTldfFsxMl1bMC05XSkkLyxcbiAgJ3RpbWUnOiAvXigyWzAtNF18WzAxXVswLTldKTooWzAtNV1bMC05XSk6KDYwfFswLTVdWzAtOV0pJC8sXG4gICdkdXJhdGlvbic6IC9QKFRcXGQrKEgoXFxkK00oXFxkK1MpPyk/fE0oXFxkK1MpP3xTKXxcXGQrKER8TShcXGQrRCk/fFkoXFxkK00oXFxkK0QpPyk/KShUXFxkKyhIKFxcZCtNKFxcZCtTKT8pP3xNKFxcZCtTKT98UykpP3xcXGQrVykvaSxcblxuICAvLyA3LjMuMi4gRW1haWwgQWRkcmVzc2VzXG4gIC8vIFRPRE86IGZpeCB0aGUgZW1haWwgcHJvZHVjdGlvblxuICAnZW1haWwnOiAvXig/OltcXHdcXCFcXCNcXCRcXCVcXCZcXCdcXCpcXCtcXC1cXC9cXD1cXD9cXF5cXGBcXHtcXHxcXH1cXH5dK1xcLikqW1xcd1xcIVxcI1xcJFxcJVxcJlxcJ1xcKlxcK1xcLVxcL1xcPVxcP1xcXlxcYFxce1xcfFxcfVxcfl0rQCg/Oig/Oig/OlthLXpBLVowLTldKD86W2EtekEtWjAtOVxcLV0oPyFcXC4pKXswLDYxfVthLXpBLVowLTldP1xcLikrW2EtekEtWjAtOV0oPzpbYS16QS1aMC05XFwtXSg/ISQpKXswLDYxfVthLXpBLVowLTldPyl8KD86XFxbKD86KD86WzAxXT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSlcXC4pezN9KD86WzAxXT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSlcXF0pKSQvLFxuICAnaWRuLWVtYWlsJzogL14oXCIoPzpbISMtXFxbXFxdLVxcdXsxMEZGRkZ9XXxcXFxcW1xcdCAtXFx1ezEwRkZGRn1dKSpcInxbISMtJyorXFwtLy05PT9BLVpcXF4tXFx1ezEwRkZGRn1dKD86XFwuP1shIy0nKitcXC0vLTk9P0EtWlxcXi1cXHV7MTBGRkZGfV0pKilAKFshIy0nKitcXC0vLTk9P0EtWlxcXi1cXHV7MTBGRkZGfV0oPzpcXC4/WyEjLScqK1xcLS8tOT0/QS1aXFxeLVxcdXsxMEZGRkZ9XSkqfFxcW1shLVpcXF4tXFx1ezEwRkZGRn1dKlxcXSkkL3UsXG5cbiAgLy8gNy4zLjMuIEhvc3RuYW1lc1xuXG4gIC8vIDcuMy40LiBJUCBBZGRyZXNzZXNcbiAgJ2lwLWFkZHJlc3MnOiAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSQvLFxuICAvLyBGSVhNRSB3aGl0ZXNwYWNlIGlzIGludmFsaWRcbiAgJ2lwdjYnOiAvXlxccyooKChbMC05QS1GYS1mXXsxLDR9Oil7N30oWzAtOUEtRmEtZl17MSw0fXw6KSl8KChbMC05QS1GYS1mXXsxLDR9Oil7Nn0oOlswLTlBLUZhLWZdezEsNH18KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXs1fSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDJ9KXw6KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXs0fSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDN9KXwoKDpbMC05QS1GYS1mXXsxLDR9KT86KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05QS1GYS1mXXsxLDR9Oil7M30oKCg6WzAtOUEtRmEtZl17MSw0fSl7MSw0fSl8KCg6WzAtOUEtRmEtZl17MSw0fSl7MCwyfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXsyfSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDV9KXwoKDpbMC05QS1GYS1mXXsxLDR9KXswLDN9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezF9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsNn0pfCgoOlswLTlBLUZhLWZdezEsNH0pezAsNH06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KDooKCg6WzAtOUEtRmEtZl17MSw0fSl7MSw3fSl8KCg6WzAtOUEtRmEtZl17MSw0fSl7MCw1fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkoJS4rKT9cXHMqJC8sXG5cbiAgLy8gNy4zLjUuIFJlc291cmNlIElkZW50aWZpZXJzXG4gIC8vIFRPRE86IEEgbW9yZSBhY2N1cmF0ZSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIFwidXJpXCIgZ29lczpcbiAgLy8gW0EtWmEtel1bK1xcLS4wLTlBLVphLXpdKjooKC8oLygoJVswLTlBLUZhLWZdezJ9fFshJCYtLjAtOTs9QS1aX2Eten5dKSt8KFxcWygoW1Z2XVswLTlBLUZhLWZdK1xcLlshJCYtLjAtOz1BLVpfYS16fl0rKT98Wy4wLTpBLUZhLWZdKylcXF0pPykoOlxcZCopPyk/KT8jKCVbMC05QS1GYS1mXXsyfXxbISQmLTs9Py1aX2Eten5dKSp8KC8oLygoJVswLTlBLUZhLWZdezJ9fFshJCYtLjAtOTs9QS1aX2Eten5dKSt8KFxcWygoW1Z2XVswLTlBLUZhLWZdK1xcLlshJCYtLjAtOz1BLVpfYS16fl0rKT98Wy4wLTpBLUZhLWZdKylcXF0pPykoOlxcZCopP1svP118WyEkJi0uMC07PT8tWl9hLXp+XSl8Lz8lWzAtOUEtRmEtZl17Mn18WyEkJi0uMC07PT8tWl9hLXp+XSkoJVswLTlBLUZhLWZdezJ9fFshJCYtOz0/LVpfYS16fl0pKigjKCVbMC05QS1GYS1mXXsyfXxbISQmLTs9Py1aX2Eten5dKSopP3wvKC8oKCVbMC05QS1GYS1mXXsyfXxbISQmLS4wLTk7PUEtWl9hLXp+XSkrKDpcXGQqKT98KFxcWygoW1Z2XVswLTlBLUZhLWZdK1xcLlshJCYtLjAtOz1BLVpfYS16fl0rKT98Wy4wLTpBLUZhLWZdKylcXF0pPzpcXGQqfFxcWygoW1Z2XVswLTlBLUZhLWZdK1xcLlshJCYtLjAtOz1BLVpfYS16fl0rKT98Wy4wLTpBLUZhLWZdKylcXF0pPyk/KT9cbiAgJ3VyaSc6IC9eW2EtekEtWl1bYS16QS1aMC05Ky4tXSo6W15cXHNdKiQvLFxuICAndXJpLXJlZmVyZW5jZSc6IC9eKCgoKFtBLVphLXpdWytcXC0uMC05QS1aYS16XSooOiVbMC05QS1GYS1mXXsyfXw6WyEkJi0uMC07PT8tWl9hLXp+XXxbLz9dKXxcXD8pKCVbMC05QS1GYS1mXXsyfXxbISQmLTs9Py1aX2Eten5dKSp8KFtBLVphLXpdWytcXC0uMC05QS1aYS16XSo6Pyk/KXwoW0EtWmEtel1bK1xcLS4wLTlBLVphLXpdKjopP1xcLygoJVswLTlBLUZhLWZdezJ9fFxcLygoJVswLTlBLUZhLWZdezJ9fFshJCYtLjAtOTs9QS1aX2Eten5dKSt8KFxcWygoW1Z2XVswLTlBLUZhLWZdK1xcLlshJCYtLjAtOz1BLVpfYS16fl0rKT98Wy4wLTpBLUZhLWZdKylcXF0pPykoOlxcZCopP1svP118WyEkJi0uMC07PT8tWl9hLXp+XSkoJVswLTlBLUZhLWZdezJ9fFshJCYtOz0/LVpfYS16fl0pKnwoXFwvKCglWzAtOUEtRmEtZl17Mn18WyEkJi0uMC05Oz1BLVpfYS16fl0pK3woXFxbKChbVnZdWzAtOUEtRmEtZl0rXFwuWyEkJi0uMC07PUEtWl9hLXp+XSspP3xbLjAtOkEtRmEtZl0rKVxcXSk/KSg6XFxkKik/KT8pKSMoJVswLTlBLUZhLWZdezJ9fFshJCYtOz0/LVpfYS16fl0pKnwoKFtBLVphLXpdWytcXC0uMC05QS1aYS16XSopPyVbMC05QS1GYS1mXXsyfXxbISQmLS4wLTk7PUBffl18W0EtWmEtel1bK1xcLS4wLTlBLVphLXpdKlshJCYtKiw7PUBffl0pKCVbMC05QS1GYS1mXXsyfXxbISQmLS4wLTk7PUAtWl9hLXp+XSkqKCgoWy8/XSglWzAtOUEtRmEtZl17Mn18WyEkJi07PT8tWl9hLXp+XSkqKT8jfFsvP10pKCVbMC05QS1GYS1mXXsyfXxbISQmLTs9Py1aX2Eten5dKSopP3woW0EtWmEtel1bK1xcLS4wLTlBLVphLXpdKig6JVswLTlBLUZhLWZdezJ9fDpbISQmLS4wLTs9Py1aX2Eten5dfFsvP10pfFxcPykoJVswLTlBLUZhLWZdezJ9fFshJCYtOz0/LVpfYS16fl0pKnwoW0EtWmEtel1bK1xcLS4wLTlBLVphLXpdKjopP1xcLygoJVswLTlBLUZhLWZdezJ9fFxcLygoJVswLTlBLUZhLWZdezJ9fFshJCYtLjAtOTs9QS1aX2Eten5dKSt8KFxcWygoW1Z2XVswLTlBLUZhLWZdK1xcLlshJCYtLjAtOz1BLVpfYS16fl0rKT98Wy4wLTpBLUZhLWZdKylcXF0pPykoOlxcZCopP1svP118WyEkJi0uMC07PT8tWl9hLXp+XSkoJVswLTlBLUZhLWZdezJ9fFshJCYtOz0/LVpfYS16fl0pKnxcXC8oKCVbMC05QS1GYS1mXXsyfXxbISQmLS4wLTk7PUEtWl9hLXp+XSkrKDpcXGQqKT98KFxcWygoW1Z2XVswLTlBLUZhLWZdK1xcLlshJCYtLjAtOz1BLVpfYS16fl0rKT98Wy4wLTpBLUZhLWZdKylcXF0pPzpcXGQqfFxcWygoW1Z2XVswLTlBLUZhLWZdK1xcLlshJCYtLjAtOz1BLVpfYS16fl0rKT98Wy4wLTpBLUZhLWZdKylcXF0pPyk/fFtBLVphLXpdWytcXC0uMC05QS1aYS16XSo6Pyk/JC8sXG4gICdpcmknOiAvXlthLXpBLVpdW2EtekEtWjAtOSsuLV0qOlteXFxzXSokLyxcbiAgJ2lyaS1yZWZlcmVuY2UnOiAvXigoKChbQS1aYS16XVsrXFwtLjAtOUEtWmEtel0qKDolWzAtOUEtRmEtZl17Mn18OlshJCYtLjAtOz0/LVpfYS16fi1cXHV7MTBGRkZGfV18Wy8/XSl8XFw/KSglWzAtOUEtRmEtZl17Mn18WyEkJi07PT8tWl9hLXp+LVxcdXsxMEZGRkZ9XSkqfChbQS1aYS16XVsrXFwtLjAtOUEtWmEtel0qOj8pPyl8KFtBLVphLXpdWytcXC0uMC05QS1aYS16XSo6KT9cXC8oKCVbMC05QS1GYS1mXXsyfXxcXC8oKCVbMC05QS1GYS1mXXsyfXxbISQmLS4wLTk7PUEtWl9hLXp+LVxcdXsxMEZGRkZ9XSkrfChcXFsoKFtWdl1bMC05QS1GYS1mXStcXC5bISQmLS4wLTs9QS1aX2Eten4tXFx1ezEwRkZGRn1dKyk/fFsuMC06QS1GYS1mXSspXFxdKT8pKDpcXGQqKT9bLz9dfFshJCYtLjAtOz0/LVpfYS16fi1cXHV7MTBGRkZGfV0pKCVbMC05QS1GYS1mXXsyfXxbISQmLTs9Py1aX2Eten4tXFx1ezEwRkZGRn1dKSp8KFxcLygoJVswLTlBLUZhLWZdezJ9fFshJCYtLjAtOTs9QS1aX2Eten4tXFx1ezEwRkZGRn1dKSt8KFxcWygoW1Z2XVswLTlBLUZhLWZdK1xcLlshJCYtLjAtOz1BLVpfYS16fi1cXHV7MTBGRkZGfV0rKT98Wy4wLTpBLUZhLWZdKylcXF0pPykoOlxcZCopPyk/KSkjKCVbMC05QS1GYS1mXXsyfXxbISQmLTs9Py1aX2Eten4tXFx1ezEwRkZGRn1dKSp8KChbQS1aYS16XVsrXFwtLjAtOUEtWmEtel0qKT8lWzAtOUEtRmEtZl17Mn18WyEkJi0uMC05Oz1AX34tXFx1ezEwRkZGRn1dfFtBLVphLXpdWytcXC0uMC05QS1aYS16XSpbISQmLSosOz1AX34tXFx1ezEwRkZGRn1dKSglWzAtOUEtRmEtZl17Mn18WyEkJi0uMC05Oz1ALVpfYS16fi1cXHV7MTBGRkZGfV0pKigoKFsvP10oJVswLTlBLUZhLWZdezJ9fFshJCYtOz0/LVpfYS16fi1cXHV7MTBGRkZGfV0pKik/I3xbLz9dKSglWzAtOUEtRmEtZl17Mn18WyEkJi07PT8tWl9hLXp+LVxcdXsxMEZGRkZ9XSkqKT98KFtBLVphLXpdWytcXC0uMC05QS1aYS16XSooOiVbMC05QS1GYS1mXXsyfXw6WyEkJi0uMC07PT8tWl9hLXp+LVxcdXsxMEZGRkZ9XXxbLz9dKXxcXD8pKCVbMC05QS1GYS1mXXsyfXxbISQmLTs9Py1aX2Eten4tXFx1ezEwRkZGRn1dKSp8KFtBLVphLXpdWytcXC0uMC05QS1aYS16XSo6KT9cXC8oKCVbMC05QS1GYS1mXXsyfXxcXC8oKCVbMC05QS1GYS1mXXsyfXxbISQmLS4wLTk7PUEtWl9hLXp+LVxcdXsxMEZGRkZ9XSkrfChcXFsoKFtWdl1bMC05QS1GYS1mXStcXC5bISQmLS4wLTs9QS1aX2Eten4tXFx1ezEwRkZGRn1dKyk/fFsuMC06QS1GYS1mXSspXFxdKT8pKDpcXGQqKT9bLz9dfFshJCYtLjAtOz0/LVpfYS16fi1cXHV7MTBGRkZGfV0pKCVbMC05QS1GYS1mXXsyfXxbISQmLTs9Py1aX2Eten4tXFx1ezEwRkZGRn1dKSp8XFwvKCglWzAtOUEtRmEtZl17Mn18WyEkJi0uMC05Oz1BLVpfYS16fi1cXHV7MTBGRkZGfV0pKyg6XFxkKik/fChcXFsoKFtWdl1bMC05QS1GYS1mXStcXC5bISQmLS4wLTs9QS1aX2Eten4tXFx1ezEwRkZGRn1dKyk/fFsuMC06QS1GYS1mXSspXFxdKT86XFxkKnxcXFsoKFtWdl1bMC05QS1GYS1mXStcXC5bISQmLS4wLTs9QS1aX2Eten4tXFx1ezEwRkZGRn1dKyk/fFsuMC06QS1GYS1mXSspXFxdKT8pP3xbQS1aYS16XVsrXFwtLjAtOUEtWmEtel0qOj8pPyQvdSxcbiAgJ3V1aWQnOiAvXlswLTlBLUZdezh9LVswLTlBLUZdezR9LVswLTlBLUZdezR9LVswLTlBLUZdezR9LVswLTlBLUZdezEyfSQvaSxcblxuICAvLyA3LjMuNi4gdXJpLXRlbXBsYXRlXG4gICd1cmktdGVtcGxhdGUnOiAvKCVbMC05YS1mXXsyfXxbISMkJigtOz0/QFxcW1xcXV9hLXp+XXxcXHtbISMmKywuLzs9P0B8XT8oJVswLTlhLWZdezJ9fFswLTlfYS16XSkoXFwuPyglWzAtOWEtZl17Mn18WzAtOV9hLXpdKSkqKDpbMS05XVxcZHswLDN9fFxcKik/KCwoJVswLTlhLWZdezJ9fFswLTlfYS16XSkoXFwuPyglWzAtOWEtZl17Mn18WzAtOV9hLXpdKSkqKDpbMS05XVxcZHswLDN9fFxcKik/KSpcXH0pKi9pdSxcblxuICAvLyA3LjMuNy4gSlNPTiBQb2ludGVyc1xuICAnanNvbi1wb2ludGVyJzogL14oXFwvKFtcXHgwMC1cXHgyZTAtQFxcWy19XFx4N2ZdfH5bMDFdKSopKiQvaXUsXG4gICdyZWxhdGl2ZS1qc29uLXBvaW50ZXInOiAvXlxcZCsoI3woXFwvKFtcXHgwMC1cXHgyZTAtQFxcWy19XFx4N2ZdfH5bMDFdKSopKikkL2l1LFxuXG4gIC8vIGhvc3RuYW1lIHJlZ2V4IGZyb206IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE0MjAyMjUvNTYyOFxuICAnaG9zdG5hbWUnOiAvXig/PS57MSwyNTV9JClbMC05QS1aYS16XSg/Oig/OlswLTlBLVphLXpdfC0pezAsNjF9WzAtOUEtWmEtel0pPyg/OlxcLlswLTlBLVphLXpdKD86KD86WzAtOUEtWmEtel18LSl7MCw2MX1bMC05QS1aYS16XSk/KSpcXC4/JC8sXG4gICdob3N0LW5hbWUnOiAvXig/PS57MSwyNTV9JClbMC05QS1aYS16XSg/Oig/OlswLTlBLVphLXpdfC0pezAsNjF9WzAtOUEtWmEtel0pPyg/OlxcLlswLTlBLVphLXpdKD86KD86WzAtOUEtWmEtel18LSl7MCw2MX1bMC05QS1aYS16XSk/KSpcXC4/JC8sXG5cbiAgJ3V0Yy1taWxsaXNlYyc6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHJldHVybiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykgJiYgcGFyc2VGbG9hdChpbnB1dCkgPT09IHBhcnNlSW50KGlucHV0LCAxMCkgJiYgIWlzTmFOKGlucHV0KTtcbiAgfSxcblxuICAvLyA3LjMuOC4gcmVnZXhcbiAgJ3JlZ2V4JzogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBSZWdFeHAoaW5wdXQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8vIE90aGVyIGRlZmluaXRpb25zXG4gIC8vIFwic3R5bGVcIiB3YXMgcmVtb3ZlZCBmcm9tIEpTT04gU2NoZW1hIGluIGRyYWZ0LTQgYW5kIGlzIGRlcHJlY2F0ZWRcbiAgJ3N0eWxlJzogL1tcXHJcXG5cXHQgXSpbXlxcclxcblxcdCBdW146XSo6W1xcclxcblxcdCBdKlteXFxyXFxuXFx0IDtdKltcXHJcXG5cXHQgXSo7Py8sXG4gIC8vIFwiY29sb3JcIiB3YXMgcmVtb3ZlZCBmcm9tIEpTT04gU2NoZW1hIGluIGRyYWZ0LTQgYW5kIGlzIGRlcHJlY2F0ZWRcbiAgJ2NvbG9yJzogL14oIz8oWzAtOUEtRmEtZl17M30pezEsMn1cXGJ8YXF1YXxibGFja3xibHVlfGZ1Y2hzaWF8Z3JheXxncmVlbnxsaW1lfG1hcm9vbnxuYXZ5fG9saXZlfG9yYW5nZXxwdXJwbGV8cmVkfHNpbHZlcnx0ZWFsfHdoaXRlfHllbGxvd3wocmdiXFwoXFxzKlxcYihbMC05XXxbMS05XVswLTldfDFbMC05XVswLTldfDJbMC00XVswLTldfDI1WzAtNV0pXFxiXFxzKixcXHMqXFxiKFswLTldfFsxLTldWzAtOV18MVswLTldWzAtOV18MlswLTRdWzAtOV18MjVbMC01XSlcXGJcXHMqLFxccypcXGIoWzAtOV18WzEtOV1bMC05XXwxWzAtOV1bMC05XXwyWzAtNF1bMC05XXwyNVswLTVdKVxcYlxccypcXCkpfChyZ2JcXChcXHMqKFxcZD9cXGQlfDEwMCUpK1xccyosXFxzKihcXGQ/XFxkJXwxMDAlKStcXHMqLFxccyooXFxkP1xcZCV8MTAwJSkrXFxzKlxcKSkpJC8sXG4gICdwaG9uZSc6IC9eXFwrKD86WzAtOV0gPyl7NiwxNH1bMC05XSQvLFxuICAnYWxwaGEnOiAvXlthLXpBLVpdKyQvLFxuICAnYWxwaGFudW1lcmljJzogL15bYS16QS1aMC05XSskLyxcbn07XG5cbkZPUk1BVF9SRUdFWFBTLnJlZ2V4cCA9IEZPUk1BVF9SRUdFWFBTLnJlZ2V4O1xuRk9STUFUX1JFR0VYUFMucGF0dGVybiA9IEZPUk1BVF9SRUdFWFBTLnJlZ2V4O1xuRk9STUFUX1JFR0VYUFMuaXB2NCA9IEZPUk1BVF9SRUdFWFBTWydpcC1hZGRyZXNzJ107XG5cbmV4cG9ydHMuaXNGb3JtYXQgPSBmdW5jdGlvbiBpc0Zvcm1hdCAoaW5wdXQsIGZvcm1hdCwgdmFsaWRhdG9yKSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnICYmIEZPUk1BVF9SRUdFWFBTW2Zvcm1hdF0gIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChGT1JNQVRfUkVHRVhQU1tmb3JtYXRdIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gRk9STUFUX1JFR0VYUFNbZm9ybWF0XS50ZXN0KGlucHV0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBGT1JNQVRfUkVHRVhQU1tmb3JtYXRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gRk9STUFUX1JFR0VYUFNbZm9ybWF0XShpbnB1dCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbGlkYXRvciAmJiB2YWxpZGF0b3IuY3VzdG9tRm9ybWF0cyAmJlxuICAgICAgdHlwZW9mIHZhbGlkYXRvci5jdXN0b21Gb3JtYXRzW2Zvcm1hdF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsaWRhdG9yLmN1c3RvbUZvcm1hdHNbZm9ybWF0XShpbnB1dCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgbWFrZVN1ZmZpeCA9IGV4cG9ydHMubWFrZVN1ZmZpeCA9IGZ1bmN0aW9uIG1ha2VTdWZmaXggKGtleSkge1xuICBrZXkgPSBrZXkudG9TdHJpbmcoKTtcbiAgLy8gVGhpcyBmdW5jdGlvbiBjb3VsZCBiZSBjYXBhYmxlIG9mIG91dHB1dHRpbmcgdmFsaWQgYSBFQ01BU2NyaXB0IHN0cmluZywgYnV0IHRoZVxuICAvLyByZXN1bHRpbmcgY29kZSBmb3IgdGVzdGluZyB3aGljaCBmb3JtIHRvIHVzZSB3b3VsZCBiZSB0ZW5zIG9mIHRob3VzYW5kcyBvZiBjaGFyYWN0ZXJzIGxvbmdcbiAgLy8gVGhhdCBtZWFucyB0aGlzIHdpbGwgdXNlIHRoZSBuYW1lIGZvcm0gZm9yIHNvbWUgaWxsZWdhbCBmb3Jtc1xuICBpZiAoIWtleS5tYXRjaCgvWy5cXHNcXFtcXF1dLykgJiYgIWtleS5tYXRjaCgvXltcXGRdLykpIHtcbiAgICByZXR1cm4gJy4nICsga2V5O1xuICB9XG4gIGlmIChrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgcmV0dXJuICdbJyArIGtleSArICddJztcbiAgfVxuICByZXR1cm4gJ1snICsgSlNPTi5zdHJpbmdpZnkoa2V5KSArICddJztcbn07XG5cbmV4cG9ydHMuZGVlcENvbXBhcmVTdHJpY3QgPSBmdW5jdGlvbiBkZWVwQ29tcGFyZVN0cmljdCAoYSwgYikge1xuICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGEuZXZlcnkoZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgIHJldHVybiBkZWVwQ29tcGFyZVN0cmljdChhW2ldLCBiW2ldKTtcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKCFhIHx8ICFiKSB7XG4gICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICB9XG4gICAgdmFyIGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG4gICAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBhS2V5cy5ldmVyeShmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIGRlZXBDb21wYXJlU3RyaWN0KGFbdl0sIGJbdl0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBhID09PSBiO1xufTtcblxuZnVuY3Rpb24gZGVlcE1lcmdlciAodGFyZ2V0LCBkc3QsIGUsIGkpIHtcbiAgaWYgKHR5cGVvZiBlID09PSAnb2JqZWN0Jykge1xuICAgIGRzdFtpXSA9IGRlZXBNZXJnZSh0YXJnZXRbaV0sIGUpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0YXJnZXQuaW5kZXhPZihlKSA9PT0gLTEpIHtcbiAgICAgIGRzdC5wdXNoKGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5aXN0IChzcmMsIGRzdCwga2V5KSB7XG4gIGRzdFtrZXldID0gc3JjW2tleV07XG59XG5cbmZ1bmN0aW9uIGNvcHlpc3RXaXRoRGVlcE1lcmdlICh0YXJnZXQsIHNyYywgZHN0LCBrZXkpIHtcbiAgaWYgKHR5cGVvZiBzcmNba2V5XSAhPT0gJ29iamVjdCcgfHwgIXNyY1trZXldKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XTtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAoIXRhcmdldFtrZXldKSB7XG4gICAgICBkc3Rba2V5XSA9IHNyY1trZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBkc3Rba2V5XSA9IGRlZXBNZXJnZSh0YXJnZXRba2V5XSwgc3JjW2tleV0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWVwTWVyZ2UgKHRhcmdldCwgc3JjKSB7XG4gIHZhciBhcnJheSA9IEFycmF5LmlzQXJyYXkoc3JjKTtcbiAgdmFyIGRzdCA9IGFycmF5ICYmIFtdIHx8IHt9O1xuXG4gIGlmIChhcnJheSkge1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBbXTtcbiAgICBkc3QgPSBkc3QuY29uY2F0KHRhcmdldCk7XG4gICAgc3JjLmZvckVhY2goZGVlcE1lcmdlci5iaW5kKG51bGwsIHRhcmdldCwgZHN0KSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmtleXModGFyZ2V0KS5mb3JFYWNoKGNvcHlpc3QuYmluZChudWxsLCB0YXJnZXQsIGRzdCkpO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhzcmMpLmZvckVhY2goY29weWlzdFdpdGhEZWVwTWVyZ2UuYmluZChudWxsLCB0YXJnZXQsIHNyYywgZHN0KSk7XG4gIH1cblxuICByZXR1cm4gZHN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cy5kZWVwTWVyZ2UgPSBkZWVwTWVyZ2U7XG5cbi8qKlxuICogVmFsaWRhdGVzIGluc3RhbmNlIGFnYWluc3QgdGhlIHByb3ZpZGVkIHNjaGVtYVxuICogSW1wbGVtZW50cyBVUkkrSlNPTiBQb2ludGVyIGVuY29kaW5nLCBlLmcuIFwiJTdlXCI9XCJ+MFwiPT5cIn5cIiwgXCJ+MVwiPVwiJTJmXCI9PlwiL1wiXG4gKiBAcGFyYW0gb1xuICogQHBhcmFtIHMgVGhlIHBhdGggdG8gd2FsayBvIGFsb25nXG4gKiBAcmV0dXJuIGFueVxuICovXG5leHBvcnRzLm9iamVjdEdldFBhdGggPSBmdW5jdGlvbiBvYmplY3RHZXRQYXRoKG8sIHMpIHtcbiAgdmFyIHBhcnRzID0gcy5zcGxpdCgnLycpLnNsaWNlKDEpO1xuICB2YXIgaztcbiAgd2hpbGUgKHR5cGVvZiAoaz1wYXJ0cy5zaGlmdCgpKSA9PSAnc3RyaW5nJykge1xuICAgIHZhciBuID0gZGVjb2RlVVJJQ29tcG9uZW50KGsucmVwbGFjZSgvfjAvLCd+JykucmVwbGFjZSgvfjEvZywnLycpKTtcbiAgICBpZiAoIShuIGluIG8pKSByZXR1cm47XG4gICAgbyA9IG9bbl07XG4gIH1cbiAgcmV0dXJuIG87XG59O1xuXG5mdW5jdGlvbiBwYXRoRW5jb2RlciAodikge1xuICByZXR1cm4gJy8nK2VuY29kZVVSSUNvbXBvbmVudCh2KS5yZXBsYWNlKC9+L2csJyU3RScpO1xufVxuLyoqXG4gKiBBY2NlcHQgYW4gQXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHJldHVybiBhIEpTT04gUG9pbnRlciBVUkkgZnJhZ21lbnRcbiAqIEBwYXJhbSBBcnJheSBhXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMuZW5jb2RlUGF0aCA9IGZ1bmN0aW9uIGVuY29kZVBvaW50ZXIoYSl7XG4gIC8vIH4gbXVzdCBiZSBlbmNvZGVkIGV4cGxpY2l0bHkgYmVjYXVzZSBoYWNrc1xuICAvLyB0aGUgc2xhc2ggaXMgZW5jb2RlZCBieSBlbmNvZGVVUklDb21wb25lbnRcbiAgcmV0dXJuIGEubWFwKHBhdGhFbmNvZGVyKS5qb2luKCcnKTtcbn07XG5cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBhIG51bWJlciB1c2VzXG4gKiBXZSBuZWVkIHRoaXMgdG8gZ2V0IGNvcnJlY3QgcmVzdWx0cyBvdXQgb2YgbXVsdGlwbGVPZiBhbmQgZGl2aXNpYmxlQnlcbiAqIHdoZW4gZWl0aGVyIGZpZ3VyZSBpcyBoYXMgZGVjaW1hbCBwbGFjZXMsIGR1ZSB0byBJRUVFLTc1NCBmbG9hdCBpc3N1ZXMuXG4gKiBAcGFyYW0gbnVtYmVyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLmdldERlY2ltYWxQbGFjZXMgPSBmdW5jdGlvbiBnZXREZWNpbWFsUGxhY2VzKG51bWJlcikge1xuXG4gIHZhciBkZWNpbWFsUGxhY2VzID0gMDtcbiAgaWYgKGlzTmFOKG51bWJlcikpIHJldHVybiBkZWNpbWFsUGxhY2VzO1xuXG4gIGlmICh0eXBlb2YgbnVtYmVyICE9PSAnbnVtYmVyJykge1xuICAgIG51bWJlciA9IE51bWJlcihudW1iZXIpO1xuICB9XG5cbiAgdmFyIHBhcnRzID0gbnVtYmVyLnRvU3RyaW5nKCkuc3BsaXQoJ2UnKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGlmIChwYXJ0c1sxXVswXSAhPT0gJy0nKSB7XG4gICAgICByZXR1cm4gZGVjaW1hbFBsYWNlcztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVjaW1hbFBsYWNlcyA9IE51bWJlcihwYXJ0c1sxXS5zbGljZSgxKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlY2ltYWxQYXJ0cyA9IHBhcnRzWzBdLnNwbGl0KCcuJyk7XG4gIGlmIChkZWNpbWFsUGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgZGVjaW1hbFBsYWNlcyArPSBkZWNpbWFsUGFydHNbMV0ubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIGRlY2ltYWxQbGFjZXM7XG59O1xuXG5leHBvcnRzLmlzU2NoZW1hID0gZnVuY3Rpb24gaXNTY2hlbWEodmFsKXtcbiAgcmV0dXJuICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwpIHx8ICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpO1xufTtcblxuIl0sIm5hbWVzIjpbInVyaSIsInJlcXVpcmUiLCJWYWxpZGF0aW9uRXJyb3IiLCJleHBvcnRzIiwibWVzc2FnZSIsImluc3RhbmNlIiwic2NoZW1hIiwicGF0aCIsIm5hbWUiLCJhcmd1bWVudCIsIkFycmF5IiwiaXNBcnJheSIsInByb3BlcnR5IiwicmVkdWNlIiwic3VtIiwiaXRlbSIsIm1ha2VTdWZmaXgiLCJ1bmRlZmluZWQiLCJpZCIsIiRpZCIsInN0YWNrIiwidG9TdHJpbmciLCJwcm90b3R5cGUiLCJWYWxpZGF0b3JSZXN1bHQiLCJvcHRpb25zIiwiY3R4IiwicHJvcGVydHlQYXRoIiwiZXJyb3JzIiwidGhyb3dFcnJvciIsInRocm93Rmlyc3QiLCJ0aHJvd0FsbCIsImRpc2FibGVGb3JtYXQiLCJhZGRFcnJvciIsImRldGFpbCIsImVyciIsIkVycm9yIiwicHVzaCIsIlZhbGlkYXRvclJlc3VsdEVycm9yIiwiaW1wb3J0RXJyb3JzIiwicmVzIiwidmFsaWRhdG9yVHlwZSIsImNvbmNhdCIsInN0cmluZ2l6ZXIiLCJ2IiwiaSIsIm1hcCIsImpvaW4iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImxlbmd0aCIsIm1vZHVsZSIsInJlc3VsdCIsImNhcHR1cmVTdGFja1RyYWNlIiwiY29uc3RydWN0b3IiLCJTY2hlbWFFcnJvciIsIm1zZyIsImNhbGwiLCJjcmVhdGUiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJTY2hlbWFDb250ZXh0IiwiYmFzZSIsInNjaGVtYXMiLCJyZXNvbHZlIiwidGFyZ2V0IiwibWFrZUNoaWxkIiwicHJvcGVydHlOYW1lIiwiRk9STUFUX1JFR0VYUFMiLCJpbnB1dCIsInBhcnNlRmxvYXQiLCJwYXJzZUludCIsImlzTmFOIiwiUmVnRXhwIiwiZSIsInJlZ2V4cCIsInJlZ2V4IiwicGF0dGVybiIsImlwdjQiLCJpc0Zvcm1hdCIsImZvcm1hdCIsInZhbGlkYXRvciIsInRlc3QiLCJjdXN0b21Gb3JtYXRzIiwia2V5IiwibWF0Y2giLCJKU09OIiwic3RyaW5naWZ5IiwiZGVlcENvbXBhcmVTdHJpY3QiLCJhIiwiYiIsImV2ZXJ5IiwiYUtleXMiLCJrZXlzIiwiYktleXMiLCJkZWVwTWVyZ2VyIiwiZHN0IiwiZGVlcE1lcmdlIiwiaW5kZXhPZiIsImNvcHlpc3QiLCJzcmMiLCJjb3B5aXN0V2l0aERlZXBNZXJnZSIsImFycmF5IiwiZm9yRWFjaCIsImJpbmQiLCJvYmplY3RHZXRQYXRoIiwibyIsInMiLCJwYXJ0cyIsInNwbGl0Iiwic2xpY2UiLCJrIiwic2hpZnQiLCJuIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicmVwbGFjZSIsInBhdGhFbmNvZGVyIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZW5jb2RlUGF0aCIsImVuY29kZVBvaW50ZXIiLCJnZXREZWNpbWFsUGxhY2VzIiwibnVtYmVyIiwiZGVjaW1hbFBsYWNlcyIsIk51bWJlciIsImRlY2ltYWxQYXJ0cyIsImlzU2NoZW1hIiwidmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonschema/lib/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonschema/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/jsonschema/lib/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar Validator = module.exports.Validator = __webpack_require__(/*! ./validator */ \"(ssr)/./node_modules/jsonschema/lib/validator.js\");\nmodule.exports.ValidatorResult = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/jsonschema/lib/helpers.js\").ValidatorResult;\nmodule.exports.ValidatorResultError = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/jsonschema/lib/helpers.js\").ValidatorResultError;\nmodule.exports.ValidationError = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/jsonschema/lib/helpers.js\").ValidationError;\nmodule.exports.SchemaError = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/jsonschema/lib/helpers.js\").SchemaError;\nmodule.exports.SchemaScanResult = __webpack_require__(/*! ./scan */ \"(ssr)/./node_modules/jsonschema/lib/scan.js\").SchemaScanResult;\nmodule.exports.scan = __webpack_require__(/*! ./scan */ \"(ssr)/./node_modules/jsonschema/lib/scan.js\").scan;\nmodule.exports.validate = function(instance, schema, options) {\n    var v = new Validator();\n    return v.validate(instance, schema, options);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbnNjaGVtYS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxZQUFZQyxxSEFBbUM7QUFFbkRBLHVJQUFxRTtBQUNyRUEsaUpBQStFO0FBQy9FQSx1SUFBcUU7QUFDckVBLCtIQUE2RDtBQUM3REEsbUlBQW9FO0FBQ3BFQSwyR0FBNEM7QUFFNUNBLHVCQUF1QixHQUFHLFNBQVVVLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxPQUFPO0lBQzNELElBQUlDLElBQUksSUFBSWQ7SUFDWixPQUFPYyxFQUFFSixRQUFRLENBQUNDLFVBQVVDLFFBQVFDO0FBQ3RDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9qc29uc2NoZW1hL2xpYi9pbmRleC5qcz8yYWI1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFZhbGlkYXRvciA9IG1vZHVsZS5leHBvcnRzLlZhbGlkYXRvciA9IHJlcXVpcmUoJy4vdmFsaWRhdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzLlZhbGlkYXRvclJlc3VsdCA9IHJlcXVpcmUoJy4vaGVscGVycycpLlZhbGlkYXRvclJlc3VsdDtcbm1vZHVsZS5leHBvcnRzLlZhbGlkYXRvclJlc3VsdEVycm9yID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuVmFsaWRhdG9yUmVzdWx0RXJyb3I7XG5tb2R1bGUuZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5WYWxpZGF0aW9uRXJyb3I7XG5tb2R1bGUuZXhwb3J0cy5TY2hlbWFFcnJvciA9IHJlcXVpcmUoJy4vaGVscGVycycpLlNjaGVtYUVycm9yO1xubW9kdWxlLmV4cG9ydHMuU2NoZW1hU2NhblJlc3VsdCA9IHJlcXVpcmUoJy4vc2NhbicpLlNjaGVtYVNjYW5SZXN1bHQ7XG5tb2R1bGUuZXhwb3J0cy5zY2FuID0gcmVxdWlyZSgnLi9zY2FuJykuc2NhbjtcblxubW9kdWxlLmV4cG9ydHMudmFsaWRhdGUgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucykge1xuICB2YXIgdiA9IG5ldyBWYWxpZGF0b3IoKTtcbiAgcmV0dXJuIHYudmFsaWRhdGUoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucyk7XG59O1xuIl0sIm5hbWVzIjpbIlZhbGlkYXRvciIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiVmFsaWRhdG9yUmVzdWx0IiwiVmFsaWRhdG9yUmVzdWx0RXJyb3IiLCJWYWxpZGF0aW9uRXJyb3IiLCJTY2hlbWFFcnJvciIsIlNjaGVtYVNjYW5SZXN1bHQiLCJzY2FuIiwidmFsaWRhdGUiLCJpbnN0YW5jZSIsInNjaGVtYSIsIm9wdGlvbnMiLCJ2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonschema/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonschema/lib/scan.js":
/*!*********************************************!*\
  !*** ./node_modules/jsonschema/lib/scan.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar urilib = __webpack_require__(/*! url */ \"url\");\nvar helpers = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/jsonschema/lib/helpers.js\");\nmodule.exports.SchemaScanResult = SchemaScanResult;\nfunction SchemaScanResult(found, ref) {\n    this.id = found;\n    this.ref = ref;\n}\n/**\n * Adds a schema with a certain urn to the Validator instance.\n * @param string uri\n * @param object schema\n * @return {Object}\n */ module.exports.scan = function scan(base, schema) {\n    function scanSchema(baseuri, schema) {\n        if (!schema || typeof schema != \"object\") return;\n        // Mark all referenced schemas so we can tell later which schemas are referred to, but never defined\n        if (schema.$ref) {\n            var resolvedUri = urilib.resolve(baseuri, schema.$ref);\n            ref[resolvedUri] = ref[resolvedUri] ? ref[resolvedUri] + 1 : 0;\n            return;\n        }\n        var id = schema.$id || schema.id;\n        var ourBase = id ? urilib.resolve(baseuri, id) : baseuri;\n        if (ourBase) {\n            // If there's no fragment, append an empty one\n            if (ourBase.indexOf(\"#\") < 0) ourBase += \"#\";\n            if (found[ourBase]) {\n                if (!helpers.deepCompareStrict(found[ourBase], schema)) {\n                    throw new Error(\"Schema <\" + ourBase + \"> already exists with different definition\");\n                }\n                return found[ourBase];\n            }\n            found[ourBase] = schema;\n            // strip trailing fragment\n            if (ourBase[ourBase.length - 1] == \"#\") {\n                found[ourBase.substring(0, ourBase.length - 1)] = schema;\n            }\n        }\n        scanArray(ourBase + \"/items\", Array.isArray(schema.items) ? schema.items : [\n            schema.items\n        ]);\n        scanArray(ourBase + \"/extends\", Array.isArray(schema.extends) ? schema.extends : [\n            schema.extends\n        ]);\n        scanSchema(ourBase + \"/additionalItems\", schema.additionalItems);\n        scanObject(ourBase + \"/properties\", schema.properties);\n        scanSchema(ourBase + \"/additionalProperties\", schema.additionalProperties);\n        scanObject(ourBase + \"/definitions\", schema.definitions);\n        scanObject(ourBase + \"/patternProperties\", schema.patternProperties);\n        scanObject(ourBase + \"/dependencies\", schema.dependencies);\n        scanArray(ourBase + \"/disallow\", schema.disallow);\n        scanArray(ourBase + \"/allOf\", schema.allOf);\n        scanArray(ourBase + \"/anyOf\", schema.anyOf);\n        scanArray(ourBase + \"/oneOf\", schema.oneOf);\n        scanSchema(ourBase + \"/not\", schema.not);\n    }\n    function scanArray(baseuri, schemas) {\n        if (!Array.isArray(schemas)) return;\n        for(var i = 0; i < schemas.length; i++){\n            scanSchema(baseuri + \"/\" + i, schemas[i]);\n        }\n    }\n    function scanObject(baseuri, schemas) {\n        if (!schemas || typeof schemas != \"object\") return;\n        for(var p in schemas){\n            scanSchema(baseuri + \"/\" + p, schemas[p]);\n        }\n    }\n    var found = {};\n    var ref = {};\n    scanSchema(base, schema);\n    return new SchemaScanResult(found, ref);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbnNjaGVtYS9saWIvc2Nhbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUlBLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlDLFVBQVVELG1CQUFPQSxDQUFDO0FBRXRCRSwrQkFBK0IsR0FBR0U7QUFDbEMsU0FBU0EsaUJBQWlCQyxLQUFLLEVBQUVDLEdBQUc7SUFDbEMsSUFBSSxDQUFDQyxFQUFFLEdBQUdGO0lBQ1YsSUFBSSxDQUFDQyxHQUFHLEdBQUdBO0FBQ2I7QUFFQTs7Ozs7Q0FLQyxHQUNESixtQkFBbUIsR0FBRyxTQUFTTSxLQUFLQyxJQUFJLEVBQUVDLE1BQU07SUFDOUMsU0FBU0MsV0FBV0MsT0FBTyxFQUFFRixNQUFNO1FBQ2pDLElBQUcsQ0FBQ0EsVUFBVSxPQUFPQSxVQUFRLFVBQVU7UUFDdkMsb0dBQW9HO1FBQ3BHLElBQUdBLE9BQU9HLElBQUksRUFBQztZQUNiLElBQUlDLGNBQWNmLE9BQU9nQixPQUFPLENBQUNILFNBQVNGLE9BQU9HLElBQUk7WUFDckRQLEdBQUcsQ0FBQ1EsWUFBWSxHQUFHUixHQUFHLENBQUNRLFlBQVksR0FBR1IsR0FBRyxDQUFDUSxZQUFZLEdBQUMsSUFBSTtZQUMzRDtRQUNGO1FBQ0EsSUFBSVAsS0FBS0csT0FBT00sR0FBRyxJQUFJTixPQUFPSCxFQUFFO1FBQ2hDLElBQUlVLFVBQVVWLEtBQUtSLE9BQU9nQixPQUFPLENBQUNILFNBQVNMLE1BQU1LO1FBQ2pELElBQUlLLFNBQVM7WUFDWCw4Q0FBOEM7WUFDOUMsSUFBR0EsUUFBUUMsT0FBTyxDQUFDLE9BQUssR0FBR0QsV0FBVztZQUN0QyxJQUFHWixLQUFLLENBQUNZLFFBQVEsRUFBQztnQkFDaEIsSUFBRyxDQUFDaEIsUUFBUWtCLGlCQUFpQixDQUFDZCxLQUFLLENBQUNZLFFBQVEsRUFBRVAsU0FBUTtvQkFDcEQsTUFBTSxJQUFJVSxNQUFNLGFBQVdILFVBQVE7Z0JBQ3JDO2dCQUNBLE9BQU9aLEtBQUssQ0FBQ1ksUUFBUTtZQUN2QjtZQUNBWixLQUFLLENBQUNZLFFBQVEsR0FBR1A7WUFDakIsMEJBQTBCO1lBQzFCLElBQUdPLE9BQU8sQ0FBQ0EsUUFBUUksTUFBTSxHQUFDLEVBQUUsSUFBRSxLQUFJO2dCQUNoQ2hCLEtBQUssQ0FBQ1ksUUFBUUssU0FBUyxDQUFDLEdBQUdMLFFBQVFJLE1BQU0sR0FBQyxHQUFHLEdBQUdYO1lBQ2xEO1FBQ0Y7UUFDQWEsVUFBVU4sVUFBUSxVQUFXTyxNQUFNQyxPQUFPLENBQUNmLE9BQU9nQixLQUFLLElBQUVoQixPQUFPZ0IsS0FBSyxHQUFDO1lBQUNoQixPQUFPZ0IsS0FBSztTQUFDO1FBQ3BGSCxVQUFVTixVQUFRLFlBQWFPLE1BQU1DLE9BQU8sQ0FBQ2YsT0FBT2lCLE9BQU8sSUFBRWpCLE9BQU9pQixPQUFPLEdBQUM7WUFBQ2pCLE9BQU9pQixPQUFPO1NBQUM7UUFDNUZoQixXQUFXTSxVQUFRLG9CQUFvQlAsT0FBT2tCLGVBQWU7UUFDN0RDLFdBQVdaLFVBQVEsZUFBZVAsT0FBT29CLFVBQVU7UUFDbkRuQixXQUFXTSxVQUFRLHlCQUF5QlAsT0FBT3FCLG9CQUFvQjtRQUN2RUYsV0FBV1osVUFBUSxnQkFBZ0JQLE9BQU9zQixXQUFXO1FBQ3JESCxXQUFXWixVQUFRLHNCQUFzQlAsT0FBT3VCLGlCQUFpQjtRQUNqRUosV0FBV1osVUFBUSxpQkFBaUJQLE9BQU93QixZQUFZO1FBQ3ZEWCxVQUFVTixVQUFRLGFBQWFQLE9BQU95QixRQUFRO1FBQzlDWixVQUFVTixVQUFRLFVBQVVQLE9BQU8wQixLQUFLO1FBQ3hDYixVQUFVTixVQUFRLFVBQVVQLE9BQU8yQixLQUFLO1FBQ3hDZCxVQUFVTixVQUFRLFVBQVVQLE9BQU80QixLQUFLO1FBQ3hDM0IsV0FBV00sVUFBUSxRQUFRUCxPQUFPNkIsR0FBRztJQUN2QztJQUNBLFNBQVNoQixVQUFVWCxPQUFPLEVBQUU0QixPQUFPO1FBQ2pDLElBQUcsQ0FBQ2hCLE1BQU1DLE9BQU8sQ0FBQ2UsVUFBVTtRQUM1QixJQUFJLElBQUlDLElBQUUsR0FBR0EsSUFBRUQsUUFBUW5CLE1BQU0sRUFBRW9CLElBQUk7WUFDakM5QixXQUFXQyxVQUFRLE1BQUk2QixHQUFHRCxPQUFPLENBQUNDLEVBQUU7UUFDdEM7SUFDRjtJQUNBLFNBQVNaLFdBQVdqQixPQUFPLEVBQUU0QixPQUFPO1FBQ2xDLElBQUcsQ0FBQ0EsV0FBVyxPQUFPQSxXQUFTLFVBQVU7UUFDekMsSUFBSSxJQUFJRSxLQUFLRixRQUFRO1lBQ25CN0IsV0FBV0MsVUFBUSxNQUFJOEIsR0FBR0YsT0FBTyxDQUFDRSxFQUFFO1FBQ3RDO0lBQ0Y7SUFFQSxJQUFJckMsUUFBUSxDQUFDO0lBQ2IsSUFBSUMsTUFBTSxDQUFDO0lBQ1hLLFdBQVdGLE1BQU1DO0lBQ2pCLE9BQU8sSUFBSU4saUJBQWlCQyxPQUFPQztBQUNyQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvanNvbnNjaGVtYS9saWIvc2Nhbi5qcz9iNGJmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdXJpbGliID0gcmVxdWlyZSgndXJsJyk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG5tb2R1bGUuZXhwb3J0cy5TY2hlbWFTY2FuUmVzdWx0ID0gU2NoZW1hU2NhblJlc3VsdDtcbmZ1bmN0aW9uIFNjaGVtYVNjYW5SZXN1bHQoZm91bmQsIHJlZil7XG4gIHRoaXMuaWQgPSBmb3VuZDtcbiAgdGhpcy5yZWYgPSByZWY7XG59XG5cbi8qKlxuICogQWRkcyBhIHNjaGVtYSB3aXRoIGEgY2VydGFpbiB1cm4gdG8gdGhlIFZhbGlkYXRvciBpbnN0YW5jZS5cbiAqIEBwYXJhbSBzdHJpbmcgdXJpXG4gKiBAcGFyYW0gb2JqZWN0IHNjaGVtYVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5tb2R1bGUuZXhwb3J0cy5zY2FuID0gZnVuY3Rpb24gc2NhbihiYXNlLCBzY2hlbWEpe1xuICBmdW5jdGlvbiBzY2FuU2NoZW1hKGJhc2V1cmksIHNjaGVtYSl7XG4gICAgaWYoIXNjaGVtYSB8fCB0eXBlb2Ygc2NoZW1hIT0nb2JqZWN0JykgcmV0dXJuO1xuICAgIC8vIE1hcmsgYWxsIHJlZmVyZW5jZWQgc2NoZW1hcyBzbyB3ZSBjYW4gdGVsbCBsYXRlciB3aGljaCBzY2hlbWFzIGFyZSByZWZlcnJlZCB0bywgYnV0IG5ldmVyIGRlZmluZWRcbiAgICBpZihzY2hlbWEuJHJlZil7XG4gICAgICB2YXIgcmVzb2x2ZWRVcmkgPSB1cmlsaWIucmVzb2x2ZShiYXNldXJpLCBzY2hlbWEuJHJlZik7XG4gICAgICByZWZbcmVzb2x2ZWRVcmldID0gcmVmW3Jlc29sdmVkVXJpXSA/IHJlZltyZXNvbHZlZFVyaV0rMSA6IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpZCA9IHNjaGVtYS4kaWQgfHwgc2NoZW1hLmlkO1xuICAgIHZhciBvdXJCYXNlID0gaWQgPyB1cmlsaWIucmVzb2x2ZShiYXNldXJpLCBpZCkgOiBiYXNldXJpO1xuICAgIGlmIChvdXJCYXNlKSB7XG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIGZyYWdtZW50LCBhcHBlbmQgYW4gZW1wdHkgb25lXG4gICAgICBpZihvdXJCYXNlLmluZGV4T2YoJyMnKTwwKSBvdXJCYXNlICs9ICcjJztcbiAgICAgIGlmKGZvdW5kW291ckJhc2VdKXtcbiAgICAgICAgaWYoIWhlbHBlcnMuZGVlcENvbXBhcmVTdHJpY3QoZm91bmRbb3VyQmFzZV0sIHNjaGVtYSkpe1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2NoZW1hIDwnK291ckJhc2UrJz4gYWxyZWFkeSBleGlzdHMgd2l0aCBkaWZmZXJlbnQgZGVmaW5pdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZFtvdXJCYXNlXTtcbiAgICAgIH1cbiAgICAgIGZvdW5kW291ckJhc2VdID0gc2NoZW1hO1xuICAgICAgLy8gc3RyaXAgdHJhaWxpbmcgZnJhZ21lbnRcbiAgICAgIGlmKG91ckJhc2Vbb3VyQmFzZS5sZW5ndGgtMV09PScjJyl7XG4gICAgICAgIGZvdW5kW291ckJhc2Uuc3Vic3RyaW5nKDAsIG91ckJhc2UubGVuZ3RoLTEpXSA9IHNjaGVtYTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2NhbkFycmF5KG91ckJhc2UrJy9pdGVtcycsIChBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcyk/c2NoZW1hLml0ZW1zOltzY2hlbWEuaXRlbXNdKSk7XG4gICAgc2NhbkFycmF5KG91ckJhc2UrJy9leHRlbmRzJywgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmV4dGVuZHMpP3NjaGVtYS5leHRlbmRzOltzY2hlbWEuZXh0ZW5kc10pKTtcbiAgICBzY2FuU2NoZW1hKG91ckJhc2UrJy9hZGRpdGlvbmFsSXRlbXMnLCBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zKTtcbiAgICBzY2FuT2JqZWN0KG91ckJhc2UrJy9wcm9wZXJ0aWVzJywgc2NoZW1hLnByb3BlcnRpZXMpO1xuICAgIHNjYW5TY2hlbWEob3VyQmFzZSsnL2FkZGl0aW9uYWxQcm9wZXJ0aWVzJywgc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKTtcbiAgICBzY2FuT2JqZWN0KG91ckJhc2UrJy9kZWZpbml0aW9ucycsIHNjaGVtYS5kZWZpbml0aW9ucyk7XG4gICAgc2Nhbk9iamVjdChvdXJCYXNlKycvcGF0dGVyblByb3BlcnRpZXMnLCBzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpO1xuICAgIHNjYW5PYmplY3Qob3VyQmFzZSsnL2RlcGVuZGVuY2llcycsIHNjaGVtYS5kZXBlbmRlbmNpZXMpO1xuICAgIHNjYW5BcnJheShvdXJCYXNlKycvZGlzYWxsb3cnLCBzY2hlbWEuZGlzYWxsb3cpO1xuICAgIHNjYW5BcnJheShvdXJCYXNlKycvYWxsT2YnLCBzY2hlbWEuYWxsT2YpO1xuICAgIHNjYW5BcnJheShvdXJCYXNlKycvYW55T2YnLCBzY2hlbWEuYW55T2YpO1xuICAgIHNjYW5BcnJheShvdXJCYXNlKycvb25lT2YnLCBzY2hlbWEub25lT2YpO1xuICAgIHNjYW5TY2hlbWEob3VyQmFzZSsnL25vdCcsIHNjaGVtYS5ub3QpO1xuICB9XG4gIGZ1bmN0aW9uIHNjYW5BcnJheShiYXNldXJpLCBzY2hlbWFzKXtcbiAgICBpZighQXJyYXkuaXNBcnJheShzY2hlbWFzKSkgcmV0dXJuO1xuICAgIGZvcih2YXIgaT0wOyBpPHNjaGVtYXMubGVuZ3RoOyBpKyspe1xuICAgICAgc2NhblNjaGVtYShiYXNldXJpKycvJytpLCBzY2hlbWFzW2ldKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2Nhbk9iamVjdChiYXNldXJpLCBzY2hlbWFzKXtcbiAgICBpZighc2NoZW1hcyB8fCB0eXBlb2Ygc2NoZW1hcyE9J29iamVjdCcpIHJldHVybjtcbiAgICBmb3IodmFyIHAgaW4gc2NoZW1hcyl7XG4gICAgICBzY2FuU2NoZW1hKGJhc2V1cmkrJy8nK3AsIHNjaGVtYXNbcF0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmb3VuZCA9IHt9O1xuICB2YXIgcmVmID0ge307XG4gIHNjYW5TY2hlbWEoYmFzZSwgc2NoZW1hKTtcbiAgcmV0dXJuIG5ldyBTY2hlbWFTY2FuUmVzdWx0KGZvdW5kLCByZWYpO1xufTtcbiJdLCJuYW1lcyI6WyJ1cmlsaWIiLCJyZXF1aXJlIiwiaGVscGVycyIsIm1vZHVsZSIsImV4cG9ydHMiLCJTY2hlbWFTY2FuUmVzdWx0IiwiZm91bmQiLCJyZWYiLCJpZCIsInNjYW4iLCJiYXNlIiwic2NoZW1hIiwic2NhblNjaGVtYSIsImJhc2V1cmkiLCIkcmVmIiwicmVzb2x2ZWRVcmkiLCJyZXNvbHZlIiwiJGlkIiwib3VyQmFzZSIsImluZGV4T2YiLCJkZWVwQ29tcGFyZVN0cmljdCIsIkVycm9yIiwibGVuZ3RoIiwic3Vic3RyaW5nIiwic2NhbkFycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiaXRlbXMiLCJleHRlbmRzIiwiYWRkaXRpb25hbEl0ZW1zIiwic2Nhbk9iamVjdCIsInByb3BlcnRpZXMiLCJhZGRpdGlvbmFsUHJvcGVydGllcyIsImRlZmluaXRpb25zIiwicGF0dGVyblByb3BlcnRpZXMiLCJkZXBlbmRlbmNpZXMiLCJkaXNhbGxvdyIsImFsbE9mIiwiYW55T2YiLCJvbmVPZiIsIm5vdCIsInNjaGVtYXMiLCJpIiwicCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonschema/lib/scan.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonschema/lib/validator.js":
/*!**************************************************!*\
  !*** ./node_modules/jsonschema/lib/validator.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar urilib = __webpack_require__(/*! url */ \"url\");\nvar attribute = __webpack_require__(/*! ./attribute */ \"(ssr)/./node_modules/jsonschema/lib/attribute.js\");\nvar helpers = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/jsonschema/lib/helpers.js\");\nvar scanSchema = (__webpack_require__(/*! ./scan */ \"(ssr)/./node_modules/jsonschema/lib/scan.js\").scan);\nvar ValidatorResult = helpers.ValidatorResult;\nvar ValidatorResultError = helpers.ValidatorResultError;\nvar SchemaError = helpers.SchemaError;\nvar SchemaContext = helpers.SchemaContext;\n//var anonymousBase = 'vnd.jsonschema:///';\nvar anonymousBase = \"/\";\n/**\n * Creates a new Validator object\n * @name Validator\n * @constructor\n */ var Validator = function Validator() {\n    // Allow a validator instance to override global custom formats or to have their\n    // own custom formats.\n    this.customFormats = Object.create(Validator.prototype.customFormats);\n    this.schemas = {};\n    this.unresolvedRefs = [];\n    // Use Object.create to make this extensible without Validator instances stepping on each other's toes.\n    this.types = Object.create(types);\n    this.attributes = Object.create(attribute.validators);\n};\n// Allow formats to be registered globally.\nValidator.prototype.customFormats = {};\n// Hint at the presence of a property\nValidator.prototype.schemas = null;\nValidator.prototype.types = null;\nValidator.prototype.attributes = null;\nValidator.prototype.unresolvedRefs = null;\n/**\n * Adds a schema with a certain urn to the Validator instance.\n * @param schema\n * @param urn\n * @return {Object}\n */ Validator.prototype.addSchema = function addSchema(schema, base) {\n    var self = this;\n    if (!schema) {\n        return null;\n    }\n    var scan = scanSchema(base || anonymousBase, schema);\n    var ourUri = base || schema.$id || schema.id;\n    for(var uri in scan.id){\n        this.schemas[uri] = scan.id[uri];\n    }\n    for(var uri in scan.ref){\n        // If this schema is already defined, it will be filtered out by the next step\n        this.unresolvedRefs.push(uri);\n    }\n    // Remove newly defined schemas from unresolvedRefs\n    this.unresolvedRefs = this.unresolvedRefs.filter(function(uri) {\n        return typeof self.schemas[uri] === \"undefined\";\n    });\n    return this.schemas[ourUri];\n};\nValidator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {\n    if (!Array.isArray(schemas)) return;\n    for(var i = 0; i < schemas.length; i++){\n        this.addSubSchema(baseuri, schemas[i]);\n    }\n};\nValidator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {\n    if (!schemas || typeof schemas != \"object\") return;\n    for(var p in schemas){\n        this.addSubSchema(baseuri, schemas[p]);\n    }\n};\n/**\n * Sets all the schemas of the Validator instance.\n * @param schemas\n */ Validator.prototype.setSchemas = function setSchemas(schemas) {\n    this.schemas = schemas;\n};\n/**\n * Returns the schema of a certain urn\n * @param urn\n */ Validator.prototype.getSchema = function getSchema(urn) {\n    return this.schemas[urn];\n};\n/**\n * Validates instance against the provided schema\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {Array}\n */ Validator.prototype.validate = function validate(instance, schema, options, ctx) {\n    if (typeof schema !== \"boolean\" && typeof schema !== \"object\" || schema === null) {\n        throw new SchemaError(\"Expected `schema` to be an object or boolean\");\n    }\n    if (!options) {\n        options = {};\n    }\n    // This section indexes subschemas in the provided schema, so they don't need to be added with Validator#addSchema\n    // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI\n    var id = schema.$id || schema.id;\n    var base = urilib.resolve(options.base || anonymousBase, id || \"\");\n    if (!ctx) {\n        ctx = new SchemaContext(schema, options, [], base, Object.create(this.schemas));\n        if (!ctx.schemas[base]) {\n            ctx.schemas[base] = schema;\n        }\n        var found = scanSchema(base, schema);\n        for(var n in found.id){\n            var sch = found.id[n];\n            ctx.schemas[n] = sch;\n        }\n    }\n    if (options.required && instance === undefined) {\n        var result = new ValidatorResult(instance, schema, options, ctx);\n        result.addError(\"is required, but is undefined\");\n        return result;\n    }\n    var result = this.validateSchema(instance, schema, options, ctx);\n    if (!result) {\n        throw new Error(\"Result undefined\");\n    } else if (options.throwAll && result.errors.length) {\n        throw new ValidatorResultError(result);\n    }\n    return result;\n};\n/**\n* @param Object schema\n* @return mixed schema uri or false\n*/ function shouldResolve(schema) {\n    var ref = typeof schema === \"string\" ? schema : schema.$ref;\n    if (typeof ref == \"string\") return ref;\n    return false;\n}\n/**\n * Validates an instance against the schema (the actual work horse)\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @private\n * @return {ValidatorResult}\n */ Validator.prototype.validateSchema = function validateSchema(instance, schema, options, ctx) {\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    // Support for the true/false schemas\n    if (typeof schema === \"boolean\") {\n        if (schema === true) {\n            // `true` is always valid\n            schema = {};\n        } else if (schema === false) {\n            // `false` is always invalid\n            schema = {\n                type: []\n            };\n        }\n    } else if (!schema) {\n        // This might be a string\n        throw new Error(\"schema is undefined\");\n    }\n    if (schema[\"extends\"]) {\n        if (Array.isArray(schema[\"extends\"])) {\n            var schemaobj = {\n                schema: schema,\n                ctx: ctx\n            };\n            schema[\"extends\"].forEach(this.schemaTraverser.bind(this, schemaobj));\n            schema = schemaobj.schema;\n            schemaobj.schema = null;\n            schemaobj.ctx = null;\n            schemaobj = null;\n        } else {\n            schema = helpers.deepMerge(schema, this.superResolve(schema[\"extends\"], ctx));\n        }\n    }\n    // If passed a string argument, load that schema URI\n    var switchSchema = shouldResolve(schema);\n    if (switchSchema) {\n        var resolved = this.resolve(schema, switchSchema, ctx);\n        var subctx = new SchemaContext(resolved.subschema, options, ctx.path, resolved.switchSchema, ctx.schemas);\n        return this.validateSchema(instance, resolved.subschema, options, subctx);\n    }\n    var skipAttributes = options && options.skipAttributes || [];\n    // Validate each schema attribute against the instance\n    for(var key in schema){\n        if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {\n            var validatorErr = null;\n            var validator = this.attributes[key];\n            if (validator) {\n                validatorErr = validator.call(this, instance, schema, options, ctx);\n            } else if (options.allowUnknownAttributes === false) {\n                // This represents an error with the schema itself, not an invalid instance\n                throw new SchemaError(\"Unsupported attribute: \" + key, schema);\n            }\n            if (validatorErr) {\n                result.importErrors(validatorErr);\n            }\n        }\n    }\n    if (typeof options.rewrite == \"function\") {\n        var value = options.rewrite.call(this, instance, schema, options, ctx);\n        result.instance = value;\n    }\n    return result;\n};\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/ Validator.prototype.schemaTraverser = function schemaTraverser(schemaobj, s) {\n    schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));\n};\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/ Validator.prototype.superResolve = function superResolve(schema, ctx) {\n    var ref = shouldResolve(schema);\n    if (ref) {\n        return this.resolve(schema, ref, ctx).subschema;\n    }\n    return schema;\n};\n/**\n* @private\n* @param Object schema\n* @param Object switchSchema\n* @param SchemaContext ctx\n* @return Object resolved schemas {subschema:String, switchSchema: String}\n* @throws SchemaError\n*/ Validator.prototype.resolve = function resolve(schema, switchSchema, ctx) {\n    switchSchema = ctx.resolve(switchSchema);\n    // First see if the schema exists under the provided URI\n    if (ctx.schemas[switchSchema]) {\n        return {\n            subschema: ctx.schemas[switchSchema],\n            switchSchema: switchSchema\n        };\n    }\n    // Else try walking the property pointer\n    var parsed = urilib.parse(switchSchema);\n    var fragment = parsed && parsed.hash;\n    var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);\n    if (!document || !ctx.schemas[document]) {\n        throw new SchemaError(\"no such schema <\" + switchSchema + \">\", schema);\n    }\n    var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));\n    if (subschema === undefined) {\n        throw new SchemaError(\"no such schema \" + fragment + \" located in <\" + document + \">\", schema);\n    }\n    return {\n        subschema: subschema,\n        switchSchema: switchSchema\n    };\n};\n/**\n * Tests whether the instance if of a certain type.\n * @private\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @param type\n * @return {boolean}\n */ Validator.prototype.testType = function validateType(instance, schema, options, ctx, type) {\n    if (type === undefined) {\n        return;\n    } else if (type === null) {\n        throw new SchemaError('Unexpected null in \"type\" keyword');\n    }\n    if (typeof this.types[type] == \"function\") {\n        return this.types[type].call(this, instance);\n    }\n    if (type && typeof type == \"object\") {\n        var res = this.validateSchema(instance, type, options, ctx);\n        return res === undefined || !(res && res.errors.length);\n    }\n    // Undefined or properties not on the list are acceptable, same as not being defined\n    return true;\n};\nvar types = Validator.prototype.types = {};\ntypes.string = function testString(instance) {\n    return typeof instance == \"string\";\n};\ntypes.number = function testNumber(instance) {\n    // isFinite returns false for NaN, Infinity, and -Infinity\n    return typeof instance == \"number\" && isFinite(instance);\n};\ntypes.integer = function testInteger(instance) {\n    return typeof instance == \"number\" && instance % 1 === 0;\n};\ntypes.boolean = function testBoolean(instance) {\n    return typeof instance == \"boolean\";\n};\ntypes.array = function testArray(instance) {\n    return Array.isArray(instance);\n};\ntypes[\"null\"] = function testNull(instance) {\n    return instance === null;\n};\ntypes.date = function testDate(instance) {\n    return instance instanceof Date;\n};\ntypes.any = function testAny(instance) {\n    return true;\n};\ntypes.object = function testObject(instance) {\n    // TODO: fix this - see #15\n    return instance && typeof instance === \"object\" && !Array.isArray(instance) && !(instance instanceof Date);\n};\nmodule.exports = Validator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbnNjaGVtYS9saWIvdmFsaWRhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsU0FBU0MsbUJBQU9BLENBQUM7QUFFckIsSUFBSUMsWUFBWUQsbUJBQU9BLENBQUM7QUFDeEIsSUFBSUUsVUFBVUYsbUJBQU9BLENBQUM7QUFDdEIsSUFBSUcsYUFBYUgsdUZBQXNCO0FBQ3ZDLElBQUlLLGtCQUFrQkgsUUFBUUcsZUFBZTtBQUM3QyxJQUFJQyx1QkFBdUJKLFFBQVFJLG9CQUFvQjtBQUN2RCxJQUFJQyxjQUFjTCxRQUFRSyxXQUFXO0FBQ3JDLElBQUlDLGdCQUFnQk4sUUFBUU0sYUFBYTtBQUN6QywyQ0FBMkM7QUFDM0MsSUFBSUMsZ0JBQWdCO0FBRXBCOzs7O0NBSUMsR0FDRCxJQUFJQyxZQUFZLFNBQVNBO0lBQ3ZCLGdGQUFnRjtJQUNoRixzQkFBc0I7SUFDdEIsSUFBSSxDQUFDQyxhQUFhLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ0gsVUFBVUksU0FBUyxDQUFDSCxhQUFhO0lBQ3BFLElBQUksQ0FBQ0ksT0FBTyxHQUFHLENBQUM7SUFDaEIsSUFBSSxDQUFDQyxjQUFjLEdBQUcsRUFBRTtJQUV4Qix1R0FBdUc7SUFDdkcsSUFBSSxDQUFDQyxLQUFLLEdBQUdMLE9BQU9DLE1BQU0sQ0FBQ0k7SUFDM0IsSUFBSSxDQUFDQyxVQUFVLEdBQUdOLE9BQU9DLE1BQU0sQ0FBQ1osVUFBVWtCLFVBQVU7QUFDdEQ7QUFFQSwyQ0FBMkM7QUFDM0NULFVBQVVJLFNBQVMsQ0FBQ0gsYUFBYSxHQUFHLENBQUM7QUFFckMscUNBQXFDO0FBQ3JDRCxVQUFVSSxTQUFTLENBQUNDLE9BQU8sR0FBRztBQUM5QkwsVUFBVUksU0FBUyxDQUFDRyxLQUFLLEdBQUc7QUFDNUJQLFVBQVVJLFNBQVMsQ0FBQ0ksVUFBVSxHQUFHO0FBQ2pDUixVQUFVSSxTQUFTLENBQUNFLGNBQWMsR0FBRztBQUVyQzs7Ozs7Q0FLQyxHQUNETixVQUFVSSxT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SyxDQUFDLE9BQU8sR0FBRyxTQUFTeUYsU0FBVTlELFFBQVE7SUFDekMsT0FBT0EsYUFBYTtBQUN0QjtBQUNBM0IsTUFBTTBGLElBQUksR0FBRyxTQUFTQyxTQUFVaEUsUUFBUTtJQUN0QyxPQUFPQSxvQkFBb0JpRTtBQUM3QjtBQUNBNUYsTUFBTTZGLEdBQUcsR0FBRyxTQUFTQyxRQUFTbkUsUUFBUTtJQUNwQyxPQUFPO0FBQ1Q7QUFDQTNCLE1BQU0rRixNQUFNLEdBQUcsU0FBU0MsV0FBWXJFLFFBQVE7SUFDMUMsMkJBQTJCO0lBQzNCLE9BQU9BLFlBQWEsT0FBT0EsYUFBYSxZQUFhLENBQUVYLE1BQU1DLE9BQU8sQ0FBQ1UsYUFBYyxDQUFFQSxDQUFBQSxvQkFBb0JpRSxJQUFHO0FBQzlHO0FBRUFLLE9BQU9DLE9BQU8sR0FBR3pHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9qc29uc2NoZW1hL2xpYi92YWxpZGF0b3IuanM/MTc4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1cmlsaWIgPSByZXF1aXJlKCd1cmwnKTtcblxudmFyIGF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4vYXR0cmlidXRlJyk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xudmFyIHNjYW5TY2hlbWEgPSByZXF1aXJlKCcuL3NjYW4nKS5zY2FuO1xudmFyIFZhbGlkYXRvclJlc3VsdCA9IGhlbHBlcnMuVmFsaWRhdG9yUmVzdWx0O1xudmFyIFZhbGlkYXRvclJlc3VsdEVycm9yID0gaGVscGVycy5WYWxpZGF0b3JSZXN1bHRFcnJvcjtcbnZhciBTY2hlbWFFcnJvciA9IGhlbHBlcnMuU2NoZW1hRXJyb3I7XG52YXIgU2NoZW1hQ29udGV4dCA9IGhlbHBlcnMuU2NoZW1hQ29udGV4dDtcbi8vdmFyIGFub255bW91c0Jhc2UgPSAndm5kLmpzb25zY2hlbWE6Ly8vJztcbnZhciBhbm9ueW1vdXNCYXNlID0gJy8nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVmFsaWRhdG9yIG9iamVjdFxuICogQG5hbWUgVmFsaWRhdG9yXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFZhbGlkYXRvciA9IGZ1bmN0aW9uIFZhbGlkYXRvciAoKSB7XG4gIC8vIEFsbG93IGEgdmFsaWRhdG9yIGluc3RhbmNlIHRvIG92ZXJyaWRlIGdsb2JhbCBjdXN0b20gZm9ybWF0cyBvciB0byBoYXZlIHRoZWlyXG4gIC8vIG93biBjdXN0b20gZm9ybWF0cy5cbiAgdGhpcy5jdXN0b21Gb3JtYXRzID0gT2JqZWN0LmNyZWF0ZShWYWxpZGF0b3IucHJvdG90eXBlLmN1c3RvbUZvcm1hdHMpO1xuICB0aGlzLnNjaGVtYXMgPSB7fTtcbiAgdGhpcy51bnJlc29sdmVkUmVmcyA9IFtdO1xuXG4gIC8vIFVzZSBPYmplY3QuY3JlYXRlIHRvIG1ha2UgdGhpcyBleHRlbnNpYmxlIHdpdGhvdXQgVmFsaWRhdG9yIGluc3RhbmNlcyBzdGVwcGluZyBvbiBlYWNoIG90aGVyJ3MgdG9lcy5cbiAgdGhpcy50eXBlcyA9IE9iamVjdC5jcmVhdGUodHlwZXMpO1xuICB0aGlzLmF0dHJpYnV0ZXMgPSBPYmplY3QuY3JlYXRlKGF0dHJpYnV0ZS52YWxpZGF0b3JzKTtcbn07XG5cbi8vIEFsbG93IGZvcm1hdHMgdG8gYmUgcmVnaXN0ZXJlZCBnbG9iYWxseS5cblZhbGlkYXRvci5wcm90b3R5cGUuY3VzdG9tRm9ybWF0cyA9IHt9O1xuXG4vLyBIaW50IGF0IHRoZSBwcmVzZW5jZSBvZiBhIHByb3BlcnR5XG5WYWxpZGF0b3IucHJvdG90eXBlLnNjaGVtYXMgPSBudWxsO1xuVmFsaWRhdG9yLnByb3RvdHlwZS50eXBlcyA9IG51bGw7XG5WYWxpZGF0b3IucHJvdG90eXBlLmF0dHJpYnV0ZXMgPSBudWxsO1xuVmFsaWRhdG9yLnByb3RvdHlwZS51bnJlc29sdmVkUmVmcyA9IG51bGw7XG5cbi8qKlxuICogQWRkcyBhIHNjaGVtYSB3aXRoIGEgY2VydGFpbiB1cm4gdG8gdGhlIFZhbGlkYXRvciBpbnN0YW5jZS5cbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSB1cm5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS5hZGRTY2hlbWEgPSBmdW5jdGlvbiBhZGRTY2hlbWEgKHNjaGVtYSwgYmFzZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICghc2NoZW1hKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHNjYW4gPSBzY2FuU2NoZW1hKGJhc2V8fGFub255bW91c0Jhc2UsIHNjaGVtYSk7XG4gIHZhciBvdXJVcmkgPSBiYXNlIHx8IHNjaGVtYS4kaWQgfHwgc2NoZW1hLmlkO1xuICBmb3IodmFyIHVyaSBpbiBzY2FuLmlkKXtcbiAgICB0aGlzLnNjaGVtYXNbdXJpXSA9IHNjYW4uaWRbdXJpXTtcbiAgfVxuICBmb3IodmFyIHVyaSBpbiBzY2FuLnJlZil7XG4gICAgLy8gSWYgdGhpcyBzY2hlbWEgaXMgYWxyZWFkeSBkZWZpbmVkLCBpdCB3aWxsIGJlIGZpbHRlcmVkIG91dCBieSB0aGUgbmV4dCBzdGVwXG4gICAgdGhpcy51bnJlc29sdmVkUmVmcy5wdXNoKHVyaSk7XG4gIH1cbiAgLy8gUmVtb3ZlIG5ld2x5IGRlZmluZWQgc2NoZW1hcyBmcm9tIHVucmVzb2x2ZWRSZWZzXG4gIHRoaXMudW5yZXNvbHZlZFJlZnMgPSB0aGlzLnVucmVzb2x2ZWRSZWZzLmZpbHRlcihmdW5jdGlvbih1cmkpe1xuICAgIHJldHVybiB0eXBlb2Ygc2VsZi5zY2hlbWFzW3VyaV09PT0ndW5kZWZpbmVkJztcbiAgfSk7XG4gIHJldHVybiB0aGlzLnNjaGVtYXNbb3VyVXJpXTtcbn07XG5cblZhbGlkYXRvci5wcm90b3R5cGUuYWRkU3ViU2NoZW1hQXJyYXkgPSBmdW5jdGlvbiBhZGRTdWJTY2hlbWFBcnJheShiYXNldXJpLCBzY2hlbWFzKSB7XG4gIGlmKCFBcnJheS5pc0FycmF5KHNjaGVtYXMpKSByZXR1cm47XG4gIGZvcih2YXIgaT0wOyBpPHNjaGVtYXMubGVuZ3RoOyBpKyspe1xuICAgIHRoaXMuYWRkU3ViU2NoZW1hKGJhc2V1cmksIHNjaGVtYXNbaV0pO1xuICB9XG59O1xuXG5WYWxpZGF0b3IucHJvdG90eXBlLmFkZFN1YlNjaGVtYU9iamVjdCA9IGZ1bmN0aW9uIGFkZFN1YlNjaGVtYUFycmF5KGJhc2V1cmksIHNjaGVtYXMpIHtcbiAgaWYoIXNjaGVtYXMgfHwgdHlwZW9mIHNjaGVtYXMhPSdvYmplY3QnKSByZXR1cm47XG4gIGZvcih2YXIgcCBpbiBzY2hlbWFzKXtcbiAgICB0aGlzLmFkZFN1YlNjaGVtYShiYXNldXJpLCBzY2hlbWFzW3BdKTtcbiAgfVxufTtcblxuXG5cbi8qKlxuICogU2V0cyBhbGwgdGhlIHNjaGVtYXMgb2YgdGhlIFZhbGlkYXRvciBpbnN0YW5jZS5cbiAqIEBwYXJhbSBzY2hlbWFzXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUuc2V0U2NoZW1hcyA9IGZ1bmN0aW9uIHNldFNjaGVtYXMgKHNjaGVtYXMpIHtcbiAgdGhpcy5zY2hlbWFzID0gc2NoZW1hcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2NoZW1hIG9mIGEgY2VydGFpbiB1cm5cbiAqIEBwYXJhbSB1cm5cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS5nZXRTY2hlbWEgPSBmdW5jdGlvbiBnZXRTY2hlbWEgKHVybikge1xuICByZXR1cm4gdGhpcy5zY2hlbWFzW3Vybl07XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyBpbnN0YW5jZSBhZ2FpbnN0IHRoZSBwcm92aWRlZCBzY2hlbWFcbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIFtvcHRpb25zXVxuICogQHBhcmFtIFtjdHhdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgaWYoKHR5cGVvZiBzY2hlbWEgIT09ICdib29sZWFuJyAmJiB0eXBlb2Ygc2NoZW1hICE9PSAnb2JqZWN0JykgfHwgc2NoZW1hID09PSBudWxsKXtcbiAgICB0aHJvdyBuZXcgU2NoZW1hRXJyb3IoJ0V4cGVjdGVkIGBzY2hlbWFgIHRvIGJlIGFuIG9iamVjdCBvciBib29sZWFuJyk7XG4gIH1cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIC8vIFRoaXMgc2VjdGlvbiBpbmRleGVzIHN1YnNjaGVtYXMgaW4gdGhlIHByb3ZpZGVkIHNjaGVtYSwgc28gdGhleSBkb24ndCBuZWVkIHRvIGJlIGFkZGVkIHdpdGggVmFsaWRhdG9yI2FkZFNjaGVtYVxuICAvLyBUaGlzIHdpbGwgd29yayBzbyBsb25nIGFzIHRoZSBmdW5jdGlvbiBhdCB1cmkucmVzb2x2ZSgpIHdpbGwgcmVzb2x2ZSBhIHJlbGF0aXZlIFVSSSB0byBhIHJlbGF0aXZlIFVSSVxuICB2YXIgaWQgPSBzY2hlbWEuJGlkIHx8IHNjaGVtYS5pZDtcbiAgdmFyIGJhc2UgPSB1cmlsaWIucmVzb2x2ZShvcHRpb25zLmJhc2V8fGFub255bW91c0Jhc2UsIGlkfHwnJyk7XG4gIGlmKCFjdHgpe1xuICAgIGN0eCA9IG5ldyBTY2hlbWFDb250ZXh0KHNjaGVtYSwgb3B0aW9ucywgW10sIGJhc2UsIE9iamVjdC5jcmVhdGUodGhpcy5zY2hlbWFzKSk7XG4gICAgaWYgKCFjdHguc2NoZW1hc1tiYXNlXSkge1xuICAgICAgY3R4LnNjaGVtYXNbYmFzZV0gPSBzY2hlbWE7XG4gICAgfVxuICAgIHZhciBmb3VuZCA9IHNjYW5TY2hlbWEoYmFzZSwgc2NoZW1hKTtcbiAgICBmb3IodmFyIG4gaW4gZm91bmQuaWQpe1xuICAgICAgdmFyIHNjaCA9IGZvdW5kLmlkW25dO1xuICAgICAgY3R4LnNjaGVtYXNbbl0gPSBzY2g7XG4gICAgfVxuICB9XG4gIGlmKG9wdGlvbnMucmVxdWlyZWQgJiYgaW5zdGFuY2U9PT11bmRlZmluZWQpe1xuICAgIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gICAgcmVzdWx0LmFkZEVycm9yKCdpcyByZXF1aXJlZCwgYnV0IGlzIHVuZGVmaW5lZCcpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRoaXMudmFsaWRhdGVTY2hlbWEoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgaWYgKCFyZXN1bHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3VsdCB1bmRlZmluZWQnKTtcbiAgfWVsc2UgaWYob3B0aW9ucy50aHJvd0FsbCAmJiByZXN1bHQuZXJyb3JzLmxlbmd0aCl7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRvclJlc3VsdEVycm9yKHJlc3VsdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuKiBAcGFyYW0gT2JqZWN0IHNjaGVtYVxuKiBAcmV0dXJuIG1peGVkIHNjaGVtYSB1cmkgb3IgZmFsc2VcbiovXG5mdW5jdGlvbiBzaG91bGRSZXNvbHZlKHNjaGVtYSkge1xuICB2YXIgcmVmID0gKHR5cGVvZiBzY2hlbWEgPT09ICdzdHJpbmcnKSA/IHNjaGVtYSA6IHNjaGVtYS4kcmVmO1xuICBpZiAodHlwZW9mIHJlZj09J3N0cmluZycpIHJldHVybiByZWY7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgYW4gaW5zdGFuY2UgYWdhaW5zdCB0aGUgc2NoZW1hICh0aGUgYWN0dWFsIHdvcmsgaG9yc2UpXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gY3R4XG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7VmFsaWRhdG9yUmVzdWx0fVxuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlU2NoZW1hID0gZnVuY3Rpb24gdmFsaWRhdGVTY2hlbWEgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuXG4gIC8vIFN1cHBvcnQgZm9yIHRoZSB0cnVlL2ZhbHNlIHNjaGVtYXNcbiAgaWYodHlwZW9mIHNjaGVtYT09PSdib29sZWFuJykge1xuICAgIGlmKHNjaGVtYT09PXRydWUpe1xuICAgICAgLy8gYHRydWVgIGlzIGFsd2F5cyB2YWxpZFxuICAgICAgc2NoZW1hID0ge307XG4gICAgfWVsc2UgaWYoc2NoZW1hPT09ZmFsc2Upe1xuICAgICAgLy8gYGZhbHNlYCBpcyBhbHdheXMgaW52YWxpZFxuICAgICAgc2NoZW1hID0ge3R5cGU6IFtdfTtcbiAgICB9XG4gIH1lbHNlIGlmKCFzY2hlbWEpe1xuICAgIC8vIFRoaXMgbWlnaHQgYmUgYSBzdHJpbmdcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgaXMgdW5kZWZpbmVkXCIpO1xuICB9XG5cbiAgaWYgKHNjaGVtYVsnZXh0ZW5kcyddKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hWydleHRlbmRzJ10pKSB7XG4gICAgICB2YXIgc2NoZW1hb2JqID0ge3NjaGVtYTogc2NoZW1hLCBjdHg6IGN0eH07XG4gICAgICBzY2hlbWFbJ2V4dGVuZHMnXS5mb3JFYWNoKHRoaXMuc2NoZW1hVHJhdmVyc2VyLmJpbmQodGhpcywgc2NoZW1hb2JqKSk7XG4gICAgICBzY2hlbWEgPSBzY2hlbWFvYmouc2NoZW1hO1xuICAgICAgc2NoZW1hb2JqLnNjaGVtYSA9IG51bGw7XG4gICAgICBzY2hlbWFvYmouY3R4ID0gbnVsbDtcbiAgICAgIHNjaGVtYW9iaiA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVtYSA9IGhlbHBlcnMuZGVlcE1lcmdlKHNjaGVtYSwgdGhpcy5zdXBlclJlc29sdmUoc2NoZW1hWydleHRlbmRzJ10sIGN0eCkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHBhc3NlZCBhIHN0cmluZyBhcmd1bWVudCwgbG9hZCB0aGF0IHNjaGVtYSBVUklcbiAgdmFyIHN3aXRjaFNjaGVtYSA9IHNob3VsZFJlc29sdmUoc2NoZW1hKTtcbiAgaWYgKHN3aXRjaFNjaGVtYSkge1xuICAgIHZhciByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZShzY2hlbWEsIHN3aXRjaFNjaGVtYSwgY3R4KTtcbiAgICB2YXIgc3ViY3R4ID0gbmV3IFNjaGVtYUNvbnRleHQocmVzb2x2ZWQuc3Vic2NoZW1hLCBvcHRpb25zLCBjdHgucGF0aCwgcmVzb2x2ZWQuc3dpdGNoU2NoZW1hLCBjdHguc2NoZW1hcyk7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGVTY2hlbWEoaW5zdGFuY2UsIHJlc29sdmVkLnN1YnNjaGVtYSwgb3B0aW9ucywgc3ViY3R4KTtcbiAgfVxuXG4gIHZhciBza2lwQXR0cmlidXRlcyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5za2lwQXR0cmlidXRlcyB8fCBbXTtcbiAgLy8gVmFsaWRhdGUgZWFjaCBzY2hlbWEgYXR0cmlidXRlIGFnYWluc3QgdGhlIGluc3RhbmNlXG4gIGZvciAodmFyIGtleSBpbiBzY2hlbWEpIHtcbiAgICBpZiAoIWF0dHJpYnV0ZS5pZ25vcmVQcm9wZXJ0aWVzW2tleV0gJiYgc2tpcEF0dHJpYnV0ZXMuaW5kZXhPZihrZXkpIDwgMCkge1xuICAgICAgdmFyIHZhbGlkYXRvckVyciA9IG51bGw7XG4gICAgICB2YXIgdmFsaWRhdG9yID0gdGhpcy5hdHRyaWJ1dGVzW2tleV07XG4gICAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICAgIHZhbGlkYXRvckVyciA9IHZhbGlkYXRvci5jYWxsKHRoaXMsIGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYWxsb3dVbmtub3duQXR0cmlidXRlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gVGhpcyByZXByZXNlbnRzIGFuIGVycm9yIHdpdGggdGhlIHNjaGVtYSBpdHNlbGYsIG5vdCBhbiBpbnZhbGlkIGluc3RhbmNlXG4gICAgICAgIHRocm93IG5ldyBTY2hlbWFFcnJvcihcIlVuc3VwcG9ydGVkIGF0dHJpYnV0ZTogXCIgKyBrZXksIHNjaGVtYSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsaWRhdG9yRXJyKSB7XG4gICAgICAgIHJlc3VsdC5pbXBvcnRFcnJvcnModmFsaWRhdG9yRXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMucmV3cml0ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy5yZXdyaXRlLmNhbGwodGhpcywgaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgICByZXN1bHQuaW5zdGFuY2UgPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4qIEBwcml2YXRlXG4qIEBwYXJhbSBPYmplY3Qgc2NoZW1hXG4qIEBwYXJhbSBTY2hlbWFDb250ZXh0IGN0eFxuKiBAcmV0dXJucyBPYmplY3Qgc2NoZW1hIG9yIHJlc29sdmVkIHNjaGVtYVxuKi9cblZhbGlkYXRvci5wcm90b3R5cGUuc2NoZW1hVHJhdmVyc2VyID0gZnVuY3Rpb24gc2NoZW1hVHJhdmVyc2VyIChzY2hlbWFvYmosIHMpIHtcbiAgc2NoZW1hb2JqLnNjaGVtYSA9IGhlbHBlcnMuZGVlcE1lcmdlKHNjaGVtYW9iai5zY2hlbWEsIHRoaXMuc3VwZXJSZXNvbHZlKHMsIHNjaGVtYW9iai5jdHgpKTtcbn07XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0gT2JqZWN0IHNjaGVtYVxuKiBAcGFyYW0gU2NoZW1hQ29udGV4dCBjdHhcbiogQHJldHVybnMgT2JqZWN0IHNjaGVtYSBvciByZXNvbHZlZCBzY2hlbWFcbiovXG5WYWxpZGF0b3IucHJvdG90eXBlLnN1cGVyUmVzb2x2ZSA9IGZ1bmN0aW9uIHN1cGVyUmVzb2x2ZSAoc2NoZW1hLCBjdHgpIHtcbiAgdmFyIHJlZiA9IHNob3VsZFJlc29sdmUoc2NoZW1hKTtcbiAgaWYocmVmKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZShzY2hlbWEsIHJlZiwgY3R4KS5zdWJzY2hlbWE7XG4gIH1cbiAgcmV0dXJuIHNjaGVtYTtcbn07XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0gT2JqZWN0IHNjaGVtYVxuKiBAcGFyYW0gT2JqZWN0IHN3aXRjaFNjaGVtYVxuKiBAcGFyYW0gU2NoZW1hQ29udGV4dCBjdHhcbiogQHJldHVybiBPYmplY3QgcmVzb2x2ZWQgc2NoZW1hcyB7c3Vic2NoZW1hOlN0cmluZywgc3dpdGNoU2NoZW1hOiBTdHJpbmd9XG4qIEB0aHJvd3MgU2NoZW1hRXJyb3JcbiovXG5WYWxpZGF0b3IucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlIChzY2hlbWEsIHN3aXRjaFNjaGVtYSwgY3R4KSB7XG4gIHN3aXRjaFNjaGVtYSA9IGN0eC5yZXNvbHZlKHN3aXRjaFNjaGVtYSk7XG4gIC8vIEZpcnN0IHNlZSBpZiB0aGUgc2NoZW1hIGV4aXN0cyB1bmRlciB0aGUgcHJvdmlkZWQgVVJJXG4gIGlmIChjdHguc2NoZW1hc1tzd2l0Y2hTY2hlbWFdKSB7XG4gICAgcmV0dXJuIHtzdWJzY2hlbWE6IGN0eC5zY2hlbWFzW3N3aXRjaFNjaGVtYV0sIHN3aXRjaFNjaGVtYTogc3dpdGNoU2NoZW1hfTtcbiAgfVxuICAvLyBFbHNlIHRyeSB3YWxraW5nIHRoZSBwcm9wZXJ0eSBwb2ludGVyXG4gIHZhciBwYXJzZWQgPSB1cmlsaWIucGFyc2Uoc3dpdGNoU2NoZW1hKTtcbiAgdmFyIGZyYWdtZW50ID0gcGFyc2VkICYmIHBhcnNlZC5oYXNoO1xuICB2YXIgZG9jdW1lbnQgPSBmcmFnbWVudCAmJiBmcmFnbWVudC5sZW5ndGggJiYgc3dpdGNoU2NoZW1hLnN1YnN0cigwLCBzd2l0Y2hTY2hlbWEubGVuZ3RoIC0gZnJhZ21lbnQubGVuZ3RoKTtcbiAgaWYgKCFkb2N1bWVudCB8fCAhY3R4LnNjaGVtYXNbZG9jdW1lbnRdKSB7XG4gICAgdGhyb3cgbmV3IFNjaGVtYUVycm9yKFwibm8gc3VjaCBzY2hlbWEgPFwiICsgc3dpdGNoU2NoZW1hICsgXCI+XCIsIHNjaGVtYSk7XG4gIH1cbiAgdmFyIHN1YnNjaGVtYSA9IGhlbHBlcnMub2JqZWN0R2V0UGF0aChjdHguc2NoZW1hc1tkb2N1bWVudF0sIGZyYWdtZW50LnN1YnN0cigxKSk7XG4gIGlmKHN1YnNjaGVtYT09PXVuZGVmaW5lZCl7XG4gICAgdGhyb3cgbmV3IFNjaGVtYUVycm9yKFwibm8gc3VjaCBzY2hlbWEgXCIgKyBmcmFnbWVudCArIFwiIGxvY2F0ZWQgaW4gPFwiICsgZG9jdW1lbnQgKyBcIj5cIiwgc2NoZW1hKTtcbiAgfVxuICByZXR1cm4ge3N1YnNjaGVtYTogc3Vic2NoZW1hLCBzd2l0Y2hTY2hlbWE6IHN3aXRjaFNjaGVtYX07XG59O1xuXG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgdGhlIGluc3RhbmNlIGlmIG9mIGEgY2VydGFpbiB0eXBlLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBjdHhcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLnRlc3RUeXBlID0gZnVuY3Rpb24gdmFsaWRhdGVUeXBlIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgsIHR5cGUpIHtcbiAgaWYodHlwZT09PXVuZGVmaW5lZCl7XG4gICAgcmV0dXJuO1xuICB9ZWxzZSBpZih0eXBlPT09bnVsbCl7XG4gICAgdGhyb3cgbmV3IFNjaGVtYUVycm9yKCdVbmV4cGVjdGVkIG51bGwgaW4gXCJ0eXBlXCIga2V5d29yZCcpO1xuICB9XG4gIGlmICh0eXBlb2YgdGhpcy50eXBlc1t0eXBlXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZXNbdHlwZV0uY2FsbCh0aGlzLCBpbnN0YW5jZSk7XG4gIH1cbiAgaWYgKHR5cGUgJiYgdHlwZW9mIHR5cGUgPT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0gdGhpcy52YWxpZGF0ZVNjaGVtYShpbnN0YW5jZSwgdHlwZSwgb3B0aW9ucywgY3R4KTtcbiAgICByZXR1cm4gcmVzID09PSB1bmRlZmluZWQgfHwgIShyZXMgJiYgcmVzLmVycm9ycy5sZW5ndGgpO1xuICB9XG4gIC8vIFVuZGVmaW5lZCBvciBwcm9wZXJ0aWVzIG5vdCBvbiB0aGUgbGlzdCBhcmUgYWNjZXB0YWJsZSwgc2FtZSBhcyBub3QgYmVpbmcgZGVmaW5lZFxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciB0eXBlcyA9IFZhbGlkYXRvci5wcm90b3R5cGUudHlwZXMgPSB7fTtcbnR5cGVzLnN0cmluZyA9IGZ1bmN0aW9uIHRlc3RTdHJpbmcgKGluc3RhbmNlKSB7XG4gIHJldHVybiB0eXBlb2YgaW5zdGFuY2UgPT0gJ3N0cmluZyc7XG59O1xudHlwZXMubnVtYmVyID0gZnVuY3Rpb24gdGVzdE51bWJlciAoaW5zdGFuY2UpIHtcbiAgLy8gaXNGaW5pdGUgcmV0dXJucyBmYWxzZSBmb3IgTmFOLCBJbmZpbml0eSwgYW5kIC1JbmZpbml0eVxuICByZXR1cm4gdHlwZW9mIGluc3RhbmNlID09ICdudW1iZXInICYmIGlzRmluaXRlKGluc3RhbmNlKTtcbn07XG50eXBlcy5pbnRlZ2VyID0gZnVuY3Rpb24gdGVzdEludGVnZXIgKGluc3RhbmNlKSB7XG4gIHJldHVybiAodHlwZW9mIGluc3RhbmNlID09ICdudW1iZXInKSAmJiBpbnN0YW5jZSAlIDEgPT09IDA7XG59O1xudHlwZXMuYm9vbGVhbiA9IGZ1bmN0aW9uIHRlc3RCb29sZWFuIChpbnN0YW5jZSkge1xuICByZXR1cm4gdHlwZW9mIGluc3RhbmNlID09ICdib29sZWFuJztcbn07XG50eXBlcy5hcnJheSA9IGZ1bmN0aW9uIHRlc3RBcnJheSAoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaW5zdGFuY2UpO1xufTtcbnR5cGVzWydudWxsJ10gPSBmdW5jdGlvbiB0ZXN0TnVsbCAoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlID09PSBudWxsO1xufTtcbnR5cGVzLmRhdGUgPSBmdW5jdGlvbiB0ZXN0RGF0ZSAoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlIGluc3RhbmNlb2YgRGF0ZTtcbn07XG50eXBlcy5hbnkgPSBmdW5jdGlvbiB0ZXN0QW55IChpbnN0YW5jZSkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG50eXBlcy5vYmplY3QgPSBmdW5jdGlvbiB0ZXN0T2JqZWN0IChpbnN0YW5jZSkge1xuICAvLyBUT0RPOiBmaXggdGhpcyAtIHNlZSAjMTVcbiAgcmV0dXJuIGluc3RhbmNlICYmICh0eXBlb2YgaW5zdGFuY2UgPT09ICdvYmplY3QnKSAmJiAhKEFycmF5LmlzQXJyYXkoaW5zdGFuY2UpKSAmJiAhKGluc3RhbmNlIGluc3RhbmNlb2YgRGF0ZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZhbGlkYXRvcjtcbiJdLCJuYW1lcyI6WyJ1cmlsaWIiLCJyZXF1aXJlIiwiYXR0cmlidXRlIiwiaGVscGVycyIsInNjYW5TY2hlbWEiLCJzY2FuIiwiVmFsaWRhdG9yUmVzdWx0IiwiVmFsaWRhdG9yUmVzdWx0RXJyb3IiLCJTY2hlbWFFcnJvciIsIlNjaGVtYUNvbnRleHQiLCJhbm9ueW1vdXNCYXNlIiwiVmFsaWRhdG9yIiwiY3VzdG9tRm9ybWF0cyIsIk9iamVjdCIsImNyZWF0ZSIsInByb3RvdHlwZSIsInNjaGVtYXMiLCJ1bnJlc29sdmVkUmVmcyIsInR5cGVzIiwiYXR0cmlidXRlcyIsInZhbGlkYXRvcnMiLCJhZGRTY2hlbWEiLCJzY2hlbWEiLCJiYXNlIiwic2VsZiIsIm91clVyaSIsIiRpZCIsImlkIiwidXJpIiwicmVmIiwicHVzaCIsImZpbHRlciIsImFkZFN1YlNjaGVtYUFycmF5IiwiYmFzZXVyaSIsIkFycmF5IiwiaXNBcnJheSIsImkiLCJsZW5ndGgiLCJhZGRTdWJTY2hlbWEiLCJhZGRTdWJTY2hlbWFPYmplY3QiLCJwIiwic2V0U2NoZW1hcyIsImdldFNjaGVtYSIsInVybiIsInZhbGlkYXRlIiwiaW5zdGFuY2UiLCJvcHRpb25zIiwiY3R4IiwicmVzb2x2ZSIsImZvdW5kIiwibiIsInNjaCIsInJlcXVpcmVkIiwidW5kZWZpbmVkIiwicmVzdWx0IiwiYWRkRXJyb3IiLCJ2YWxpZGF0ZVNjaGVtYSIsIkVycm9yIiwidGhyb3dBbGwiLCJlcnJvcnMiLCJzaG91bGRSZXNvbHZlIiwiJHJlZiIsInR5cGUiLCJzY2hlbWFvYmoiLCJmb3JFYWNoIiwic2NoZW1hVHJhdmVyc2VyIiwiYmluZCIsImRlZXBNZXJnZSIsInN1cGVyUmVzb2x2ZSIsInN3aXRjaFNjaGVtYSIsInJlc29sdmVkIiwic3ViY3R4Iiwic3Vic2NoZW1hIiwicGF0aCIsInNraXBBdHRyaWJ1dGVzIiwia2V5IiwiaWdub3JlUHJvcGVydGllcyIsImluZGV4T2YiLCJ2YWxpZGF0b3JFcnIiLCJ2YWxpZGF0b3IiLCJjYWxsIiwiYWxsb3dVbmtub3duQXR0cmlidXRlcyIsImltcG9ydEVycm9ycyIsInJld3JpdGUiLCJ2YWx1ZSIsInMiLCJwYXJzZWQiLCJwYXJzZSIsImZyYWdtZW50IiwiaGFzaCIsImRvY3VtZW50Iiwic3Vic3RyIiwib2JqZWN0R2V0UGF0aCIsInRlc3RUeXBlIiwidmFsaWRhdGVUeXBlIiwicmVzIiwic3RyaW5nIiwidGVzdFN0cmluZyIsIm51bWJlciIsInRlc3ROdW1iZXIiLCJpc0Zpbml0ZSIsImludGVnZXIiLCJ0ZXN0SW50ZWdlciIsImJvb2xlYW4iLCJ0ZXN0Qm9vbGVhbiIsImFycmF5IiwidGVzdEFycmF5IiwidGVzdE51bGwiLCJkYXRlIiwidGVzdERhdGUiLCJEYXRlIiwiYW55IiwidGVzdEFueSIsIm9iamVjdCIsInRlc3RPYmplY3QiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonschema/lib/validator.js\n");

/***/ })

};
;