"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/micro-ftch";
exports.ids = ["vendor-chunks/micro-ftch"];
exports.modules = {

/***/ "(ssr)/./node_modules/micro-ftch/index.js":
/*!******************************************!*\
  !*** ./node_modules/micro-ftch/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InvalidStatusCodeError = exports.InvalidCertError = void 0;\nconst DEFAULT_OPT = Object.freeze({\n    redirect: true,\n    expectStatusCode: 200,\n    headers: {},\n    full: false,\n    keepAlive: true,\n    cors: false,\n    referrer: false,\n    sslAllowSelfSigned: false,\n    _redirectCount: 0\n});\nclass InvalidCertError extends Error {\n    constructor(msg, fingerprint256){\n        super(msg);\n        this.fingerprint256 = fingerprint256;\n    }\n}\nexports.InvalidCertError = InvalidCertError;\nclass InvalidStatusCodeError extends Error {\n    constructor(statusCode){\n        super(`Request Failed. Status Code: ${statusCode}`);\n        this.statusCode = statusCode;\n    }\n}\nexports.InvalidStatusCodeError = InvalidStatusCodeError;\nfunction detectType(b, type) {\n    if (!type || type === \"text\" || type === \"json\") {\n        try {\n            let text = new TextDecoder(\"utf8\", {\n                fatal: true\n            }).decode(b);\n            if (type === \"text\") return text;\n            try {\n                return JSON.parse(text);\n            } catch (err) {\n                if (type === \"json\") throw err;\n                return text;\n            }\n        } catch (err) {\n            if (type === \"text\" || type === \"json\") throw err;\n        }\n    }\n    return b;\n}\nlet agents = {};\nfunction fetchNode(url, _options) {\n    let options = {\n        ...DEFAULT_OPT,\n        ..._options\n    };\n    const http = __webpack_require__(/*! http */ \"http\");\n    const https = __webpack_require__(/*! https */ \"https\");\n    const zlib = __webpack_require__(/*! zlib */ \"zlib\");\n    const { promisify } = __webpack_require__(/*! util */ \"util\");\n    const { resolve: urlResolve } = __webpack_require__(/*! url */ \"url\");\n    const isSecure = !!/^https/.test(url);\n    let opts = {\n        method: options.method || \"GET\",\n        headers: {\n            \"Accept-Encoding\": \"gzip, deflate, br\"\n        }\n    };\n    const compactFP = (s)=>s.replace(/:| /g, \"\").toLowerCase();\n    if (options.keepAlive) {\n        const agentOpt = {\n            keepAlive: true,\n            keepAliveMsecs: 30 * 1000,\n            maxFreeSockets: 1024,\n            maxCachedSessions: 1024\n        };\n        const agentKey = [\n            isSecure,\n            isSecure && options.sslPinnedCertificates?.map((i)=>compactFP(i)).sort()\n        ].join();\n        opts.agent = agents[agentKey] || (agents[agentKey] = new (isSecure ? https : http).Agent(agentOpt));\n    }\n    if (options.type === \"json\") opts.headers[\"Content-Type\"] = \"application/json\";\n    if (options.data) {\n        if (!options.method) opts.method = \"POST\";\n        opts.body = options.type === \"json\" ? JSON.stringify(options.data) : options.data;\n    }\n    opts.headers = {\n        ...opts.headers,\n        ...options.headers\n    };\n    if (options.sslAllowSelfSigned) opts.rejectUnauthorized = false;\n    const handleRes = async (res)=>{\n        const status = res.statusCode;\n        if (options.redirect && 300 <= status && status < 400 && res.headers[\"location\"]) {\n            if (options._redirectCount == 10) throw new Error(\"Request failed. Too much redirects.\");\n            options._redirectCount += 1;\n            return await fetchNode(urlResolve(url, res.headers[\"location\"]), options);\n        }\n        if (options.expectStatusCode && status !== options.expectStatusCode) {\n            res.resume();\n            throw new InvalidStatusCodeError(status);\n        }\n        let buf = [];\n        for await (const chunk of res)buf.push(chunk);\n        let bytes = Buffer.concat(buf);\n        const encoding = res.headers[\"content-encoding\"];\n        if (encoding === \"br\") bytes = await promisify(zlib.brotliDecompress)(bytes);\n        if (encoding === \"gzip\" || encoding === \"deflate\") bytes = await promisify(zlib.unzip)(bytes);\n        const body = detectType(bytes, options.type);\n        if (options.full) return {\n            headers: res.headers,\n            status,\n            body\n        };\n        return body;\n    };\n    return new Promise((resolve, reject)=>{\n        const handleError = async (err)=>{\n            if (err && err.code === \"DEPTH_ZERO_SELF_SIGNED_CERT\") {\n                try {\n                    await fetchNode(url, {\n                        ...options,\n                        sslAllowSelfSigned: true,\n                        sslPinnedCertificates: []\n                    });\n                } catch (e) {\n                    if (e && e.fingerprint256) {\n                        err = new InvalidCertError(`Self-signed SSL certificate: ${e.fingerprint256}`, e.fingerprint256);\n                    }\n                }\n            }\n            reject(err);\n        };\n        const req = (isSecure ? https : http).request(url, opts, (res)=>{\n            res.on(\"error\", handleError);\n            (async ()=>{\n                try {\n                    resolve(await handleRes(res));\n                } catch (error) {\n                    reject(error);\n                }\n            })();\n        });\n        req.on(\"error\", handleError);\n        const pinned = options.sslPinnedCertificates?.map((i)=>compactFP(i));\n        const mfetchSecureConnect = (socket)=>{\n            const fp256 = compactFP(socket.getPeerCertificate()?.fingerprint256 || \"\");\n            if (!fp256 && socket.isSessionReused()) return;\n            if (pinned.includes(fp256)) return;\n            req.emit(\"error\", new InvalidCertError(`Invalid SSL certificate: ${fp256} Expected: ${pinned}`, fp256));\n            return req.abort();\n        };\n        if (options.sslPinnedCertificates) {\n            req.on(\"socket\", (socket)=>{\n                const hasListeners = socket.listeners(\"secureConnect\").map((i)=>(i.name || \"\").replace(\"bound \", \"\")).includes(\"mfetchSecureConnect\");\n                if (hasListeners) return;\n                socket.on(\"secureConnect\", mfetchSecureConnect.bind(null, socket));\n            });\n        }\n        if (options.keepAlive) req.setNoDelay(true);\n        if (opts.body) req.write(opts.body);\n        req.end();\n    });\n}\nconst SAFE_HEADERS = new Set([\n    \"Accept\",\n    \"Accept-Language\",\n    \"Content-Language\",\n    \"Content-Type\"\n].map((i)=>i.toLowerCase()));\nconst FORBIDDEN_HEADERS = new Set([\n    \"Accept-Charset\",\n    \"Accept-Encoding\",\n    \"Access-Control-Request-Headers\",\n    \"Access-Control-Request-Method\",\n    \"Connection\",\n    \"Content-Length\",\n    \"Cookie\",\n    \"Cookie2\",\n    \"Date\",\n    \"DNT\",\n    \"Expect\",\n    \"Host\",\n    \"Keep-Alive\",\n    \"Origin\",\n    \"Referer\",\n    \"TE\",\n    \"Trailer\",\n    \"Transfer-Encoding\",\n    \"Upgrade\",\n    \"Via\"\n].map((i)=>i.toLowerCase()));\nasync function fetchBrowser(url, _options) {\n    let options = {\n        ...DEFAULT_OPT,\n        ..._options\n    };\n    const headers = new Headers();\n    if (options.type === \"json\") headers.set(\"Content-Type\", \"application/json\");\n    let parsed = new URL(url);\n    if (parsed.username) {\n        const auth = btoa(`${parsed.username}:${parsed.password}`);\n        headers.set(\"Authorization\", `Basic ${auth}`);\n        parsed.username = \"\";\n        parsed.password = \"\";\n    }\n    url = \"\" + parsed;\n    for(let k in options.headers){\n        const name = k.toLowerCase();\n        if (SAFE_HEADERS.has(name) || options.cors && !FORBIDDEN_HEADERS.has(name)) headers.set(k, options.headers[k]);\n    }\n    let opts = {\n        headers,\n        redirect: options.redirect ? \"follow\" : \"manual\"\n    };\n    if (!options.referrer) opts.referrerPolicy = \"no-referrer\";\n    if (options.cors) opts.mode = \"cors\";\n    if (options.data) {\n        if (!options.method) opts.method = \"POST\";\n        opts.body = options.type === \"json\" ? JSON.stringify(options.data) : options.data;\n    }\n    const res = await fetch(url, opts);\n    if (options.expectStatusCode && res.status !== options.expectStatusCode) throw new InvalidStatusCodeError(res.status);\n    const body = detectType(new Uint8Array(await res.arrayBuffer()), options.type);\n    if (options.full) return {\n        headers: Object.fromEntries(res.headers.entries()),\n        status: res.status,\n        body\n    };\n    return body;\n}\nconst IS_NODE = !!(typeof process == \"object\" && process.versions && process.versions.node && process.versions.v8);\nfunction fetchUrl(url, options) {\n    const fn = IS_NODE ? fetchNode : fetchBrowser;\n    return fn(url, options);\n}\nexports[\"default\"] = fetchUrl;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm8tZnRjaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsOEJBQThCLEdBQUdBLHdCQUF3QixHQUFHLEtBQUs7QUFDakUsTUFBTUksY0FBY04sT0FBT08sTUFBTSxDQUFDO0lBQzlCQyxVQUFVO0lBQ1ZDLGtCQUFrQjtJQUNsQkMsU0FBUyxDQUFDO0lBQ1ZDLE1BQU07SUFDTkMsV0FBVztJQUNYQyxNQUFNO0lBQ05DLFVBQVU7SUFDVkMsb0JBQW9CO0lBQ3BCQyxnQkFBZ0I7QUFDcEI7QUFDQSxNQUFNWCx5QkFBeUJZO0lBQzNCQyxZQUFZQyxHQUFHLEVBQUVDLGNBQWMsQ0FBRTtRQUM3QixLQUFLLENBQUNEO1FBQ04sSUFBSSxDQUFDQyxjQUFjLEdBQUdBO0lBQzFCO0FBQ0o7QUFDQWxCLHdCQUF3QixHQUFHRztBQUMzQixNQUFNRCwrQkFBK0JhO0lBQ2pDQyxZQUFZRyxVQUFVLENBQUU7UUFDcEIsS0FBSyxDQUFDLENBQUMsNkJBQTZCLEVBQUVBLFdBQVcsQ0FBQztRQUNsRCxJQUFJLENBQUNBLFVBQVUsR0FBR0E7SUFDdEI7QUFDSjtBQUNBbkIsOEJBQThCLEdBQUdFO0FBQ2pDLFNBQVNrQixXQUFXQyxDQUFDLEVBQUVDLElBQUk7SUFDdkIsSUFBSSxDQUFDQSxRQUFRQSxTQUFTLFVBQVVBLFNBQVMsUUFBUTtRQUM3QyxJQUFJO1lBQ0EsSUFBSUMsT0FBTyxJQUFJQyxZQUFZLFFBQVE7Z0JBQUVDLE9BQU87WUFBSyxHQUFHQyxNQUFNLENBQUNMO1lBQzNELElBQUlDLFNBQVMsUUFDVCxPQUFPQztZQUNYLElBQUk7Z0JBQ0EsT0FBT0ksS0FBS0MsS0FBSyxDQUFDTDtZQUN0QixFQUNBLE9BQU9NLEtBQUs7Z0JBQ1IsSUFBSVAsU0FBUyxRQUNULE1BQU1PO2dCQUNWLE9BQU9OO1lBQ1g7UUFDSixFQUNBLE9BQU9NLEtBQUs7WUFDUixJ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O0lBQzFCLElBQUlwRixRQUFRdkIsSUFBSSxFQUNaaUMsS0FBSzJFLElBQUksR0FBRztJQUNoQixJQUFJckYsUUFBUTRCLElBQUksRUFBRTtRQUNkLElBQUksQ0FBQzVCLFFBQVFXLE1BQU0sRUFDZkQsS0FBS0MsTUFBTSxHQUFHO1FBQ2xCRCxLQUFLbUIsSUFBSSxHQUFHN0IsUUFBUVosSUFBSSxLQUFLLFNBQVNLLEtBQUtxQyxTQUFTLENBQUM5QixRQUFRNEIsSUFBSSxJQUFJNUIsUUFBUTRCLElBQUk7SUFDckY7SUFDQSxNQUFNSyxNQUFNLE1BQU1xRCxNQUFNeEYsS0FBS1k7SUFDN0IsSUFBSVYsUUFBUTNCLGdCQUFnQixJQUFJNEQsSUFBSUMsTUFBTSxLQUFLbEMsUUFBUTNCLGdCQUFnQixFQUNuRSxNQUFNLElBQUlMLHVCQUF1QmlFLElBQUlDLE1BQU07SUFDL0MsTUFBTUwsT0FBTzNDLFdBQVcsSUFBSXFHLFdBQVcsTUFBTXRELElBQUl1RCxXQUFXLEtBQUt4RixRQUFRWixJQUFJO0lBQzdFLElBQUlZLFFBQVF6QixJQUFJLEVBQ1osT0FBTztRQUFFRCxTQUFTVixPQUFPNkgsV0FBVyxDQUFDeEQsSUFBSTNELE9BQU8sQ0FBQ29ILE9BQU87UUFBS3hELFFBQVFELElBQUlDLE1BQU07UUFBRUw7SUFBSztJQUMxRixPQUFPQTtBQUNYO0FBQ0EsTUFBTThELFVBQVUsQ0FBQyxDQUFFLFFBQU9DLFdBQVcsWUFDakNBLFFBQVFDLFFBQVEsSUFDaEJELFFBQVFDLFFBQVEsQ0FBQ0MsSUFBSSxJQUNyQkYsUUFBUUMsUUFBUSxDQUFDRSxFQUFFO0FBQ3ZCLFNBQVNDLFNBQVNsRyxHQUFHLEVBQUVFLE9BQU87SUFDMUIsTUFBTWlHLEtBQUtOLFVBQVU5RixZQUFZNEU7SUFDakMsT0FBT3dCLEdBQUduRyxLQUFLRTtBQUNuQjtBQUNBbEMsa0JBQWUsR0FBR2tJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9taWNyby1mdGNoL2luZGV4LmpzPzBjODAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkludmFsaWRTdGF0dXNDb2RlRXJyb3IgPSBleHBvcnRzLkludmFsaWRDZXJ0RXJyb3IgPSB2b2lkIDA7XG5jb25zdCBERUZBVUxUX09QVCA9IE9iamVjdC5mcmVlemUoe1xuICAgIHJlZGlyZWN0OiB0cnVlLFxuICAgIGV4cGVjdFN0YXR1c0NvZGU6IDIwMCxcbiAgICBoZWFkZXJzOiB7fSxcbiAgICBmdWxsOiBmYWxzZSxcbiAgICBrZWVwQWxpdmU6IHRydWUsXG4gICAgY29yczogZmFsc2UsXG4gICAgcmVmZXJyZXI6IGZhbHNlLFxuICAgIHNzbEFsbG93U2VsZlNpZ25lZDogZmFsc2UsXG4gICAgX3JlZGlyZWN0Q291bnQ6IDAsXG59KTtcbmNsYXNzIEludmFsaWRDZXJ0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnLCBmaW5nZXJwcmludDI1Nikge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICB0aGlzLmZpbmdlcnByaW50MjU2ID0gZmluZ2VycHJpbnQyNTY7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkQ2VydEVycm9yID0gSW52YWxpZENlcnRFcnJvcjtcbmNsYXNzIEludmFsaWRTdGF0dXNDb2RlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzQ29kZSkge1xuICAgICAgICBzdXBlcihgUmVxdWVzdCBGYWlsZWQuIFN0YXR1cyBDb2RlOiAke3N0YXR1c0NvZGV9YCk7XG4gICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkU3RhdHVzQ29kZUVycm9yID0gSW52YWxpZFN0YXR1c0NvZGVFcnJvcjtcbmZ1bmN0aW9uIGRldGVjdFR5cGUoYiwgdHlwZSkge1xuICAgIGlmICghdHlwZSB8fCB0eXBlID09PSAndGV4dCcgfHwgdHlwZSA9PT0gJ2pzb24nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgdGV4dCA9IG5ldyBUZXh0RGVjb2RlcigndXRmOCcsIHsgZmF0YWw6IHRydWUgfSkuZGVjb2RlKGIpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICd0ZXh0JylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdqc29uJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndGV4dCcgfHwgdHlwZSA9PT0gJ2pzb24nKVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYjtcbn1cbmxldCBhZ2VudHMgPSB7fTtcbmZ1bmN0aW9uIGZldGNoTm9kZSh1cmwsIF9vcHRpb25zKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB7IC4uLkRFRkFVTFRfT1BULCAuLi5fb3B0aW9ucyB9O1xuICAgIGNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG4gICAgY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuICAgIGNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG4gICAgY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcbiAgICBjb25zdCB7IHJlc29sdmU6IHVybFJlc29sdmUgfSA9IHJlcXVpcmUoJ3VybCcpO1xuICAgIGNvbnN0IGlzU2VjdXJlID0gISEvXmh0dHBzLy50ZXN0KHVybCk7XG4gICAgbGV0IG9wdHMgPSB7XG4gICAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0FjY2VwdC1FbmNvZGluZyc6ICdnemlwLCBkZWZsYXRlLCBicicgfSxcbiAgICB9O1xuICAgIGNvbnN0IGNvbXBhY3RGUCA9IChzKSA9PiBzLnJlcGxhY2UoLzp8IC9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAob3B0aW9ucy5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29uc3QgYWdlbnRPcHQgPSB7XG4gICAgICAgICAgICBrZWVwQWxpdmU6IHRydWUsXG4gICAgICAgICAgICBrZWVwQWxpdmVNc2VjczogMzAgKiAxMDAwLFxuICAgICAgICAgICAgbWF4RnJlZVNvY2tldHM6IDEwMjQsXG4gICAgICAgICAgICBtYXhDYWNoZWRTZXNzaW9uczogMTAyNCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYWdlbnRLZXkgPSBbXG4gICAgICAgICAgICBpc1NlY3VyZSxcbiAgICAgICAgICAgIGlzU2VjdXJlICYmIG9wdGlvbnMuc3NsUGlubmVkQ2VydGlmaWNhdGVzPy5tYXAoKGkpID0+IGNvbXBhY3RGUChpKSkuc29ydCgpLFxuICAgICAgICBdLmpvaW4oKTtcbiAgICAgICAgb3B0cy5hZ2VudCA9XG4gICAgICAgICAgICBhZ2VudHNbYWdlbnRLZXldIHx8IChhZ2VudHNbYWdlbnRLZXldID0gbmV3IChpc1NlY3VyZSA/IGh0dHBzIDogaHR0cCkuQWdlbnQoYWdlbnRPcHQpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ2pzb24nKVxuICAgICAgICBvcHRzLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLm1ldGhvZClcbiAgICAgICAgICAgIG9wdHMubWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBvcHRzLmJvZHkgPSBvcHRpb25zLnR5cGUgPT09ICdqc29uJyA/IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuZGF0YSkgOiBvcHRpb25zLmRhdGE7XG4gICAgfVxuICAgIG9wdHMuaGVhZGVycyA9IHsgLi4ub3B0cy5oZWFkZXJzLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICBpZiAob3B0aW9ucy5zc2xBbGxvd1NlbGZTaWduZWQpXG4gICAgICAgIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gZmFsc2U7XG4gICAgY29uc3QgaGFuZGxlUmVzID0gYXN5bmMgKHJlcykgPT4ge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSByZXMuc3RhdHVzQ29kZTtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVkaXJlY3QgJiYgMzAwIDw9IHN0YXR1cyAmJiBzdGF0dXMgPCA0MDAgJiYgcmVzLmhlYWRlcnNbJ2xvY2F0aW9uJ10pIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLl9yZWRpcmVjdENvdW50ID09IDEwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdCBmYWlsZWQuIFRvbyBtdWNoIHJlZGlyZWN0cy4nKTtcbiAgICAgICAgICAgIG9wdGlvbnMuX3JlZGlyZWN0Q291bnQgKz0gMTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBmZXRjaE5vZGUodXJsUmVzb2x2ZSh1cmwsIHJlcy5oZWFkZXJzWydsb2NhdGlvbiddKSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZXhwZWN0U3RhdHVzQ29kZSAmJiBzdGF0dXMgIT09IG9wdGlvbnMuZXhwZWN0U3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgcmVzLnJlc3VtZSgpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTdGF0dXNDb2RlRXJyb3Ioc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYnVmID0gW107XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVzKVxuICAgICAgICAgICAgYnVmLnB1c2goY2h1bmspO1xuICAgICAgICBsZXQgYnl0ZXMgPSBCdWZmZXIuY29uY2F0KGJ1Zik7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gcmVzLmhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXTtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnYnInKVxuICAgICAgICAgICAgYnl0ZXMgPSBhd2FpdCBwcm9taXNpZnkoemxpYi5icm90bGlEZWNvbXByZXNzKShieXRlcyk7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2d6aXAnIHx8IGVuY29kaW5nID09PSAnZGVmbGF0ZScpXG4gICAgICAgICAgICBieXRlcyA9IGF3YWl0IHByb21pc2lmeSh6bGliLnVuemlwKShieXRlcyk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBkZXRlY3RUeXBlKGJ5dGVzLCBvcHRpb25zLnR5cGUpO1xuICAgICAgICBpZiAob3B0aW9ucy5mdWxsKVxuICAgICAgICAgICAgcmV0dXJuIHsgaGVhZGVyczogcmVzLmhlYWRlcnMsIHN0YXR1cywgYm9keSB9O1xuICAgICAgICByZXR1cm4gYm9keTtcbiAgICB9O1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZUVycm9yID0gYXN5bmMgKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSA9PT0gJ0RFUFRIX1pFUk9fU0VMRl9TSUdORURfQ0VSVCcpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBmZXRjaE5vZGUodXJsLCB7IC4uLm9wdGlvbnMsIHNzbEFsbG93U2VsZlNpZ25lZDogdHJ1ZSwgc3NsUGlubmVkQ2VydGlmaWNhdGVzOiBbXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgJiYgZS5maW5nZXJwcmludDI1Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gbmV3IEludmFsaWRDZXJ0RXJyb3IoYFNlbGYtc2lnbmVkIFNTTCBjZXJ0aWZpY2F0ZTogJHtlLmZpbmdlcnByaW50MjU2fWAsIGUuZmluZ2VycHJpbnQyNTYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcSA9IChpc1NlY3VyZSA/IGh0dHBzIDogaHR0cCkucmVxdWVzdCh1cmwsIG9wdHMsIChyZXMpID0+IHtcbiAgICAgICAgICAgIHJlcy5vbignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYXdhaXQgaGFuZGxlUmVzKHJlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxLm9uKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAgICAgICAgY29uc3QgcGlubmVkID0gb3B0aW9ucy5zc2xQaW5uZWRDZXJ0aWZpY2F0ZXM/Lm1hcCgoaSkgPT4gY29tcGFjdEZQKGkpKTtcbiAgICAgICAgY29uc3QgbWZldGNoU2VjdXJlQ29ubmVjdCA9IChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZwMjU2ID0gY29tcGFjdEZQKHNvY2tldC5nZXRQZWVyQ2VydGlmaWNhdGUoKT8uZmluZ2VycHJpbnQyNTYgfHwgJycpO1xuICAgICAgICAgICAgaWYgKCFmcDI1NiAmJiBzb2NrZXQuaXNTZXNzaW9uUmV1c2VkKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHBpbm5lZC5pbmNsdWRlcyhmcDI1NikpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcmVxLmVtaXQoJ2Vycm9yJywgbmV3IEludmFsaWRDZXJ0RXJyb3IoYEludmFsaWQgU1NMIGNlcnRpZmljYXRlOiAke2ZwMjU2fSBFeHBlY3RlZDogJHtwaW5uZWR9YCwgZnAyNTYpKTtcbiAgICAgICAgICAgIHJldHVybiByZXEuYWJvcnQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3NsUGlubmVkQ2VydGlmaWNhdGVzKSB7XG4gICAgICAgICAgICByZXEub24oJ3NvY2tldCcsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNMaXN0ZW5lcnMgPSBzb2NrZXRcbiAgICAgICAgICAgICAgICAgICAgLmxpc3RlbmVycygnc2VjdXJlQ29ubmVjdCcpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGkpID0+IChpLm5hbWUgfHwgJycpLnJlcGxhY2UoJ2JvdW5kICcsICcnKSlcbiAgICAgICAgICAgICAgICAgICAgLmluY2x1ZGVzKCdtZmV0Y2hTZWN1cmVDb25uZWN0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0xpc3RlbmVycylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHNvY2tldC5vbignc2VjdXJlQ29ubmVjdCcsIG1mZXRjaFNlY3VyZUNvbm5lY3QuYmluZChudWxsLCBzb2NrZXQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmtlZXBBbGl2ZSlcbiAgICAgICAgICAgIHJlcS5zZXROb0RlbGF5KHRydWUpO1xuICAgICAgICBpZiAob3B0cy5ib2R5KVxuICAgICAgICAgICAgcmVxLndyaXRlKG9wdHMuYm9keSk7XG4gICAgICAgIHJlcS5lbmQoKTtcbiAgICB9KTtcbn1cbmNvbnN0IFNBRkVfSEVBREVSUyA9IG5ldyBTZXQoWydBY2NlcHQnLCAnQWNjZXB0LUxhbmd1YWdlJywgJ0NvbnRlbnQtTGFuZ3VhZ2UnLCAnQ29udGVudC1UeXBlJ10ubWFwKChpKSA9PiBpLnRvTG93ZXJDYXNlKCkpKTtcbmNvbnN0IEZPUkJJRERFTl9IRUFERVJTID0gbmV3IFNldChbJ0FjY2VwdC1DaGFyc2V0JywgJ0FjY2VwdC1FbmNvZGluZycsICdBY2Nlc3MtQ29udHJvbC1SZXF1ZXN0LUhlYWRlcnMnLCAnQWNjZXNzLUNvbnRyb2wtUmVxdWVzdC1NZXRob2QnLFxuICAgICdDb25uZWN0aW9uJywgJ0NvbnRlbnQtTGVuZ3RoJywgJ0Nvb2tpZScsICdDb29raWUyJywgJ0RhdGUnLCAnRE5UJywgJ0V4cGVjdCcsICdIb3N0JywgJ0tlZXAtQWxpdmUnLCAnT3JpZ2luJywgJ1JlZmVyZXInLCAnVEUnLCAnVHJhaWxlcicsXG4gICAgJ1RyYW5zZmVyLUVuY29kaW5nJywgJ1VwZ3JhZGUnLCAnVmlhJ10ubWFwKChpKSA9PiBpLnRvTG93ZXJDYXNlKCkpKTtcbmFzeW5jIGZ1bmN0aW9uIGZldGNoQnJvd3Nlcih1cmwsIF9vcHRpb25zKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB7IC4uLkRFRkFVTFRfT1BULCAuLi5fb3B0aW9ucyB9O1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIGlmIChvcHRpb25zLnR5cGUgPT09ICdqc29uJylcbiAgICAgICAgaGVhZGVycy5zZXQoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgbGV0IHBhcnNlZCA9IG5ldyBVUkwodXJsKTtcbiAgICBpZiAocGFyc2VkLnVzZXJuYW1lKSB7XG4gICAgICAgIGNvbnN0IGF1dGggPSBidG9hKGAke3BhcnNlZC51c2VybmFtZX06JHtwYXJzZWQucGFzc3dvcmR9YCk7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdBdXRob3JpemF0aW9uJywgYEJhc2ljICR7YXV0aH1gKTtcbiAgICAgICAgcGFyc2VkLnVzZXJuYW1lID0gJyc7XG4gICAgICAgIHBhcnNlZC5wYXNzd29yZCA9ICcnO1xuICAgIH1cbiAgICB1cmwgPSAnJyArIHBhcnNlZDtcbiAgICBmb3IgKGxldCBrIGluIG9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICBjb25zdCBuYW1lID0gay50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoU0FGRV9IRUFERVJTLmhhcyhuYW1lKSB8fCAob3B0aW9ucy5jb3JzICYmICFGT1JCSURERU5fSEVBREVSUy5oYXMobmFtZSkpKVxuICAgICAgICAgICAgaGVhZGVycy5zZXQoaywgb3B0aW9ucy5oZWFkZXJzW2tdKTtcbiAgICB9XG4gICAgbGV0IG9wdHMgPSB7IGhlYWRlcnMsIHJlZGlyZWN0OiBvcHRpb25zLnJlZGlyZWN0ID8gJ2ZvbGxvdycgOiAnbWFudWFsJyB9O1xuICAgIGlmICghb3B0aW9ucy5yZWZlcnJlcilcbiAgICAgICAgb3B0cy5yZWZlcnJlclBvbGljeSA9ICduby1yZWZlcnJlcic7XG4gICAgaWYgKG9wdGlvbnMuY29ycylcbiAgICAgICAgb3B0cy5tb2RlID0gJ2NvcnMnO1xuICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLm1ldGhvZClcbiAgICAgICAgICAgIG9wdHMubWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBvcHRzLmJvZHkgPSBvcHRpb25zLnR5cGUgPT09ICdqc29uJyA/IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuZGF0YSkgOiBvcHRpb25zLmRhdGE7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwgb3B0cyk7XG4gICAgaWYgKG9wdGlvbnMuZXhwZWN0U3RhdHVzQ29kZSAmJiByZXMuc3RhdHVzICE9PSBvcHRpb25zLmV4cGVjdFN0YXR1c0NvZGUpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkU3RhdHVzQ29kZUVycm9yKHJlcy5zdGF0dXMpO1xuICAgIGNvbnN0IGJvZHkgPSBkZXRlY3RUeXBlKG5ldyBVaW50OEFycmF5KGF3YWl0IHJlcy5hcnJheUJ1ZmZlcigpKSwgb3B0aW9ucy50eXBlKTtcbiAgICBpZiAob3B0aW9ucy5mdWxsKVxuICAgICAgICByZXR1cm4geyBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMocmVzLmhlYWRlcnMuZW50cmllcygpKSwgc3RhdHVzOiByZXMuc3RhdHVzLCBib2R5IH07XG4gICAgcmV0dXJuIGJvZHk7XG59XG5jb25zdCBJU19OT0RFID0gISEodHlwZW9mIHByb2Nlc3MgPT0gJ29iamVjdCcgJiZcbiAgICBwcm9jZXNzLnZlcnNpb25zICYmXG4gICAgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICYmXG4gICAgcHJvY2Vzcy52ZXJzaW9ucy52OCk7XG5mdW5jdGlvbiBmZXRjaFVybCh1cmwsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmbiA9IElTX05PREUgPyBmZXRjaE5vZGUgOiBmZXRjaEJyb3dzZXI7XG4gICAgcmV0dXJuIGZuKHVybCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBmZXRjaFVybDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkludmFsaWRTdGF0dXNDb2RlRXJyb3IiLCJJbnZhbGlkQ2VydEVycm9yIiwiREVGQVVMVF9PUFQiLCJmcmVlemUiLCJyZWRpcmVjdCIsImV4cGVjdFN0YXR1c0NvZGUiLCJoZWFkZXJzIiwiZnVsbCIsImtlZXBBbGl2ZSIsImNvcnMiLCJyZWZlcnJlciIsInNzbEFsbG93U2VsZlNpZ25lZCIsIl9yZWRpcmVjdENvdW50IiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1zZyIsImZpbmdlcnByaW50MjU2Iiwic3RhdHVzQ29kZSIsImRldGVjdFR5cGUiLCJiIiwidHlwZSIsInRleHQiLCJUZXh0RGVjb2RlciIsImZhdGFsIiwiZGVjb2RlIiwiSlNPTiIsInBhcnNlIiwiZXJyIiwiYWdlbnRzIiwiZmV0Y2hOb2RlIiwidXJsIiwiX29wdGlvbnMiLCJvcHRpb25zIiwiaHR0cCIsInJlcXVpcmUiLCJodHRwcyIsInpsaWIiLCJwcm9taXNpZnkiLCJyZXNvbHZlIiwidXJsUmVzb2x2ZSIsImlzU2VjdXJlIiwidGVzdCIsIm9wdHMiLCJtZXRob2QiLCJjb21wYWN0RlAiLCJzIiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIiwiYWdlbnRPcHQiLCJrZWVwQWxpdmVNc2VjcyIsIm1heEZyZWVTb2NrZXRzIiwibWF4Q2FjaGVkU2Vzc2lvbnMiLCJhZ2VudEtleSIsInNzbFBpbm5lZENlcnRpZmljYXRlcyIsIm1hcCIsImkiLCJzb3J0Iiwiam9pbiIsImFnZW50IiwiQWdlbnQiLCJkYXRhIiwiYm9keSIsInN0cmluZ2lmeSIsInJlamVjdFVuYXV0aG9yaXplZCIsImhhbmRsZVJlcyIsInJlcyIsInN0YXR1cyIsInJlc3VtZSIsImJ1ZiIsImNodW5rIiwicHVzaCIsImJ5dGVzIiwiQnVmZmVyIiwiY29uY2F0IiwiZW5jb2RpbmciLCJicm90bGlEZWNvbXByZXNzIiwidW56aXAiLCJQcm9taXNlIiwicmVqZWN0IiwiaGFuZGxlRXJyb3IiLCJjb2RlIiwiZSIsInJlcSIsInJlcXVlc3QiLCJvbiIsImVycm9yIiwicGlubmVkIiwibWZldGNoU2VjdXJlQ29ubmVjdCIsInNvY2tldCIsImZwMjU2IiwiZ2V0UGVlckNlcnRpZmljYXRlIiwiaXNTZXNzaW9uUmV1c2VkIiwiaW5jbHVkZXMiLCJlbWl0IiwiYWJvcnQiLCJoYXNMaXN0ZW5lcnMiLCJsaXN0ZW5lcnMiLCJuYW1lIiwiYmluZCIsInNldE5vRGVsYXkiLCJ3cml0ZSIsImVuZCIsIlNBRkVfSEVBREVSUyIsIlNldCIsIkZPUkJJRERFTl9IRUFERVJTIiwiZmV0Y2hCcm93c2VyIiwiSGVhZGVycyIsInNldCIsInBhcnNlZCIsIlVSTCIsInVzZXJuYW1lIiwiYXV0aCIsImJ0b2EiLCJwYXNzd29yZCIsImsiLCJoYXMiLCJyZWZlcnJlclBvbGljeSIsIm1vZGUiLCJmZXRjaCIsIlVpbnQ4QXJyYXkiLCJhcnJheUJ1ZmZlciIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsIklTX05PREUiLCJwcm9jZXNzIiwidmVyc2lvbnMiLCJub2RlIiwidjgiLCJmZXRjaFVybCIsImZuIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micro-ftch/index.js\n");

/***/ })

};
;