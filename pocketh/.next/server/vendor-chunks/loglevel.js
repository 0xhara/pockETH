/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/loglevel";
exports.ids = ["vendor-chunks/loglevel"];
exports.modules = {

/***/ "(ssr)/./node_modules/loglevel/lib/loglevel.js":
/*!***********************************************!*\
  !*** ./node_modules/loglevel/lib/loglevel.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/ (function(root, definition) {\n    \"use strict\";\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(this, function() {\n    \"use strict\";\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = \"undefined\" !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === \"function\") {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [\n                        obj,\n                        arguments\n                    ]);\n                };\n            }\n        }\n    }\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [\n                    console,\n                    arguments\n                ]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === \"debug\") {\n            methodName = \"log\";\n        }\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === \"trace\" && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, \"log\");\n        } else {\n            return noop;\n        }\n    }\n    // These private functions always need `this` to be set properly\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */ for(var i = 0; i < logMethods.length; i++){\n            var methodName = logMethods[i];\n            this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);\n        }\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function() {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */ return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n    function Logger(name, defaultLevel, factory) {\n        var self = this;\n        var currentLevel;\n        defaultLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n        var storageKey = \"loglevel\";\n        if (typeof name === \"string\") {\n            storageKey += \":\" + name;\n        } else if (typeof name === \"symbol\") {\n            storageKey = undefined;\n        }\n        function persistLevelIfPossible(levelNum) {\n            var levelName = (logMethods[levelNum] || \"silent\").toUpperCase();\n            if (\"undefined\" === undefinedType || !storageKey) return;\n            // Use localStorage if available\n            try {\n                window.localStorage[storageKey] = levelName;\n                return;\n            } catch (ignore) {}\n            // Use session cookie as fallback\n            try {\n                window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n            } catch (ignore) {}\n        }\n        function getPersistedLevel() {\n            var storedLevel;\n            if (\"undefined\" === undefinedType || !storageKey) return;\n            try {\n                storedLevel = window.localStorage[storageKey];\n            } catch (ignore) {}\n            // Fallback to cookies if local storage gives us nothing\n            if (typeof storedLevel === undefinedType) {\n                try {\n                    var cookie = window.document.cookie;\n                    var location = cookie.indexOf(encodeURIComponent(storageKey) + \"=\");\n                    if (location !== -1) {\n                        storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                    }\n                } catch (ignore) {}\n            }\n            // If the stored level is not valid, treat it as if nothing was stored.\n            if (self.levels[storedLevel] === undefined) {\n                storedLevel = undefined;\n            }\n            return storedLevel;\n        }\n        function clearPersistedLevel() {\n            if (\"undefined\" === undefinedType || !storageKey) return;\n            // Use localStorage if available\n            try {\n                window.localStorage.removeItem(storageKey);\n                return;\n            } catch (ignore) {}\n            // Use session cookie as fallback\n            try {\n                window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n            } catch (ignore) {}\n        }\n        /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */ self.name = name;\n        self.levels = {\n            \"TRACE\": 0,\n            \"DEBUG\": 1,\n            \"INFO\": 2,\n            \"WARN\": 3,\n            \"ERROR\": 4,\n            \"SILENT\": 5\n        };\n        self.methodFactory = factory || defaultMethodFactory;\n        self.getLevel = function() {\n            return currentLevel;\n        };\n        self.setLevel = function(level, persist) {\n            if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n                level = self.levels[level.toUpperCase()];\n            }\n            if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n                currentLevel = level;\n                if (persist !== false) {\n                    persistLevelIfPossible(level);\n                }\n                replaceLoggingMethods.call(self, level, name);\n                if (typeof console === undefinedType && level < self.levels.SILENT) {\n                    return \"No console available for logging\";\n                }\n            } else {\n                throw \"log.setLevel() called with invalid level: \" + level;\n            }\n        };\n        self.setDefaultLevel = function(level) {\n            defaultLevel = level;\n            if (!getPersistedLevel()) {\n                self.setLevel(level, false);\n            }\n        };\n        self.resetLevel = function() {\n            self.setLevel(defaultLevel, false);\n            clearPersistedLevel();\n        };\n        self.enableAll = function(persist) {\n            self.setLevel(self.levels.TRACE, persist);\n        };\n        self.disableAll = function(persist) {\n            self.setLevel(self.levels.SILENT, persist);\n        };\n        // Initialize with the right level\n        var initialLevel = getPersistedLevel();\n        if (initialLevel == null) {\n            initialLevel = defaultLevel;\n        }\n        self.setLevel(initialLevel, false);\n    }\n    /*\n     *\n     * Top-level API\n     *\n     */ var defaultLogger = new Logger();\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n            throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n        var logger = _loggersByName[name];\n        if (!logger) {\n            logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n    // Grab the current global log variable in case of overwrite\n    var _log = \"undefined\" !== undefinedType ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (\"undefined\" !== undefinedType && window.log === defaultLogger) {\n            window.log = _log;\n        }\n        return defaultLogger;\n    };\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n    // ES6 default export, for compatibility\n    defaultLogger[\"default\"] = defaultLogger;\n    return defaultLogger;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7OztBQUtBLEdBQ0MsVUFBVUEsSUFBSSxFQUFFQyxVQUFVO0lBQ3ZCO0lBQ0EsSUFBSSxJQUEwQyxFQUFFO1FBQzVDQyxvQ0FBT0QsVUFBVUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxrR0FBQ0E7SUFDdEIsT0FBTyxFQUlOO0FBQ0wsR0FBRSxJQUFJLEVBQUU7SUFDSjtJQUVBLDBEQUEwRDtJQUMxRCxJQUFJTSxPQUFPLFlBQVk7SUFDdkIsSUFBSUMsZ0JBQWdCO0lBQ3BCLElBQUlDLE9BQU8sZ0JBQW1CRCxpQkFBbUIsT0FBT0UsT0FBT0MsU0FBUyxLQUFLSCxpQkFDekUsa0JBQWtCSSxJQUFJLENBQUNGLE9BQU9DLFNBQVMsQ0FBQ0UsU0FBUztJQUdyRCxJQUFJQyxhQUFhO1FBQ2I7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBRUQsZ0VBQWdFO0lBQ2hFLFNBQVNDLFdBQVdDLEdBQUcsRUFBRUMsVUFBVTtRQUMvQixJQUFJQyxTQUFTRixHQUFHLENBQUNDLFdBQVc7UUFDNUIsSUFBSSxPQUFPQyxPQUFPQyxJQUFJLEtBQUssWUFBWTtZQUNuQyxPQUFPRCxPQUFPQyxJQUFJLENBQUNIO1FBQ3ZCLE9BQU87WUFDSCxJQUFJO2dCQUNBLE9BQU9JLFNBQVNDLFNBQVMsQ0FBQ0YsSUFBSSxDQUFDRyxJQUFJLENBQUNKLFFBQVFGO1lBQ2hELEVBQUUsT0FBT08sR0FBRztnQkFDUiw2REFBNkQ7Z0JBQzdELE9BQU87b0JBQ0gsT0FBT0gsU0FBU0MsU0FBUyxDQUFDRyxLQUFLLENBQUNBLEtBQUssQ0FBQ04sUUFBUTt3QkFBQ0Y7d0JBQUtTO3FCQUFVO2dCQUNsRTtZQUNKO1FBQ0o7SUFDSjtJQUVBLCtFQUErRTtJQUMvRSxTQUFTQztRQUNMLElBQUlDLFFBQVFyQixHQUFHLEVBQUU7WUFDYixJQUFJcUIsUUFBUXJCLEdBQUcsQ0FBQ2tCLEtBQUssRUFB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TSxFQUFFRDtRQUN0QztRQUVBLGtDQUFrQztRQUNsQyxJQUFJTyxlQUFlbEI7UUFDbkIsSUFBSWtCLGdCQUFnQixNQUFNO1lBQ3RCQSxlQUFlaEM7UUFDbkI7UUFDQUUsS0FBS3NCLFFBQVEsQ0FBQ1EsY0FBYztJQUM5QjtJQUVBOzs7O0tBSUMsR0FFRCxJQUFJQyxnQkFBZ0IsSUFBSW5DO0lBRXhCLElBQUlvQyxpQkFBaUIsQ0FBQztJQUN0QkQsY0FBY0UsU0FBUyxHQUFHLFNBQVNBLFVBQVVwQyxJQUFJO1FBQzdDLElBQUksT0FBUUEsU0FBUyxZQUFZLE9BQU9BLFNBQVMsWUFBYUEsU0FBUyxJQUFJO1lBQ3pFLE1BQU0sSUFBSXFDLFVBQVU7UUFDdEI7UUFFQSxJQUFJQyxTQUFTSCxjQUFjLENBQUNuQyxLQUFLO1FBQ2pDLElBQUksQ0FBQ3NDLFFBQVE7WUFDWEEsU0FBU0gsY0FBYyxDQUFDbkMsS0FBSyxHQUFHLElBQUlELE9BQ2xDQyxNQUFNa0MsY0FBY1YsUUFBUSxJQUFJVSxjQUFjdkMsYUFBYTtRQUMvRDtRQUNBLE9BQU8yQztJQUNYO0lBRUEsNERBQTREO0lBQzVELElBQUlDLE9BQU8sZ0JBQW1CeEUsZ0JBQWlCRSxPQUFPSixHQUFHLEdBQUd3QjtJQUM1RDZDLGNBQWNNLFVBQVUsR0FBRztRQUN2QixJQUFJLGdCQUFrQnpFLGlCQUNmRSxPQUFPSixHQUFHLEtBQUtxRSxlQUFlO1lBQ2pDakUsT0FBT0osR0FBRyxHQUFHMEU7UUFDakI7UUFFQSxPQUFPTDtJQUNYO0lBRUFBLGNBQWNPLFVBQVUsR0FBRyxTQUFTQTtRQUNoQyxPQUFPTjtJQUNYO0lBRUEsd0NBQXdDO0lBQ3hDRCxhQUFhLENBQUMsVUFBVSxHQUFHQTtJQUUzQixPQUFPQTtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanM/Njg2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG4gICAgdmFyIGlzSUUgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yICE9PSB1bmRlZmluZWRUeXBlKSAmJiAoXG4gICAgICAgIC9UcmlkZW50XFwvfE1TSUUgLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KVxuICAgICk7XG5cbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcbiAgICAgICAgXCJ0cmFjZVwiLFxuICAgICAgICBcImRlYnVnXCIsXG4gICAgICAgIFwiaW5mb1wiLFxuICAgICAgICBcIndhcm5cIixcbiAgICAgICAgXCJlcnJvclwiXG4gICAgXTtcblxuICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHJhY2UoKSBkb2Vzbid0IHByaW50IHRoZSBtZXNzYWdlIGluIElFLCBzbyBmb3IgdGhhdCBjYXNlIHdlIG5lZWQgdG8gd3JhcCBpdFxuICAgIGZ1bmN0aW9uIHRyYWNlRm9ySUUoKSB7XG4gICAgICAgIGlmIChjb25zb2xlLmxvZykge1xuICAgICAgICAgICAgaWYgKGNvbnNvbGUubG9nLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gb2xkIElFLCBuYXRpdmUgY29uc29sZSBtZXRob2RzIHRoZW1zZWx2ZXMgZG9uJ3QgaGF2ZSBhcHBseSgpLlxuICAgICAgICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShjb25zb2xlLmxvZywgW2NvbnNvbGUsIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zb2xlLnRyYWNlKSBjb25zb2xlLnRyYWNlKCk7XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09ICd0cmFjZScgJiYgaXNJRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNlRm9ySUU7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/XG4gICAgICAgICAgICAgICAgbm9vcCA6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcbiAgICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnO1xuICAgIH1cblxuICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmRcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XG4gICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGRlZmF1bHRMZXZlbCwgZmFjdG9yeSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGN1cnJlbnRMZXZlbDtcbiAgICAgIGRlZmF1bHRMZXZlbCA9IGRlZmF1bHRMZXZlbCA9PSBudWxsID8gXCJXQVJOXCIgOiBkZWZhdWx0TGV2ZWw7XG5cbiAgICAgIHZhciBzdG9yYWdlS2V5ID0gXCJsb2dsZXZlbFwiO1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICBzdG9yYWdlS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XG4gICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbikpWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjbGVhclBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPTsgZXhwaXJlcz1UaHUsIDAxIEphbiAxOTcwIDAwOjAwOjAwIFVUQ1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqXG4gICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgc2VsZi5uYW1lID0gbmFtZTtcblxuICAgICAgc2VsZi5sZXZlbHMgPSB7IFwiVFJBQ0VcIjogMCwgXCJERUJVR1wiOiAxLCBcIklORk9cIjogMiwgXCJXQVJOXCI6IDMsXG4gICAgICAgICAgXCJFUlJPUlwiOiA0LCBcIlNJTEVOVFwiOiA1fTtcblxuICAgICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZmFjdG9yeSB8fCBkZWZhdWx0TWV0aG9kRmFjdG9yeTtcblxuICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudExldmVsO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCwgcGVyc2lzdCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwic3RyaW5nXCIgJiYgc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgICBpZiAocGVyc2lzdCAhPT0gZmFsc2UpIHsgIC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYsIGxldmVsLCBuYW1lKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlICYmIGxldmVsIDwgc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGxldmVsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgZGVmYXVsdExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgaWYgKCFnZXRQZXJzaXN0ZWRMZXZlbCgpKSB7XG4gICAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnJlc2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChkZWZhdWx0TGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgICBjbGVhclBlcnNpc3RlZExldmVsKCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbml0aWFsaXplIHdpdGggdGhlIHJpZ2h0IGxldmVsXG4gICAgICB2YXIgaW5pdGlhbExldmVsID0gZ2V0UGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgIGlmIChpbml0aWFsTGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgIGluaXRpYWxMZXZlbCA9IGRlZmF1bHRMZXZlbDtcbiAgICAgIH1cbiAgICAgIHNlbGYuc2V0TGV2ZWwoaW5pdGlhbExldmVsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKlxuICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgKlxuICAgICAqL1xuXG4gICAgdmFyIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbiAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gICAgICAgIGlmICgodHlwZW9mIG5hbWUgIT09IFwic3ltYm9sXCIgJiYgdHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3Qgc3VwcGx5IGEgbmFtZSB3aGVuIGNyZWF0aW5nIGEgbG9nZ2VyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoXG4gICAgICAgICAgICBuYW1lLCBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCksIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9O1xuXG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcbiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xuICAgIH07XG5cbiAgICAvLyBFUzYgZGVmYXVsdCBleHBvcnQsIGZvciBjb21wYXRpYmlsaXR5XG4gICAgZGVmYXVsdExvZ2dlclsnZGVmYXVsdCddID0gZGVmYXVsdExvZ2dlcjtcblxuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xufSkpO1xuIl0sIm5hbWVzIjpbInJvb3QiLCJkZWZpbml0aW9uIiwiZGVmaW5lIiwiYW1kIiwibW9kdWxlIiwiZXhwb3J0cyIsImxvZyIsIm5vb3AiLCJ1bmRlZmluZWRUeXBlIiwiaXNJRSIsIndpbmRvdyIsIm5hdmlnYXRvciIsInRlc3QiLCJ1c2VyQWdlbnQiLCJsb2dNZXRob2RzIiwiYmluZE1ldGhvZCIsIm9iaiIsIm1ldGhvZE5hbWUiLCJtZXRob2QiLCJiaW5kIiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJjYWxsIiwiZSIsImFwcGx5IiwiYXJndW1lbnRzIiwidHJhY2VGb3JJRSIsImNvbnNvbGUiLCJ0cmFjZSIsInJlYWxNZXRob2QiLCJ1bmRlZmluZWQiLCJyZXBsYWNlTG9nZ2luZ01ldGhvZHMiLCJsZXZlbCIsImxvZ2dlck5hbWUiLCJpIiwibGVuZ3RoIiwibWV0aG9kRmFjdG9yeSIsImRlYnVnIiwiZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyIsImRlZmF1bHRNZXRob2RGYWN0b3J5IiwiTG9nZ2VyIiwibmFtZSIsImRlZmF1bHRMZXZlbCIsImZhY3RvcnkiLCJzZWxmIiwiY3VycmVudExldmVsIiwic3RvcmFnZUtleSIsInBlcnNpc3RMZXZlbElmUG9zc2libGUiLCJsZXZlbE51bSIsImxldmVsTmFtZSIsInRvVXBwZXJDYXNlIiwibG9jYWxTdG9yYWdlIiwiaWdub3JlIiwiZG9jdW1lbnQiLCJjb29raWUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJnZXRQZXJzaXN0ZWRMZXZlbCIsInN0b3JlZExldmVsIiwibG9jYXRpb24iLCJpbmRleE9mIiwiZXhlYyIsInNsaWNlIiwibGV2ZWxzIiwiY2xlYXJQZXJzaXN0ZWRMZXZlbCIsInJlbW92ZUl0ZW0iLCJnZXRMZXZlbCIsInNldExldmVsIiwicGVyc2lzdCIsIlNJTEVOVCIsInNldERlZmF1bHRMZXZlbCIsInJlc2V0TGV2ZWwiLCJlbmFibGVBbGwiLCJUUkFDRSIsImRpc2FibGVBbGwiLCJpbml0aWFsTGV2ZWwiLCJkZWZhdWx0TG9nZ2VyIiwiX2xvZ2dlcnNCeU5hbWUiLCJnZXRMb2dnZXIiLCJUeXBlRXJyb3IiLCJsb2dnZXIiLCJfbG9nIiwibm9Db25mbGljdCIsImdldExvZ2dlcnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/loglevel/lib/loglevel.js\n");

/***/ })

};
;