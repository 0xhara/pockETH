"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@adraffy";
exports.ids = ["vendor-chunks/@adraffy"];
exports.modules = {

/***/ "(ssr)/./node_modules/@adraffy/ens-normalize/dist/index.cjs":
/*!************************************************************!*\
  !*** ./node_modules/@adraffy/ens-normalize/dist/index.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// created 2023-09-12T22:05:14.211Z\n// compressed base64-encoded blob for include-ens data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: 0565ed049b9cf1614bb9e11ba7d8ac6a6fb96c893253d890f7e2b2884b9ded32\nvar COMPRESSED$1 = \"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\";\nconst FENCED = new Map([\n    [\n        8217,\n        \"apostrophe\"\n    ],\n    [\n        8260,\n        \"fraction slash\"\n    ],\n    [\n        12539,\n        \"middle dot\"\n    ]\n]);\nconst NSM_MAX = 4;\nfunction decode_arithmetic(bytes) {\n    let pos = 0;\n    function u16() {\n        return bytes[pos++] << 8 | bytes[pos++];\n    }\n    // decode the frequency table\n    let symbol_count = u16();\n    let total = 1;\n    let acc = [\n        0,\n        1\n    ]; // first symbol has frequency 1\n    for(let i = 1; i < symbol_count; i++){\n        acc.push(total += u16());\n    }\n    // skip the sized-payload that the last 3 symbols index into\n    let skip = u16();\n    let pos_payload = pos;\n    pos += skip;\n    let read_width = 0;\n    let read_buffer = 0;\n    function read_bit() {\n        if (read_width == 0) {\n            // this will read beyond end of buffer\n            // but (undefined|0) => zero pad\n            read_buffer = read_buffer << 8 | bytes[pos++];\n            read_width = 8;\n        }\n        return read_buffer >> --read_width & 1;\n    }\n    const N = 31;\n    const FULL = 2 ** N;\n    const HALF = FULL >>> 1;\n    const QRTR = HALF >> 1;\n    const MASK = FULL - 1;\n    // fill register\n    let register = 0;\n    for(let i = 0; i < N; i++)register = register << 1 | read_bit();\n    let symbols = [];\n    let low = 0;\n    let range = FULL; // treat like a float\n    while(true){\n        let value = Math.floor(((register - low + 1) * total - 1) / range);\n        let start = 0;\n        let end = symbol_count;\n        while(end - start > 1){\n            let mid = start + end >>> 1;\n            if (value < acc[mid]) {\n                end = mid;\n            } else {\n                start = mid;\n            }\n        }\n        if (start == 0) break; // first symbol is end mark\n        symbols.push(start);\n        let a = low + Math.floor(range * acc[start] / total);\n        let b = low + Math.floor(range * acc[start + 1] / total) - 1;\n        while(((a ^ b) & HALF) == 0){\n            register = register << 1 & MASK | read_bit();\n            a = a << 1 & MASK;\n            b = b << 1 & MASK | 1;\n        }\n        while(a & ~b & QRTR){\n            register = register & HALF | register << 1 & MASK >>> 1 | read_bit();\n            a = a << 1 ^ HALF;\n            b = (b ^ HALF) << 1 | HALF | 1;\n        }\n        low = a;\n        range = 1 + b - a;\n    }\n    let offset = symbol_count - 4;\n    return symbols.map((x)=>{\n        switch(x - offset){\n            case 3:\n                return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n            case 2:\n                return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n            case 1:\n                return offset + bytes[pos_payload++];\n            default:\n                return x - 1;\n        }\n    });\n}\n// returns an iterator which returns the next symbol\nfunction read_payload(v) {\n    let pos = 0;\n    return ()=>v[pos++];\n}\nfunction read_compressed_payload(s) {\n    return read_payload(decode_arithmetic(unsafe_atob(s)));\n}\n// unsafe in the sense:\n// expected well-formed Base64 w/o padding \n// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4\nfunction unsafe_atob(s) {\n    let lookup = [];\n    [\n        ...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n    ].forEach((c, i)=>lookup[c.charCodeAt(0)] = i);\n    let n = s.length;\n    let ret = new Uint8Array(6 * n >> 3);\n    for(let i = 0, pos = 0, width = 0, carry = 0; i < n; i++){\n        carry = carry << 6 | lookup[s.charCodeAt(i)];\n        width += 6;\n        if (width >= 8) {\n            ret[pos++] = carry >> (width -= 8);\n        }\n    }\n    return ret;\n}\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nfunction signed(i) {\n    return i & 1 ? ~i >> 1 : i >> 1;\n}\nfunction read_deltas(n, next) {\n    let v = Array(n);\n    for(let i = 0, x = 0; i < n; i++)v[i] = x += signed(next());\n    return v;\n}\n// [123][5] => [0 3] [1 1] [0 0]\nfunction read_sorted(next, prev = 0) {\n    let ret = [];\n    while(true){\n        let x = next();\n        let n = next();\n        if (!n) break;\n        prev += x;\n        for(let i = 0; i < n; i++){\n            ret.push(prev + i);\n        }\n        prev += n + 1;\n    }\n    return ret;\n}\nfunction read_sorted_arrays(next) {\n    return read_array_while(()=>{\n        let v = read_sorted(next);\n        if (v.length) return v;\n    });\n}\n// returns map of x => ys\nfunction read_mapped(next) {\n    let ret = [];\n    while(true){\n        let w = next();\n        if (w == 0) break;\n        ret.push(read_linear_table(w, next));\n    }\n    while(true){\n        let w = next() - 1;\n        if (w < 0) break;\n        ret.push(read_replacement_table(w, next));\n    }\n    return ret.flat();\n}\n// read until next is falsy\n// return array of read values\nfunction read_array_while(next) {\n    let v = [];\n    while(true){\n        let x = next(v.length);\n        if (!x) break;\n        v.push(x);\n    }\n    return v;\n}\n// read w columns of length n\n// return as n rows of length w\nfunction read_transposed(n, w, next) {\n    let m = Array(n).fill().map(()=>[]);\n    for(let i = 0; i < w; i++){\n        read_deltas(n, next).forEach((x, j)=>m[j].push(x));\n    }\n    return m;\n}\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\n// where dx/dy = steps, n = run size, w = length of y\nfunction read_linear_table(w, next) {\n    let dx = 1 + next();\n    let dy = next();\n    let vN = read_array_while(next);\n    let m = read_transposed(vN.length, 1 + w, next);\n    return m.flatMap((v, i)=>{\n        let [x, ...ys] = v;\n        return Array(vN[i]).fill().map((_, j)=>{\n            let j_dy = j * dy;\n            return [\n                x + j * dx,\n                ys.map((y)=>y + j_dy)\n            ];\n        });\n    });\n}\n// return [[x, ys...], ...]\n// where w = length of y\nfunction read_replacement_table(w, next) {\n    let n = 1 + next();\n    let m = read_transposed(n, 1 + w, next);\n    return m.map((v)=>[\n            v[0],\n            v.slice(1)\n        ]);\n}\nfunction read_trie(next) {\n    let ret = [];\n    let sorted = read_sorted(next);\n    expand(decode([]), []);\n    return ret; // not sorted\n    function decode(Q) {\n        let S = next(); // state: valid, save, check\n        let B = read_array_while(()=>{\n            let cps = read_sorted(next).map((i)=>sorted[i]);\n            if (cps.length) return decode(cps);\n        });\n        return {\n            S,\n            B,\n            Q\n        };\n    }\n    function expand({ S, B }, cps, saved) {\n        if (S & 4 && saved === cps[cps.length - 1]) return;\n        if (S & 2) saved = cps[cps.length - 1];\n        if (S & 1) ret.push(cps);\n        for (let br of B){\n            for (let cp of br.Q){\n                expand(br, [\n                    ...cps,\n                    cp\n                ], saved);\n            }\n        }\n    }\n}\nfunction hex_cp(cp) {\n    return cp.toString(16).toUpperCase().padStart(2, \"0\");\n}\nfunction quote_cp(cp) {\n    return `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\n}\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/ function explode_cp(s) {\n    let cps = [];\n    for(let pos = 0, len = s.length; pos < len;){\n        let cp = s.codePointAt(pos);\n        pos += cp < 0x10000 ? 1 : 2;\n        cps.push(cp);\n    }\n    return cps;\n}\nfunction str_from_cps(cps) {\n    const chunk = 4096;\n    let len = cps.length;\n    if (len < chunk) return String.fromCodePoint(...cps);\n    let buf = [];\n    for(let i = 0; i < len;){\n        buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\n    }\n    return buf.join(\"\");\n}\nfunction compare_arrays(a, b) {\n    let n = a.length;\n    let c = n - b.length;\n    for(let i = 0; c == 0 && i < n; i++)c = a[i] - b[i];\n    return c;\n}\n// created 2023-09-12T22:05:14.211Z\n// compressed base64-encoded blob for include-nf data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: a974b6f8541fc29d919bc85118af0a44015851fab5343f8679cb31be2bdb209e\nvar COMPRESSED = \"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\";\n// https://unicode.org/reports/tr15/\n// for reference implementation\n// see: /derive/nf.js\n// algorithmic hangul\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\nconst S0 = 0xAC00;\nconst L0 = 0x1100;\nconst V0 = 0x1161;\nconst T0 = 0x11A7;\nconst L_COUNT = 19;\nconst V_COUNT = 21;\nconst T_COUNT = 28;\nconst N_COUNT = V_COUNT * T_COUNT;\nconst S_COUNT = L_COUNT * N_COUNT;\nconst S1 = S0 + S_COUNT;\nconst L1 = L0 + L_COUNT;\nconst V1 = V0 + V_COUNT;\nconst T1 = T0 + T_COUNT;\nfunction unpack_cc(packed) {\n    return packed >> 24 & 0xFF;\n}\nfunction unpack_cp(packed) {\n    return packed & 0xFFFFFF;\n}\nlet SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;\nfunction init$1() {\n    //console.time('nf');\n    let r = read_compressed_payload(COMPRESSED);\n    SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i)=>v.map((x)=>[\n                x,\n                i + 1 << 24\n            ]))); // pre-shifted\n    EXCLUSIONS = new Set(read_sorted(r));\n    DECOMP = new Map();\n    RECOMP = new Map();\n    for (let [cp, cps] of read_mapped(r)){\n        if (!EXCLUSIONS.has(cp) && cps.length == 2) {\n            let [a, b] = cps;\n            let bucket = RECOMP.get(a);\n            if (!bucket) {\n                bucket = new Map();\n                RECOMP.set(a, bucket);\n            }\n            bucket.set(b, cp);\n        }\n        DECOMP.set(cp, cps.reverse()); // stored reversed\n    }\n//console.timeEnd('nf');\n// 20230905: 11ms\n}\nfunction is_hangul(cp) {\n    return cp >= S0 && cp < S1;\n}\nfunction compose_pair(a, b) {\n    if (a >= L0 && a < L1 && b >= V0 && b < V1) {\n        return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\n    } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\n        return a + (b - T0);\n    } else {\n        let recomp = RECOMP.get(a);\n        if (recomp) {\n            recomp = recomp.get(b);\n            if (recomp) {\n                return recomp;\n            }\n        }\n        return -1;\n    }\n}\nfunction decomposed(cps) {\n    if (!SHIFTED_RANK) init$1();\n    let ret = [];\n    let buf = [];\n    let check_order = false;\n    function add(cp) {\n        let cc = SHIFTED_RANK.get(cp);\n        if (cc) {\n            check_order = true;\n            cp |= cc;\n        }\n        ret.push(cp);\n    }\n    for (let cp of cps){\n        while(true){\n            if (cp < 0x80) {\n                ret.push(cp);\n            } else if (is_hangul(cp)) {\n                let s_index = cp - S0;\n                let l_index = s_index / N_COUNT | 0;\n                let v_index = s_index % N_COUNT / T_COUNT | 0;\n                let t_index = s_index % T_COUNT;\n                add(L0 + l_index);\n                add(V0 + v_index);\n                if (t_index > 0) add(T0 + t_index);\n            } else {\n                let mapped = DECOMP.get(cp);\n                if (mapped) {\n                    buf.push(...mapped);\n                } else {\n                    add(cp);\n                }\n            }\n            if (!buf.length) break;\n            cp = buf.pop();\n        }\n    }\n    if (check_order && ret.length > 1) {\n        let prev_cc = unpack_cc(ret[0]);\n        for(let i = 1; i < ret.length; i++){\n            let cc = unpack_cc(ret[i]);\n            if (cc == 0 || prev_cc <= cc) {\n                prev_cc = cc;\n                continue;\n            }\n            let j = i - 1;\n            while(true){\n                let tmp = ret[j + 1];\n                ret[j + 1] = ret[j];\n                ret[j] = tmp;\n                if (!j) break;\n                prev_cc = unpack_cc(ret[--j]);\n                if (prev_cc <= cc) break;\n            }\n            prev_cc = unpack_cc(ret[i]);\n        }\n    }\n    return ret;\n}\nfunction composed_from_decomposed(v) {\n    let ret = [];\n    let stack = [];\n    let prev_cp = -1;\n    let prev_cc = 0;\n    for (let packed of v){\n        let cc = unpack_cc(packed);\n        let cp = unpack_cp(packed);\n        if (prev_cp == -1) {\n            if (cc == 0) {\n                prev_cp = cp;\n            } else {\n                ret.push(cp);\n            }\n        } else if (prev_cc > 0 && prev_cc >= cc) {\n            if (cc == 0) {\n                ret.push(prev_cp, ...stack);\n                stack.length = 0;\n                prev_cp = cp;\n            } else {\n                stack.push(cp);\n            }\n            prev_cc = cc;\n        } else {\n            let composed = compose_pair(prev_cp, cp);\n            if (composed >= 0) {\n                prev_cp = composed;\n            } else if (prev_cc == 0 && cc == 0) {\n                ret.push(prev_cp);\n                prev_cp = cp;\n            } else {\n                stack.push(cp);\n                prev_cc = cc;\n            }\n        }\n    }\n    if (prev_cp >= 0) {\n        ret.push(prev_cp, ...stack);\n    }\n    return ret;\n}\n// note: cps can be iterable\nfunction nfd(cps) {\n    return decomposed(cps).map(unpack_cp);\n}\nfunction nfc(cps) {\n    return composed_from_decomposed(decomposed(cps));\n}\nconst HYPHEN = 0x2D;\nconst STOP = 0x2E;\nconst STOP_CH = \".\";\nconst FE0F = 0xFE0F;\nconst UNIQUE_PH = 1;\n// 20230913: replace [...v] with Array_from(v) to avoid large spreads\nconst Array_from = (x)=>Array.from(x); // Array.from.bind(Array);\nfunction group_has_cp(g, cp) {\n    // 20230913: keep primary and secondary distinct instead of creating valid union\n    return g.P.has(cp) || g.Q.has(cp);\n}\nclass Emoji extends Array {\n    get is_emoji() {\n        return true;\n    }\n}\nlet MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;\nfunction init() {\n    if (MAPPED) return;\n    let r = read_compressed_payload(COMPRESSED$1);\n    const read_sorted_array = ()=>read_sorted(r);\n    const read_sorted_set = ()=>new Set(read_sorted_array());\n    MAPPED = new Map(read_mapped(r));\n    IGNORED = read_sorted_set(); // ignored characters are not valid, so just read raw codepoints\n    /*\r\n\t// direct include from payload is smaller than the decompression code\r\n\tconst FENCED = new Map(read_array_while(() => {\r\n\t\tlet cp = r();\r\n\t\tif (cp) return [cp, read_str(r())];\r\n\t}));\r\n\t*/ // 20230217: we still need all CM for proper error formatting\n    // but norm only needs NSM subset that are potentially-valid\n    CM = read_sorted_array();\n    NSM = new Set(read_sorted_array().map((i)=>CM[i]));\n    CM = new Set(CM);\n    ESCAPE = read_sorted_set(); // characters that should not be printed\n    NFC_CHECK = read_sorted_set(); // only needed to illustrate ens_tokenize() transformations\n    let chunks = read_sorted_arrays(r);\n    let unrestricted = r();\n    const read_chunked = ()=>new Set(read_sorted_array().flatMap((i)=>chunks[i]).concat(read_sorted_array()));\n    GROUPS = read_array_while((i)=>{\n        // minifier property mangling seems unsafe\n        // so these are manually renamed to single chars\n        let N = read_array_while(r).map((x)=>x + 0x60);\n        if (N.length) {\n            let R = i >= unrestricted; // first arent restricted\n            N[0] -= 32; // capitalize\n            N = str_from_cps(N);\n            if (R) N = `Restricted[${N}]`;\n            let P = read_chunked(); // primary\n            let Q = read_chunked(); // secondary\n            let M = !r(); // not-whitelisted, check for NSM\n            // *** this code currently isn't needed ***\n            /*\r\n\t\t\tlet V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid\r\n\t\t\tlet M = r()-1; // number of combining mark\r\n\t\t\tif (M < 0) { // whitelisted\r\n\t\t\t\tM = new Map(read_array_while(() => {\r\n\t\t\t\t\tlet i = r();\r\n\t\t\t\t\tif (i) return [V[i-1], read_array_while(() => {\r\n\t\t\t\t\t\tlet v = read_array_while(r);\r\n\t\t\t\t\t\tif (v.length) return v.map(x => x-1);\r\n\t\t\t\t\t})];\r\n\t\t\t\t}));\r\n\t\t\t}*/ return {\n                N,\n                P,\n                Q,\n                M,\n                R\n            };\n        }\n    });\n    // decode compressed wholes\n    WHOLE_VALID = read_sorted_set();\n    WHOLE_MAP = new Map();\n    let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b)=>a - b); // must be sorted\n    wholes.forEach((cp, i)=>{\n        let d = r();\n        let w = wholes[i] = d ? wholes[i - d] : {\n            V: [],\n            M: new Map()\n        };\n        w.V.push(cp); // add to member set\n        if (!WHOLE_VALID.has(cp)) {\n            WHOLE_MAP.set(cp, w); // register with whole map\n        }\n    });\n    // compute confusable-extent complements\n    for (let { V, M } of new Set(WHOLE_MAP.values())){\n        // connect all groups that have each whole character\n        let recs = [];\n        for (let cp of V){\n            let gs = GROUPS.filter((g)=>group_has_cp(g, cp));\n            let rec = recs.find(({ G })=>gs.some((g)=>G.has(g)));\n            if (!rec) {\n                rec = {\n                    G: new Set(),\n                    V: []\n                };\n                recs.push(rec);\n            }\n            rec.V.push(cp);\n            gs.forEach((g)=>rec.G.add(g));\n        }\n        // per character cache groups which are not a member of the extent\n        let union = recs.flatMap((x)=>Array_from(x.G));\n        for (let { G, V } of recs){\n            let complement = new Set(union.filter((g)=>!G.has(g)));\n            for (let cp of V){\n                M.set(cp, complement);\n            }\n        }\n    }\n    // compute valid set\n    let union = new Set(); // exists in 1+ groups\n    let multi = new Set(); // exists in 2+ groups\n    const add_to_union = (cp)=>union.has(cp) ? multi.add(cp) : union.add(cp);\n    for (let g of GROUPS){\n        for (let cp of g.P)add_to_union(cp);\n        for (let cp of g.Q)add_to_union(cp);\n    }\n    // dual purpose WHOLE_MAP: return placeholder if unique non-confusable\n    for (let cp of union){\n        if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\n            WHOLE_MAP.set(cp, UNIQUE_PH);\n        }\n    }\n    VALID = new Set(Array_from(union).concat(Array_from(nfd(union)))); // possibly valid\n    // decode emoji\n    // 20230719: emoji are now fully-expanded to avoid quirk logic \n    EMOJI_LIST = read_trie(r).map((v)=>Emoji.from(v)).sort(compare_arrays);\n    EMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)\n    for (let cps of EMOJI_LIST){\n        // 20230719: change to *slightly* stricter algorithm which disallows \n        // insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)\n        // example: beautified [A B] (eg. flag emoji) \n        //  before: allow: [A FE0F B], error: [A FE0F FE0F B] \n        //   after: error: both\n        // note: this code now matches ENSNormalize.{cs,java} logic\n        let prev = [\n            EMOJI_ROOT\n        ];\n        for (let cp of cps){\n            let next = prev.map((node)=>{\n                let child = node.get(cp);\n                if (!child) {\n                    // should this be object? \n                    // (most have 1-2 items, few have many)\n                    // 20230719: no, v8 default map is 4?\n                    child = new Map();\n                    node.set(cp, child);\n                }\n                return child;\n            });\n            if (cp === FE0F) {\n                prev.push(...next); // less than 20 elements\n            } else {\n                prev = next;\n            }\n        }\n        for (let x of prev){\n            x.V = cps;\n        }\n    }\n}\n// if escaped: {HEX}\n//       else: \"x\" {HEX}\nfunction quoted_cp(cp) {\n    return (should_escape(cp) ? \"\" : `${bidi_qq(safe_str_from_cps([\n        cp\n    ]))} `) + quote_cp(cp);\n}\n// 20230211: some messages can be mixed-directional and result in spillover\n// use 200E after a quoted string to force the remainder of a string from \n// acquring the direction of the quote\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\nfunction bidi_qq(s) {\n    return `\"${s}\"\\u200E`; // strong LTR\n}\nfunction check_label_extension(cps) {\n    if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\n        throw new Error(`invalid label extension: \"${str_from_cps(cps.slice(0, 4))}\"`);\n    }\n}\nfunction check_leading_underscore(cps) {\n    const UNDERSCORE = 0x5F;\n    for(let i = cps.lastIndexOf(UNDERSCORE); i > 0;){\n        if (cps[--i] !== UNDERSCORE) {\n            throw new Error(\"underscore allowed only at start\");\n        }\n    }\n}\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\nfunction check_fenced(cps) {\n    let cp = cps[0];\n    let prev = FENCED.get(cp);\n    if (prev) throw error_placement(`leading ${prev}`);\n    let n = cps.length;\n    let last = -1; // prevents trailing from throwing\n    for(let i = 1; i < n; i++){\n        cp = cps[i];\n        let match = FENCED.get(cp);\n        if (match) {\n            // since cps[0] isn't fenced, cps[1] cannot throw\n            if (last == i) throw error_placement(`${prev} + ${match}`);\n            last = i + 1;\n            prev = match;\n        }\n    }\n    if (last == n) throw error_placement(`trailing ${prev}`);\n}\n// create a safe to print string \n// invisibles are escaped\n// leading cm uses placeholder\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\n// note: in html, you'd call this function then replace [<>&] with entities\nfunction safe_str_from_cps(cps, quoter = quote_cp) {\n    //if (Number.isInteger(cps)) cps = [cps];\n    //if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\n    let buf = [];\n    if (is_combining_mark(cps[0])) buf.push(\"\");\n    let prev = 0;\n    let n = cps.length;\n    for(let i = 0; i < n; i++){\n        let cp = cps[i];\n        if (should_escape(cp)) {\n            buf.push(str_from_cps(cps.slice(prev, i)));\n            buf.push(quoter(cp));\n            prev = i + 1;\n        }\n    }\n    buf.push(str_from_cps(cps.slice(prev, n)));\n    return buf.join(\"\");\n}\n// note: set(s) cannot be exposed because they can be modified\n// note: Object.freeze() doesn't work\nfunction is_combining_mark(cp) {\n    init();\n    return CM.has(cp);\n}\nfunction should_escape(cp) {\n    init();\n    return ESCAPE.has(cp);\n}\n// return all supported emoji as fully-qualified emoji \n// ordered by length then lexicographic \nfunction ens_emoji() {\n    init();\n    return EMOJI_LIST.map((x)=>x.slice()); // emoji are exposed so copy\n}\nfunction ens_normalize_fragment(frag, decompose) {\n    init();\n    let nf = decompose ? nfd : nfc;\n    return frag.split(STOP_CH).map((label)=>str_from_cps(tokens_from_str(explode_cp(label), nf, filter_fe0f).flat())).join(STOP_CH);\n}\nfunction ens_normalize(name) {\n    return flatten(split(name, nfc, filter_fe0f));\n}\nfunction ens_beautify(name) {\n    let labels = split(name, nfc, (x)=>x); // emoji not exposed\n    for (let { type, output, error } of labels){\n        if (error) break; // flatten will throw\n        // replace leading/trailing hyphen\n        // 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\n        // not exactly the same in every font, but very similar: \"-\" vs \"\"\n        /*\r\n\t\tconst UNICODE_HYPHEN = 0x2010;\r\n\t\t// maybe this should replace all for visual consistancy?\r\n\t\t// `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n\t\t//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n\t\tif (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n\t\tlet end = output.length-1;\r\n\t\tif (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n\t\t*/ // 20230123: WHATWG URL uses \"CheckHyphens\" false\n        // https://url.spec.whatwg.org/#idna\n        // update ethereum symbol\n        //  =>  if not greek\n        if (type !== \"Greek\") {\n            let prev = 0;\n            while(true){\n                let next = output.indexOf(0x3BE, prev);\n                if (next < 0) break;\n                output[next] = 0x39E;\n                prev = next + 1;\n            }\n        }\n    // 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\n    // could be fixed with special case for: 2D (.) + 200E (LTR)\n    // https://discuss.ens.domains/t/bidi-label-ordering-spoof/15824\n    //output.splice(0, 0, 0x200E);\n    }\n    return flatten(labels);\n}\nfunction ens_split(name, preserve_emoji) {\n    return split(name, nfc, preserve_emoji ? (x)=>x.slice() : filter_fe0f); // emoji are exposed so copy\n}\nfunction split(name, nf, ef) {\n    if (!name) return []; // 20230719: empty name allowance\n    init();\n    let offset = 0;\n    // https://unicode.org/reports/tr46/#Validity_Criteria\n    // 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\n    return name.split(STOP_CH).map((label)=>{\n        let input = explode_cp(label);\n        let info = {\n            input,\n            offset\n        };\n        offset += input.length + 1; // + stop\n        try {\n            // 1.) \"The label must be in Unicode Normalization Form NFC\"\n            let tokens = info.tokens = tokens_from_str(input, nf, ef);\n            let token_count = tokens.length;\n            let type;\n            if (!token_count) {\n                //norm = [];\n                //type = 'None'; // use this instead of next match, \"ASCII\"\n                // 20230120: change to strict\n                // https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\n                throw new Error(`empty label`);\n            }\n            let norm = info.output = tokens.flat();\n            check_leading_underscore(norm);\n            let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji; // same as: tokens.some(x => x.is_emoji);\n            if (!emoji && norm.every((cp)=>cp < 0x80)) {\n                // 20230123: matches matches WHATWG, see note 3.3\n                check_label_extension(norm); // only needed for ascii\n                // cant have fenced\n                // cant have cm\n                // cant have wholes\n                // see derive: \"Fastpath ASCII\"\n                type = \"ASCII\";\n            } else {\n                let chars = tokens.flatMap((x)=>x.is_emoji ? [] : x); // all of the nfc tokens concat together\n                if (!chars.length) {\n                    type = \"Emoji\";\n                } else {\n                    // 5.) \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\n                    if (CM.has(norm[0])) throw error_placement(\"leading combining mark\");\n                    for(let i = 1; i < token_count; i++){\n                        let cps = tokens[i];\n                        if (!cps.is_emoji && CM.has(cps[0])) {\n                            // bidi_qq() not needed since emoji is LTR and cps is a CM\n                            throw error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([\n                                cps[0]\n                            ])}\"`);\n                        }\n                    }\n                    check_fenced(norm);\n                    let unique = Array_from(new Set(chars));\n                    let [g] = determine_group(unique); // take the first match\n                    // see derive: \"Matching Groups have Same CM Style\"\n                    // alternative: could form a hybrid type: Latin/Japanese/...\t\n                    check_group(g, chars); // need text in order\n                    check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\n                    type = g.N;\n                // 20230121: consider exposing restricted flag\n                // it's simpler to just check for 'Restricted'\n                // or even better: type.endsWith(']')\n                //if (g.R) info.restricted = true;\n                }\n            }\n            info.type = type;\n        } catch (err) {\n            info.error = err; // use full error object\n        }\n        return info;\n    });\n}\nfunction check_whole(group, unique) {\n    let maker;\n    let shared = [];\n    for (let cp of unique){\n        let whole = WHOLE_MAP.get(cp);\n        if (whole === UNIQUE_PH) return; // unique, non-confusable\n        if (whole) {\n            let set = whole.M.get(cp); // groups which have a character that look-like this character\n            maker = maker ? maker.filter((g)=>set.has(g)) : Array_from(set);\n            if (!maker.length) return; // confusable intersection is empty\n        } else {\n            shared.push(cp);\n        }\n    }\n    if (maker) {\n        // we have 1+ confusable\n        // check if any of the remaining groups\n        // contain the shared characters too\n        for (let g of maker){\n            if (shared.every((cp)=>group_has_cp(g, cp))) {\n                throw new Error(`whole-script confusable: ${group.N}/${g.N}`);\n            }\n        }\n    }\n}\n// assumption: unique.size > 0\n// returns list of matching groups\nfunction determine_group(unique) {\n    let groups = GROUPS;\n    for (let cp of unique){\n        // note: we need to dodge CM that are whitelisted\n        // but that code isn't currently necessary\n        let gs = groups.filter((g)=>group_has_cp(g, cp));\n        if (!gs.length) {\n            if (!GROUPS.some((g)=>group_has_cp(g, cp))) {\n                // the character was composed of valid parts\n                // but it's NFC form is invalid\n                // 20230716: change to more exact statement, see: ENSNormalize.{cs,java}\n                // note: this doesn't have to be a composition\n                // 20230720: change to full check\n                throw error_disallowed(cp); // this should be rare\n            } else {\n                // there is no group that contains all these characters\n                // throw using the highest priority group that matched\n                // https://www.unicode.org/reports/tr39/#mixed_script_confusables\n                throw error_group_member(groups[0], cp);\n            }\n        }\n        groups = gs;\n        if (gs.length == 1) break; // there is only one group left\n    }\n    // there are at least 1 group(s) with all of these characters\n    return groups;\n}\n// throw on first error\nfunction flatten(split) {\n    return split.map(({ input, error, output })=>{\n        if (error) {\n            // don't print label again if just a single label\n            let msg = error.message;\n            // bidi_qq() only necessary if msg is digits\n            throw new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input))}: ${msg}`);\n        }\n        return str_from_cps(output);\n    }).join(STOP_CH);\n}\nfunction error_disallowed(cp) {\n    // TODO: add cp to error?\n    return new Error(`disallowed character: ${quoted_cp(cp)}`);\n}\nfunction error_group_member(g, cp) {\n    let quoted = quoted_cp(cp);\n    let gg = GROUPS.find((g)=>g.P.has(cp)); // only check primary\n    if (gg) {\n        quoted = `${gg.N} ${quoted}`;\n    }\n    return new Error(`illegal mixture: ${g.N} + ${quoted}`);\n}\nfunction error_placement(where) {\n    return new Error(`illegal placement: ${where}`);\n}\n// assumption: cps.length > 0\n// assumption: cps[0] isn't a CM\n// assumption: the previous character isn't an emoji\nfunction check_group(g, cps) {\n    for (let cp of cps){\n        if (!group_has_cp(g, cp)) {\n            // for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\n            // at the moment, it's unnecessary to introduce an extra error type\n            // until there exists a whitelisted multi-character\n            //   eg. if (M < 0 && is_combining_mark(cp)) { ... }\n            // there are 3 cases:\n            //   1. illegal cm for wrong group => mixture error\n            //   2. illegal cm for same group => cm error\n            //       requires set of whitelist cm per group: \n            //        eg. new Set([...g.P, ...g.Q].flatMap(nfc).filter(cp => CM.has(cp)))\n            //   3. wrong group => mixture error\n            throw error_group_member(g, cp);\n        }\n    }\n    //if (M >= 0) { // we have a known fixed cm count\n    if (g.M) {\n        let decomposed = nfd(cps);\n        for(let i = 1, e = decomposed.length; i < e; i++){\n            // 20230210: bugfix: using cps instead of decomposed h/t Carbon225\n            /*\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t\t*/ // 20230217: switch to NSM counting\n            // https://www.unicode.org/reports/tr39/#Optional_Detection\n            if (NSM.has(decomposed[i])) {\n                let j = i + 1;\n                for(let cp; j < e && NSM.has(cp = decomposed[j]); j++){\n                    // a. Forbid sequences of the same nonspacing mark.\n                    for(let k = i; k < j; k++){\n                        if (decomposed[k] == cp) {\n                            throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);\n                        }\n                    }\n                }\n                // parse to end so we have full nsm count\n                // b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\n                if (j - i > NSM_MAX) {\n                    // note: this slice starts with a base char or spacing-mark cm\n                    throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);\n                }\n                i = j;\n            }\n        }\n    }\n// *** this code currently isn't needed ***\n/*\r\n\tlet cm_whitelist = M instanceof Map;\r\n\tfor (let i = 0, e = cps.length; i < e; ) {\r\n\t\tlet cp = cps[i++];\r\n\t\tlet seqs = cm_whitelist && M.get(cp);\r\n\t\tif (seqs) { \r\n\t\t\t// list of codepoints that can follow\r\n\t\t\t// if this exists, this will always be 1+\r\n\t\t\tlet j = i;\r\n\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\tlet cms = cps.slice(i, j);\r\n\t\t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n\t\t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n\t\t\ti = j;\r\n\t\t} else if (!V.has(cp)) {\r\n\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\tlet quoted = quoted_cp(cp);\r\n\t\t\tfor (let cp of cps) {\r\n\t\t\t\tlet u = UNIQUE.get(cp);\r\n\t\t\t\tif (u && u !== g) {\r\n\t\t\t\t\t// if both scripts are restricted this error is confusing\r\n\t\t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n\t\t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n\t\t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n\t\t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n\t\t}\r\n\t}\r\n\tif (!cm_whitelist) {\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*/ }\n// given a list of codepoints\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\n// eg. explode_cp(\"abcd\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\n// 20230818: rename for 'process' name collision h/t Javarome\n// https://github.com/adraffy/ens-normalize.js/issues/23\nfunction tokens_from_str(input, nf, ef) {\n    let ret = [];\n    let chars = [];\n    input = input.slice().reverse(); // flip so we can pop\n    while(input.length){\n        let emoji = consume_emoji_reversed(input);\n        if (emoji) {\n            if (chars.length) {\n                ret.push(nf(chars));\n                chars = [];\n            }\n            ret.push(ef(emoji));\n        } else {\n            let cp = input.pop();\n            if (VALID.has(cp)) {\n                chars.push(cp);\n            } else {\n                let cps = MAPPED.get(cp);\n                if (cps) {\n                    chars.push(...cps); // less than 10 elements\n                } else if (!IGNORED.has(cp)) {\n                    // 20230912: unicode 15.1 changed the order of processing such that\n                    // disallowed parts are only rejected after NFC\n                    // https://unicode.org/reports/tr46/#Validity_Criteria\n                    // this doesn't impact normalization as of today\n                    // technically, this error can be removed as the group logic will apply similar logic\n                    // however the error type might be less clear\n                    throw error_disallowed(cp);\n                }\n            }\n        }\n    }\n    if (chars.length) {\n        ret.push(nf(chars));\n    }\n    return ret;\n}\nfunction filter_fe0f(cps) {\n    return cps.filter((cp)=>cp != FE0F);\n}\n// given array of codepoints\n// returns the longest valid emoji sequence (or undefined if no match)\n// *MUTATES* the supplied array\n// disallows interleaved ignored characters\n// fills (optional) eaten array with matched codepoints\nfunction consume_emoji_reversed(cps, eaten) {\n    let node = EMOJI_ROOT;\n    let emoji;\n    let pos = cps.length;\n    while(pos){\n        node = node.get(cps[--pos]);\n        if (!node) break;\n        let { V } = node;\n        if (V) {\n            emoji = V;\n            if (eaten) eaten.push(...cps.slice(pos).reverse()); // (optional) copy input, used for ens_tokenize()\n            cps.length = pos; // truncate\n        }\n    }\n    return emoji;\n}\n// ************************************************************\n// tokenizer \nconst TY_VALID = \"valid\";\nconst TY_MAPPED = \"mapped\";\nconst TY_IGNORED = \"ignored\";\nconst TY_DISALLOWED = \"disallowed\";\nconst TY_EMOJI = \"emoji\";\nconst TY_NFC = \"nfc\";\nconst TY_STOP = \"stop\";\nfunction ens_tokenize(name, { nf = true } = {}) {\n    init();\n    let input = explode_cp(name).reverse();\n    let eaten = [];\n    let tokens = [];\n    while(input.length){\n        let emoji = consume_emoji_reversed(input, eaten);\n        if (emoji) {\n            tokens.push({\n                type: TY_EMOJI,\n                emoji: emoji.slice(),\n                input: eaten,\n                cps: filter_fe0f(emoji)\n            });\n            eaten = []; // reset buffer\n        } else {\n            let cp = input.pop();\n            if (cp == STOP) {\n                tokens.push({\n                    type: TY_STOP,\n                    cp\n                });\n            } else if (VALID.has(cp)) {\n                tokens.push({\n                    type: TY_VALID,\n                    cps: [\n                        cp\n                    ]\n                });\n            } else if (IGNORED.has(cp)) {\n                tokens.push({\n                    type: TY_IGNORED,\n                    cp\n                });\n            } else {\n                let cps = MAPPED.get(cp);\n                if (cps) {\n                    tokens.push({\n                        type: TY_MAPPED,\n                        cp,\n                        cps: cps.slice()\n                    });\n                } else {\n                    tokens.push({\n                        type: TY_DISALLOWED,\n                        cp\n                    });\n                }\n            }\n        }\n    }\n    if (nf) {\n        for(let i = 0, start = -1; i < tokens.length; i++){\n            let token = tokens[i];\n            if (is_valid_or_mapped(token.type)) {\n                if (requires_check(token.cps)) {\n                    let end = i + 1;\n                    for(let pos = end; pos < tokens.length; pos++){\n                        let { type, cps } = tokens[pos];\n                        if (is_valid_or_mapped(type)) {\n                            if (!requires_check(cps)) break;\n                            end = pos + 1;\n                        } else if (type !== TY_IGNORED) {\n                            break;\n                        }\n                    }\n                    if (start < 0) start = i;\n                    let slice = tokens.slice(start, end);\n                    let cps0 = slice.flatMap((x)=>is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\n                    let cps = nfc(cps0);\n                    if (compare_arrays(cps, cps0)) {\n                        tokens.splice(start, end - start, {\n                            type: TY_NFC,\n                            input: cps0,\n                            cps,\n                            tokens0: collapse_valid_tokens(slice),\n                            tokens: ens_tokenize(str_from_cps(cps), {\n                                nf: false\n                            })\n                        });\n                        i = start;\n                    } else {\n                        i = end - 1; // skip to end of slice\n                    }\n                    start = -1; // reset\n                } else {\n                    start = i; // remember last\n                }\n            } else if (token.type !== TY_IGNORED) {\n                start = -1; // reset\n            }\n        }\n    }\n    return collapse_valid_tokens(tokens);\n}\nfunction is_valid_or_mapped(type) {\n    return type == TY_VALID || type == TY_MAPPED;\n}\nfunction requires_check(cps) {\n    return cps.some((cp)=>NFC_CHECK.has(cp));\n}\nfunction collapse_valid_tokens(tokens) {\n    for(let i = 0; i < tokens.length; i++){\n        if (tokens[i].type == TY_VALID) {\n            let j = i + 1;\n            while(j < tokens.length && tokens[j].type == TY_VALID)j++;\n            tokens.splice(i, j - i, {\n                type: TY_VALID,\n                cps: tokens.slice(i, j).flatMap((x)=>x.cps)\n            });\n        }\n    }\n    return tokens;\n}\nexports.ens_beautify = ens_beautify;\nexports.ens_emoji = ens_emoji;\nexports.ens_normalize = ens_normalize;\nexports.ens_normalize_fragment = ens_normalize_fragment;\nexports.ens_split = ens_split;\nexports.ens_tokenize = ens_tokenize;\nexports.is_combining_mark = is_combining_mark;\nexports.nfc = nfc;\nexports.nfd = nfd;\nexports.safe_str_from_cps = safe_str_from_cps;\nexports.should_escape = should_escape;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFkcmFmZnkvZW5zLW5vcm1hbGl6ZS9kaXN0L2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLG1DQUFtQztBQUNuQyxzREFBc0Q7QUFDdEQsNEVBQTRFO0FBQzVFLDREQUE0RDtBQUM1RCw0RUFBNEU7QUFDNUUsSUFBSUEsZUFBZTtBQUNuQixNQUFNQyxTQUFTLElBQUlDLElBQUk7SUFBQztRQUFDO1FBQUs7S0FBYTtJQUFDO1FBQUM7UUFBSztLQUFpQjtJQUFDO1FBQUM7UUFBTTtLQUFhO0NBQUM7QUFDekYsTUFBTUMsVUFBVTtBQUVoQixTQUFTQyxrQkFBa0JDLEtBQUs7SUFDL0IsSUFBSUMsTUFBTTtJQUNWLFNBQVNDO1FBQVEsT0FBTyxLQUFNLENBQUNELE1BQU0sSUFBSSxJQUFLRCxLQUFLLENBQUNDLE1BQU07SUFBRTtJQUU1RCw2QkFBNkI7SUFDN0IsSUFBSUUsZUFBZUQ7SUFDbkIsSUFBSUUsUUFBUTtJQUNaLElBQUlDLE1BQU07UUFBQztRQUFHO0tBQUUsRUFBRSwrQkFBK0I7SUFDakQsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILGNBQWNHLElBQUs7UUFDdENELElBQUlFLElBQUksQ0FBQ0gsU0FBU0Y7SUFDbkI7SUFFQSw0REFBNEQ7SUFDNUQsSUFBSU0sT0FBT047SUFDWCxJQUFJTyxjQUFjUjtJQUNsQkEsT0FBT087SUFFUCxJQUFJRSxhQUFhO0lBQ2pCLElBQUlDLGNBQWM7SUFDbEIsU0FBU0M7UUFDUixJQUFJRixjQUFjLEdBQUc7WUFDcEIsc0NBQXNDO1lBQ3RDLGdDQUFnQztZQUNoQ0MsY0FBYyxlQUFnQixJQUFLWCxLQUFLLENBQUNDLE1BQU07WUFDL0NTLGFBQWE7UUFDZDtRQUNBLE9BQU8sZUFBZ0IsRUFBRUEsYUFBYztJQUN4QztJQUVBLE1BQU1HLElBQUk7SUFDVixNQUFNQyxPQUFPLEtBQUdEO0lBQ2hCLE1BQU1FLE9BQU9ELFNBQVM7SUFDdEIsTUFBTUUsT0FBT0QsUUFBUTtJ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QUFNLElBQUlvTSxNQUFNLENBQUMvSyxFQUFFLENBQUNzSyxJQUFJLElBQUlvQyxTQUFVMU07WUFDeEQrSyxPQUFPdUMsTUFBTSxDQUFDaFIsR0FBRzBELElBQUkxRCxHQUFHO2dCQUFDZ08sTUFBTW9DO2dCQUFVekwsS0FBSzhKLE9BQU90SyxLQUFLLENBQUNuRSxHQUFHMEQsR0FBR0ksT0FBTyxDQUFDcEMsQ0FBQUEsSUFBS0EsRUFBRWlELEdBQUc7WUFBQztRQUNyRjtJQUNEO0lBQ0EsT0FBTzhKO0FBQ1I7QUFFQTBDLG9CQUFvQixHQUFHckQ7QUFDdkJxRCxpQkFBaUIsR0FBR2pFO0FBQ3BCaUUscUJBQXFCLEdBQUd4RDtBQUN4QndELDhCQUE4QixHQUFHaEU7QUFDakNnRSxpQkFBaUIsR0FBRy9DO0FBQ3BCK0Msb0JBQW9CLEdBQUdSO0FBQ3ZCUSx5QkFBeUIsR0FBR2xFO0FBQzVCa0UsV0FBVyxHQUFHcEk7QUFDZG9JLFdBQVcsR0FBR3JJO0FBQ2RxSSx5QkFBeUIsR0FBRzdFO0FBQzVCNkUscUJBQXFCLEdBQUcvRSIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvQGFkcmFmZnkvZW5zLW5vcm1hbGl6ZS9kaXN0L2luZGV4LmNqcz9mZTE5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gY3JlYXRlZCAyMDIzLTA5LTEyVDIyOjA1OjE0LjIxMVpcbi8vIGNvbXByZXNzZWQgYmFzZTY0LWVuY29kZWQgYmxvYiBmb3IgaW5jbHVkZS1lbnMgZGF0YVxuLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzL2Jsb2IvbWFpbi9zcmMvbWFrZS5qc1xuLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzI3NlY3VyaXR5XG4vLyBTSEEtMjU2OiAwNTY1ZWQwNDliOWNmMTYxNGJiOWUxMWJhN2Q4YWM2YTZmYjk2Yzg5MzI1M2Q4OTBmN2UyYjI4ODRiOWRlZDMyXG52YXIgQ09NUFJFU1NFRCQxID0gJ0FFRVVkd21nRFM4QnhRS0tBUDRCT2dEakFUQUFuZ0RVQUlNQW9BQm9BT0FBYWdDT0FFUUFoQUJNQUhJQU93QTlBQ3NBTmdBbUFHSUFIZ0F1QUNnQUp3QVhBQzBBR2dBakFCOEFMd0FVQUNrQUVnQWVBQWtBR3dBUkFCa0FGZ0E1QUNnQUxRQXJBRGNBRlFBcEFCQUFIZ0FpQUJBQUdnQWVBQk1BR0FVaEJlOEJGeFJFTjhzRjJ3QzVBSzVIQVc4QXJRa0R6UUN1aHpjM056Y0JQNjhORWZNQUJRZEhCdXc1QlY4RllBQTlNemtJOXI0WkJnN1F5UUFXQTlDZU93TE5DamNDanFrQ2h1QS9sbStSQXNYVEFvUDZBU2ZuRVFEeXRRRkpBaldWQ2tlWEFPc0E2Z29kQUIvY3dkQVVFMFdsQkNOL0FRVUNRUmpGRC9NUkJqSHhEUVNKYncwakJ6VUFzd0J4bWUrdG5JY0FZd2FiQXlzRzhRQWpBRU1NbXhjRHFnUEtReURYQ01NeEE3a1VRd0QzTlhPckFLbUZJQUFmQkMwRDN4NEJKUURCR2RVRkFoRWdWRDhKbndtUUppTldZVXpyZzBvQUd3QVVBQjBBRm5OY0FDa0FGZ0JQOWgzZ1Bmc0RPV0RLbmVZMkNoZ2xYMVVEWUQzMEFCc0FGQUFkQUJaeklHUkFud0REOHdBakFFRU16UmJEcWdNQjJzQUZZd1hxQXRDbkFzUzRBd3BVSktSdEZIc2FkVXo5QU1NVmJ3THBBQk0xTkpFWDBaa0NnWU1CRXlNQXhSVnZBdWtBRXpVQlVGQXRtVXdTQXk0REJURVIzM0VmdFFIZlN3QjVNeEovQWprV0tRTHpMOEUvY3dCQjZRSDlMUURQRHRPOUFTTnJpUUM1RFFBTkF3Q0syMUVGSTkxekh3Q29MOWtCcVFjSEJ3Y0hLelVEb3dCdkFRb2hQdlUzZkFRZ0h3Q3lBYzhDS1FNQTV6TVNlenI3VUxnRm1EcC9MelZRQmdFR0FpOEZZUVZndDhBRmNUdGxRaHBDV0VtZmU1dG1aNklBRXhzRHpROHQrWDhyQkt0VEFsdGJBbjBqc3k4Qmw2dXRQV01EVFI4RWkya1JBTmtEQnJOSE55c0RCekVDUVdVQWN3RnBKM2tBaXlVaEFKMEJVYjhBTDNFZkFiZk5BejgxS1VzRld3RjNZUVp0QW0wQStWRWZBekVKRFFCUlNRQ3pBUUJsQUhzQU03MEdEL3YzSVpXSEJ3QVJLUUF4QUxzalR3SFpBZU1QRXptWGdJSHdBQklBR1FBOEFFVUFRRHQzZ2R2SUVHY1FaQWtHVFJGTWRFSVZFd0swRDY0TDdSRWRETmtxMDlQZ0FEU3hCL01EV3dmekExc0RXd2Z6Qi9NRFd3ZnpBMXNEV3dOYkExc2NFdkFpMjhnUVp3OVFCSFVGbGdXVEJONElpeVpSRVlrSE1BamFWQlYwSmh4UEEwMEJCQ010U1NRN216TVRKVXBNRkUwTENBUTJTbXl2ZlVBRFR6R3pWUDJRcWdQVE1sYzVkQWtHSG5rU3FBQXlEM3NrTmIxT2hucFBjYWdLVTArMnRZZEphazV2QXNZNnNFQUFDaWtKbTIvRGQxWUdSUkFmSjZrUSt3dzNBYmtCUHczeFM5d0U5UVkvQk0wZmdSa2REOUdWb0FpcExlRU04U2JuTHFXQVhpUDVLb2NGOFV2NFBPRUxVVkZzRDEwTGFRbm5PbWVCVWdNbEFSRWlqd3JoRFQwSWNSRDNDczF2RGVrUlNRYzlBOWxKbmdDcEJ3VUxGUjA1RmJrbUZHS3dDdzA1ZXdiL0d2b0xreWF6RXkxN0FBWFhHaVVHVVFFdEd3TUEweTdyaGJSYU5Wd2dUMk1HQndzcEk4c1VyRkFrRFNsQXUzaE1HaDhIR1NXdEFwVkRkRXFMVVRvZWx5SDZQRUVOYWk0WFVZQUgrVHdKR1ZNTGhUeWlScTlGRWhIV1BwRTlUQ0pOVERBRU9ZTXNNeWVQQ2RNUGlReTlmSFlCWFFrbENiVU1kUk0xRVJzM3lRZzlCeDB4bHlnbkdRZ2xScGxnbmdUN293UDNFOVVERHdWRENVVUhGd081SERFVE1oVXRCUkdCS05zQzl6YlpMcmNDazFhRUFSc0Z6dzhwSCtNUVZFZmtEdTBJbndKcEE0Y2w3d0F4RlNVQUd5S2ZDRWRuQUdPUDNGTUpMczhJeTJwd0kzZ0RheFRyWlJGM0I1VU9Xd2VySERjVnd4emxjTXhlRDRZTUtLZXpDVjhCZVFtZEFXTUU1d2dOTlYrTXBDQkZaMWVMWEJpZklHVkJRMTRBQWpVTWFSV2pSTUdIZkFLUEQyOFNId0U1QVhjSFBRMEZBbnNSOFJGdkVKa0k3NFlJTmJrei9Eb3BCRk1oaHlBVkNpc0RVMnpTQ3lzbS9RejhiUUduRW1ZREVEUkJkL0pucjJDNktCZ0JCeDB5eVVGa0lmVUxsay9SREtBYXhSaEdWRElaNkFmREEvY2E5eWZ1UVZzR0F3T25CeGM2VVRQeUJNRUxiUWlQQ1VNQVRRNm5Hd2ZiR0c0S2RZelVBVFdQQWJ1ZEExdVZod0p6a3dZN0J3OEFhdytMQlgzcEFDRUNxd2luQUFrQTB3TmJBRDBDc1FlaEFCMEFpVVVCUVFNck13RWw2UUtUQTVjSU5jOEJtVE1COXkwRUg4Y01HUUQ3TzI1T0FzTzFBb0J1WnFZRjRWd0NrZ0pOT1FGUktRUUpVa3RWQTdOMTVRRGZBRThHRitOTEFSbXZUczhlNTBjQjQzTXZBTXNBL3dBSk9RY0pSUUhSQWZkeEFMc0JZd3MxQ2FhM3VRRlI3UzBBaHdBWmJ3SGJBbzBBNFFBNUFJUDFBVmNBVVFWZC9RWFhBbE5OQVJVMUhDOWJaUUcvQXlNQk53RVJBSDBHejVHcHpRc2pCSEVIMXdJUUh4WGxBdTh5QjdrRkF5TGpFOUZDeVFLOTRsa0FNaG9LUEFxckNxcGdYMlEzQ2pWMlBWUUFFaCtzUHNzL1VnVlZPMWM3WER0WE8xdzdWenRjTzFjN1hEdFhPMXdEbThQbXcrWUtjRjlKWWU4TXFnM1lSTXc2VFJQZllGVmdOaFBNTGJzVXhSWFNKVm9aUVJyQUp3a2w2RlVORHdndDEyWTBDREEwZVJmQUFFTXBiSU5GWTRvZU5BcFBIT3RUbFZUOExSOEF0VXVtTTdNTnNCc1pSRVFGUzNYeFlpNFdFZ29tQW1TRkFtSkdYMUd6QVY4M0pBS2grd0pvbkFKbURRS2ZpRGdmRHdKbVB3Sm1LZ1J5QklNRGZ4Y0RmcFk1Q2psN0d6bUdPaWNuQW13aEFqSTZPQTRDYmNzQ2JiTHpqZ00zYTBrdkFXc0E0Z0RsQUU0SkI1d01rUUVDRDhZQUVia0Nkek1DZHFaREFubFBSd0o0dmlGZzMwV3lSdmNDZkVNQ2Vzd0NmUTBDZlBSSUJFaUJaeWdBTHhsSlhFcGZHUnRLMEFMUkJRTFEwRXNyQTRoVEE0ZnFSTW1STmdMeXBWMEhBd095UzlKTU1Ta0gwMDFRVGJNQ2kwTUNpdHpGSHdzaFIyc0p1d0tPT3dLT1lFU2JoUUtPM1FLT1lIeFJ1Rk01QVE1UzJGU0pBcFAvQXBNUUFPMEFJRlVpVmJOVjFBb3NIeW1aaWpMbGVHcEZQejBDbDZNQzc3WllKYXdBWFNrQ2xwTUNsb0NnQUsxWnNGb05oVkVBUHdLV3VRS1dVbHhJWE5VQ21jOENtV2hjemwwTEhRS2Nuem5HT3FFQ25Cb0NuNThDbnJ5T0FDRVROUzRUQXAzMUFwNldBTGxCWVRoaDh3S2Uxd0tnY2dHdEFwNmpJd0tlVXFsanpHUXJLUzhDSjdNQ0pvSUNvUDhDb0ZEYkFxWXpBcVhTQXFnREFJRUNwL1pvZ0dpMUFBZE5haUJxMVFLczV3S3NzZ0t0YXdLdEJnSlhJUUpWNEFLeDVkc0RIMUpzbXdLeXdSRUNzdXdiYk9SdFoyMU1Zd01sMFFLMllEOURicFFES1VrQ3VHSUN1VXNaQXJrdWUzQTZjT1VDdlIwRExiWURNaFVDdm94eUJnTXpkUUsrSG5NbWMxTUN3ODhDd3doemhuUlBPVWwwNUFNOHF3RURQSjREUGNNQ3hZQUN4a3NDeGhTTkFzaHRWUUxJU0FMSlV3TEpNZ0prb1FMZDFuaDlaWGl5ZVNsTDFBTVlwMmNHQW1INEdmZVZLSHNQWHBaZXZ4VUN6MjhDejNBelQxZlc5eGVqQU1xeEFzOTNBUzN1QTA0V2ZrOEpBdHdyQXR1T0F0SlRBMUpnQTFOakFRVURWWkNBalVNRXp4cnhaRWw1QTRMU2c1RUMyc3NDMmVLRUZJUk5wMEFEaHFrQU13TmtFb1oxWGYwQVdRTGZhUUxldkhkN0F1SXo3UmdCOHpRckFmU2ZBZkxXaXdMcjl3THBkSDBEQXVyOUF1cm9BUDFMQWIwQzdvMEM2NkNXcnBjSEF1NURBNFhrbUgxdzVIR2xBdk1IQUcwRGpocVpsd0wzRndPUmNnT1Npd0wzbkFMNTNRTDRhcG9nbXErL081c2lBNTJIQXY3K0FSOEFQWjhnQVorM0F3V1JBNlp1QTZiZEFOWEpBd1p1b1l5aUNRMERERTBCRXdFakIzRUdaYjFyQ1FDL0JHL0RGWThldHhFQUczazlBQ2NETnhKUkE0MkRBV2NySlFDTTh3QWxBT2FuQzZPVkNMc0dJNmZKQmdDdkJSbkRCdkVsUlVZRkZvQUZjRDlHU0ROQ0tVSzhYM2taWDhRQWxzMEZPZ0NRVkNHYndUc3VZRG9adXRjT054ak9HSkhKL2dWZkJXQUZYd1ZnQldzRllBVmZCV0FGWHdWZ0JWOEZZQVZmQldCT0hRamZqVzhLQ2dvS2JGN3hNd1RSQTdrR044UERBTU1FcjhNQTcwZ3hGcm9GVGo1eFBuaENSMEsrWDMwL1gvQUFXQmt6c3dDTkJzeHp6QVNtNzBhQ1JTNHJERE1lTHo0OWZuWGZjc0g1R2Nvc2NRRnoxM1k0SHdWbkJYTEp5Y25BQ05kUll3Z0lDQXFFWG9XVHhnQTdQNGtBQ3hiWkJ1MjFLdzBBak1zVEF3a1ZBT1Z0SlVVc0oxSkN1VUxFU1VBclh5OWdQaTlBS3duSlJRWUtURDlMUG9BK2lUNTRQbmtDa1VMRVVVcERYOU5XVjNKVkVqUUFjMXczQTNJQkUzWW5YK2c3UWlNSmI2TUthaXN6UkNVdVFyTkN4RFBNQ2N3RVg5RVdKellSRUJFRUJ3SUhLbjZsMzNKQ05WSWZ5YlBKdEFsdHlkUFVDbWhCWncvdEVLc1pBSk9WSlUxQ0xSdXhiVUhPUUFvN1AwcytlRUpISEE4U0pWUlBkR00wTlZycHZCb0toZlVsTTBKSEhHVVFVaEVXTzF4TFNqOE1PMHVjTkFxSkl6VkNSeHY5RUZzcUt5QTRPUWdOajJud1pncDVaTkZnRTJBMUszWUhTMkFoUVFvakptQzdEZ3B6R0cxV1lGVVpDUVlIWk85Z0hXQ2RZSVZndTJCVFlKbHdGaDhHdlJiY1hiRzhZZ3RESHJNQnd6UFZ5UW9uSFFna0N5WUJnUUowQWpjNG5WcUlBd0dTQ3NCUElnRHNLM1NXRXRJVkJhNU44Z0dqQW8ra1Z3Vklad0QvQUVVU0NEd2VYNElUclJRc0o4SzNUd0JYRkR3RUFCMFR2elZjQXRvVFMyMFJJd0RnVmdaOUJCSW1ZZ0E1QUw0Q29pOExGbmV6T2tDbklRRmpBWTRLQkFQaDlSY0dzZ1pTQnNFQUpjdGRzV0lSdTJrVGtRc3RSdzdEQWNNQktncFBCR0lHTURBd0tDWW5LVFFhTGc0QUtSU1ZBRndDZGwrWVVaMEpkaWNGRDNsUEFkdDFGOVpaS0NHeHVFM3lCeGtGVkdjQS93QkZFZ2lDQndBT0xIUVNqeE90UURnMXo3ZGVGUk1BWjhRVEFHdEtiMUFwSWlQSEFEa0F2Z0tpTHkxREZ0WUNtQmlEQWxERFdOQjBlbzdmcGFNTy9hRVZSUnYwQVRFUVpCSU9EeU1FQWM4SlFoQ2JEUmd6RkQ0VEFFTUF1OVlCQ2dDc0FPa0FtNUkzQUJ3QVl4dk9OblIrTWhYSkF4Z0tReXhMMitra0poTWJoUUtEQk1rU3N2RjBBRDlCTlE2dVFDN1dxU1FId3hFQUVFSXUxaGtoQUgyejRpUVB3eUpQSE5XcGR5WUJSU3BuSkFMem9CQUVWUFBzSDIwTXhBMENDRVFLUmdBRnlBdEZBbE1Od3dqRURVUUpSQXJFTHRhcE1nN0REWmdKSXcrVEd1a0VJd3ZERmtNQXFBdERFTU1NQmhpb2UrUUFPM01NUkFBQ3JnbkVCU1BZOVEwRkRuYlNCb01BQjhNU1l4a1N4QUVKQVBJSkFBQjhGV01PRnRNYy9IY1h3eGhEQUM3REF2T293d0Fld3dKZEtES0hBQUhEQUFMckZVUVZ3d0Fid3l2enBXTVd2OHdBL0FCcEF5KytiY1lEVUtQRDBLaERDd0ttSjFNQUFtTUE1K1Vad3hBYWd3aXBCUkwvZUFEZnc2ZkRHT01DR3NPamszbDZCd09wbzRzQUVzTU9HeE1BQTVzQWJjTU9BQXZEcDBNSkdrTUR3Z2lwbk5JUEF3ZklxVU1HQU9HREFBUHpBQlhEQUFjREFBbkRBR21UQUJyREFBN0RDaGpEam5FV0F3QUJZd0FPY3dBdVV5WUFCc01BRjhNSUtRQU5VZ0M2d3k0QUE4TUFEcU1xOHdDeVlnQWNJd0FCOHdxcEFBWE9DeDBWNHdBSG93QkN3d0VLQUduREFBdURBQjNEQUFqRENha0FCZElBYnFjWjNRQ1pDQ2tBQmRJQUFBRkRBQWZqQUIyakNDa0FCcUlBQ1lNQUd6TUFiU01BNXNPSUFBaGpBQWhEQUJUREJBa3BBQWJTQU9PVEFBbERDNmtPelB0bkFBZERBRzZrUUZBQVR3QUt3d3dBQTBNQUNiVURQd0FISXdBWmd3QUNFNmNEQUFvakFBcERBQW9EcC9NR3d3QUpJd0FERXdBUVF3Z0FGRU1BRVhNQUQ1TUFEZk1BRGNNQUdSTU9GaU1BRlVNQWJxTVd1d0hEQU1JQUUwTUxBR2t6RWdEaFV3QUNRd0FFV2dBWGd3VWpBQWJZQUJqREJTWUJnekJhQUVGTkFMY1FCeFVNZWdBd01uZ0JyQTBJWmdKMEt4UUhCUkVQZDFOMFp6S1JKd2FJSEFacU5UNERxUXE4QnduZ0FCNERBd3QyQVg1NlQxb2NLUU5YQWgxR0FUUUdDM3RPeFlOYWdrZ0FNUUE1Q1FBREFRRUFXeExqQUlPWU5BRXpBSDd0RlJrNlRnbFNBRjhOQUFsWUFRK1MxQUNBUXdRb3JRQmlBTjRkQUoxd1B5ZVRBTlZ6dVFEWDNBSWVFTXA5ZXlNZ1hpVUFFZGtCa0ppektsdGJWVkFhUk1xUkFBRUFoeVEvU0RFejZCbWZWd0I2QVRFc09DbEtJUmNET0YwRS84MzJBRk50NUFCeUFua0NSeEdDT3M5NE5qWGRBd0lOR0JvbkRCd1BBTFcyQXdJQ0FnQUFBQUFBQUFZREJRTURBUnJVQXdBdEFBQUFBZ0VHQmdZR0JnWUZCUVVGQlFVRUJRWUhDQWtFQlFVRkJRUUFBQUlDQUFBQUlnQ05BSkFBbFQwQTZnQzdBTndBcEVRQXdnQ3lBSzBBcUFEdUFLWUEyZ0NqQU9jQkNBRURBTWNBZ1FCaUFOSUExQUVEQU40QThnQ1FBS2tCTVFEcUFOOEEzQXNCQ1E4eU85cmEydHE4eHVMVDF0UkpPQjBCVWdGY05VMEJXZ0ZwQVdnQld3Rk1VVWxMYmhNQlV4c05FQXM2UGhNT0FDY1VLeTB2TWo1QVFFTkRRMFJGRkVZR0pGZFhWMWRaV1ZoWkwxcGJYVnhjSTJObloyWm9aeXBzYm5aMWVIaDRlSGg0ZW5wNmVucDZlbnA2ZW5wOGZIMThlMklBUlBJQVNRQ2FBSGdBTWdCbStBQ09BRmNBVndBM0FuYnZBSXNBQmZqNEFHUUFrL0lBbndCUEFHSUFaUC8vc0FDRkFJVUFhUUJXQUxFQUpBQzJBSU1DUUFKREFQd0E1d0QrQVA0QTZBRC9BT2tBNlFEb0FPWUFMd0o3QVZFQlFBRStBVlFCUGdFK0FUNEJPUUU0QVRnQk9BRWNBVmdYQURFUUNBRUFVeDhTSGdzZEhoWUFqZ0NXQUtZQVVRQnFJQUl4QUhZQWJ3Q1hBeFVESnpJRElVbEdUekVBa1FKUEFNY0NWd0trQU1BQ2xnS1dBcFlDbGdLV0FwWUNpd0tXQXBZQ2xnS1dBcFlDbGdLVkFwVUNtQUtnQXBjQ2xnS1dBcFFDbEFLVUFwUUNrZ0tWQW5VQjFBS1hBcDhDbGdLV0FwVWVBSUVUQlFEK0RRT2ZBbUVDT2g4QlZCZzlBdUlaRWpNYkFVNC9HMVdaQVh1c1JBRnBZUUVGQTBGUEFRWUFtVEVlSUpkeUFERm9BSEVBTmdDUkE1ek1rL0MyakdJTndqTVd5Z0laQ2FYZGZESUxCQ3M1ZEFFN1luUUJ1Z0RsaG9pSGhvaUdpWXFLaG91T2pJYU5rSTZJajRxUWlwR0drb2FUaHBTU2xZYVdocGVLbUlhWmhwcUdtNGFjaTUyUW5vcWZodUlDNFhUcEF0OTBBSXAwTEhTb0FJc0FkSFFFUXdSQUJFSUVSUVJEQkVrRVJnUkJCRWNFU1FSSUJFUUVSZ1JKQUo1dWRBQ3JBNDkwQUx4dUFRMTBBTkZaZEhRQTEzUUNGSFFBL21KMEFQNEJJUUQrQVB3QS9BRDlBUHdEaEdaMDNBU01LMjNIQVA0QS9BRDhBUDBBL0NSMGRBQ1JZblFBL2dDUkFTRUEvZ0NSQXZRQS9nQ1JBNFJtZE53RWpDdHR4eVIwQVA5aWRBRWhBUDRBL2dEOEFQd0EvUUQ4QVA4QS9BRDhBUDBBL0FPRVpuVGNCSXdyYmNja2RIUUFrV0owQVNFQS9nQ1JBUDRBa1FMMEFQNEFrUU9FWm5UY0JJd3JiY2NrZEFKTEFUNTBBbElCUVhRQ1U4bDBkQUpmZEhRRHBnTDBBNllEcGdPbkE2Y0Rwd09uQTRSbWROd0VqQ3R0eHlSMGRBQ1JZblFCSVFPbUFKRURwZ0NSQXZRRHBnQ1JBNFJtZE53RWpDdHR4eVIwQkRoMEFKRUVPUUNSRHBVNWRTZ0NBRFIwM2dWMkN3QXJkQUVGQU01aUNuUjBBRjFpQUFZY09ncDBkQUNSQ25RQVhBRUl3V1owQ25SbWRIUUFrV1owQ25SbWRFWGdBRkYwM2dwMGRFWTB0bFQydTNTT0FRVHdzY3doalpaS3JoWWNCU2ZGcDlYTmJLaVZET0QyYitjcGU0L1oxN21RbmJ0enpoYWVRdEUyR0dqMElETlRqUlVTeVR4eHcvUlBIVy8rdlM3ZDFOZlJ0OXo5UVBaZzRYN1FGZmhDbmt2Z05QSUl0T3NDMmVWNmhQYW5uWk5IbFo5eHJ3WlhJTU9sdTNqU29RU3E3OFdFandMancxRUxTbEYxYUJ2Znp3azVaWDdBVXZRempQUUtiRHVRK3NtNHdOT3A0QTZBZFZ1UlMwdDF5L0RacGc0UjZtN0ZOak05SGd2VzdCaTg4emFNak9vNmxNOHd0QkJkajhMUDR5bHYzekNYUGhlYk1LSmMwNjZvOXNGNzFvRlcvOEpYdTg2SEpid0RJRDVsenc1R1dMUi9MaFQwUXFucDJKUXhOWk5mY2JMSXpQeStZeXBxUm0vbEJtR21leCs4MitQaXN4VXVtU2VKa0FMSVQ2ckplenhNSCtDVEptUXR0NXV3VFZiTDNwdG1qRFVRemxTSXZXaThUbDduZzFOcHVSbjFOZzRuMTRRYyszSWlsN093a3ZOV29nTFNQa24zcGloSUZ5dHlJR21NaE9lM24xdFdzdU15OUJkS3lxRjRaM3YyU2dnZ1RMOUtWdk1YUG5DYlJlK29PdUZGUDNIZWpCRy93OWd2bWZOWXZnNkp1V2lhMmxjU1NOMXVJakJrdHpvSWF6T0hQSlo3a0tIUHo4bVJXVmRXM2xBOFdHRjlkUUY2Qm02NzNib292M0JVV0RVMkpOY2FoUjIzR3RmSEtMT3ovdmlaK3JZblpGYUl6blhPNjdDWUVKMWZYdVRScFpoWVprS2U1NHhlb2Fna05HTHMrTlRaSEUwclg0NS9YdlEyUkdBRFg2dmNBdmR4SVVCVjI3d3hHbTJ6alpvNFgzSUxnQWxyT0ZoZXVaNnd0c3ZhSWo0eUxZN3FxYXdsbGlhSWNyejJHK2MzdnNjQW5Da0N1TXpNbVp2TWZ1OWxMd1R2ZlgrM2NWU3lQZE45WndnRFpoZmpSZ05KY0xpSjY3Yjl4eDhKSHN3cHJiaUUzdjlVcGhvdEFQSWduWFZJTjVLbU1jMHBpWGhjNmNDaFBuTitNUmhHOWFkdGR0dFFUVHdTSXBsOEk0L2ovL2Qzc3oxMzI2cVRCVHBQUk0vSGdoM2t6cUVYczhaQWs0RXJRaE5POGh6clEwRExrV01BL04rOTF0bjJNZE9KbldDMkZDWmVoa1Fyd3p3YktPamh2WnNiTTk1UW9lTDlza1l5TWY0c3JWUFZKU2dnN3BPTFV0ci9uOWVUOTlvZTluTHRGUnBqQTlva1YyS2o4aDlrNUhhQzBvaXZSRDhWeVhrSjgxdGNkNGZITlhQQ2Zsb0lRYXN4c3VPMTgvNDZkUjJqZ3VsL1VJZXQyRzBrUnZueU9OTUtoSHM2SjI2RkVvcVNxZCtyZllqZUVHd0hXVkRwWDFmaDFqQkJjS0dNcVJlcGp1OVkwMG1EVkhDK1hkaWovajQ0cktmdmZqR2luTnMxak8vMEYzakI4M1hDRElOTi9IQjg0YXhsUCszRS9rbGt0Um8rdmwzVS9haXlNSmJJb2RFMVhTc0RuNlVBeklvTXRVT2JZMitrLzRnWS9sK0FrWko1U2oydlFya3lMbTNGb3hqaERYKzMxVVhCRmY5WHJBSDMxZkZxb0JtREVadmh2dnBuWjg3TitvWkV1N1U5Ty9ubmsrUVdqM3g4dXlvUmJFbmYrTzVVTXI5aTBuSFAzOElGNUF2enJCVzhZV0JVUjBtSUF6SXZuZFFxOU4zdi9KdG8zYVBqUFhVUGw4QVNkUFB5QXA3akVOZjhiazdWTU05b2w5WEdtbEJtZURNdUdxdCtXenVMNkNYQXhYakloQ1BNNXZBQ2NoZ01KLzhYQkdMTy9EMWlzVnZHaHd3SEhyMURMYUk1bW4ySnIvYjFwVUQ5MHVjaURhUzhjWE5EekNXdk5tVC9QaFFlNWU4blRubm5rdDhEcy9TSWppYmN1bS9mcURoS29weEFZOEFrU3JQbitJR0RFS09PK1UzWE9QNmRqRnMySDVOOStvcmhPYWhpUWs1S25FVVdhK0N6a1Z6aHA4Yk1IUmJnODFxaGpqWHVJS2JIalNMU0lCS1dxb2NrR3RLaW5ZK3o0L1JkQlVGNnBjYzNKbW5seFZjTmdySTRTRXpLVVpTd2NEMlFDeXh6S3ZlK2dBbWc2WnVTUmtwUEZhNm1mVGh1N0xKTnUzSDVLNDJ1Q3BOdlBBc29lZG9sS1YvTEhlL2VKK0JiYUc1TUcwTmFTR1ZQUlVtTkZNRkZTU3BYRWNYd2JWaDdVRVRPWlp0b1ZOUkdPSWJia2lnM01jRXRSNjhjRzBSWkFvSmV2V1lvN0RnL2xaMUNRemJsV2VVdlZIbXI4Zlk0TnFkOUpKaUgvekVYMjRtSnZpSDYwZkF5RnIwQTNjNGJDMWozeVpVNjBWZ0p4WG44SmdKWExVSXNpQm5tS21NWXorN3lCUUZCdnFiMmVZbnVXNTlqb1pCZjU2L3dYdldJUjRSOHdUbVY4MGkxbVp5K1M0K0JVRVMraHpqazB1WHBDLy8vei9JbHFIWjFtb256bFhwOGFDZmhHS010aTczRkkxS2JMMXE2SUtPNGZ1QnVaNTlnYWdqbjV4VTc5bXVNcEhYZzZTK2UrZ0RNL1U5QktMSGJsOWw2bzhjelFLbDRSVWtKSmlxZnRRRzJpM0JNZy9UUWxVWUZrSkRZQk9PdkF1Z1l1ellTRG5aYkREZC9hU2Q5eDBPZTZGK2JKY0hmbDkrZ3A2TDUvVGdBK0JkRkZvdmJmQ3JRNDBzNXZNUHc4ODY2cE5YOHp5RkdlRldkeElwUFZwOVJnMVVQT1ZGYkZacnZhRnEvWUF6SFFncU1XcGFoTVlmcUhwbXdYZkhMMS9rcFltR3VIRndUNTVtUXUwZHlsZk51cTJPcTBoVE1DUHdxZnhudUJJUExYZmNpNFkxQU55KzFDVWlwUXhsZC9pelZoMTZXeUcyUTBDUVE5TnF0QW54MUhDSHdEajdzWXhPU0Iwd29wWlNuT3p4UU9jRXhteHJWVEYyQmtPdGhWcEdmdWhhR0VDZkNKcEpLcGpuaWhZK3hPVDJRSnhONjErOUs2UVNxdHYyU2hyODJJM2pnSnJxQmcwd0VMRlpQanZIcHZ6VHRhSm5MSzZWYjk3WW45MzNrb08vc2FON2ZzandOS3pwNGwybEpWeDJvcmpDR3pDLzRaTDR6Q3ZlcjZhUVl0QzVzZG95Y2h1RkU2dWZPaW9nK1ZXaTVVRGtibXZtdGFoLzNhQXJFQklpMzlzNUlMVW5sRkxnaWxjR3V6OUNRc2hFWTdmdzJvdW9JTEFZUFZUL2d5QUlxM1RGQUl3VnNsK2t0a1J6L3FHZm5DREdybTVnc2wvbDlRZHZDV0dzalB6M2RVN1h1cUtmZFVyci82WElnanA0cmV5NkFKQm1DbVVKTWpJVEhWZEZiNW0xcCtkTE1DTDh0NTV6RDQyY21mdG1MRUpDMERhMDRZaVJDVlVCTExhOEQwNzEvTjVVQk5CWERoMExGc21oVi81QjVFeE9CNGozV1ZHL1MzbGZLNW8rVjZFTEh2eTZSUjluNGFjK1ZzSzRWRTR5cGhQdlYra0c5RmVnVEJINFpSWEwySHl0VUhDZHVKYXpCL0t5a2pmZXRZeE9YVEx3czI2N2FHT2QrSStKaEtQLy8rVm5YbVM5ME9EL2p2TGNWdTBhc3lxY3VZTjFtU2I2WFRsQ2txdjF2aWdaUElZd05GL3pwV2NUMUdSLzZhRUlSamtoMHloZzRMWEpmYUdvYllKVFk0Skk1OEtpQUtnbW1nQUtXZGw1bllDZUxxYXZSSkdRTnVZdVp0WkZHeCtJa0k0dzROUzJ4d2JldE5NdW5PakJ1L2htS0NJL3c3dGZpaXlVZC8vNHJiVGVXdDRpekJZOFl2R0lONnZ5S1ltUC84WDh3SEtDZU4rV1JjS003MCt0WEtOR3lldlU5SDJEZzVCc2xqblRmOFlic0oxVG1Nczc0Q2UyWGxIaXNsZWd1aHllZzQ0clFPSFp1dy82SFRraG5udXJLMmQ2MnE2eVM3MjEwU3NBSWFSK2pYTVFBK3N2a3JMcHNVWStGMzBVdzg5dU9kR0FSNnZvNEZJTUUwRWZWVmVIVHU2ZUtpY2ZoU3FPZVhKaGJmdGNkMDhzV0VuTlVMMUM5Zm5wclRnZDgzSU11dDhvblZVRjBodnF6WmZIZHVQamJqd0VYSWNvWW15K1A2dGNKWkhtZU92NlZydkVka0hESmVjakh1SGVXQU5lNzlWRzY2MnFUakEvSEN2dW1WdjNxTCtMck9jcHFHcHMyWkd3UWRGSjdQVTRpdXlSbEJyd2ZPK3huUHlyNDdzMmNYVmJXekF5em5EaUJHakNNM2tzeGpqcU02MkdFOUM4ZjVVMzhrQjNWanRhYktwL25SZHZNRVNQR0RHOTBiV1JMQXQxUWs1RHlMdWF6UlIxWXpkQzFjK2haWHZBV1Y4eEE3MlM0QThCNjd2alZoYmJhM01Nb3AyOTNGZUVYcGU3ekl0TVdySkcvTE9IOUJ5T1htWW5OSmZqbWZ1WDlLYnJwZ0xPYmE0blorZmw4R2Jkdi9paHYrNndGR0tIQ1lyVndtaEZDMEozVjJibjJ0SUIxd0NjMUNTVDNkM1gyT3l4aGd1WGNzNHNtNjc5VW5nem9mdVNlQmV3TUZKYm9JUUhiVWgvbTJKaFcyaEc5REl2RzJ0N3laSXpLQlR6OXdCdG5OQysycENSWWhTSXVRMWo4eHN6NVZ2cW55VUl0aHZ1b3l5dTdmTklyZy9LUVVWbUdRYXFrcVprL1Z4NWIzMy9nc0VzOHlYN1NDMUorTlY0aWN6NmJ2SUU3QzVHNk1jQmFJOHJWZzU2cTVRQkpXeG4vODdRMXNQSzQrc1FhOGZMVTVnWG80cGFhcTRjT2NRNHdSMFZCSFBHaktoK1VsUENiQTFuTFh5RVVYNDVxWjhKNy9MbjRGUEpFMlRkekQwWjhNTFNOUWl5a01NbVN5T0NpRmZ5ODRScTYwZW1ZQjJ2RDA5S2pZd3NvSXBlRGNCRFRFbEJiWHhORDcyeWhkOXBDLzFDTWlkLzVIVU12QUwyN090Y0lKRHpOS3BSUE5xUE9weXQyYVBHejlRV0lzOWhROUxpWDVzOG05aGpUVXUvZjdNeUlhdGpqZCt0U2ZRM3VmWnhQcG1KaFRhQnRadEtMVWNmT0NVcUFEdU8rUW9IOEI5djZVK1AwSFYxR0xRbXRvTkZUYjNzNzRpdlpnakVTMHFmSys4UmRHZ0JiY0NNU3k4ZUJ2aDk4K2V0MUtJRnFTZTFLUVB5WFVMQk1Uc0lZbnlzSXdpWkJKWWRJMjB2c2VWK3d1SmtjcUdlbWVoS2phQWI5TDU3eFptM2cyelgwYloyeGsvZlUrYkNvN1RsbmJXN0p1RjFZZFVSby8yR3c3VmNsREcxVzdMT3RhczJMWDR1cGlmWi8yM3J6cHNuWS9BTGZSZ3JjV1A1aFltVjlWeFZPUUExZlp2cDlGMlVOVSs3ZDd4UnlWbTV3aUxwMy8wZGxWN3ZkdzFQTWlacmJEQVl6SVZxRWpSWTJZVTAzc0poUG5sd0lQY1pVRzVsdEw2UzhYQ3hVMWVZUzVjanIzNHZlQm1YQXZ5N3lONFpqQXJJRzBkZkQvNVVwQk5sWDFaUG94Sk93eXFSaTN3UVd0T3pkNG9OS2gwTGtvVG04Y3dxZ0lmS2hxcUdPaHdvNzFJK3pYbk1lbVR2MkIyQVV6QUJXeUZ6dEdnR1VMakREeldZd0pVVkJUaktDbjVLMlFHTUsxQ1FUN1N6emlPam8rQmhBbXFCanp1YzN4WXltMmVlZEdlT0lSSlZ5VHdEdzM3aUNNZTRnNVZibnNiNVpCZHhPQW5NVDdIVTRESHB4V0d1UTdHZWlZMzBDcGJ2enNzNTUrNUttMVlzYkQ1ZWEzTkk5UU5ZSVhvbDVhcGdTdTlkWjhmOHhTNWR0SHBpZG81QmNsRHVMV1k0bGhpazB0YkphMDd5SmhIMEJPeUV1dC9HUmJZVFM2UmZpVFlXR01Da05wZlNIaTdIdmRpVGdsRVZIS1pYYVZoZXpINGtrWGlJdktvcFlBbFB1c2Z0cEU0YTVJWnd2dzF4L2VMdm9ESWgvenBvOUZpUUluc1RiMlNBa0tIVjQyWFlCanBKRGc0Mzc0WGlWYjN3czRxTTBzOWVTUTVIenNNVTRPWkpLdW9wRmpCTStkQVpFbDhSVU14NXVVMk40ODZLcjE0MXRWc0dRZkdqT1JZTUNKQU1zeEVMZU5UNFJtV2pSY3BkVEdCd2N4NlhOOWRyV3FQbUp6Y3JHckg0K0RSYzcrbjF3M2tQWnd1MEJrTnI2aFFycWdvN0pUQjlBNWtkSi9IN1A0Y1dCTXdzbXVpeEF6SkIzeXJRcG5HSXE5MGx4QVhMekRDZG4xTFBpYnNSdDdySE5qZ1FCa2xSZ1BaOHZUYmpYZGdYclRXUXNLNU1kclhYUVZQcDBSaW5xM2ZyelpLSjBxRDZRaGM0MFZ6QXJhVVhsb2IxZ3ZraEszdnBtSGdJNkZSbFFaTng2ZVJxa3Awenk0QVFsWDgxM2ZBUHRMM2pNUmFpdEdGRmpvMHptRXJsb0MraCtZWWRWUTZrNEYvZXB4QW9GMEJtcUVvS05UdDZqNHZRWk5RMkJvcUY5Vmo1M1RPSW9ObURpdTlYcDE1UmtJZ1FJR2NvTHBmb0liZW56cEdVQXRxRkpwNVcrTExueDM4akhlRUNUSi9uYXZLWTFOV2ZOMHNZMVQ4L3BCOGtJSDNEVTNEWCt1NlczWXdweXBCTVlPaGJTeEdqcTg0Ulo4NGZXSm93OHB5SHFuNFMvOUoxNUVjQ01zWHFyZnd5ZDltaGl1MytyRW85cFBwb0prZFpxSGpyYTROdnpGd3VUaE5LeTZoYW8vU2xMdzNaQURVY1VwM3czU1JWZlcycmhsODB6T2dUWW5LRTBIczJxcDFKNkgzeHFQcUlrdlVEUk1GRFl5UmJzRkkzTTlNRXlvdlBrOHJsdzcvMGE4MWNEVkxtQnNSMnplMnBCdUtiMjNmYmVaQzB1WG9JdkRwcGZUd0lEeGsxT3EyZEdlc0djK29KWFdKTEdrT2hhM0NYK0RVbnpnQXA5SEdIOVJzUFpONjNIbjRSTUE1ZVNWaFBITys5UmNSYi9JT2d0VzMxVjFRNUlQR3RveFBqQytNRUpiVmxJTVlBRGQ5YUhZV1VJUUtvcHVQT0htb3FTa3VibkFLbnpnS0hxZ0lPZlc1UmRBZ290TjZCTitPMlpZSGt1ZW1MbnZROFU5VEhWclMxUnRMbUtiY0M3UGVlRHNZem52cXplZzZWQ053bXIwWXl4MXduTGp5VDg0Qlp6M0VKeUNwdEQzeWV1ZUF5RFdJczBMMnFzL1ZRM0hVeXFmcmphMFYxTGREenFBaWtlV3VWNHNjN1JMSUI2OWpFSUJqQ2t5WmVkb1VIcUNyT3ZTaFZ6eWQ3M09kckpXMGhQT3VRdjJxT29IRGM5eFZiNll1NnVxM1hxcDJaYUg0NkE3bHpldmJ4UUVtZnJ6dkFZU0p1WjRXRGsxSHozUVgxTFZkaVVLMEV2bEFHQVlsRzNNZDMwcjdkY1BONjN5cUJDSWoyNXBycHZaUDBuSTQrRWdXb0ZHOTVWNTk2Q3VyWHBLUkJHUmpRbEhDdnk1SWIvaVc4blpKV3dyRVQzbWdkNm1FaGZQNEtDdWFMam9wV3M3aCtNZFhGZEl2OGRIUUpnZzF4aTFlWXFCMHVEWWp4d1ZtcmkwU3Y1WEt1dC9vbnFhcEMrRlFpQzJDMWx2WUo5TVZjbzZ5RFlzUzNBQU5VZk10dnRiWUkyaGZ3WmF0aVNzbm9VZU1aZDM0R1Zqa01NS0ErWG5qSnBYZ1JXMlNIVFpwbFZvd1BtSnN2WHk2dzNjZk8xQUsyZHZ0WkVLVGtDL1RZOUxGaUtIQ0cwRG5yTVFkR20ybHpsQkhNOWlFWXluSDJVY1ZNaFVFanNjMG9EQlRnbzJaU1ExZ3prQUhlV2VCWFlGallMdXVmOHl6VEN5Ny9SRlI4MVdEalhNYnEyQk9INWRVUm54bzZvaXZteEwzY0t6S0lubFprRDMxbnZwSEI5S2s3R2ZjZkUxdCsxVjY0YjlMdGdlSkdscFJGeFFDQXFXSjVEb1k3N3NraThnc09FT3IydXl3WmFvTy9OR2EwWDB5MXBOUUhCaTNiMlNVR05wY1p4RFQ3ckxiQmYxRlNuUThndXhHVzNXKzM2QlcwZ0JqZTRET3o2QmE2U1ZrMHhpS2d0K3EySk9GeXI0U1lmbnUrSWMxUVpZSXV3SEJyZ3pyNlV2T2NTQ3pQVE9vN0Q2SUM0SVNlUzd6a2w0aCsyVm9lSHBuRy91V1IzK3lzTmdQY09JWFFidjBuNG1yM0J3UWNkS0p4Z1BTZXl1UC96MUpqZzRlOW5Vdm9YZWdxUVZJRTMwRUh4NUdIditGQVZVTlRvd1lESmd5RmhmNUl2bFltRXFSaWY2K1dOMU1rRUptRGNRSVR4OUZYMjNhNG14eTFBUVJzT0hPLytlSW1YOWw4RU1KSTNvUFd6Vlh4U09lSFUxZFVXWXIydUFBN0FNYit2QUVaU2JVM3FvYjlpYkN5WGV5cEVNcFo2ODYzbzZRUHFscUdIWmt1V0FCU1RWTmQ0Y09oOWh2M3FFcFN4Mlp5L0RKTVA2Y0l0RW1pQko1UEZxUW5ERUl0M05yQTNDT2xPU2d6NDNEN2dwTkZOSjVNQmg0b0Z6aERQaWdsQzJ5cHNOVTRJU3l3WTJlcmt5YjFOQzNRaC9JZldqMGVEZ1pJNC9sbjhXUGZCc1QzbWVUanExVXF0MUU3WmwvcWZ0cWt4NmFNOUt1ZU1DZWtTbk1yY0hqMUNxVFdXekV6UHNaR2NEZTNVZTRXcytYRllWeE5iT0ZGOGV6a3ZRR1I2Wk90T0xVMmxRRW5NQlN0eDQ3dkU2UGI3QVlNQlJqMk9PZlpYZmlzakpucFRmU05qbzZzWjZxU3ZOeFpObURlUzdHazN5WXlDazFIdEtOMlVuaE1Jak9YVXpBcUR2OTBseDlPL3EvQVQxWk1uaXQ1WFFlOXdtUXhuRS9XU0gwQ3FaOS8ySHkrU2ZtcGVnOFJ3c0hJNVo4a0M4SDI5M20vTEhWVk0vQkE3SGFUSllnNUVuazdNL3hXcHEwMTkyQUNmQmFpMkxBL3FyQ2pDcjZEaDFCSU16TVhJTkJtWDk2TUo1SG4ybnhsbi9SWFBGaHdIeFVtU1YwRVYyVjBqbTg2L2R4eHVZU1UxVzdzVmtFYk45RXprRzBRRndQaHlIS3liM3QrRmo1V29VVVRFcmNhekUvTjZFVzZMdnAwZC8vU0RQajdFVjlVZEpOK0FtbmYzV3drM0EwU2xKOVowMHl2WFo3bjN6NzBHNDdIZnNvdzhXcTFKWGNmd25BK1l4YTVtRnNnVjQ2NEtLUDRUMzF3cUlnekZQZDNlQ2UzajVvcnk1ZkJGMmhnQ0Z5VkZyTHpJOWVldE5Ydk03b1FxeUZnRG80Q1RwL2hEVjlOTVg5SkRIUS9ueUhUTHZaTE5MRjZmdG4yT3hqR204K1BxT3doeG5QSFdpcGtFLzh3YnR5cmk4MFNyN3BNTmtRR01mbzRaWUs5T2NDQzRFU1ZGRmJMTUl2bHhTb1JxV2llMHd4cW5MZmNMU1hNU3BNTVFFSllEVk9iWXNYSVFOdjRUR053anExa3ZUMVVPa2ljVHJHM0lhQlozWGRTY1MzdThzZ2VaUFZwT0xrYmlGOTQwRmpiQ2VOUklOTnZEYmQwMUVQQnJUQ1BwbTEybTQzemUxYkJCNTlJYTZPdmhudXIvTnZ4M0l4d1NXb2wrM0gycWZDSlI4ZGY2YVFmNHY2V2lPTnhrSytJcVQ0cEtRclpLL0xwbGdESS9QSlpiT2VwOGR0YlY3b0NyNkNnZnBXYThOY3pPa1B4ODFpU0hic05oVlNKQk90ckxJTXJMMzFMSzlUcUhxQWJBSGUwUkxtbVY4MDZrUkxETE5FaFVFSmZtOXUwc3hwa0w5M1pnZDZydyt0cUJmVE1pNTl4cVhITFhTSHdTYlNCbDBFSzArbG9FQ09QdHJsKy9uc2FGZTE5N2RpNHlVZ29lNGpLb0FKRFhjNkRHRGpyUU9vRkRXWko5SFh3dDh4RHJRUCs3YVJ3V0tXSTFHRjhzOE80S3p4V0JCY3dubDN2bmwxT2V6M29oNkVhMXZqUjcvejdERFRyRnRxVTJXL0tBRXpBdVhETlo3TVk3M01GMjE2ZHpkU2JXbVVwNGxjbTdrZUpmV2FNSGd1dDl4NUM5bWo2NlowbEoreWhzalZ2eWlXcmZrMWx6UE9UZGhHMTVZN2dRbFh0YWN2STdxdi9YTlNzY0R3cWtnd0hUL2dVc0Q1eUI3TGRSUnZKeFFHWUlObjloVHBvZEtGVlNUUHJ0R3Z5UXcrSGxSRlhJa29kRXJBR3U5SXkxWXBmU1BjM2prRmg1Q1gzbFB4djdhcWpFL0pBZlRJcEVqR2IvSDdNTzBlMnZzVmlTVzFxYS9MbWk0L240REVJM2c3bFlyY2Fuc3BEZkVwS2tkVjFPalNMT3kwQkNVcVZvRUNhQjU1dnMwNnJYbDRqcW1Mc1BzRk0vN3ZZSjB2ckJoRENtLzAwQS9IODFsMXVla0ovNkxtbDNIYjkrTktpTHFBVEptRHB5emZZWkZIdW1FakM2NjJMMEJ3a3hpN0U5VTRjUUEwWE1WRHVNWUFJZUxNUGdRYU1WT2Q4Zm10NVNmbEZJZnVCb3N6ZUF3N293NWdYUEUyWS95QmMvN2pFeEFSVWYvQnhJSFFCRjVTbjNpNjF3NHo1eEpkQ3lPMUYxWDMrM2F4K0pTdk1lWjdTNlFTS3AxRnAvc2pZejZaK1ZnQ1p6aWJHZUVvdWpyeWZNdWxIN1JhaTVrQWZ0OWViY1c1MER5SnIydW8yejk3bVRXSXU0NVlzU25OU01yck5VdUcxWHNZQnREOVREWXpRZmZLQjg3dldia000RWJQQUZnb0JWNEdRUyt2dEZEVXFPRkFvaTFuVHRtSU92ZzM4TjRoVDJTbjhyOGNsbUJDWHNwQmxNQllUbnJxRkpHQlQzd1pPekF5SkRyZTlkSEg3K3g3cWFhS0RPQjRVUUFMRDVlY1MwREU0b2J1YlFFaXVKWjBFcEJWcEx1WWNjZThBYTRQWWQvVjRETERBSkJZS1FQQ1dUY3JFYVo1SFliSmkxMUdkNmhqR29tMWlpMThWSFluRzI4Tktwa3oyVUtWUHhsaFlTcDh1WnIzNjdpT21veTd6c3hlaFc5d3pjeTJ6RzBhODBQQk1DUlFNYjMyaG5hSGVPUjhmbk5EelpoYU5ZaGtPZERzQlVaM2xvRE1hMVlQMHVTMGNqVVAzYi82REJscW1aT2VOQUJEc0xsNUJJNVFKdXBzOHV4QXVXSmRrVUIvcE82WmF4NnRzZzdmTjVtampEZ01HbmdPK0RQY0txaUhJRGJGSUd1ZHh0UFRJeURpOVNGTUtCRGNmZEdRUnY0MXExQXFteGdrVmZKTW5QOHcvQmM3TjkvVFI2QzdtR09iRnFGa0lFb204c0tpMnhZcUpMVENISzdjeHphWnZxT0RvMjJjM3dpc0JDUDRIZUFnY1JiTlBBc0JrTlJoU21ENDhkSHVwZEJSdzRtSXZ0UzVvZUY2emVUMUtNQ3loTW5taHBrRkFHV25Hc2NvTmt3dlE4Wk01bEUvdmdUSEZZTDk5T3VOeGRGQnhURURkNXYycUxSOHk5V2tYc1dnRzZrWk5uZEZHK3BPL1VBa09DaXBxSWhMM2hxN2NSU2RyQ3E3WWhVc1RvY0VjbmFGYTZuVmtoblNlUllVQTFZTzB6NWl0RjlTbHkzVmx4WUR3MjM5VEpKSDZmM0VVZllPNWxiN2JjRmN6OEJwN09vOFFtbnNVSE96L2ZhZ1ZVQnRLRXcxaVQ4OGorYUtrdjhjc2NLTmtNeGpZcjgzNDREMWtGb1o3L3RkMVc2TENOWU41OTQzMDF0VUdSbUZqQXplUmc1dnlvTTFGNitiSlovUTU0ak4vazhTRmQzRHhQVFlhQVVzaXZzQmZnVG43TXg4SDJTcFB0NEdPZFlSbkVKT0g2akhNMnA2U2dCMGd6SVJxNmZIeEdNbVNtcWFQQ21sZnd4aXVsb2FWSWl0TEdOOHdpZTJDRFdoa3pMb0NKY09EaDdLSU9BcWJIRXZYZFV4YVM0VFRUczA3Q2x6ai82R21WczlraVpEZXJNeEVuaFVCNlFRUGxjZnFrRzk4ODJScUhvTGlIR0JvSGZRdVhJc0FHOEdUQXRhbzJLVndSbnZ2YW04am8xZTMxMkdRQUtXRWE0c1VWRUFNRzRHNmNrY09ORHdSY2cxZTJEMytvaFhnWTRVQVdGOHdIS1FNclNuekNnZkZwc3hoK2FIWE1HdFBRcm9RYXNSWTRVNlVkRzByejFWamJrYTBNZWtPR1JaUUV2cVFGbHhzZUZvcjh6V0ZnSGVrM3YyOStXcU42Z2FLNWdaT1RPTVp6cFFJQzEyMDFMa01DWGlsZDN2V1hTYzVVWDl4Y0ZZZmJSUHpHRmExRkRjUGZQQi9qVUVxL0ZlR3Q0MTlDSTNZbUJsVm9Ic2E0S2Rjd1FQNVpTd0hIaEZKNy9QaC9SYXAvNHZtRzkxZUR3UFAwbERmQ0RSQ0xzelRxZnpNNzF4cG1pS2kySHdTNFdscXZHTnd0dndGNURxcG42S1RxOGF4MDBVTVBreERjWnJFRUVzSXZIaVVYWEVwaGRiNEdCNEZ5bWxQd0J6NEdwZXJxcTVwVzdUUTYveU5SaFc4VlQ1Tmh1UDB1ZGx4bzRnSUxxNVp4QVprOFpHaDNnNENxeEpsUEtZN0FReHVwZlVjVnBXVDVWSXRwMSszMFVxb3lQNHdXc1JvM29sUlJna1daWjJaTjZWQzNPWkZlWEI4TmJuVXJTZGlrTnB0RDFRaUd1S2tyOEVtU1IvQUs5UncrRkYzczV1d3VQYnZIR2lQZUZPVmlsdE1LN0FVYU9zcTkreDljbmRrM2lKRUU1TEtaUmxXSmJLT1p3ZVJPem1QTlZQa2pFM0svVHlBNTdSczY4VGtaM01SOGFrS3BtN2NGam5qUGQvRGRrV2pnWW9LSFNyNVd1NXNzb0JZVTRhY1JzNWcyREh4VW1kcThWWE9YUmJ1bkQ4UU4wTGhna3NzZ2FoY2RvWXNOdnVYR1VLL0tYRC83b0ZiK1ZHZGhxSW4wMnZldU01Ykx1ZEpPYzJLeTBHTWFHNFcveFdCeElKY0w3eWxpSk9YT3B4MEFrQnFVZ3psRGN6bUxUNGlJTFhEeHh0UlIxb1phMkpXRmdpQWI0M29ickpuRy9UWkMyS1NLMndxT3pSWlRYYXZaWkZNYjFmM2JYdlZhTmFLODI4dzlUTzYxMGdrOEpOZjNnTWZFVHpYWHNiY3ZSR0NHOUpXUVo2K2NEUHFjNDQ2NllvMlJjS0grUElMZUtPcXRubGJJblIzTW1CZUdHM0ZIMTB5emt5YnVxRUMySFNRd3BBMEFuN2Q5KzczQmtEVVRtMzBiWm1vUC9SR2JnRk4rR3JDT2ZBRGdxcjBXYkkxYTFva3BGbXM4aUhZdzlobTB6VXZsRU1pdkJSeE1vZHJiSkorOS9wM2pVZFFROUJDdFFkeG5PR3JUNWR6UlVtdzA1OTMvbWJSU2RCZzBuUnZSWk01L0UxNm03WkhtREV0V2h3dmZkWkNaOEo4TTEyVzB5Uk1zelhhbVdmUVR3SVo0YXlZa3RybnNjUXVXcjhpZHAzUGpUMmVGL2ptdGRoSWZjcE1uYitJZlpZMkZlYlc2VVkvQUszalA0dTNUdTR6RTRxbG5RZ0xGYk0xOUVCSXNOZjdLaGpkYnFRL0Q2eWlEYitObEVpMlNLRCtpdlhWVUs4aWIwb0JvMzY2Z1hrUjhaeEdqcEpJRGNFZ1pQYTlUY1llMFRJYmlQbC9yUFVRRHUzWEJKOVgvR05xM0ZBVXNLc2xsNTdEemFHTXJqY1QrZ2N0cCs5TUxZWENxK3NxUDgxZVZRMHI5bHQrZ2NRZlpiQUNSYkVqdmxNc2t6dFpHOGdiQzhRbjl0dDI2UTd5N25EcmJacS9MRXo3a1I2SmM2cGczTjlyVlg4WTVNSnJHbE1MOXA5bFU0amJUa0txQ3ZlZVpVSmpIQjAzbTJLUktSMlR5dG9Ga1RYT0xnN2tlVTFzMWxyUE1RSnBvT0tMdUFBQyt5MUhsSnVjVTZ5c0I1aHNYaHZTUFBMcTVKN0p0bnFIS1o0dllqQzRWeTgxNTNRWSs2NzgweER1R0FSc0diT3MxV3F6SDBRUzc2NXJuU0tFYmJLbGtPOG9JL1ZEd1VkMGlzMTN0S3BxSUx1MW1ESkZOeS9pSkFXY3ZEZ2p4dnVzSVQrUEd6M1NUL0o5cjlNdGZkMGpwYUdlaUxZSXFYYzdEaUhTUzhUY2pGVmtzaTY2UEVreFcxejZ1amJMTFVHTk5ZbnpPV3BIOEJaR0s0YkNLN2lSK01iSXY4bmNEQXoxdTRTdE4zdlRUemV3cjlJUWprOXd4RnhuKzZOMWRkS3MwdmZmSmlTMDhOM2E0RzFTVnJsWjk3US9NKzhHOWZlNUFQNmQ5L1FxNFdSbk9SVmhvZlBJS0VkQ3IzbGxzcFVmRTBvS0lJWW9CeUJSUGgrYlgxSExTM0pXR0pSaEl2RTFhVzROVGQ4ZVBpNFora1hiK1o4c25ZZlNOY3FpamhBZ1ZzeDRSQ001NGNYVWlZa2plQm1tQzRhak9IckNob0VMc2NKSkM3Kzlqak1qdzVCYWdaS2xnUk1pU05ZejdoN3Z2WklvUXFidFFtc3BjMGNVazFHLzczaVh0U3BST2w1d3RMZ1FpMG1XMkV4OGkzV1VMaGNnZ3g2RTFMTVZIVXNkYzlHSEkxUEgzVTJLbzBQeUdkbjlLZFZPTG03RlBCdWkwaTlhMEhwQTYwTXNld1ZFNHo4Q0F0NWQ0MDFHdjZ6WGxJVDVZYml0MVZJQTBGQ3M3d3R2WXJlcnUxZlV5VzNvTEFaLythVG5ack9jWVJOVkE4c3BvUnRsUm9XZmxzUkNsRmNnemtxaUhPcmYwL1NWdytFcFZhRmxKMGc0S3hxMU1NT21pUWRwTU5wdGU4bE1NUXFtNmNJRlhsbkdiZkpsbHlzS0RpKzBKSk1vdGtxZ0l4T1NRZ1U5ZG4vbFdrZVZmOG5VbTNpd1gyTmwzV0R3OWk2QVVLM3ZCQWJaWnJjSnBEUS9ONjRBVndqVDA3SmVmMzBHU1NtdE51MldsVzdZb3lXMkZsV2ZaRlFVd2s4NjdFZExZS2s5Vkc2SmdFbkJpQnhrWTdMTW80WUxRSkpsQW85bC9vVHZKa1NBUkRGL1h0eUF6TThPMnQzZVQvaVhhNndETjNXZXdObVFIZFBmc3hDaFUvS3RMRzJNbjhpNFpxS2RTbElhQlphZHhKbVJ6VlMvbzR5QTY1UlRTVmlxNjBvYTM5NUxxdzBwelk0U2lwd0UwU1hYc0tWK0dacmFHU2tyL1JXMDh3UFJ2cXZTVWtZQk1BOWxQeDRtMjRheitJSG1DYlhBKzBmYXhUUkU5d3VHZU8wNkRJWGE2UWxLSjNwdUl5aXVBVmZQcjczNnZ6bzJwQmlyUytWeGVsM1RNbTNKS2h6OW8yWm9SdmFGVnBJa3lrYjBIY200b0hGQk1jTlNOajcvNEdKdDQzb2dvblkyVmc0bnNEUUlXeEFjb3JwWEFDemdCcVFQallzRS9WVXBYcHdOTWFuRXJ1NE53TUNGUGtYdk1vcXZvZUxOM3F5dS9OMWVXRUh0dE1ENjV2MTlsLzBrSDJtUjM1aXYvRkkreWpvSEo5Z1BNejY3YWYzTXEvQm9XWHF1M3JwaGlXTVhWa21uUFNFa3BHcFVJMmgxTVRoaWRlR0ZFT0s2WVpIUHdZek1CdnBOQzcrWkh4UGI3ZXBmZWZHeUlCNEp6TzlEVE5FWW5ETFZWSGRReXZPRVZlZnJrNlV2NWtUUVlWWVdXZHFyZGNJbDd5bGp3d0lXZGZRL3krMlFCM2VSL3F4WU9idVl5QjRnVGJvMmluNFB6YXJVMXNPOW5FVGttajkvQW94REErSk0zR01xUXRKUjRqdGR1SHRub0NMeGQxZ1FVc2NIUkIvTW9SWUlFc1AycERaOUt2SGd0bGsxaVRiV1diSGhvaHdGRVlYN3k1MWZVVjJudVVtbm9VY3FuV0lRQUFnbDlMVFZYK0JjMFFHTkVoQ2h4SFI0WWpmRTUxUFVkR2ZzU0ZFNmNrN0JMMy9oVGY5akxxNEcxSWFmSU54T0xLZUF0TzdxdXVsWXZINVlPQmMrelg3Q3JNZ1duVzQ3L2pmUnNXbkpqWVlvRTd4TWZXVjJITjJpeUlxTEknO1xuY29uc3QgRkVOQ0VEID0gbmV3IE1hcChbWzgyMTcsXCJhcG9zdHJvcGhlXCJdLFs4MjYwLFwiZnJhY3Rpb24gc2xhc2hcIl0sWzEyNTM5LFwibWlkZGxlIGRvdFwiXV0pO1xuY29uc3QgTlNNX01BWCA9IDQ7XG5cbmZ1bmN0aW9uIGRlY29kZV9hcml0aG1ldGljKGJ5dGVzKSB7XHJcblx0bGV0IHBvcyA9IDA7XHJcblx0ZnVuY3Rpb24gdTE2KCkgeyByZXR1cm4gKGJ5dGVzW3BvcysrXSA8PCA4KSB8IGJ5dGVzW3BvcysrXTsgfVxyXG5cdFxyXG5cdC8vIGRlY29kZSB0aGUgZnJlcXVlbmN5IHRhYmxlXHJcblx0bGV0IHN5bWJvbF9jb3VudCA9IHUxNigpO1xyXG5cdGxldCB0b3RhbCA9IDE7XHJcblx0bGV0IGFjYyA9IFswLCAxXTsgLy8gZmlyc3Qgc3ltYm9sIGhhcyBmcmVxdWVuY3kgMVxyXG5cdGZvciAobGV0IGkgPSAxOyBpIDwgc3ltYm9sX2NvdW50OyBpKyspIHtcclxuXHRcdGFjYy5wdXNoKHRvdGFsICs9IHUxNigpKTtcclxuXHR9XHJcblxyXG5cdC8vIHNraXAgdGhlIHNpemVkLXBheWxvYWQgdGhhdCB0aGUgbGFzdCAzIHN5bWJvbHMgaW5kZXggaW50b1xyXG5cdGxldCBza2lwID0gdTE2KCk7XHJcblx0bGV0IHBvc19wYXlsb2FkID0gcG9zO1xyXG5cdHBvcyArPSBza2lwO1xyXG5cclxuXHRsZXQgcmVhZF93aWR0aCA9IDA7XHJcblx0bGV0IHJlYWRfYnVmZmVyID0gMDsgXHJcblx0ZnVuY3Rpb24gcmVhZF9iaXQoKSB7XHJcblx0XHRpZiAocmVhZF93aWR0aCA9PSAwKSB7XHJcblx0XHRcdC8vIHRoaXMgd2lsbCByZWFkIGJleW9uZCBlbmQgb2YgYnVmZmVyXHJcblx0XHRcdC8vIGJ1dCAodW5kZWZpbmVkfDApID0+IHplcm8gcGFkXHJcblx0XHRcdHJlYWRfYnVmZmVyID0gKHJlYWRfYnVmZmVyIDw8IDgpIHwgYnl0ZXNbcG9zKytdO1xyXG5cdFx0XHRyZWFkX3dpZHRoID0gODtcclxuXHRcdH1cclxuXHRcdHJldHVybiAocmVhZF9idWZmZXIgPj4gLS1yZWFkX3dpZHRoKSAmIDE7XHJcblx0fVxyXG5cclxuXHRjb25zdCBOID0gMzE7XHJcblx0Y29uc3QgRlVMTCA9IDIqKk47XHJcblx0Y29uc3QgSEFMRiA9IEZVTEwgPj4+IDE7XHJcblx0Y29uc3QgUVJUUiA9IEhBTEYgPj4gMTtcclxuXHRjb25zdCBNQVNLID0gRlVMTCAtIDE7XHJcblxyXG5cdC8vIGZpbGwgcmVnaXN0ZXJcclxuXHRsZXQgcmVnaXN0ZXIgPSAwO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgTjsgaSsrKSByZWdpc3RlciA9IChyZWdpc3RlciA8PCAxKSB8IHJlYWRfYml0KCk7XHJcblxyXG5cdGxldCBzeW1ib2xzID0gW107XHJcblx0bGV0IGxvdyA9IDA7XHJcblx0bGV0IHJhbmdlID0gRlVMTDsgLy8gdHJlYXQgbGlrZSBhIGZsb2F0XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB2YWx1ZSA9IE1hdGguZmxvb3IoKCgocmVnaXN0ZXIgLSBsb3cgKyAxKSAqIHRvdGFsKSAtIDEpIC8gcmFuZ2UpO1xyXG5cdFx0bGV0IHN0YXJ0ID0gMDtcclxuXHRcdGxldCBlbmQgPSBzeW1ib2xfY291bnQ7XHJcblx0XHR3aGlsZSAoZW5kIC0gc3RhcnQgPiAxKSB7IC8vIGJpbmFyeSBzZWFyY2hcclxuXHRcdFx0bGV0IG1pZCA9IChzdGFydCArIGVuZCkgPj4+IDE7XHJcblx0XHRcdGlmICh2YWx1ZSA8IGFjY1ttaWRdKSB7XHJcblx0XHRcdFx0ZW5kID0gbWlkO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YXJ0ID0gbWlkO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAoc3RhcnQgPT0gMCkgYnJlYWs7IC8vIGZpcnN0IHN5bWJvbCBpcyBlbmQgbWFya1xyXG5cdFx0c3ltYm9scy5wdXNoKHN0YXJ0KTtcclxuXHRcdGxldCBhID0gbG93ICsgTWF0aC5mbG9vcihyYW5nZSAqIGFjY1tzdGFydF0gICAvIHRvdGFsKTtcclxuXHRcdGxldCBiID0gbG93ICsgTWF0aC5mbG9vcihyYW5nZSAqIGFjY1tzdGFydCsxXSAvIHRvdGFsKSAtIDE7XHJcblx0XHR3aGlsZSAoKChhIF4gYikgJiBIQUxGKSA9PSAwKSB7XHJcblx0XHRcdHJlZ2lzdGVyID0gKHJlZ2lzdGVyIDw8IDEpICYgTUFTSyB8IHJlYWRfYml0KCk7XHJcblx0XHRcdGEgPSAoYSA8PCAxKSAmIE1BU0s7XHJcblx0XHRcdGIgPSAoYiA8PCAxKSAmIE1BU0sgfCAxO1xyXG5cdFx0fVxyXG5cdFx0d2hpbGUgKGEgJiB+YiAmIFFSVFIpIHtcclxuXHRcdFx0cmVnaXN0ZXIgPSAocmVnaXN0ZXIgJiBIQUxGKSB8ICgocmVnaXN0ZXIgPDwgMSkgJiAoTUFTSyA+Pj4gMSkpIHwgcmVhZF9iaXQoKTtcclxuXHRcdFx0YSA9IChhIDw8IDEpIF4gSEFMRjtcclxuXHRcdFx0YiA9ICgoYiBeIEhBTEYpIDw8IDEpIHwgSEFMRiB8IDE7XHJcblx0XHR9XHJcblx0XHRsb3cgPSBhO1xyXG5cdFx0cmFuZ2UgPSAxICsgYiAtIGE7XHJcblx0fVxyXG5cdGxldCBvZmZzZXQgPSBzeW1ib2xfY291bnQgLSA0O1xyXG5cdHJldHVybiBzeW1ib2xzLm1hcCh4ID0+IHsgLy8gaW5kZXggaW50byBwYXlsb2FkXHJcblx0XHRzd2l0Y2ggKHggLSBvZmZzZXQpIHtcclxuXHRcdFx0Y2FzZSAzOiByZXR1cm4gb2Zmc2V0ICsgMHgxMDEwMCArICgoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgMTYpIHwgKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDgpIHwgYnl0ZXNbcG9zX3BheWxvYWQrK10pO1xyXG5cdFx0XHRjYXNlIDI6IHJldHVybiBvZmZzZXQgKyAweDEwMCArICgoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgOCkgfCBieXRlc1twb3NfcGF5bG9hZCsrXSk7XHJcblx0XHRcdGNhc2UgMTogcmV0dXJuIG9mZnNldCArIGJ5dGVzW3Bvc19wYXlsb2FkKytdO1xyXG5cdFx0XHRkZWZhdWx0OiByZXR1cm4geCAtIDE7XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cdFxyXG5cclxuLy8gcmV0dXJucyBhbiBpdGVyYXRvciB3aGljaCByZXR1cm5zIHRoZSBuZXh0IHN5bWJvbFxyXG5mdW5jdGlvbiByZWFkX3BheWxvYWQodikge1xyXG5cdGxldCBwb3MgPSAwO1xyXG5cdHJldHVybiAoKSA9PiB2W3BvcysrXTtcclxufVxyXG5mdW5jdGlvbiByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChzKSB7XHJcblx0cmV0dXJuIHJlYWRfcGF5bG9hZChkZWNvZGVfYXJpdGhtZXRpYyh1bnNhZmVfYXRvYihzKSkpO1xyXG59XHJcblxyXG4vLyB1bnNhZmUgaW4gdGhlIHNlbnNlOlxyXG4vLyBleHBlY3RlZCB3ZWxsLWZvcm1lZCBCYXNlNjQgdy9vIHBhZGRpbmcgXHJcbi8vIDIwMjIwOTIyOiBhZGRlZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9pc3N1ZXMvNFxyXG5mdW5jdGlvbiB1bnNhZmVfYXRvYihzKSB7XHJcblx0bGV0IGxvb2t1cCA9IFtdO1xyXG5cdFsuLi4nQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyddLmZvckVhY2goKGMsIGkpID0+IGxvb2t1cFtjLmNoYXJDb2RlQXQoMCldID0gaSk7XHJcblx0bGV0IG4gPSBzLmxlbmd0aDtcclxuXHRsZXQgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoKDYgKiBuKSA+PiAzKTtcclxuXHRmb3IgKGxldCBpID0gMCwgcG9zID0gMCwgd2lkdGggPSAwLCBjYXJyeSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdGNhcnJ5ID0gKGNhcnJ5IDw8IDYpIHwgbG9va3VwW3MuY2hhckNvZGVBdChpKV07XHJcblx0XHR3aWR0aCArPSA2O1xyXG5cdFx0aWYgKHdpZHRoID49IDgpIHtcclxuXHRcdFx0cmV0W3BvcysrXSA9IChjYXJyeSA+PiAod2lkdGggLT0gOCkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vLyBlZy4gWzAsMSwyLDMuLi5dID0+IFswLC0xLDEsLTIsLi4uXVxyXG5mdW5jdGlvbiBzaWduZWQoaSkgeyBcclxuXHRyZXR1cm4gKGkgJiAxKSA/ICh+aSA+PiAxKSA6IChpID4+IDEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkX2RlbHRhcyhuLCBuZXh0KSB7XHJcblx0bGV0IHYgPSBBcnJheShuKTtcclxuXHRmb3IgKGxldCBpID0gMCwgeCA9IDA7IGkgPCBuOyBpKyspIHZbaV0gPSB4ICs9IHNpZ25lZChuZXh0KCkpO1xyXG5cdHJldHVybiB2O1xyXG59XHJcblxyXG4vLyBbMTIzXVs1XSA9PiBbMCAzXSBbMSAxXSBbMCAwXVxyXG5mdW5jdGlvbiByZWFkX3NvcnRlZChuZXh0LCBwcmV2ID0gMCkge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHggPSBuZXh0KCk7XHJcblx0XHRsZXQgbiA9IG5leHQoKTtcclxuXHRcdGlmICghbikgYnJlYWs7XHJcblx0XHRwcmV2ICs9IHg7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0XHRyZXQucHVzaChwcmV2ICsgaSk7XHJcblx0XHR9XHJcblx0XHRwcmV2ICs9IG4gKyAxO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkX3NvcnRlZF9hcnJheXMobmV4dCkge1xyXG5cdHJldHVybiByZWFkX2FycmF5X3doaWxlKCgpID0+IHsgXHJcblx0XHRsZXQgdiA9IHJlYWRfc29ydGVkKG5leHQpO1xyXG5cdFx0aWYgKHYubGVuZ3RoKSByZXR1cm4gdjtcclxuXHR9KTtcclxufVxyXG5cclxuLy8gcmV0dXJucyBtYXAgb2YgeCA9PiB5c1xyXG5mdW5jdGlvbiByZWFkX21hcHBlZChuZXh0KSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgdyA9IG5leHQoKTtcclxuXHRcdGlmICh3ID09IDApIGJyZWFrO1xyXG5cdFx0cmV0LnB1c2gocmVhZF9saW5lYXJfdGFibGUodywgbmV4dCkpO1xyXG5cdH1cclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHcgPSBuZXh0KCkgLSAxO1xyXG5cdFx0aWYgKHcgPCAwKSBicmVhaztcclxuXHRcdHJldC5wdXNoKHJlYWRfcmVwbGFjZW1lbnRfdGFibGUodywgbmV4dCkpO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0LmZsYXQoKTtcclxufVxyXG5cclxuLy8gcmVhZCB1bnRpbCBuZXh0IGlzIGZhbHN5XHJcbi8vIHJldHVybiBhcnJheSBvZiByZWFkIHZhbHVlc1xyXG5mdW5jdGlvbiByZWFkX2FycmF5X3doaWxlKG5leHQpIHtcclxuXHRsZXQgdiA9IFtdO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgeCA9IG5leHQodi5sZW5ndGgpO1xyXG5cdFx0aWYgKCF4KSBicmVhaztcclxuXHRcdHYucHVzaCh4KTtcclxuXHR9XHJcblx0cmV0dXJuIHY7XHJcbn1cclxuXHJcbi8vIHJlYWQgdyBjb2x1bW5zIG9mIGxlbmd0aCBuXHJcbi8vIHJldHVybiBhcyBuIHJvd3Mgb2YgbGVuZ3RoIHdcclxuZnVuY3Rpb24gcmVhZF90cmFuc3Bvc2VkKG4sIHcsIG5leHQpIHtcclxuXHRsZXQgbSA9IEFycmF5KG4pLmZpbGwoKS5tYXAoKCkgPT4gW10pO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgdzsgaSsrKSB7XHJcblx0XHRyZWFkX2RlbHRhcyhuLCBuZXh0KS5mb3JFYWNoKCh4LCBqKSA9PiBtW2pdLnB1c2goeCkpO1xyXG5cdH1cclxuXHRyZXR1cm4gbTtcclxufVxyXG4gXHJcbi8vIHJldHVybnMgW1t4LCB5c10sIFt4K2R4LCB5cytkeV0sIFt4KzIqZHgsIHlzKzIqZHldLCAuLi5dXHJcbi8vIHdoZXJlIGR4L2R5ID0gc3RlcHMsIG4gPSBydW4gc2l6ZSwgdyA9IGxlbmd0aCBvZiB5XHJcbmZ1bmN0aW9uIHJlYWRfbGluZWFyX3RhYmxlKHcsIG5leHQpIHtcclxuXHRsZXQgZHggPSAxICsgbmV4dCgpO1xyXG5cdGxldCBkeSA9IG5leHQoKTtcclxuXHRsZXQgdk4gPSByZWFkX2FycmF5X3doaWxlKG5leHQpO1xyXG5cdGxldCBtID0gcmVhZF90cmFuc3Bvc2VkKHZOLmxlbmd0aCwgMSt3LCBuZXh0KTtcclxuXHRyZXR1cm4gbS5mbGF0TWFwKCh2LCBpKSA9PiB7XHJcblx0XHRsZXQgW3gsIC4uLnlzXSA9IHY7XHJcblx0XHRyZXR1cm4gQXJyYXkodk5baV0pLmZpbGwoKS5tYXAoKF8sIGopID0+IHtcclxuXHRcdFx0bGV0IGpfZHkgPSBqICogZHk7XHJcblx0XHRcdHJldHVybiBbeCArIGogKiBkeCwgeXMubWFwKHkgPT4geSArIGpfZHkpXTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG59XHJcblxyXG4vLyByZXR1cm4gW1t4LCB5cy4uLl0sIC4uLl1cclxuLy8gd2hlcmUgdyA9IGxlbmd0aCBvZiB5XHJcbmZ1bmN0aW9uIHJlYWRfcmVwbGFjZW1lbnRfdGFibGUodywgbmV4dCkgeyBcclxuXHRsZXQgbiA9IDEgKyBuZXh0KCk7XHJcblx0bGV0IG0gPSByZWFkX3RyYW5zcG9zZWQobiwgMSt3LCBuZXh0KTtcclxuXHRyZXR1cm4gbS5tYXAodiA9PiBbdlswXSwgdi5zbGljZSgxKV0pO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcmVhZF90cmllKG5leHQpIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0bGV0IHNvcnRlZCA9IHJlYWRfc29ydGVkKG5leHQpOyBcclxuXHRleHBhbmQoZGVjb2RlKFtdKSwgW10pO1xyXG5cdHJldHVybiByZXQ7IC8vIG5vdCBzb3J0ZWRcclxuXHRmdW5jdGlvbiBkZWNvZGUoUSkgeyAvLyBjaGFyYWN0ZXJzIHRoYXQgbGVhZCBpbnRvIHRoaXMgbm9kZVxyXG5cdFx0bGV0IFMgPSBuZXh0KCk7IC8vIHN0YXRlOiB2YWxpZCwgc2F2ZSwgY2hlY2tcclxuXHRcdGxldCBCID0gcmVhZF9hcnJheV93aGlsZSgoKSA9PiB7IC8vIGJ1Y2tldHMgbGVhZGluZyB0byBuZXcgbm9kZXNcclxuXHRcdFx0bGV0IGNwcyA9IHJlYWRfc29ydGVkKG5leHQpLm1hcChpID0+IHNvcnRlZFtpXSk7XHJcblx0XHRcdGlmIChjcHMubGVuZ3RoKSByZXR1cm4gZGVjb2RlKGNwcyk7XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiB7UywgQiwgUX07XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGV4cGFuZCh7UywgQn0sIGNwcywgc2F2ZWQpIHtcclxuXHRcdGlmIChTICYgNCAmJiBzYXZlZCA9PT0gY3BzW2Nwcy5sZW5ndGgtMV0pIHJldHVybjtcclxuXHRcdGlmIChTICYgMikgc2F2ZWQgPSBjcHNbY3BzLmxlbmd0aC0xXTtcclxuXHRcdGlmIChTICYgMSkgcmV0LnB1c2goY3BzKTsgXHJcblx0XHRmb3IgKGxldCBiciBvZiBCKSB7XHJcblx0XHRcdGZvciAobGV0IGNwIG9mIGJyLlEpIHtcclxuXHRcdFx0XHRleHBhbmQoYnIsIFsuLi5jcHMsIGNwXSwgc2F2ZWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XG5cbmZ1bmN0aW9uIGhleF9jcChjcCkge1xyXG5cdHJldHVybiBjcC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5wYWRTdGFydCgyLCAnMCcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBxdW90ZV9jcChjcCkge1xyXG5cdHJldHVybiBgeyR7aGV4X2NwKGNwKX19YDsgLy8gcmFmZnkgY29udmVudGlvbjogbGlrZSBcIlxcdXtYfVwiIHcvbyB0aGUgXCJcXHVcIlxyXG59XHJcblxyXG4vKlxyXG5leHBvcnQgZnVuY3Rpb24gZXhwbG9kZV9jcChzKSB7XHJcblx0cmV0dXJuIFsuLi5zXS5tYXAoYyA9PiBjLmNvZGVQb2ludEF0KDApKTtcclxufVxyXG4qL1xyXG5mdW5jdGlvbiBleHBsb2RlX2NwKHMpIHsgLy8gdGhpcyBpcyBhYm91dCAyeCBmYXN0ZXJcclxuXHRsZXQgY3BzID0gW107XHJcblx0Zm9yIChsZXQgcG9zID0gMCwgbGVuID0gcy5sZW5ndGg7IHBvcyA8IGxlbjsgKSB7XHJcblx0XHRsZXQgY3AgPSBzLmNvZGVQb2ludEF0KHBvcyk7XHJcblx0XHRwb3MgKz0gY3AgPCAweDEwMDAwID8gMSA6IDI7XHJcblx0XHRjcHMucHVzaChjcCk7XHJcblx0fVxyXG5cdHJldHVybiBjcHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cl9mcm9tX2NwcyhjcHMpIHtcclxuXHRjb25zdCBjaHVuayA9IDQwOTY7XHJcblx0bGV0IGxlbiA9IGNwcy5sZW5ndGg7XHJcblx0aWYgKGxlbiA8IGNodW5rKSByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY3BzKTtcclxuXHRsZXQgYnVmID0gW107XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICkge1xyXG5cdFx0YnVmLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY3BzLnNsaWNlKGksIGkgKz0gY2h1bmspKSk7XHJcblx0fVxyXG5cdHJldHVybiBidWYuam9pbignJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBhcmVfYXJyYXlzKGEsIGIpIHtcclxuXHRsZXQgbiA9IGEubGVuZ3RoO1xyXG5cdGxldCBjID0gbiAtIGIubGVuZ3RoO1xyXG5cdGZvciAobGV0IGkgPSAwOyBjID09IDAgJiYgaSA8IG47IGkrKykgYyA9IGFbaV0gLSBiW2ldO1xyXG5cdHJldHVybiBjO1xyXG59XG5cbi8vIGNyZWF0ZWQgMjAyMy0wOS0xMlQyMjowNToxNC4yMTFaXG4vLyBjb21wcmVzc2VkIGJhc2U2NC1lbmNvZGVkIGJsb2IgZm9yIGluY2x1ZGUtbmYgZGF0YVxuLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzL2Jsb2IvbWFpbi9zcmMvbWFrZS5qc1xuLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzI3NlY3VyaXR5XG4vLyBTSEEtMjU2OiBhOTc0YjZmODU0MWZjMjlkOTE5YmM4NTExOGFmMGE0NDAxNTg1MWZhYjUzNDNmODY3OWNiMzFiZTJiZGIyMDllXG52YXIgQ09NUFJFU1NFRCA9ICdBRVVEVEFIQkNGUUFUUURSQURBQWNnQWdBRFFBRkFBc0FCUUFId0FPQUNRQURRQVJBQW9BRndBSEFCSUFDQUFQQUFVQUN3QUZBQXdBQkFBUUFBTUFCd0FFQUFvQUJRQUlBQUlBQ2dBQkFBUUFGQUFMQUFJQUN3QUJBQUlBQVFBSEFBTUFBd0FFQUFzQURBQU1BQXdBQ2dBTkFBMEFBd0FLQUFrQUJBQWRBQVlBWndEU0Fkc0RKZ0MwQ2tNQjh4aFpBcWZvQzE5MFVHY1RoZ0J1cndmN1BUMDlQYjA5QWpnSnVtOE9qRGxseEhZVUtYQVB4enE2dEFCQXhnSzh5c1V2V0FnTVBUMDlQVDA5UFNzNkxUMkhjZ1dYV3dGTG9TTUVFRWw1UkZWTUt2TzBYUThFeERkSk1uSWdzajI2UFRReXk4RmZFUThBWThJUEFHY0Vid1J3QkhFRWNnUnpCSFFFZFFSMkJIY0VlQVI2QkhzRWZBUitCSUFFZ2ZuZEJRb0JZZ1VMQVdJRkRBRmlCTmNFMkFUWkJSQUZFUVV2QmRBTEZBc1ZEUGNOQncxM0RZY09NQTR4RGpNQjRCbGxISTBCMmdyYkFNRHBITGtRN1FIVkFQUk5RUUZuR1JVRWcweUVCMnVhSkY4QUpwSUJwb2I1QUVSU01BS05vQVhxYVFMVUJNQ3pFaUFDbndSWkVra1ZzUzd0QU5Bc0JHMFJ1QVFMRVBBQnY5SElDVFVCWGlnUFp3UkJBcE1ET3dBYW1odGFBQnFFQVk4S3ZLeDNMUTRBckFCOFVod0VCQVZTYWdEOEFFRlpBRGtCSWFkVmoyVU1VZ3g1SWw0QU5RQzlBeElCMUJsYkVQTUFzMzBDR3hsWEFod1pLUUlFQ0JjNkVic0NveG5nenY3VXpSUUE4TTBCYXdMNlp3a043d0FCQUQzM09RUmNzZ0xKQ2pNQ2pxVUNodHcva20rTkFzWFBBb1AyQlQ4NFB3VVJBSzBSQXZwdGI2Y0FwUVMvT01NZXk1SEpTODRVZHhweFRQa0NvZ1ZGSVRhVE93RVJBSzVwQXZrTkJPVnlBN3EzQktsT0pTQUxBZ1VJQlJjRWRBU3BCWHF6QUJYRlNXWk9hd0xDT3F3Ly9Bb2xDWmR2djNkU0JrRVFHeWVsRVBjTU13RzFBVHNON1V2WUJQRUdPd1RKSDMwWkdRL05sWndJcFMzZERPMG00eTZoZ0ZvajlTcURCZTFMOUR6ZEMwMVJhQTlaQzJVSjR6cGpnVTRESVFFTklvc0szUTA1Q0cwUTh3ckphdzNsRVVVSE9RUFZTWm9BcFFjQkN4RWROUlcxSmhCaXJBc0pPWGNHK3hyMkM0OG1yeE1wZXZ3RjB4b2hCazBCS1JyL0FNOHU1NFd3V2pGY0hFOWZCZ01MSlNQSEZLaFFJQTBsUUxkNFNCb2JCeFVscVFLUlEzQktoMUUySHBNaDlqdzlEV1l1RTFGOEIvVThCUmxQQzRFOG5rYXJSUTRSMGo2TlBVZ2lTVXdzQkRWL0xDOG5pd25QRDRVTXVYeHlBVmtKSVFteERIRVRNUkVYTjhVSU9RY1pMWmNrSnhVSUlVYVZZSm9FOTU4RDh4UFJBd3NGUHdsQkJ4TUR0Und0RXk0VktRVU5nU1RYQXZNMjFTNnpBbzlXZ0FFWEJjc1BKUi9mRUZCSDRBN3BDSnNDWlFPREplc0FMUlVoQUJjaW13aERZd0JmajloVEJTN0xDTWRxYkNOMEEyY1U1MkVSY3dlUkRsY0hweHd6RmI4YzRYRElYZ3VHQ0NpanJ3bGJBWFVKbVFGZkJPTUlDVFZiaktBZ1FXZFRpMWdZbXlCaFFUOWQvQUl4REdVVm4wUzloM2dDaXc5ckVoc0JOUUZ6QnprTkFRSjNFZTBSYXhDVkNPdUdCRFcxTS9nNkpRUlBJWU1nRVFvbkEwOXN6Z3NuSnZrTStHa0JveEppQXd3MFBYZnVaNnRndGlRWC9RY1pNc1ZCWUNIeEM1SlB6UXljR3NFWVFsUXVHZVFIdndQekd2TW42a0ZYQmY4RG93TVRPazB6N2dTOUMya0lpd2svQUVrT294Y0gxeGhxQ25HTTBBRXhpd0czbVFOWGtZTUNiNDhHTndjTEFHY0xod1Y1NVFBZEFxY0lvd0FGQU04RFZ3QTVBcTBIblFBWkFJVkJBVDBESnk4QkllVUNqd09UQ0RITEFaVXZBZk1wQkJ2RERCVUE5emR1U2dMRHNRS0FhbWFpQmQxWUFvNENTVFVCVFNVRUJVNUhVUU92Y2VFQTJ3QkxCaFBmUndFVnEwckxHdU5EQWQ5dkt3REhBUHNBQlRVSEJVRUJ6UUh6YlFDM0FWOExNUW1pczdVQlRla3BBSU1BRldzQjF3S0pBTjBBTlFCLzhRRlRBRTBGV2ZrRjB3SlBTUUVSTVJnclYyRUJ1d01mQVRNQkRRQjVCc3VOcGNrSEh3UnRCOU1DRUJzVjRRTHZMZ2UxQVFNaTN4UE5Rc1VDdmQ1Vm9XQUNaSUVDWWtKYlRhOWJOeUFDb2ZjQ2FKZ0NaZ2tDbjRRNEd3c0NaanNDWmlZRWJnUi9BMzhUQTM2U09RWTVkeGM1Z2pvakl3SnNIUUl5TmpnS0FtM0hBbTJ1NzRvelowVXJBV2NBM2dEaEFFb0ZCNWdNalFEK0M4SUFEYlVDZHk4Q2RxSS9BbmxMUXdKNHVoMWMyMFd1UnRjQ2ZEOENlc2dDZlFrQ2ZQQUZXUVVnU0FCSWZXTWtBb0Z0QW9BQUFvQUZBbit1U1ZoS1d4VVhTc3dDMFFFQzBNeExKd09JVHdPSDVrVEZrVElDOHFGZEF3TURya3ZPVEMwbEE4OU5URTJ2QW9zL0Fvcll3UnNISFVObkJiY0NqamNDamx4QWw0RUNqdGtDamx4NFViUlROUXBTMUZTRkFwUDdBcE1NQU9rQUhGVWVWYTlWMEFZc0d5bVZoakxoZUdaRk96a0NsNThDNzdKWUlhZ0FXU1VDbG84Q2xueWNBS2xackZvSmdVMEFPd0tXdFFLV1RseEVYTkVDbWNzQ21XUmN5bDBIR1FLY216bkNPcDBDbkJZQ241c0NucmlLQUIwUE1Tb1BBcDN4QXA2U0FMVTlZVFJoN3dLZTB3S2diZ0dwQXA2Zkh3S2VUcVZqeUdRbkpTc0NKNjhDSm40Q29Qc0NvRXdDb3QwQ29jUUNwaThDcGM0Q3AvOEFmUUtuOG1oOGFMRUFBMGxxSEdyUkFxempBcXl1QXExbkFxMENBbGNkQWxYY0FySGgxd01mVG15WEFySzlEUUt5NkJkczRHMWpiVWhmQXlYTkFyWmNPejl1a0FNcFJRSzRYZ0s1UnhVQ3VTcDNjRFp3NFFLOUdRSzcybkNXQXpJUkFyNkljZ0lETTNFQ3ZocHpJbk5QQXNQTEFzTUVjNEowU3pWRmRPQURQS2NEUEpvRFBiOEN4WHdDeGtjQ3hoQ0pBc2hwVVFMSVJBTEpUd0xKTGdKa25RTGQwbmg1WVhpdWVTVkwwQU1ZbzJjQ0FtSDBHZk9WSkhzTFhwSmV1eEVDejJzQ3oyd3ZTMVBTOHhPZkFNYXRBczl6QVNucUEwNFNma3NGQXR3bkF0dUtBdEpQQTFKY0ExTmZBUUVEVll5QWlUOEF5eGJ0WUVXQ0hJTFRnczZEalFMYXh3TFozb1FRaEVtblBBT0dwUUF2QTJRT2huRlorUUJWQXQ5bEF0NjRjM2NDNGkvdEZBSHpNQ2NCOUpzQjh0S0hBdXZ6QXVsd2VRTHErUUxxNUFENVJ3RzVBdTZKQXV1Y2xxcVhBd0x1UHdPRjRKaDVjT0J4b1FMekF3QnBBNDRXbVpNQzl4TURrVzREa29jQzk1Z0MrZGtDK0dhYUhKcXJ1emViSGdPZGd3TCsrZ0ViQURtZkhKK3pBd1dOQTZacUE2YlpBTkhGQXdacW9ZaWlCUWtEREVrQ3dBQS9Bd0RoUVJkVEFSSHpBMnNIbDJjRkFKTXRLN2V2dmRzQmlaa1VmeEVFT1FIN0tRVWhEcDBKbndDUy9TbFh4UUwzQVowQXR3VzVBRzhMYlVFdUZDYU5MZ0ZEQVlEOEFiVW1BSFVERGdSdEFDd0NGZ3loQUFBS0FqMENhZ1BkQTM0RWtRRWdSUVVoZkFvQUJRQkVBQk1BTmhJQ2R3RUFCZFVEYSs4S3hRSUE5d3FmSjcreHQrVUJrU0ZCUWdIcEZIOFJOTUNKQUFRQUd3QmFBa1VDaElzQUJqcFRPcFNOYlFDNE9vODYwQUNOT01FNjNBQ2xBT2dBeXdFNmdUbzdPZnc1K1R0MmlUcGJPNTZKT204NUdBRldBVE1CYkFVdk5WMDFuald0TldZMWRUVzJOY1UxZ2pXUk5kSTE0VFdlTmEwMTdqWDlOYkkxd1RZQ05oRTF4alhWTmhZMkp6WGVOZTAyTGpZOU5pNDFMU0UyT2pZOU5qdzJ5VGNJQkpBOFZ6WTROdDAzSURjUE5zb2dONGszTUFvRXNEeG5OaVEzR1Rkc09vMDNJVUxVUXdkQzRFTUxIQThQQ1pzb2JTaFJWUVlBNlg4QTZiQUJGQ25YQXVrQm93QzlCYmNBYndOekJMOE1EQU1NQVFnREFBa0tDd3NMQ1FvR0JBVlZCSS9EdndEejliMjlrYVVDYjBRdHNSVE5MdDRlR0JjU0hBTVpGaFlaRWhZRUFSQUVCVUVjUVJ4QkhFRWNRUnhCSEVFYVFSeEJIRUZDU1R4QlBFbElTVWhCTmtNMlFUWWJOa2xJU1ZtQlZJZ0JGTFdaQXUwQmhRQ2pCY0VBYnlrQnZ3R0pBYVFjRVowZVBDa2xNQUFoTXZBSU1BTDU0Z0M3Qm04RWVzY2p6UU1wQVJRcEtnRFVBQmF2QWo2MjZ4UUFKUDBBM2V0enVmNE5OUkE3ZWZ5Mlo5TlFyQ25DME9TeUFOejVCQkliSjVJRkRSNm1pSWF2WVM2dHByamptdUtlYnhtNUM3NFEyMjVYMXBrYVlZUGI2ZjFESzRrM3hNRUJiOVMyV01qRWliVE5XaHNSSklBK3Z3TlZFaVhURTVpWHMvd2V6VjY2b0ZMZnA5TlpHWVcrR2sxOUoyK2JDVDZZZTJ3NkxEWWRnektNVWFiazU5NWVMQkNYQU56OUhVcFdiQVRxOXZxWFZ4OVhEZytQYzlYcDQrYnNTMDA1U1ZNL0JKQk00Njg3V1V1ZitVajlkRWk4YUROYVB4dHBiRHhjRzFUSFRJbVVNWnE0VUNhYU5ZcHNWcXJhTnlLTEpYRFlzRlovNWpsN2JMUnRPODh0N1AzeFphQXhoYjVPZFBNWHFzU2twMVdDaWVHOGpYbTFVOTkrYmx2TGxYelBDUytNOTNWbkpDaUsrMDlMZmFTYUJBVkJvbXlEZ0p1YThkZlV6UjdnYTM0SXZSMk52aitBOWhlSjZsc2wxS0c0TmtJMTAzMkNuZmYxbTF3b2YyQjlvSEpLNGJpNkprRWRTcWVOZWl1bzZRb1paaW5jb2M3My9USDlTWEY4c0NFN1h5dVl5VzhXU2diR0ZDalBWMGloTEtoZFBzMDhUeDgyZllBa0xMYzRJMndkbDRhcFk3R1U1bEhSRnpSV0plcDdXdzN3YmVBM3FtZDU5Lzg2UDR4dU5hcURweWdYdDZNODVnbFNCSE9DR2dKRG50K3BOOWJLN0hBcE1ndVg2KzA2UlpOanpWbWNaSit3Y1VySjkvL2JwUk54TnVLcE5sOXVGZHMrUzl0ZHg3TGFNNVprSXJQajZuSVU5bW5iRnRWYnM5cy91TGdsOE1WY3pBd2V0K2lPRXp6QmxZVzdSQ01nRTZneU5MZXE2KzF0SXg0ZHBnWm5kMERrc0pTNWYrSk5EcHd3Y1BOWGFhVnNwcTFmYlFhak9ySmdLMG9mS3RKMU5lOTBMNlZPNE1PbDVTODg2cDd1NnhvN09Makc4VEdMK0hVMUpYR0pncHBnNG5OYk5KNW5selNwdVBZeTIxSlVFY1VBOTRQb0ZpWmZqWnVlK1FueVE4MGVrT3VaVmt4eDRnK2N2aEpmSGdObDRoeTEvYTYrUktjS2xhci9KMjl5Ly9FenRsYlZQSFZVZVExelg4NmVRVkFqUi9NM2RBOXc0VzhMZmFYcDRFZ004NXdPV2FzbGk4MzdQelZNT25zTHpSK2szbzc1L2xSUEFKU0UxeEFLUXpFaTV2MTBrZStWQnZSdDFjd1FSTWQrVTVtTENUR1ZkNlhpWnRnQkc1Y0RpMHcyMkdLY1ZOdkhpdTVMUWJaRURWdHowb25uN2s1K2hldUtYVnNadFN6aWxrTFJBVW1qTVhFTUIzSjlZQzUwWEJ4UGl6NTNTQytFaG5QbDlXc0tDdjkyU00vT0ZGSU1KWllmbDBXVzh0SU8zVXhZY3dkTUFqN0ZTbWdyc1oyYUFaTzAzQk9oUDFiTk5aSXR5WFlRRlRwQzNTRzFWdVBEcUg5R2tpQ0RtRStKd3h5SVZTTzVzaURFckFPcEVYRmdqeTZQUXRPVkRqK3M2ZTFyOGhlV1Z2bVpuVGNpdWY0RWlOWnpDQWQ3U09NaFhFUklPbHNISU1HMzk5aTlhTFR5M20yaFJMWmpKVkROTFM1M2lHSUsxMWRQcVF0MHpCRHlnNnFjN1lxa0RtMk01VmU2ZENXQ2FDYlRYWDJyVG9hSWd6Nit6aDRsWVVpLys2bnFjRk1Ba1FKS0hZTEswd1lrNU45c3pWNnhpaERiRERGcjQ1bE4xSzRhQ1hCcS9GaXRQU3VkOWdMdDVaVm4rWnFHWDdjd20yejVFR01nZkZwSUZ5aEdHdURQbXNvNlRJdFRNd255Kzd1UG5MQ2Y0VzZnb0ZRRlYwb1FTc2M5VmZNbVZMY0xyNlpldERaYmFTRlRMcW5TTy9iSVBqQTMvekFVb3FnR0ZBRVFTNElodU16RXAySTNqSnpiemtrL0lFbXlheCtyaFpUd2Q2ZitDR3R3UGl4dThJdnpBQ3F1UFdQUkV1OVp2R2tVenBSd3ZSUnVhTk42Y3IwVzF3V2l0czlJQ2RZSjdsdGJnTWlTTDNzVFBldWZnTmNWcU1WV0ZrQ1BESDRqRzJqQTBYY1ZnUWo2MkNiMjl2OWYvei8rMktiWXZJdi96empwUUFQa2xpYVZEek5yVzU3VFovWk95WkQwbmxmTW1BSUJJQUdBSTBEM2svbWRONHhyOXY4NVpiWmJicWZIMmpHZDVoVXFOWld3bDVTUGZvR21mRWxtYXpVSWVOTDFqL21rRjdWTkF6VHE0ak50OEpvUTExTlFPY21ocHJYb3hTeGZSR0o5TERFT0FRK2RteEFRSDkwaXRpOWUydS9Nb2V1YUdjRFRIb0MreHNtRWVXbXhFS2VmUXVJekhicHc1VGM1Y0VvY2JvQUQwOW9pcFdRaHRUTzF3aXZmL08rRFJlMnJwbC9FOXdscnpCb3JqSnNPZUcxQi9YUFc0RWFKRUZkTmxFQ0VaZ2E1Wm9HUkhYZ1lvdUdSdVZrbTh0REVTaUV5Rk5vKzNzNU01cHVTZFR5VUwybGxuSU5WSEV0OTFYVU5XNGV3ZE1nSjRib0pmRXl0L2lZNVdYcWJBK0EyRmt0NVowbHV0aVdoZTluWkl5SVVqeVhEQzNVc2FHMXQrZU54Nno0Vy9PWW9UQjdBNngrZE5TVE9pOUFJbmN0YkVTcW01Z3ZPTHd3N09XWFBybUh3Vlphc3JsNGVEMTEzcG0rSnRUN0pWT3ZuQ1hxZHp6ZFRSSGdKMFBpR1RGWVc1R3Z0OVI5TEQ2THpmczB2L1RaWkhTbXlWTnE3dmlJSEU2REJLN1FwMDdJejU1RU04U1l0UXZaZi9vYkJuaVRXaTVDMi9vdkhmdzRWbmRrRTVYWWRqT2hDTVJqRGVPRWZYZU4vQ3dmR2R1aVVJZnNvRmVVeFhlUVhiYTdjNzk3MlhOdjh3K2RUampVTTBRZU5BUmVXK0owMTRkS0FEL01jUVlYVDdjMEdRUElrbjNMbDZSN2dHanVpUW9aRDBURWVFcVFwS29aMTVnLzBPUFFJMTdRaVN2OUFVUk9hL1YvVFFOM2R2TEFyZWMzUnJzWWx2Qm0xYjhMV3psdGR1Z3NDNTBsTktZTEVwMmErWlpZcVBlalVMUmxPSmg1emovTFZNeVREdndLaE14eHd1RGt4SjFRcG9OSTBPVFdMb200WjcxU056STlUVjFpWEpySXU5V2NuZCtNQ2FBdzhvMWpTWGQ5NFlVLzFnbmtyQzlCVUVPdFF2RUlRN2cwaTZoK0tMMkpLazhZZGw3SHJ1dmdXTVNBbU5lK0xzaEdoVjRxbldIaE85L1JJUFF6WTF0SFJqMlZxT3lOc0RwSzBjd3crNTZBZERDNGdzV3dZMFh4b3VjSVdJcXMvR2N3bldxbGFUMEtQcjhtYks1VTk0LzMwMWkxV0x0NFlJTlRWdkNGQnJGWmJJYlk4ZXljT2RlSjJ0ZUQ1SWZQTENSZzdqamNGVHdsTUZObDl6ZGgvbzNFL2hIUHdqN0JXZzBNVTA5cFByQkxickNnbTU0QTZIK0k2djI3K2pMNWdraldnL2lZZGtzOWpiZlZQNXkvbjBkbGdXRU1sS2FzbDdKdkZaZDU2TGZ5YlcxZWVhVk8wZ3hUZlhad0Q4RzRTSTExNnl4N1VLVlJndWk2WWExWXBpeHFYZU5MYzhJeHRBd0NVNUlod1FnbitOcUhuUmFEdjYxQ3hLaE9xNHBPWDdNNnBrQStQbXBkNGoxdm42QUNVQUxvTExjNHZwWGNpOFZpZEx4em03cUZCZTdzK3F1dUpzNkVUWW1ucGdTM0x3U1p4UElsdGdCRFh6OE0xay9XMnlTTnYyZjkvTlBoeExHSzJEMjFka0hlU0dtZW5SVDNZcWNkbDBtL2gzT1lyOFYrbFhOWUdmOGFDQ3BkNGJXakU0UUlQajd2VUtONE5yZnM3TUw2WTJPeVM4MzBKQ25vZmcvazdscEZwdDRTcVpjNUhHZzFIQ09ySHZPZEM4YlA2RkdEYkUvVlYwbVg0SWFremJkUy9vcCtLdDNHMjQvOFFiQlY3eTg2c0dTUS92WnpVOEZYczd1NmpJdndjaHNFUDJCcEloVzNHOHVXTndhM0htamZIL1pqaGhDV3ZsdUFjRituTWYxNENsS2c1aEdndFBMSjk4dWVOQWtjNUhzMldabGsyUUh2ZnJlQ0sxQ0NHTzZuTVpWU2I5OVZNL2FqcjhXSFR0ZTlKU21rWHEvaS9VOTQzSEViZHpXNlJlL1M4OGRLZ2c4cEdPTGxBZU5pcXJjTGtVUjMvYUNsRnBNWGNPVVAzcm1FVGNXU2ZNWFpFM1RVT2k4aStmcVJuVFlMZmxWeC9WYi82R0o3ZUlSWlVBNmszUllSM2lGU0s5YzRpRGROd0p1WkwyRkt6L0lLNVZpbWNOV0VxZFhqU294U2dtRjBVUGxEb1VsTnJQY003ZnRtQThZOWdLaXFLRUh1V04rQVpSSXd0VlN4eWUyS2Y4ck0zbGhKNVhjQlhVOW40djBPeTFSVTJNKzRxTThBUVBWd3NlOEVyTlNvYjVvRlBXeHVxWm5Wem8xcUIvSUJ4a00zRVZVS0ZVVWxPM2U1MTI1OUdnTmNKYkNtbHZyZGp0b1RXN3JDaG0xd3lDS3pwQ1R3b3pVVUVPSWNXTG5lUkxnTVhoK1NqR1NGa0FsbHpiR1M1SEs3TGxmQ01STlJEU3ZiUVBqY1hhZW5OWXhDdnUyUXl6bno2U3R1eFZqNjZTZ0kwVDhCNi9zZkhBSllaYVo3OHRoak9TSUZ1bU5XTFFiZVppeERDQ0MrdjBZQnRreGlCQjNqZWZIcVovZEZIVStjcmJqNk92UzF4L0pERDd2bG03ek9WUHdwVUMwMW5oeFp1WS82M0U3Zyc7XG5cbi8vIGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjE1L1xyXG4vLyBmb3IgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uXHJcbi8vIHNlZTogL2Rlcml2ZS9uZi5qc1xyXG5cclxuXHJcbi8vIGFsZ29yaXRobWljIGhhbmd1bFxyXG4vLyBodHRwczovL3d3dy51bmljb2RlLm9yZy92ZXJzaW9ucy9Vbmljb2RlMTUuMC4wL2NoMDMucGRmIChwYWdlIDE0NClcclxuY29uc3QgUzAgPSAweEFDMDA7XHJcbmNvbnN0IEwwID0gMHgxMTAwO1xyXG5jb25zdCBWMCA9IDB4MTE2MTtcclxuY29uc3QgVDAgPSAweDExQTc7XHJcbmNvbnN0IExfQ09VTlQgPSAxOTtcclxuY29uc3QgVl9DT1VOVCA9IDIxO1xyXG5jb25zdCBUX0NPVU5UID0gMjg7XHJcbmNvbnN0IE5fQ09VTlQgPSBWX0NPVU5UICogVF9DT1VOVDtcclxuY29uc3QgU19DT1VOVCA9IExfQ09VTlQgKiBOX0NPVU5UO1xyXG5jb25zdCBTMSA9IFMwICsgU19DT1VOVDtcclxuY29uc3QgTDEgPSBMMCArIExfQ09VTlQ7XHJcbmNvbnN0IFYxID0gVjAgKyBWX0NPVU5UO1xyXG5jb25zdCBUMSA9IFQwICsgVF9DT1VOVDtcclxuXHJcbmZ1bmN0aW9uIHVucGFja19jYyhwYWNrZWQpIHtcclxuXHRyZXR1cm4gKHBhY2tlZCA+PiAyNCkgJiAweEZGO1xyXG59XHJcbmZ1bmN0aW9uIHVucGFja19jcChwYWNrZWQpIHtcclxuXHRyZXR1cm4gcGFja2VkICYgMHhGRkZGRkY7XHJcbn1cclxuXHJcbmxldCBTSElGVEVEX1JBTkssIEVYQ0xVU0lPTlMsIERFQ09NUCwgUkVDT01QO1xyXG5cclxuZnVuY3Rpb24gaW5pdCQxKCkge1xyXG5cdC8vY29uc29sZS50aW1lKCduZicpO1xyXG5cdGxldCByID0gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQoQ09NUFJFU1NFRCk7XHJcblx0U0hJRlRFRF9SQU5LID0gbmV3IE1hcChyZWFkX3NvcnRlZF9hcnJheXMocikuZmxhdE1hcCgodiwgaSkgPT4gdi5tYXAoeCA9PiBbeCwgKGkrMSkgPDwgMjRdKSkpOyAvLyBwcmUtc2hpZnRlZFxyXG5cdEVYQ0xVU0lPTlMgPSBuZXcgU2V0KHJlYWRfc29ydGVkKHIpKTtcclxuXHRERUNPTVAgPSBuZXcgTWFwKCk7XHJcblx0UkVDT01QID0gbmV3IE1hcCgpO1xyXG5cdGZvciAobGV0IFtjcCwgY3BzXSBvZiByZWFkX21hcHBlZChyKSkge1xyXG5cdFx0aWYgKCFFWENMVVNJT05TLmhhcyhjcCkgJiYgY3BzLmxlbmd0aCA9PSAyKSB7XHJcblx0XHRcdGxldCBbYSwgYl0gPSBjcHM7XHJcblx0XHRcdGxldCBidWNrZXQgPSBSRUNPTVAuZ2V0KGEpO1xyXG5cdFx0XHRpZiAoIWJ1Y2tldCkge1xyXG5cdFx0XHRcdGJ1Y2tldCA9IG5ldyBNYXAoKTtcclxuXHRcdFx0XHRSRUNPTVAuc2V0KGEsIGJ1Y2tldCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YnVja2V0LnNldChiLCBjcCk7XHJcblx0XHR9XHJcblx0XHRERUNPTVAuc2V0KGNwLCBjcHMucmV2ZXJzZSgpKTsgLy8gc3RvcmVkIHJldmVyc2VkXHJcblx0fVxyXG5cdC8vY29uc29sZS50aW1lRW5kKCduZicpO1xyXG5cdC8vIDIwMjMwOTA1OiAxMW1zXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzX2hhbmd1bChjcCkge1xyXG5cdHJldHVybiBjcCA+PSBTMCAmJiBjcCA8IFMxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wb3NlX3BhaXIoYSwgYikge1xyXG5cdGlmIChhID49IEwwICYmIGEgPCBMMSAmJiBiID49IFYwICYmIGIgPCBWMSkge1xyXG5cdFx0cmV0dXJuIFMwICsgKGEgLSBMMCkgKiBOX0NPVU5UICsgKGIgLSBWMCkgKiBUX0NPVU5UO1xyXG5cdH0gZWxzZSBpZiAoaXNfaGFuZ3VsKGEpICYmIGIgPiBUMCAmJiBiIDwgVDEgJiYgKGEgLSBTMCkgJSBUX0NPVU5UID09IDApIHtcclxuXHRcdHJldHVybiBhICsgKGIgLSBUMCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGxldCByZWNvbXAgPSBSRUNPTVAuZ2V0KGEpO1xyXG5cdFx0aWYgKHJlY29tcCkge1xyXG5cdFx0XHRyZWNvbXAgPSByZWNvbXAuZ2V0KGIpO1xyXG5cdFx0XHRpZiAocmVjb21wKSB7XHJcblx0XHRcdFx0cmV0dXJuIHJlY29tcDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIC0xO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVjb21wb3NlZChjcHMpIHtcclxuXHRpZiAoIVNISUZURURfUkFOSykgaW5pdCQxKCk7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRsZXQgY2hlY2tfb3JkZXIgPSBmYWxzZTtcclxuXHRmdW5jdGlvbiBhZGQoY3ApIHtcclxuXHRcdGxldCBjYyA9IFNISUZURURfUkFOSy5nZXQoY3ApO1xyXG5cdFx0aWYgKGNjKSB7XHJcblx0XHRcdGNoZWNrX29yZGVyID0gdHJ1ZTtcclxuXHRcdFx0Y3AgfD0gY2M7XHJcblx0XHR9XHJcblx0XHRyZXQucHVzaChjcCk7XHJcblx0fVxyXG5cdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0aWYgKGNwIDwgMHg4MCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKGNwKTtcclxuXHRcdFx0fSBlbHNlIGlmIChpc19oYW5ndWwoY3ApKSB7XHJcblx0XHRcdFx0bGV0IHNfaW5kZXggPSBjcCAtIFMwO1xyXG5cdFx0XHRcdGxldCBsX2luZGV4ID0gc19pbmRleCAvIE5fQ09VTlQgfCAwO1xyXG5cdFx0XHRcdGxldCB2X2luZGV4ID0gKHNfaW5kZXggJSBOX0NPVU5UKSAvIFRfQ09VTlQgfCAwO1xyXG5cdFx0XHRcdGxldCB0X2luZGV4ID0gc19pbmRleCAlIFRfQ09VTlQ7XHJcblx0XHRcdFx0YWRkKEwwICsgbF9pbmRleCk7XHJcblx0XHRcdFx0YWRkKFYwICsgdl9pbmRleCk7XHJcblx0XHRcdFx0aWYgKHRfaW5kZXggPiAwKSBhZGQoVDAgKyB0X2luZGV4KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgbWFwcGVkID0gREVDT01QLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKG1hcHBlZCkge1xyXG5cdFx0XHRcdFx0YnVmLnB1c2goLi4ubWFwcGVkKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YWRkKGNwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFidWYubGVuZ3RoKSBicmVhaztcclxuXHRcdFx0Y3AgPSBidWYucG9wKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChjaGVja19vcmRlciAmJiByZXQubGVuZ3RoID4gMSkge1xyXG5cdFx0bGV0IHByZXZfY2MgPSB1bnBhY2tfY2MocmV0WzBdKTtcclxuXHRcdGZvciAobGV0IGkgPSAxOyBpIDwgcmV0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBjYyA9IHVucGFja19jYyhyZXRbaV0pO1xyXG5cdFx0XHRpZiAoY2MgPT0gMCB8fCBwcmV2X2NjIDw9IGNjKSB7XHJcblx0XHRcdFx0cHJldl9jYyA9IGNjO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxldCBqID0gaS0xO1xyXG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRcdGxldCB0bXAgPSByZXRbaisxXTtcclxuXHRcdFx0XHRyZXRbaisxXSA9IHJldFtqXTtcclxuXHRcdFx0XHRyZXRbal0gPSB0bXA7XHJcblx0XHRcdFx0aWYgKCFqKSBicmVhaztcclxuXHRcdFx0XHRwcmV2X2NjID0gdW5wYWNrX2NjKHJldFstLWpdKTtcclxuXHRcdFx0XHRpZiAocHJldl9jYyA8PSBjYykgYnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0cHJldl9jYyA9IHVucGFja19jYyhyZXRbaV0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wb3NlZF9mcm9tX2RlY29tcG9zZWQodikge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgc3RhY2sgPSBbXTtcclxuXHRsZXQgcHJldl9jcCA9IC0xO1xyXG5cdGxldCBwcmV2X2NjID0gMDtcclxuXHRmb3IgKGxldCBwYWNrZWQgb2Ygdikge1xyXG5cdFx0bGV0IGNjID0gdW5wYWNrX2NjKHBhY2tlZCk7XHJcblx0XHRsZXQgY3AgPSB1bnBhY2tfY3AocGFja2VkKTtcclxuXHRcdGlmIChwcmV2X2NwID09IC0xKSB7XHJcblx0XHRcdGlmIChjYyA9PSAwKSB7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldC5wdXNoKGNwKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChwcmV2X2NjID4gMCAmJiBwcmV2X2NjID49IGNjKSB7XHJcblx0XHRcdGlmIChjYyA9PSAwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gocHJldl9jcCwgLi4uc3RhY2spO1xyXG5cdFx0XHRcdHN0YWNrLmxlbmd0aCA9IDA7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2goY3ApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBjb21wb3NlZCA9IGNvbXBvc2VfcGFpcihwcmV2X2NwLCBjcCk7XHJcblx0XHRcdGlmIChjb21wb3NlZCA+PSAwKSB7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNvbXBvc2VkO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHByZXZfY2MgPT0gMCAmJiBjYyA9PSAwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gocHJldl9jcCk7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2goY3ApO1xyXG5cdFx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAocHJldl9jcCA+PSAwKSB7XHJcblx0XHRyZXQucHVzaChwcmV2X2NwLCAuLi5zdGFjayk7XHRcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuLy8gbm90ZTogY3BzIGNhbiBiZSBpdGVyYWJsZVxyXG5mdW5jdGlvbiBuZmQoY3BzKSB7XHJcblx0cmV0dXJuIGRlY29tcG9zZWQoY3BzKS5tYXAodW5wYWNrX2NwKTtcclxufVxyXG5mdW5jdGlvbiBuZmMoY3BzKSB7XHJcblx0cmV0dXJuIGNvbXBvc2VkX2Zyb21fZGVjb21wb3NlZChkZWNvbXBvc2VkKGNwcykpO1xyXG59XG5cbmNvbnN0IEhZUEhFTiA9IDB4MkQ7XHJcbmNvbnN0IFNUT1AgPSAweDJFO1xyXG5jb25zdCBTVE9QX0NIID0gJy4nO1xyXG5jb25zdCBGRTBGID0gMHhGRTBGO1xyXG5jb25zdCBVTklRVUVfUEggPSAxO1xyXG5cclxuLy8gMjAyMzA5MTM6IHJlcGxhY2UgWy4uLnZdIHdpdGggQXJyYXlfZnJvbSh2KSB0byBhdm9pZCBsYXJnZSBzcHJlYWRzXHJcbmNvbnN0IEFycmF5X2Zyb20gPSB4ID0+IEFycmF5LmZyb20oeCk7IC8vIEFycmF5LmZyb20uYmluZChBcnJheSk7XHJcblxyXG5mdW5jdGlvbiBncm91cF9oYXNfY3AoZywgY3ApIHtcclxuXHQvLyAyMDIzMDkxMzoga2VlcCBwcmltYXJ5IGFuZCBzZWNvbmRhcnkgZGlzdGluY3QgaW5zdGVhZCBvZiBjcmVhdGluZyB2YWxpZCB1bmlvblxyXG5cdHJldHVybiBnLlAuaGFzKGNwKSB8fCBnLlEuaGFzKGNwKTtcclxufVxyXG5cclxuY2xhc3MgRW1vamkgZXh0ZW5kcyBBcnJheSB7XHJcblx0Z2V0IGlzX2Vtb2ppKCkgeyByZXR1cm4gdHJ1ZTsgfSAvLyBmcmVlIHRhZ2dpbmcgc3lzdGVtXHJcbn1cclxuXHJcbmxldCBNQVBQRUQsIElHTk9SRUQsIENNLCBOU00sIEVTQ0FQRSwgTkZDX0NIRUNLLCBHUk9VUFMsIFdIT0xFX1ZBTElELCBXSE9MRV9NQVAsIFZBTElELCBFTU9KSV9MSVNULCBFTU9KSV9ST09UO1xyXG5cclxuZnVuY3Rpb24gaW5pdCgpIHtcclxuXHRpZiAoTUFQUEVEKSByZXR1cm47XHJcblx0XHJcblx0bGV0IHIgPSByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChDT01QUkVTU0VEJDEpO1xyXG5cdGNvbnN0IHJlYWRfc29ydGVkX2FycmF5ID0gKCkgPT4gcmVhZF9zb3J0ZWQocik7XHJcblx0Y29uc3QgcmVhZF9zb3J0ZWRfc2V0ID0gKCkgPT4gbmV3IFNldChyZWFkX3NvcnRlZF9hcnJheSgpKTtcclxuXHJcblx0TUFQUEVEID0gbmV3IE1hcChyZWFkX21hcHBlZChyKSk7IFxyXG5cdElHTk9SRUQgPSByZWFkX3NvcnRlZF9zZXQoKTsgLy8gaWdub3JlZCBjaGFyYWN0ZXJzIGFyZSBub3QgdmFsaWQsIHNvIGp1c3QgcmVhZCByYXcgY29kZXBvaW50c1xyXG5cclxuXHQvKlxyXG5cdC8vIGRpcmVjdCBpbmNsdWRlIGZyb20gcGF5bG9hZCBpcyBzbWFsbGVyIHRoYW4gdGhlIGRlY29tcHJlc3Npb24gY29kZVxyXG5cdGNvbnN0IEZFTkNFRCA9IG5ldyBNYXAocmVhZF9hcnJheV93aGlsZSgoKSA9PiB7XHJcblx0XHRsZXQgY3AgPSByKCk7XHJcblx0XHRpZiAoY3ApIHJldHVybiBbY3AsIHJlYWRfc3RyKHIoKSldO1xyXG5cdH0pKTtcclxuXHQqL1xyXG5cdC8vIDIwMjMwMjE3OiB3ZSBzdGlsbCBuZWVkIGFsbCBDTSBmb3IgcHJvcGVyIGVycm9yIGZvcm1hdHRpbmdcclxuXHQvLyBidXQgbm9ybSBvbmx5IG5lZWRzIE5TTSBzdWJzZXQgdGhhdCBhcmUgcG90ZW50aWFsbHktdmFsaWRcclxuXHRDTSA9IHJlYWRfc29ydGVkX2FycmF5KCk7XHJcblx0TlNNID0gbmV3IFNldChyZWFkX3NvcnRlZF9hcnJheSgpLm1hcChpID0+IENNW2ldKSk7XHJcblx0Q00gPSBuZXcgU2V0KENNKTtcclxuXHRcclxuXHRFU0NBUEUgPSByZWFkX3NvcnRlZF9zZXQoKTsgLy8gY2hhcmFjdGVycyB0aGF0IHNob3VsZCBub3QgYmUgcHJpbnRlZFxyXG5cdE5GQ19DSEVDSyA9IHJlYWRfc29ydGVkX3NldCgpOyAvLyBvbmx5IG5lZWRlZCB0byBpbGx1c3RyYXRlIGVuc190b2tlbml6ZSgpIHRyYW5zZm9ybWF0aW9uc1xyXG5cclxuXHRsZXQgY2h1bmtzID0gcmVhZF9zb3J0ZWRfYXJyYXlzKHIpO1xyXG5cdGxldCB1bnJlc3RyaWN0ZWQgPSByKCk7XHJcblx0Y29uc3QgcmVhZF9jaHVua2VkID0gKCkgPT4gbmV3IFNldChyZWFkX3NvcnRlZF9hcnJheSgpLmZsYXRNYXAoaSA9PiBjaHVua3NbaV0pLmNvbmNhdChyZWFkX3NvcnRlZF9hcnJheSgpKSk7XHJcblx0R1JPVVBTID0gcmVhZF9hcnJheV93aGlsZShpID0+IHtcclxuXHRcdC8vIG1pbmlmaWVyIHByb3BlcnR5IG1hbmdsaW5nIHNlZW1zIHVuc2FmZVxyXG5cdFx0Ly8gc28gdGhlc2UgYXJlIG1hbnVhbGx5IHJlbmFtZWQgdG8gc2luZ2xlIGNoYXJzXHJcblx0XHRsZXQgTiA9IHJlYWRfYXJyYXlfd2hpbGUocikubWFwKHggPT4geCsweDYwKTtcclxuXHRcdGlmIChOLmxlbmd0aCkge1xyXG5cdFx0XHRsZXQgUiA9IGkgPj0gdW5yZXN0cmljdGVkOyAvLyBmaXJzdCBhcmVudCByZXN0cmljdGVkXHJcblx0XHRcdE5bMF0gLT0gMzI7IC8vIGNhcGl0YWxpemVcclxuXHRcdFx0TiA9IHN0cl9mcm9tX2NwcyhOKTtcclxuXHRcdFx0aWYgKFIpIE49YFJlc3RyaWN0ZWRbJHtOfV1gO1xyXG5cdFx0XHRsZXQgUCA9IHJlYWRfY2h1bmtlZCgpOyAvLyBwcmltYXJ5XHJcblx0XHRcdGxldCBRID0gcmVhZF9jaHVua2VkKCk7IC8vIHNlY29uZGFyeVxyXG5cdFx0XHRsZXQgTSA9ICFyKCk7IC8vIG5vdC13aGl0ZWxpc3RlZCwgY2hlY2sgZm9yIE5TTVxyXG5cdFx0XHQvLyAqKiogdGhpcyBjb2RlIGN1cnJlbnRseSBpc24ndCBuZWVkZWQgKioqXHJcblx0XHRcdC8qXHJcblx0XHRcdGxldCBWID0gWy4uLlAsIC4uLlFdLnNvcnQoKGEsIGIpID0+IGEtYik7IC8vIGRlcml2ZTogc29ydGVkIHZhbGlkXHJcblx0XHRcdGxldCBNID0gcigpLTE7IC8vIG51bWJlciBvZiBjb21iaW5pbmcgbWFya1xyXG5cdFx0XHRpZiAoTSA8IDApIHsgLy8gd2hpdGVsaXN0ZWRcclxuXHRcdFx0XHRNID0gbmV3IE1hcChyZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdFx0XHRcdGxldCBpID0gcigpO1xyXG5cdFx0XHRcdFx0aWYgKGkpIHJldHVybiBbVltpLTFdLCByZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdFx0XHRcdFx0bGV0IHYgPSByZWFkX2FycmF5X3doaWxlKHIpO1xyXG5cdFx0XHRcdFx0XHRpZiAodi5sZW5ndGgpIHJldHVybiB2Lm1hcCh4ID0+IHgtMSk7XHJcblx0XHRcdFx0XHR9KV07XHJcblx0XHRcdFx0fSkpO1xyXG5cdFx0XHR9Ki9cclxuXHRcdFx0cmV0dXJuIHtOLCBQLCBRLCBNLCBSfTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0Ly8gZGVjb2RlIGNvbXByZXNzZWQgd2hvbGVzXHJcblx0V0hPTEVfVkFMSUQgPSByZWFkX3NvcnRlZF9zZXQoKTtcclxuXHRXSE9MRV9NQVAgPSBuZXcgTWFwKCk7XHJcblx0bGV0IHdob2xlcyA9IHJlYWRfc29ydGVkX2FycmF5KCkuY29uY2F0KEFycmF5X2Zyb20oV0hPTEVfVkFMSUQpKS5zb3J0KChhLCBiKSA9PiBhLWIpOyAvLyBtdXN0IGJlIHNvcnRlZFxyXG5cdHdob2xlcy5mb3JFYWNoKChjcCwgaSkgPT4ge1xyXG5cdFx0bGV0IGQgPSByKCk7IFxyXG5cdFx0bGV0IHcgPSB3aG9sZXNbaV0gPSBkID8gd2hvbGVzW2ktZF0gOiB7VjogW10sIE06IG5ldyBNYXAoKX07XHJcblx0XHR3LlYucHVzaChjcCk7IC8vIGFkZCB0byBtZW1iZXIgc2V0XHJcblx0XHRpZiAoIVdIT0xFX1ZBTElELmhhcyhjcCkpIHtcclxuXHRcdFx0V0hPTEVfTUFQLnNldChjcCwgdyk7ICAvLyByZWdpc3RlciB3aXRoIHdob2xlIG1hcFxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvLyBjb21wdXRlIGNvbmZ1c2FibGUtZXh0ZW50IGNvbXBsZW1lbnRzXHJcblx0Zm9yIChsZXQge1YsIE19IG9mIG5ldyBTZXQoV0hPTEVfTUFQLnZhbHVlcygpKSkge1xyXG5cdFx0Ly8gY29ubmVjdCBhbGwgZ3JvdXBzIHRoYXQgaGF2ZSBlYWNoIHdob2xlIGNoYXJhY3RlclxyXG5cdFx0bGV0IHJlY3MgPSBbXTtcclxuXHRcdGZvciAobGV0IGNwIG9mIFYpIHtcclxuXHRcdFx0bGV0IGdzID0gR1JPVVBTLmZpbHRlcihnID0+IGdyb3VwX2hhc19jcChnLCBjcCkpO1xyXG5cdFx0XHRsZXQgcmVjID0gcmVjcy5maW5kKCh7R30pID0+IGdzLnNvbWUoZyA9PiBHLmhhcyhnKSkpO1xyXG5cdFx0XHRpZiAoIXJlYykge1xyXG5cdFx0XHRcdHJlYyA9IHtHOiBuZXcgU2V0KCksIFY6IFtdfTtcclxuXHRcdFx0XHRyZWNzLnB1c2gocmVjKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZWMuVi5wdXNoKGNwKTtcclxuXHRcdFx0Z3MuZm9yRWFjaChnID0+IHJlYy5HLmFkZChnKSk7XHJcblx0XHR9XHJcblx0XHQvLyBwZXIgY2hhcmFjdGVyIGNhY2hlIGdyb3VwcyB3aGljaCBhcmUgbm90IGEgbWVtYmVyIG9mIHRoZSBleHRlbnRcclxuXHRcdGxldCB1bmlvbiA9IHJlY3MuZmxhdE1hcCh4ID0+IEFycmF5X2Zyb20oeC5HKSk7XHJcblx0XHRmb3IgKGxldCB7RywgVn0gb2YgcmVjcykge1xyXG5cdFx0XHRsZXQgY29tcGxlbWVudCA9IG5ldyBTZXQodW5pb24uZmlsdGVyKGcgPT4gIUcuaGFzKGcpKSk7XHJcblx0XHRcdGZvciAobGV0IGNwIG9mIFYpIHtcclxuXHRcdFx0XHRNLnNldChjcCwgY29tcGxlbWVudCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIGNvbXB1dGUgdmFsaWQgc2V0XHJcblx0bGV0IHVuaW9uID0gbmV3IFNldCgpOyAvLyBleGlzdHMgaW4gMSsgZ3JvdXBzXHJcblx0bGV0IG11bHRpID0gbmV3IFNldCgpOyAvLyBleGlzdHMgaW4gMisgZ3JvdXBzXHJcblx0Y29uc3QgYWRkX3RvX3VuaW9uID0gY3AgPT4gdW5pb24uaGFzKGNwKSA/IG11bHRpLmFkZChjcCkgOiB1bmlvbi5hZGQoY3ApO1xyXG5cdGZvciAobGV0IGcgb2YgR1JPVVBTKSB7XHJcblx0XHRmb3IgKGxldCBjcCBvZiBnLlApIGFkZF90b191bmlvbihjcCk7XHJcblx0XHRmb3IgKGxldCBjcCBvZiBnLlEpIGFkZF90b191bmlvbihjcCk7XHJcblx0fVxyXG5cdC8vIGR1YWwgcHVycG9zZSBXSE9MRV9NQVA6IHJldHVybiBwbGFjZWhvbGRlciBpZiB1bmlxdWUgbm9uLWNvbmZ1c2FibGVcclxuXHRmb3IgKGxldCBjcCBvZiB1bmlvbikge1xyXG5cdFx0aWYgKCFXSE9MRV9NQVAuaGFzKGNwKSAmJiAhbXVsdGkuaGFzKGNwKSkge1xyXG5cdFx0XHRXSE9MRV9NQVAuc2V0KGNwLCBVTklRVUVfUEgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRWQUxJRCA9IG5ldyBTZXQoQXJyYXlfZnJvbSh1bmlvbikuY29uY2F0KEFycmF5X2Zyb20obmZkKHVuaW9uKSkpKTsgLy8gcG9zc2libHkgdmFsaWRcclxuXHJcblx0Ly8gZGVjb2RlIGVtb2ppXHJcblx0Ly8gMjAyMzA3MTk6IGVtb2ppIGFyZSBub3cgZnVsbHktZXhwYW5kZWQgdG8gYXZvaWQgcXVpcmsgbG9naWMgXHJcblx0RU1PSklfTElTVCA9IHJlYWRfdHJpZShyKS5tYXAodiA9PiBFbW9qaS5mcm9tKHYpKS5zb3J0KGNvbXBhcmVfYXJyYXlzKTtcclxuXHRFTU9KSV9ST09UID0gbmV3IE1hcCgpOyAvLyB0aGlzIGhhcyBhcHByb3ggN0sgbm9kZXMgKDIrIHBlciBlbW9qaSlcclxuXHRmb3IgKGxldCBjcHMgb2YgRU1PSklfTElTVCkge1xyXG5cdFx0Ly8gMjAyMzA3MTk6IGNoYW5nZSB0byAqc2xpZ2h0bHkqIHN0cmljdGVyIGFsZ29yaXRobSB3aGljaCBkaXNhbGxvd3MgXHJcblx0XHQvLyBpbnNlcnRpb24gb2YgbWlzcGxhY2VkIEZFMEYgaW4gZW1vamkgc2VxdWVuY2VzIChtYXRjaGluZyBFTlNJUC0xNSlcclxuXHRcdC8vIGV4YW1wbGU6IGJlYXV0aWZpZWQgW0EgQl0gKGVnLiBmbGFnIGVtb2ppKSBcclxuXHRcdC8vICBiZWZvcmU6IGFsbG93OiBbQSBGRTBGIEJdLCBlcnJvcjogW0EgRkUwRiBGRTBGIEJdIFxyXG5cdFx0Ly8gICBhZnRlcjogZXJyb3I6IGJvdGhcclxuXHRcdC8vIG5vdGU6IHRoaXMgY29kZSBub3cgbWF0Y2hlcyBFTlNOb3JtYWxpemUue2NzLGphdmF9IGxvZ2ljXHJcblx0XHRsZXQgcHJldiA9IFtFTU9KSV9ST09UXTtcclxuXHRcdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0XHRsZXQgbmV4dCA9IHByZXYubWFwKG5vZGUgPT4ge1xyXG5cdFx0XHRcdGxldCBjaGlsZCA9IG5vZGUuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAoIWNoaWxkKSB7XHJcblx0XHRcdFx0XHQvLyBzaG91bGQgdGhpcyBiZSBvYmplY3Q/IFxyXG5cdFx0XHRcdFx0Ly8gKG1vc3QgaGF2ZSAxLTIgaXRlbXMsIGZldyBoYXZlIG1hbnkpXHJcblx0XHRcdFx0XHQvLyAyMDIzMDcxOTogbm8sIHY4IGRlZmF1bHQgbWFwIGlzIDQ/XHJcblx0XHRcdFx0XHRjaGlsZCA9IG5ldyBNYXAoKTtcclxuXHRcdFx0XHRcdG5vZGUuc2V0KGNwLCBjaGlsZCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBjaGlsZDtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGlmIChjcCA9PT0gRkUwRikge1xyXG5cdFx0XHRcdHByZXYucHVzaCguLi5uZXh0KTsgLy8gbGVzcyB0aGFuIDIwIGVsZW1lbnRzXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cHJldiA9IG5leHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGZvciAobGV0IHggb2YgcHJldikge1xyXG5cdFx0XHR4LlYgPSBjcHM7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vLyBpZiBlc2NhcGVkOiB7SEVYfVxyXG4vLyAgICAgICBlbHNlOiBcInhcIiB7SEVYfVxyXG5mdW5jdGlvbiBxdW90ZWRfY3AoY3ApIHtcclxuXHRyZXR1cm4gKHNob3VsZF9lc2NhcGUoY3ApID8gJycgOiBgJHtiaWRpX3FxKHNhZmVfc3RyX2Zyb21fY3BzKFtjcF0pKX0gYCkgKyBxdW90ZV9jcChjcCk7XHJcbn1cclxuXHJcbi8vIDIwMjMwMjExOiBzb21lIG1lc3NhZ2VzIGNhbiBiZSBtaXhlZC1kaXJlY3Rpb25hbCBhbmQgcmVzdWx0IGluIHNwaWxsb3ZlclxyXG4vLyB1c2UgMjAwRSBhZnRlciBhIHF1b3RlZCBzdHJpbmcgdG8gZm9yY2UgdGhlIHJlbWFpbmRlciBvZiBhIHN0cmluZyBmcm9tIFxyXG4vLyBhY3F1cmluZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBxdW90ZVxyXG4vLyBodHRwczovL3d3dy53My5vcmcvSW50ZXJuYXRpb25hbC9xdWVzdGlvbnMvcWEtYmlkaS11bmljb2RlLWNvbnRyb2xzI2V4Y2VwdGlvbnNcclxuZnVuY3Rpb24gYmlkaV9xcShzKSB7XHJcblx0cmV0dXJuIGBcIiR7c31cIlxcdTIwMEVgOyAvLyBzdHJvbmcgTFRSXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrX2xhYmVsX2V4dGVuc2lvbihjcHMpIHtcclxuXHRpZiAoY3BzLmxlbmd0aCA+PSA0ICYmIGNwc1syXSA9PSBIWVBIRU4gJiYgY3BzWzNdID09IEhZUEhFTikge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGxhYmVsIGV4dGVuc2lvbjogXCIke3N0cl9mcm9tX2NwcyhjcHMuc2xpY2UoMCwgNCkpfVwiYCk7XHJcblx0fVxyXG59XHJcbmZ1bmN0aW9uIGNoZWNrX2xlYWRpbmdfdW5kZXJzY29yZShjcHMpIHtcclxuXHRjb25zdCBVTkRFUlNDT1JFID0gMHg1RjtcclxuXHRmb3IgKGxldCBpID0gY3BzLmxhc3RJbmRleE9mKFVOREVSU0NPUkUpOyBpID4gMDsgKSB7XHJcblx0XHRpZiAoY3BzWy0taV0gIT09IFVOREVSU0NPUkUpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCd1bmRlcnNjb3JlIGFsbG93ZWQgb25seSBhdCBzdGFydCcpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4vLyBjaGVjayB0aGF0IGEgZmVuY2VkIGNwIGlzIG5vdCBsZWFkaW5nLCB0cmFpbGluZywgb3IgdG91Y2hpbmcgYW5vdGhlciBmZW5jZWQgY3BcclxuZnVuY3Rpb24gY2hlY2tfZmVuY2VkKGNwcykge1xyXG5cdGxldCBjcCA9IGNwc1swXTtcclxuXHRsZXQgcHJldiA9IEZFTkNFRC5nZXQoY3ApO1xyXG5cdGlmIChwcmV2KSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYGxlYWRpbmcgJHtwcmV2fWApO1xyXG5cdGxldCBuID0gY3BzLmxlbmd0aDtcclxuXHRsZXQgbGFzdCA9IC0xOyAvLyBwcmV2ZW50cyB0cmFpbGluZyBmcm9tIHRocm93aW5nXHJcblx0Zm9yIChsZXQgaSA9IDE7IGkgPCBuOyBpKyspIHtcclxuXHRcdGNwID0gY3BzW2ldO1xyXG5cdFx0bGV0IG1hdGNoID0gRkVOQ0VELmdldChjcCk7XHJcblx0XHRpZiAobWF0Y2gpIHtcclxuXHRcdFx0Ly8gc2luY2UgY3BzWzBdIGlzbid0IGZlbmNlZCwgY3BzWzFdIGNhbm5vdCB0aHJvd1xyXG5cdFx0XHRpZiAobGFzdCA9PSBpKSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYCR7cHJldn0gKyAke21hdGNofWApO1xyXG5cdFx0XHRsYXN0ID0gaSArIDE7XHJcblx0XHRcdHByZXYgPSBtYXRjaDtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGxhc3QgPT0gbikgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGB0cmFpbGluZyAke3ByZXZ9YCk7XHJcbn1cclxuXHJcbi8vIGNyZWF0ZSBhIHNhZmUgdG8gcHJpbnQgc3RyaW5nIFxyXG4vLyBpbnZpc2libGVzIGFyZSBlc2NhcGVkXHJcbi8vIGxlYWRpbmcgY20gdXNlcyBwbGFjZWhvbGRlclxyXG4vLyBxdW90ZXIoY3ApID0+IHN0cmluZywgZWcuIDMwMDAgPT4gXCJ7MzAwMH1cIlxyXG4vLyBub3RlOiBpbiBodG1sLCB5b3UnZCBjYWxsIHRoaXMgZnVuY3Rpb24gdGhlbiByZXBsYWNlIFs8PiZdIHdpdGggZW50aXRpZXNcclxuZnVuY3Rpb24gc2FmZV9zdHJfZnJvbV9jcHMoY3BzLCBxdW90ZXIgPSBxdW90ZV9jcCkge1xyXG5cdC8vaWYgKE51bWJlci5pc0ludGVnZXIoY3BzKSkgY3BzID0gW2Nwc107XHJcblx0Ly9pZiAoIUFycmF5LmlzQXJyYXkoY3BzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgY29kZXBvaW50c2ApO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRpZiAoaXNfY29tYmluaW5nX21hcmsoY3BzWzBdKSkgYnVmLnB1c2goJ+KXjCcpO1xyXG5cdGxldCBwcmV2ID0gMDtcclxuXHRsZXQgbiA9IGNwcy5sZW5ndGg7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdGxldCBjcCA9IGNwc1tpXTtcclxuXHRcdGlmIChzaG91bGRfZXNjYXBlKGNwKSkge1xyXG5cdFx0XHRidWYucHVzaChzdHJfZnJvbV9jcHMoY3BzLnNsaWNlKHByZXYsIGkpKSk7XHJcblx0XHRcdGJ1Zi5wdXNoKHF1b3RlcihjcCkpO1xyXG5cdFx0XHRwcmV2ID0gaSArIDE7XHJcblx0XHR9XHJcblx0fVxyXG5cdGJ1Zi5wdXNoKHN0cl9mcm9tX2NwcyhjcHMuc2xpY2UocHJldiwgbikpKTtcclxuXHRyZXR1cm4gYnVmLmpvaW4oJycpO1xyXG59XHJcblxyXG4vLyBub3RlOiBzZXQocykgY2Fubm90IGJlIGV4cG9zZWQgYmVjYXVzZSB0aGV5IGNhbiBiZSBtb2RpZmllZFxyXG4vLyBub3RlOiBPYmplY3QuZnJlZXplKCkgZG9lc24ndCB3b3JrXHJcbmZ1bmN0aW9uIGlzX2NvbWJpbmluZ19tYXJrKGNwKSB7XHJcblx0aW5pdCgpO1xyXG5cdHJldHVybiBDTS5oYXMoY3ApO1xyXG59XHJcbmZ1bmN0aW9uIHNob3VsZF9lc2NhcGUoY3ApIHtcclxuXHRpbml0KCk7XHJcblx0cmV0dXJuIEVTQ0FQRS5oYXMoY3ApO1xyXG59XHJcblxyXG4vLyByZXR1cm4gYWxsIHN1cHBvcnRlZCBlbW9qaSBhcyBmdWxseS1xdWFsaWZpZWQgZW1vamkgXHJcbi8vIG9yZGVyZWQgYnkgbGVuZ3RoIHRoZW4gbGV4aWNvZ3JhcGhpYyBcclxuZnVuY3Rpb24gZW5zX2Vtb2ppKCkge1xyXG5cdGluaXQoKTtcclxuXHRyZXR1cm4gRU1PSklfTElTVC5tYXAoeCA9PiB4LnNsaWNlKCkpOyAvLyBlbW9qaSBhcmUgZXhwb3NlZCBzbyBjb3B5XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19ub3JtYWxpemVfZnJhZ21lbnQoZnJhZywgZGVjb21wb3NlKSB7XHJcblx0aW5pdCgpO1xyXG5cdGxldCBuZiA9IGRlY29tcG9zZSA/IG5mZCA6IG5mYztcclxuXHRyZXR1cm4gZnJhZy5zcGxpdChTVE9QX0NIKS5tYXAobGFiZWwgPT4gc3RyX2Zyb21fY3BzKHRva2Vuc19mcm9tX3N0cihleHBsb2RlX2NwKGxhYmVsKSwgbmYsIGZpbHRlcl9mZTBmKS5mbGF0KCkpKS5qb2luKFNUT1BfQ0gpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfbm9ybWFsaXplKG5hbWUpIHtcclxuXHRyZXR1cm4gZmxhdHRlbihzcGxpdChuYW1lLCBuZmMsIGZpbHRlcl9mZTBmKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19iZWF1dGlmeShuYW1lKSB7XHJcblx0bGV0IGxhYmVscyA9IHNwbGl0KG5hbWUsIG5mYywgeCA9PiB4KTsgLy8gZW1vamkgbm90IGV4cG9zZWRcclxuXHRmb3IgKGxldCB7dHlwZSwgb3V0cHV0LCBlcnJvcn0gb2YgbGFiZWxzKSB7XHJcblx0XHRpZiAoZXJyb3IpIGJyZWFrOyAvLyBmbGF0dGVuIHdpbGwgdGhyb3dcclxuXHJcblx0XHQvLyByZXBsYWNlIGxlYWRpbmcvdHJhaWxpbmcgaHlwaGVuXHJcblx0XHQvLyAyMDIzMDEyMTogY29uc2lkZXIgYmVhdXRpZmluZyBhbGwgb3IgbGVhZGluZy90cmFpbGluZyBoeXBoZW4gdG8gdW5pY29kZSB2YXJpYW50XHJcblx0XHQvLyBub3QgZXhhY3RseSB0aGUgc2FtZSBpbiBldmVyeSBmb250LCBidXQgdmVyeSBzaW1pbGFyOiBcIi1cIiB2cyBcIuKAkFwiXHJcblx0XHQvKlxyXG5cdFx0Y29uc3QgVU5JQ09ERV9IWVBIRU4gPSAweDIwMTA7XHJcblx0XHQvLyBtYXliZSB0aGlzIHNob3VsZCByZXBsYWNlIGFsbCBmb3IgdmlzdWFsIGNvbnNpc3RhbmN5P1xyXG5cdFx0Ly8gYG5vZGUgdG9vbHMvcmVnLWNvdW50LmpzIHJlZ2V4IF4tXFx7MixcXH1gID0+IDU5MlxyXG5cdFx0Ly9mb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7IGkrKykgaWYgKG91dHB1dFtpXSA9PSAweDJEKSBvdXRwdXRbaV0gPSAweDIwMTA7XHJcblx0XHRpZiAob3V0cHV0WzBdID09IEhZUEhFTikgb3V0cHV0WzBdID0gVU5JQ09ERV9IWVBIRU47XHJcblx0XHRsZXQgZW5kID0gb3V0cHV0Lmxlbmd0aC0xO1xyXG5cdFx0aWYgKG91dHB1dFtlbmRdID09IEhZUEhFTikgb3V0cHV0W2VuZF0gPSBVTklDT0RFX0hZUEhFTjtcclxuXHRcdCovXHJcblx0XHQvLyAyMDIzMDEyMzogV0hBVFdHIFVSTCB1c2VzIFwiQ2hlY2tIeXBoZW5zXCIgZmFsc2VcclxuXHRcdC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jaWRuYVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBldGhlcmV1bSBzeW1ib2xcclxuXHRcdC8vIM6+ID0+IM6eIGlmIG5vdCBncmVla1xyXG5cdFx0aWYgKHR5cGUgIT09ICdHcmVlaycpIHsgXHJcblx0XHRcdGxldCBwcmV2ID0gMDtcclxuXHRcdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0XHRsZXQgbmV4dCA9IG91dHB1dC5pbmRleE9mKDB4M0JFLCBwcmV2KTtcclxuXHRcdFx0XHRpZiAobmV4dCA8IDApIGJyZWFrO1xyXG5cdFx0XHRcdG91dHB1dFtuZXh0XSA9IDB4MzlFOyBcclxuXHRcdFx0XHRwcmV2ID0gbmV4dCArIDE7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyAyMDIyMTIxMzogZml4ZXMgYmlkaSBzdWJkb21haW4gaXNzdWUsIGJ1dCBicmVha3MgaW52YXJpYW50ICgyMDBFIGlzIGRpc2FsbG93ZWQpXHJcblx0XHQvLyBjb3VsZCBiZSBmaXhlZCB3aXRoIHNwZWNpYWwgY2FzZSBmb3I6IDJEICguKSArIDIwMEUgKExUUilcclxuXHRcdC8vIGh0dHBzOi8vZGlzY3Vzcy5lbnMuZG9tYWlucy90L2JpZGktbGFiZWwtb3JkZXJpbmctc3Bvb2YvMTU4MjRcclxuXHRcdC8vb3V0cHV0LnNwbGljZSgwLCAwLCAweDIwMEUpO1xyXG5cdH1cclxuXHRyZXR1cm4gZmxhdHRlbihsYWJlbHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfc3BsaXQobmFtZSwgcHJlc2VydmVfZW1vamkpIHtcclxuXHRyZXR1cm4gc3BsaXQobmFtZSwgbmZjLCBwcmVzZXJ2ZV9lbW9qaSA/IHggPT4geC5zbGljZSgpIDogZmlsdGVyX2ZlMGYpOyAvLyBlbW9qaSBhcmUgZXhwb3NlZCBzbyBjb3B5XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNwbGl0KG5hbWUsIG5mLCBlZikge1xyXG5cdGlmICghbmFtZSkgcmV0dXJuIFtdOyAvLyAyMDIzMDcxOTogZW1wdHkgbmFtZSBhbGxvd2FuY2VcclxuXHRpbml0KCk7XHJcblx0bGV0IG9mZnNldCA9IDA7XHJcblx0Ly8gaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyNDYvI1ZhbGlkaXR5X0NyaXRlcmlhXHJcblx0Ly8gNC4pIFwiVGhlIGxhYmVsIG11c3Qgbm90IGNvbnRhaW4gYSBVKzAwMkUgKCAuICkgRlVMTCBTVE9QLlwiXHJcblx0cmV0dXJuIG5hbWUuc3BsaXQoU1RPUF9DSCkubWFwKGxhYmVsID0+IHtcclxuXHRcdGxldCBpbnB1dCA9IGV4cGxvZGVfY3AobGFiZWwpO1xyXG5cdFx0bGV0IGluZm8gPSB7XHJcblx0XHRcdGlucHV0LFxyXG5cdFx0XHRvZmZzZXQsIC8vIGNvZGVwb2ludCwgbm90IHN1YnN0cmluZyFcclxuXHRcdH07XHJcblx0XHRvZmZzZXQgKz0gaW5wdXQubGVuZ3RoICsgMTsgLy8gKyBzdG9wXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyAxLikgXCJUaGUgbGFiZWwgbXVzdCBiZSBpbiBVbmljb2RlIE5vcm1hbGl6YXRpb24gRm9ybSBORkNcIlxyXG5cdFx0XHRsZXQgdG9rZW5zID0gaW5mby50b2tlbnMgPSB0b2tlbnNfZnJvbV9zdHIoaW5wdXQsIG5mLCBlZik7XHJcblx0XHRcdGxldCB0b2tlbl9jb3VudCA9IHRva2Vucy5sZW5ndGg7XHJcblx0XHRcdGxldCB0eXBlO1xyXG5cdFx0XHRpZiAoIXRva2VuX2NvdW50KSB7IC8vIHRoZSBsYWJlbCB3YXMgZWZmZWN0aXZlbHkgZW1wdHkgKGNvdWxkIG9mIGhhZCBpZ25vcmVkIGNoYXJhY3RlcnMpXHJcblx0XHRcdFx0Ly9ub3JtID0gW107XHJcblx0XHRcdFx0Ly90eXBlID0gJ05vbmUnOyAvLyB1c2UgdGhpcyBpbnN0ZWFkIG9mIG5leHQgbWF0Y2gsIFwiQVNDSUlcIlxyXG5cdFx0XHRcdC8vIDIwMjMwMTIwOiBjaGFuZ2UgdG8gc3RyaWN0XHJcblx0XHRcdFx0Ly8gaHR0cHM6Ly9kaXNjdXNzLmVucy5kb21haW5zL3QvZW5zLW5hbWUtbm9ybWFsaXphdGlvbi0ybmQvMTQ1NjQvNTlcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGVtcHR5IGxhYmVsYCk7XHJcblx0XHRcdH0gXHJcblx0XHRcdGxldCBub3JtID0gaW5mby5vdXRwdXQgPSB0b2tlbnMuZmxhdCgpO1xyXG5cdFx0XHRjaGVja19sZWFkaW5nX3VuZGVyc2NvcmUobm9ybSk7XHJcblx0XHRcdGxldCBlbW9qaSA9IGluZm8uZW1vamkgPSB0b2tlbl9jb3VudCA+IDEgfHwgdG9rZW5zWzBdLmlzX2Vtb2ppOyAvLyBzYW1lIGFzOiB0b2tlbnMuc29tZSh4ID0+IHguaXNfZW1vamkpO1xyXG5cdFx0XHRpZiAoIWVtb2ppICYmIG5vcm0uZXZlcnkoY3AgPT4gY3AgPCAweDgwKSkgeyAvLyBzcGVjaWFsIGNhc2UgZm9yIGFzY2lpXHJcblx0XHRcdFx0Ly8gMjAyMzAxMjM6IG1hdGNoZXMgbWF0Y2hlcyBXSEFUV0csIHNlZSBub3RlIDMuM1xyXG5cdFx0XHRcdGNoZWNrX2xhYmVsX2V4dGVuc2lvbihub3JtKTsgLy8gb25seSBuZWVkZWQgZm9yIGFzY2lpXHJcblx0XHRcdFx0Ly8gY2FudCBoYXZlIGZlbmNlZFxyXG5cdFx0XHRcdC8vIGNhbnQgaGF2ZSBjbVxyXG5cdFx0XHRcdC8vIGNhbnQgaGF2ZSB3aG9sZXNcclxuXHRcdFx0XHQvLyBzZWUgZGVyaXZlOiBcIkZhc3RwYXRoIEFTQ0lJXCJcclxuXHRcdFx0XHR0eXBlID0gJ0FTQ0lJJztcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY2hhcnMgPSB0b2tlbnMuZmxhdE1hcCh4ID0+IHguaXNfZW1vamkgPyBbXSA6IHgpOyAvLyBhbGwgb2YgdGhlIG5mYyB0b2tlbnMgY29uY2F0IHRvZ2V0aGVyXHJcblx0XHRcdFx0aWYgKCFjaGFycy5sZW5ndGgpIHsgLy8gdGhlcmVzIG5vIHRleHQsIGp1c3QgZW1vamlcclxuXHRcdFx0XHRcdHR5cGUgPSAnRW1vamknO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvLyA1LikgXCJUaGUgbGFiZWwgbXVzdCBub3QgYmVnaW4gd2l0aCBhIGNvbWJpbmluZyBtYXJrLCB0aGF0IGlzOiBHZW5lcmFsX0NhdGVnb3J5PU1hcmsuXCJcclxuXHRcdFx0XHRcdGlmIChDTS5oYXMobm9ybVswXSkpIHRocm93IGVycm9yX3BsYWNlbWVudCgnbGVhZGluZyBjb21iaW5pbmcgbWFyaycpO1xyXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCB0b2tlbl9jb3VudDsgaSsrKSB7IC8vIHdlJ3ZlIGFscmVhZHkgY2hlY2tlZCB0aGUgZmlyc3QgdG9rZW5cclxuXHRcdFx0XHRcdFx0bGV0IGNwcyA9IHRva2Vuc1tpXTtcclxuXHRcdFx0XHRcdFx0aWYgKCFjcHMuaXNfZW1vamkgJiYgQ00uaGFzKGNwc1swXSkpIHsgLy8gZXZlcnkgdGV4dCB0b2tlbiBoYXMgZW1vamkgbmVpZ2hib3JzLCBlZy4gRXRFRUV0RXQuLi5cclxuXHRcdFx0XHRcdFx0XHQvLyBiaWRpX3FxKCkgbm90IG5lZWRlZCBzaW5jZSBlbW9qaSBpcyBMVFIgYW5kIGNwcyBpcyBhIENNXHJcblx0XHRcdFx0XHRcdFx0dGhyb3cgZXJyb3JfcGxhY2VtZW50KGBlbW9qaSArIGNvbWJpbmluZyBtYXJrOiBcIiR7c3RyX2Zyb21fY3BzKHRva2Vuc1tpLTFdKX0gKyAke3NhZmVfc3RyX2Zyb21fY3BzKFtjcHNbMF1dKX1cImApOyBcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Y2hlY2tfZmVuY2VkKG5vcm0pO1xyXG5cdFx0XHRcdFx0bGV0IHVuaXF1ZSA9IEFycmF5X2Zyb20obmV3IFNldChjaGFycykpO1xyXG5cdFx0XHRcdFx0bGV0IFtnXSA9IGRldGVybWluZV9ncm91cCh1bmlxdWUpOyAvLyB0YWtlIHRoZSBmaXJzdCBtYXRjaFxyXG5cdFx0XHRcdFx0Ly8gc2VlIGRlcml2ZTogXCJNYXRjaGluZyBHcm91cHMgaGF2ZSBTYW1lIENNIFN0eWxlXCJcclxuXHRcdFx0XHRcdC8vIGFsdGVybmF0aXZlOiBjb3VsZCBmb3JtIGEgaHlicmlkIHR5cGU6IExhdGluL0phcGFuZXNlLy4uLlx0XHJcblx0XHRcdFx0XHRjaGVja19ncm91cChnLCBjaGFycyk7IC8vIG5lZWQgdGV4dCBpbiBvcmRlclxyXG5cdFx0XHRcdFx0Y2hlY2tfd2hvbGUoZywgdW5pcXVlKTsgLy8gb25seSBuZWVkIHVuaXF1ZSB0ZXh0IChvcmRlciB3b3VsZCBiZSByZXF1aXJlZCBmb3IgbXVsdGlwbGUtY2hhciBjb25mdXNhYmxlcylcclxuXHRcdFx0XHRcdHR5cGUgPSBnLk47XHJcblx0XHRcdFx0XHQvLyAyMDIzMDEyMTogY29uc2lkZXIgZXhwb3NpbmcgcmVzdHJpY3RlZCBmbGFnXHJcblx0XHRcdFx0XHQvLyBpdCdzIHNpbXBsZXIgdG8ganVzdCBjaGVjayBmb3IgJ1Jlc3RyaWN0ZWQnXHJcblx0XHRcdFx0XHQvLyBvciBldmVuIGJldHRlcjogdHlwZS5lbmRzV2l0aCgnXScpXHJcblx0XHRcdFx0XHQvL2lmIChnLlIpIGluZm8ucmVzdHJpY3RlZCA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGluZm8udHlwZSA9IHR5cGU7XHJcblx0XHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdFx0aW5mby5lcnJvciA9IGVycjsgLy8gdXNlIGZ1bGwgZXJyb3Igb2JqZWN0XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gaW5mbztcclxuXHR9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tfd2hvbGUoZ3JvdXAsIHVuaXF1ZSkge1xyXG5cdGxldCBtYWtlcjtcclxuXHRsZXQgc2hhcmVkID0gW107XHJcblx0Zm9yIChsZXQgY3Agb2YgdW5pcXVlKSB7XHJcblx0XHRsZXQgd2hvbGUgPSBXSE9MRV9NQVAuZ2V0KGNwKTtcclxuXHRcdGlmICh3aG9sZSA9PT0gVU5JUVVFX1BIKSByZXR1cm47IC8vIHVuaXF1ZSwgbm9uLWNvbmZ1c2FibGVcclxuXHRcdGlmICh3aG9sZSkge1xyXG5cdFx0XHRsZXQgc2V0ID0gd2hvbGUuTS5nZXQoY3ApOyAvLyBncm91cHMgd2hpY2ggaGF2ZSBhIGNoYXJhY3RlciB0aGF0IGxvb2stbGlrZSB0aGlzIGNoYXJhY3RlclxyXG5cdFx0XHRtYWtlciA9IG1ha2VyID8gbWFrZXIuZmlsdGVyKGcgPT4gc2V0LmhhcyhnKSkgOiBBcnJheV9mcm9tKHNldCk7XHJcblx0XHRcdGlmICghbWFrZXIubGVuZ3RoKSByZXR1cm47IC8vIGNvbmZ1c2FibGUgaW50ZXJzZWN0aW9uIGlzIGVtcHR5XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzaGFyZWQucHVzaChjcCk7IFxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAobWFrZXIpIHtcclxuXHRcdC8vIHdlIGhhdmUgMSsgY29uZnVzYWJsZVxyXG5cdFx0Ly8gY2hlY2sgaWYgYW55IG9mIHRoZSByZW1haW5pbmcgZ3JvdXBzXHJcblx0XHQvLyBjb250YWluIHRoZSBzaGFyZWQgY2hhcmFjdGVycyB0b29cclxuXHRcdGZvciAobGV0IGcgb2YgbWFrZXIpIHtcclxuXHRcdFx0aWYgKHNoYXJlZC5ldmVyeShjcCA9PiBncm91cF9oYXNfY3AoZywgY3ApKSkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgd2hvbGUtc2NyaXB0IGNvbmZ1c2FibGU6ICR7Z3JvdXAuTn0vJHtnLk59YCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbi8vIGFzc3VtcHRpb246IHVuaXF1ZS5zaXplID4gMFxyXG4vLyByZXR1cm5zIGxpc3Qgb2YgbWF0Y2hpbmcgZ3JvdXBzXHJcbmZ1bmN0aW9uIGRldGVybWluZV9ncm91cCh1bmlxdWUpIHtcclxuXHRsZXQgZ3JvdXBzID0gR1JPVVBTO1xyXG5cdGZvciAobGV0IGNwIG9mIHVuaXF1ZSkge1xyXG5cdFx0Ly8gbm90ZTogd2UgbmVlZCB0byBkb2RnZSBDTSB0aGF0IGFyZSB3aGl0ZWxpc3RlZFxyXG5cdFx0Ly8gYnV0IHRoYXQgY29kZSBpc24ndCBjdXJyZW50bHkgbmVjZXNzYXJ5XHJcblx0XHRsZXQgZ3MgPSBncm91cHMuZmlsdGVyKGcgPT4gZ3JvdXBfaGFzX2NwKGcsIGNwKSk7XHJcblx0XHRpZiAoIWdzLmxlbmd0aCkge1xyXG5cdFx0XHRpZiAoIUdST1VQUy5zb21lKGcgPT4gZ3JvdXBfaGFzX2NwKGcsIGNwKSkpIHsgXHJcblx0XHRcdFx0Ly8gdGhlIGNoYXJhY3RlciB3YXMgY29tcG9zZWQgb2YgdmFsaWQgcGFydHNcclxuXHRcdFx0XHQvLyBidXQgaXQncyBORkMgZm9ybSBpcyBpbnZhbGlkXHJcblx0XHRcdFx0Ly8gMjAyMzA3MTY6IGNoYW5nZSB0byBtb3JlIGV4YWN0IHN0YXRlbWVudCwgc2VlOiBFTlNOb3JtYWxpemUue2NzLGphdmF9XHJcblx0XHRcdFx0Ly8gbm90ZTogdGhpcyBkb2Vzbid0IGhhdmUgdG8gYmUgYSBjb21wb3NpdGlvblxyXG5cdFx0XHRcdC8vIDIwMjMwNzIwOiBjaGFuZ2UgdG8gZnVsbCBjaGVja1xyXG5cdFx0XHRcdHRocm93IGVycm9yX2Rpc2FsbG93ZWQoY3ApOyAvLyB0aGlzIHNob3VsZCBiZSByYXJlXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gdGhlcmUgaXMgbm8gZ3JvdXAgdGhhdCBjb250YWlucyBhbGwgdGhlc2UgY2hhcmFjdGVyc1xyXG5cdFx0XHRcdC8vIHRocm93IHVzaW5nIHRoZSBoaWdoZXN0IHByaW9yaXR5IGdyb3VwIHRoYXQgbWF0Y2hlZFxyXG5cdFx0XHRcdC8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzOS8jbWl4ZWRfc2NyaXB0X2NvbmZ1c2FibGVzXHJcblx0XHRcdFx0dGhyb3cgZXJyb3JfZ3JvdXBfbWVtYmVyKGdyb3Vwc1swXSwgY3ApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRncm91cHMgPSBncztcclxuXHRcdGlmIChncy5sZW5ndGggPT0gMSkgYnJlYWs7IC8vIHRoZXJlIGlzIG9ubHkgb25lIGdyb3VwIGxlZnRcclxuXHR9XHJcblx0Ly8gdGhlcmUgYXJlIGF0IGxlYXN0IDEgZ3JvdXAocykgd2l0aCBhbGwgb2YgdGhlc2UgY2hhcmFjdGVyc1xyXG5cdHJldHVybiBncm91cHM7XHJcbn1cclxuXHJcbi8vIHRocm93IG9uIGZpcnN0IGVycm9yXHJcbmZ1bmN0aW9uIGZsYXR0ZW4oc3BsaXQpIHtcclxuXHRyZXR1cm4gc3BsaXQubWFwKCh7aW5wdXQsIGVycm9yLCBvdXRwdXR9KSA9PiB7XHJcblx0XHRpZiAoZXJyb3IpIHtcclxuXHRcdFx0Ly8gZG9uJ3QgcHJpbnQgbGFiZWwgYWdhaW4gaWYganVzdCBhIHNpbmdsZSBsYWJlbFxyXG5cdFx0XHRsZXQgbXNnID0gZXJyb3IubWVzc2FnZTtcclxuXHRcdFx0Ly8gYmlkaV9xcSgpIG9ubHkgbmVjZXNzYXJ5IGlmIG1zZyBpcyBkaWdpdHNcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKHNwbGl0Lmxlbmd0aCA9PSAxID8gbXNnIDogYEludmFsaWQgbGFiZWwgJHtiaWRpX3FxKHNhZmVfc3RyX2Zyb21fY3BzKGlucHV0KSl9OiAke21zZ31gKTsgXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc3RyX2Zyb21fY3BzKG91dHB1dCk7XHJcblx0fSkuam9pbihTVE9QX0NIKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXJyb3JfZGlzYWxsb3dlZChjcCkge1xyXG5cdC8vIFRPRE86IGFkZCBjcCB0byBlcnJvcj9cclxuXHRyZXR1cm4gbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNoYXJhY3RlcjogJHtxdW90ZWRfY3AoY3ApfWApOyBcclxufVxyXG5mdW5jdGlvbiBlcnJvcl9ncm91cF9tZW1iZXIoZywgY3ApIHtcclxuXHRsZXQgcXVvdGVkID0gcXVvdGVkX2NwKGNwKTtcclxuXHRsZXQgZ2cgPSBHUk9VUFMuZmluZChnID0+IGcuUC5oYXMoY3ApKTsgLy8gb25seSBjaGVjayBwcmltYXJ5XHJcblx0aWYgKGdnKSB7XHJcblx0XHRxdW90ZWQgPSBgJHtnZy5OfSAke3F1b3RlZH1gO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEVycm9yKGBpbGxlZ2FsIG1peHR1cmU6ICR7Zy5OfSArICR7cXVvdGVkfWApO1xyXG59XHJcbmZ1bmN0aW9uIGVycm9yX3BsYWNlbWVudCh3aGVyZSkge1xyXG5cdHJldHVybiBuZXcgRXJyb3IoYGlsbGVnYWwgcGxhY2VtZW50OiAke3doZXJlfWApO1xyXG59XHJcblxyXG4vLyBhc3N1bXB0aW9uOiBjcHMubGVuZ3RoID4gMFxyXG4vLyBhc3N1bXB0aW9uOiBjcHNbMF0gaXNuJ3QgYSBDTVxyXG4vLyBhc3N1bXB0aW9uOiB0aGUgcHJldmlvdXMgY2hhcmFjdGVyIGlzbid0IGFuIGVtb2ppXHJcbmZ1bmN0aW9uIGNoZWNrX2dyb3VwKGcsIGNwcykge1xyXG5cdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0aWYgKCFncm91cF9oYXNfY3AoZywgY3ApKSB7XHJcblx0XHRcdC8vIGZvciB3aGl0ZWxpc3RlZCBzY3JpcHRzLCB0aGlzIHdpbGwgdGhyb3cgaWxsZWdhbCBtaXh0dXJlIG9uIGludmFsaWQgY20sIGVnLiBcImV7MzAwfXszMDB9XCJcclxuXHRcdFx0Ly8gYXQgdGhlIG1vbWVudCwgaXQncyB1bm5lY2Vzc2FyeSB0byBpbnRyb2R1Y2UgYW4gZXh0cmEgZXJyb3IgdHlwZVxyXG5cdFx0XHQvLyB1bnRpbCB0aGVyZSBleGlzdHMgYSB3aGl0ZWxpc3RlZCBtdWx0aS1jaGFyYWN0ZXJcclxuXHRcdFx0Ly8gICBlZy4gaWYgKE0gPCAwICYmIGlzX2NvbWJpbmluZ19tYXJrKGNwKSkgeyAuLi4gfVxyXG5cdFx0XHQvLyB0aGVyZSBhcmUgMyBjYXNlczpcclxuXHRcdFx0Ly8gICAxLiBpbGxlZ2FsIGNtIGZvciB3cm9uZyBncm91cCA9PiBtaXh0dXJlIGVycm9yXHJcblx0XHRcdC8vICAgMi4gaWxsZWdhbCBjbSBmb3Igc2FtZSBncm91cCA9PiBjbSBlcnJvclxyXG5cdFx0XHQvLyAgICAgICByZXF1aXJlcyBzZXQgb2Ygd2hpdGVsaXN0IGNtIHBlciBncm91cDogXHJcblx0XHRcdC8vICAgICAgICBlZy4gbmV3IFNldChbLi4uZy5QLCAuLi5nLlFdLmZsYXRNYXAobmZjKS5maWx0ZXIoY3AgPT4gQ00uaGFzKGNwKSkpXHJcblx0XHRcdC8vICAgMy4gd3JvbmcgZ3JvdXAgPT4gbWl4dHVyZSBlcnJvclxyXG5cdFx0XHR0aHJvdyBlcnJvcl9ncm91cF9tZW1iZXIoZywgY3ApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHQvL2lmIChNID49IDApIHsgLy8gd2UgaGF2ZSBhIGtub3duIGZpeGVkIGNtIGNvdW50XHJcblx0aWYgKGcuTSkgeyAvLyB3ZSBuZWVkIHRvIGNoZWNrIGZvciBOU01cclxuXHRcdGxldCBkZWNvbXBvc2VkID0gbmZkKGNwcyk7XHJcblx0XHRmb3IgKGxldCBpID0gMSwgZSA9IGRlY29tcG9zZWQubGVuZ3RoOyBpIDwgZTsgaSsrKSB7IC8vIHNlZTogYXNzdW1wdGlvblxyXG5cdFx0XHQvLyAyMDIzMDIxMDogYnVnZml4OiB1c2luZyBjcHMgaW5zdGVhZCBvZiBkZWNvbXBvc2VkIGgvdCBDYXJib24yMjVcclxuXHRcdFx0LypcclxuXHRcdFx0aWYgKENNLmhhcyhkZWNvbXBvc2VkW2ldKSkge1xyXG5cdFx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdFx0d2hpbGUgKGogPCBlICYmIENNLmhhcyhkZWNvbXBvc2VkW2pdKSkgaisrO1xyXG5cdFx0XHRcdGlmIChqIC0gaSA+IE0pIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgdG9vIG1hbnkgY29tYmluaW5nIG1hcmtzOiAke2cuTn0gJHtiaWRpX3FxKHN0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpKX0gKCR7ai1pfS8ke019KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpID0gajtcclxuXHRcdFx0fVxyXG5cdFx0XHQqL1xyXG5cdFx0XHQvLyAyMDIzMDIxNzogc3dpdGNoIHRvIE5TTSBjb3VudGluZ1xyXG5cdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI09wdGlvbmFsX0RldGVjdGlvblxyXG5cdFx0XHRpZiAoTlNNLmhhcyhkZWNvbXBvc2VkW2ldKSkge1xyXG5cdFx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdFx0Zm9yIChsZXQgY3A7IGogPCBlICYmIE5TTS5oYXMoY3AgPSBkZWNvbXBvc2VkW2pdKTsgaisrKSB7XHJcblx0XHRcdFx0XHQvLyBhLiBGb3JiaWQgc2VxdWVuY2VzIG9mIHRoZSBzYW1lIG5vbnNwYWNpbmcgbWFyay5cclxuXHRcdFx0XHRcdGZvciAobGV0IGsgPSBpOyBrIDwgajsgaysrKSB7IC8vIE8obl4yKSBidXQgbiA8IDEwMFxyXG5cdFx0XHRcdFx0XHRpZiAoZGVjb21wb3NlZFtrXSA9PSBjcCkge1xyXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlIG5vbi1zcGFjaW5nIG1hcmtzOiAke3F1b3RlZF9jcChjcCl9YCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gcGFyc2UgdG8gZW5kIHNvIHdlIGhhdmUgZnVsbCBuc20gY291bnRcclxuXHRcdFx0XHQvLyBiLiBGb3JiaWQgc2VxdWVuY2VzIG9mIG1vcmUgdGhhbiA0IG5vbnNwYWNpbmcgbWFya3MgKGdjPU1uIG9yIGdjPU1lKS5cclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBOU01fTUFYKSB7XHJcblx0XHRcdFx0XHQvLyBub3RlOiB0aGlzIHNsaWNlIHN0YXJ0cyB3aXRoIGEgYmFzZSBjaGFyIG9yIHNwYWNpbmctbWFyayBjbVxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBleGNlc3NpdmUgbm9uLXNwYWNpbmcgbWFya3M6ICR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpKX0gKCR7ai1pfS8ke05TTV9NQVh9KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpID0gajtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHQvLyAqKiogdGhpcyBjb2RlIGN1cnJlbnRseSBpc24ndCBuZWVkZWQgKioqXHJcblx0LypcclxuXHRsZXQgY21fd2hpdGVsaXN0ID0gTSBpbnN0YW5jZW9mIE1hcDtcclxuXHRmb3IgKGxldCBpID0gMCwgZSA9IGNwcy5sZW5ndGg7IGkgPCBlOyApIHtcclxuXHRcdGxldCBjcCA9IGNwc1tpKytdO1xyXG5cdFx0bGV0IHNlcXMgPSBjbV93aGl0ZWxpc3QgJiYgTS5nZXQoY3ApO1xyXG5cdFx0aWYgKHNlcXMpIHsgXHJcblx0XHRcdC8vIGxpc3Qgb2YgY29kZXBvaW50cyB0aGF0IGNhbiBmb2xsb3dcclxuXHRcdFx0Ly8gaWYgdGhpcyBleGlzdHMsIHRoaXMgd2lsbCBhbHdheXMgYmUgMStcclxuXHRcdFx0bGV0IGogPSBpO1xyXG5cdFx0XHR3aGlsZSAoaiA8IGUgJiYgQ00uaGFzKGNwc1tqXSkpIGorKztcclxuXHRcdFx0bGV0IGNtcyA9IGNwcy5zbGljZShpLCBqKTtcclxuXHRcdFx0bGV0IG1hdGNoID0gc2Vxcy5maW5kKHNlcSA9PiAhY29tcGFyZV9hcnJheXMoc2VxLCBjbXMpKTtcclxuXHRcdFx0aWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNvbWJpbmluZyBtYXJrIHNlcXVlbmNlOiBcIiR7c2FmZV9zdHJfZnJvbV9jcHMoW2NwLCAuLi5jbXNdKX1cImApO1xyXG5cdFx0XHRpID0gajtcclxuXHRcdH0gZWxzZSBpZiAoIVYuaGFzKGNwKSkge1xyXG5cdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI21peGVkX3NjcmlwdF9jb25mdXNhYmxlc1xyXG5cdFx0XHRsZXQgcXVvdGVkID0gcXVvdGVkX2NwKGNwKTtcclxuXHRcdFx0Zm9yIChsZXQgY3Agb2YgY3BzKSB7XHJcblx0XHRcdFx0bGV0IHUgPSBVTklRVUUuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAodSAmJiB1ICE9PSBnKSB7XHJcblx0XHRcdFx0XHQvLyBpZiBib3RoIHNjcmlwdHMgYXJlIHJlc3RyaWN0ZWQgdGhpcyBlcnJvciBpcyBjb25mdXNpbmdcclxuXHRcdFx0XHRcdC8vIGJlY2F1c2Ugd2UgZG9uJ3QgZGlmZmVyZW50aWF0ZSBSZXN0cmljdGVkQSBmcm9tIFJlc3RyaWN0ZWRCIFxyXG5cdFx0XHRcdFx0aWYgKCF1LlIpIHF1b3RlZCA9IGAke3F1b3RlZH0gaXMgJHt1Lk59YDtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGRpc2FsbG93ZWQgJHtnLk59IGNoYXJhY3RlcjogJHtxdW90ZWR9YCk7XHJcblx0XHRcdC8vdGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNoYXJhY3RlcjogJHtxdW90ZWR9IChleHBlY3RlZCAke2cuTn0pYCk7XHJcblx0XHRcdC8vdGhyb3cgbmV3IEVycm9yKGAke2cuTn0gZG9lcyBub3QgYWxsb3c6ICR7cXVvdGVkfWApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoIWNtX3doaXRlbGlzdCkge1xyXG5cdFx0bGV0IGRlY29tcG9zZWQgPSBuZmQoY3BzKTtcclxuXHRcdGZvciAobGV0IGkgPSAxLCBlID0gZGVjb21wb3NlZC5sZW5ndGg7IGkgPCBlOyBpKyspIHsgLy8gd2Uga25vdyBpdCBjYW4ndCBiZSBjbSBsZWFkaW5nXHJcblx0XHRcdGlmIChDTS5oYXMoZGVjb21wb3NlZFtpXSkpIHtcclxuXHRcdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHRcdHdoaWxlIChqIDwgZSAmJiBDTS5oYXMoZGVjb21wb3NlZFtqXSkpIGorKztcclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBNKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHRvbyBtYW55IGNvbWJpbmluZyBtYXJrczogXCIke3N0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpfVwiICgke2otaX0vJHtNfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0Ki9cclxufVxyXG5cclxuLy8gZ2l2ZW4gYSBsaXN0IG9mIGNvZGVwb2ludHNcclxuLy8gcmV0dXJucyBhIGxpc3Qgb2YgbGlzdHMsIHdoZXJlIGVtb2ppIGFyZSBhIGZ1bGx5LXF1YWxpZmllZCAoYXMgQXJyYXkgc3ViY2xhc3MpXHJcbi8vIGVnLiBleHBsb2RlX2NwKFwiYWJj8J+SqWRcIikgPT4gW1s2MSwgNjIsIDYzXSwgRW1vamlbMUY0QTksIEZFMEZdLCBbNjRdXVxyXG4vLyAyMDIzMDgxODogcmVuYW1lIGZvciAncHJvY2VzcycgbmFtZSBjb2xsaXNpb24gaC90IEphdmFyb21lXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvaXNzdWVzLzIzXHJcbmZ1bmN0aW9uIHRva2Vuc19mcm9tX3N0cihpbnB1dCwgbmYsIGVmKSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBjaGFycyA9IFtdO1xyXG5cdGlucHV0ID0gaW5wdXQuc2xpY2UoKS5yZXZlcnNlKCk7IC8vIGZsaXAgc28gd2UgY2FuIHBvcFxyXG5cdHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcclxuXHRcdGxldCBlbW9qaSA9IGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoaW5wdXQpO1xyXG5cdFx0aWYgKGVtb2ppKSB7XHJcblx0XHRcdGlmIChjaGFycy5sZW5ndGgpIHtcclxuXHRcdFx0XHRyZXQucHVzaChuZihjaGFycykpO1xyXG5cdFx0XHRcdGNoYXJzID0gW107XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0LnB1c2goZWYoZW1vamkpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBjcCA9IGlucHV0LnBvcCgpO1xyXG5cdFx0XHRpZiAoVkFMSUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdGNoYXJzLnB1c2goY3ApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBjcHMgPSBNQVBQRUQuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAoY3BzKSB7XHJcblx0XHRcdFx0XHRjaGFycy5wdXNoKC4uLmNwcyk7IC8vIGxlc3MgdGhhbiAxMCBlbGVtZW50c1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIUlHTk9SRUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdFx0Ly8gMjAyMzA5MTI6IHVuaWNvZGUgMTUuMSBjaGFuZ2VkIHRoZSBvcmRlciBvZiBwcm9jZXNzaW5nIHN1Y2ggdGhhdFxyXG5cdFx0XHRcdFx0Ly8gZGlzYWxsb3dlZCBwYXJ0cyBhcmUgb25seSByZWplY3RlZCBhZnRlciBORkNcclxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjQ2LyNWYWxpZGl0eV9Dcml0ZXJpYVxyXG5cdFx0XHRcdFx0Ly8gdGhpcyBkb2Vzbid0IGltcGFjdCBub3JtYWxpemF0aW9uIGFzIG9mIHRvZGF5XHJcblx0XHRcdFx0XHQvLyB0ZWNobmljYWxseSwgdGhpcyBlcnJvciBjYW4gYmUgcmVtb3ZlZCBhcyB0aGUgZ3JvdXAgbG9naWMgd2lsbCBhcHBseSBzaW1pbGFyIGxvZ2ljXHJcblx0XHRcdFx0XHQvLyBob3dldmVyIHRoZSBlcnJvciB0eXBlIG1pZ2h0IGJlIGxlc3MgY2xlYXJcclxuXHRcdFx0XHRcdHRocm93IGVycm9yX2Rpc2FsbG93ZWQoY3ApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoY2hhcnMubGVuZ3RoKSB7XHJcblx0XHRyZXQucHVzaChuZihjaGFycykpO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaWx0ZXJfZmUwZihjcHMpIHtcclxuXHRyZXR1cm4gY3BzLmZpbHRlcihjcCA9PiBjcCAhPSBGRTBGKTtcclxufVxyXG5cclxuLy8gZ2l2ZW4gYXJyYXkgb2YgY29kZXBvaW50c1xyXG4vLyByZXR1cm5zIHRoZSBsb25nZXN0IHZhbGlkIGVtb2ppIHNlcXVlbmNlIChvciB1bmRlZmluZWQgaWYgbm8gbWF0Y2gpXHJcbi8vICpNVVRBVEVTKiB0aGUgc3VwcGxpZWQgYXJyYXlcclxuLy8gZGlzYWxsb3dzIGludGVybGVhdmVkIGlnbm9yZWQgY2hhcmFjdGVyc1xyXG4vLyBmaWxscyAob3B0aW9uYWwpIGVhdGVuIGFycmF5IHdpdGggbWF0Y2hlZCBjb2RlcG9pbnRzXHJcbmZ1bmN0aW9uIGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoY3BzLCBlYXRlbikge1xyXG5cdGxldCBub2RlID0gRU1PSklfUk9PVDtcclxuXHRsZXQgZW1vamk7XHJcblx0bGV0IHBvcyA9IGNwcy5sZW5ndGg7XHJcblx0d2hpbGUgKHBvcykge1xyXG5cdFx0bm9kZSA9IG5vZGUuZ2V0KGNwc1stLXBvc10pO1xyXG5cdFx0aWYgKCFub2RlKSBicmVhaztcclxuXHRcdGxldCB7Vn0gPSBub2RlO1xyXG5cdFx0aWYgKFYpIHsgLy8gdGhpcyBpcyBhIHZhbGlkIGVtb2ppIChzbyBmYXIpXHJcblx0XHRcdGVtb2ppID0gVjtcclxuXHRcdFx0aWYgKGVhdGVuKSBlYXRlbi5wdXNoKC4uLmNwcy5zbGljZShwb3MpLnJldmVyc2UoKSk7IC8vIChvcHRpb25hbCkgY29weSBpbnB1dCwgdXNlZCBmb3IgZW5zX3Rva2VuaXplKClcclxuXHRcdFx0Y3BzLmxlbmd0aCA9IHBvczsgLy8gdHJ1bmNhdGVcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGVtb2ppO1xyXG59XHJcblxyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gdG9rZW5pemVyIFxyXG5cclxuY29uc3QgVFlfVkFMSUQgPSAndmFsaWQnO1xyXG5jb25zdCBUWV9NQVBQRUQgPSAnbWFwcGVkJztcclxuY29uc3QgVFlfSUdOT1JFRCA9ICdpZ25vcmVkJztcclxuY29uc3QgVFlfRElTQUxMT1dFRCA9ICdkaXNhbGxvd2VkJztcclxuY29uc3QgVFlfRU1PSkkgPSAnZW1vamknO1xyXG5jb25zdCBUWV9ORkMgPSAnbmZjJztcclxuY29uc3QgVFlfU1RPUCA9ICdzdG9wJztcclxuXHJcbmZ1bmN0aW9uIGVuc190b2tlbml6ZShuYW1lLCB7XHJcblx0bmYgPSB0cnVlLCAvLyBjb2xsYXBzZSB1bm5vcm1hbGl6ZWQgcnVucyBpbnRvIGEgc2luZ2xlIHRva2VuXHJcbn0gPSB7fSkge1xyXG5cdGluaXQoKTtcclxuXHRsZXQgaW5wdXQgPSBleHBsb2RlX2NwKG5hbWUpLnJldmVyc2UoKTtcclxuXHRsZXQgZWF0ZW4gPSBbXTtcclxuXHRsZXQgdG9rZW5zID0gW107XHJcblx0d2hpbGUgKGlucHV0Lmxlbmd0aCkge1xyXG5cdFx0bGV0IGVtb2ppID0gY29uc3VtZV9lbW9qaV9yZXZlcnNlZChpbnB1dCwgZWF0ZW4pO1xyXG5cdFx0aWYgKGVtb2ppKSB7XHJcblx0XHRcdHRva2Vucy5wdXNoKHtcclxuXHRcdFx0XHR0eXBlOiBUWV9FTU9KSSxcclxuXHRcdFx0XHRlbW9qaTogZW1vamkuc2xpY2UoKSwgLy8gY29weSBlbW9qaVxyXG5cdFx0XHRcdGlucHV0OiBlYXRlbixcclxuXHRcdFx0XHRjcHM6IGZpbHRlcl9mZTBmKGVtb2ppKVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0ZWF0ZW4gPSBbXTsgLy8gcmVzZXQgYnVmZmVyXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY3AgPSBpbnB1dC5wb3AoKTtcclxuXHRcdFx0aWYgKGNwID09IFNUT1ApIHtcclxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfU1RPUCwgY3B9KTtcclxuXHRcdFx0fSBlbHNlIGlmIChWQUxJRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX1ZBTElELCBjcHM6IFtjcF19KTtcclxuXHRcdFx0fSBlbHNlIGlmIChJR05PUkVELmhhcyhjcCkpIHtcclxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfSUdOT1JFRCwgY3B9KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY3BzID0gTUFQUEVELmdldChjcCk7XHJcblx0XHRcdFx0aWYgKGNwcykge1xyXG5cdFx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX01BUFBFRCwgY3AsIGNwczogY3BzLnNsaWNlKCl9KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX0RJU0FMTE9XRUQsIGNwfSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChuZikge1xyXG5cdFx0Zm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gLTE7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IHRva2VuID0gdG9rZW5zW2ldO1xyXG5cdFx0XHRpZiAoaXNfdmFsaWRfb3JfbWFwcGVkKHRva2VuLnR5cGUpKSB7XHJcblx0XHRcdFx0aWYgKHJlcXVpcmVzX2NoZWNrKHRva2VuLmNwcykpIHsgLy8gbm9ybWFsaXphdGlvbiBtaWdodCBiZSBuZWVkZWRcclxuXHRcdFx0XHRcdGxldCBlbmQgPSBpICsgMTtcclxuXHRcdFx0XHRcdGZvciAobGV0IHBvcyA9IGVuZDsgcG9zIDwgdG9rZW5zLmxlbmd0aDsgcG9zKyspIHsgLy8gZmluZCBhZGphY2VudCB0ZXh0XHJcblx0XHRcdFx0XHRcdGxldCB7dHlwZSwgY3BzfSA9IHRva2Vuc1twb3NdO1xyXG5cdFx0XHRcdFx0XHRpZiAoaXNfdmFsaWRfb3JfbWFwcGVkKHR5cGUpKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCFyZXF1aXJlc19jaGVjayhjcHMpKSBicmVhaztcclxuXHRcdFx0XHRcdFx0XHRlbmQgPSBwb3MgKyAxO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgIT09IFRZX0lHTk9SRUQpIHsgLy8gfHwgdHlwZSAhPT0gVFlfRElTQUxMT1dFRCkgeyBcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBpO1xyXG5cdFx0XHRcdFx0bGV0IHNsaWNlID0gdG9rZW5zLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG5cdFx0XHRcdFx0bGV0IGNwczAgPSBzbGljZS5mbGF0TWFwKHggPT4gaXNfdmFsaWRfb3JfbWFwcGVkKHgudHlwZSkgPyB4LmNwcyA6IFtdKTsgLy8gc3RyaXAganVuayB0b2tlbnNcclxuXHRcdFx0XHRcdGxldCBjcHMgPSBuZmMoY3BzMCk7XHJcblx0XHRcdFx0XHRpZiAoY29tcGFyZV9hcnJheXMoY3BzLCBjcHMwKSkgeyAvLyBidW5kbGUgaW50byBhbiBuZmMgdG9rZW5cclxuXHRcdFx0XHRcdFx0dG9rZW5zLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQsIHtcclxuXHRcdFx0XHRcdFx0XHR0eXBlOiBUWV9ORkMsIFxyXG5cdFx0XHRcdFx0XHRcdGlucHV0OiBjcHMwLCAvLyB0aGVyZSBhcmUgMyBzdGF0ZXM6IHRva2VuczAgPT0ocHJvY2Vzcyk9PiBpbnB1dCA9PShuZmMpPT4gdG9rZW5zL2Nwc1xyXG5cdFx0XHRcdFx0XHRcdGNwcywgXHJcblx0XHRcdFx0XHRcdFx0dG9rZW5zMDogY29sbGFwc2VfdmFsaWRfdG9rZW5zKHNsaWNlKSxcclxuXHRcdFx0XHRcdFx0XHR0b2tlbnM6IGVuc190b2tlbml6ZShzdHJfZnJvbV9jcHMoY3BzKSwge25mOiBmYWxzZX0pXHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHRpID0gc3RhcnQ7XHJcblx0XHRcdFx0XHR9IGVsc2UgeyBcclxuXHRcdFx0XHRcdFx0aSA9IGVuZCAtIDE7IC8vIHNraXAgdG8gZW5kIG9mIHNsaWNlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRzdGFydCA9IC0xOyAvLyByZXNldFxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzdGFydCA9IGk7IC8vIHJlbWVtYmVyIGxhc3RcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAodG9rZW4udHlwZSAhPT0gVFlfSUdOT1JFRCkgeyAvLyAyMDIyMTAyNDogaXMgdGhpcyBjb3JyZWN0P1xyXG5cdFx0XHRcdHN0YXJ0ID0gLTE7IC8vIHJlc2V0XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGNvbGxhcHNlX3ZhbGlkX3Rva2Vucyh0b2tlbnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc192YWxpZF9vcl9tYXBwZWQodHlwZSkge1xyXG5cdHJldHVybiB0eXBlID09IFRZX1ZBTElEIHx8IHR5cGUgPT0gVFlfTUFQUEVEO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXF1aXJlc19jaGVjayhjcHMpIHtcclxuXHRyZXR1cm4gY3BzLnNvbWUoY3AgPT4gTkZDX0NIRUNLLmhhcyhjcCkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb2xsYXBzZV92YWxpZF90b2tlbnModG9rZW5zKSB7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmICh0b2tlbnNbaV0udHlwZSA9PSBUWV9WQUxJRCkge1xyXG5cdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHR3aGlsZSAoaiA8IHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW2pdLnR5cGUgPT0gVFlfVkFMSUQpIGorKztcclxuXHRcdFx0dG9rZW5zLnNwbGljZShpLCBqIC0gaSwge3R5cGU6IFRZX1ZBTElELCBjcHM6IHRva2Vucy5zbGljZShpLCBqKS5mbGF0TWFwKHggPT4geC5jcHMpfSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiB0b2tlbnM7XHJcbn1cblxuZXhwb3J0cy5lbnNfYmVhdXRpZnkgPSBlbnNfYmVhdXRpZnk7XG5leHBvcnRzLmVuc19lbW9qaSA9IGVuc19lbW9qaTtcbmV4cG9ydHMuZW5zX25vcm1hbGl6ZSA9IGVuc19ub3JtYWxpemU7XG5leHBvcnRzLmVuc19ub3JtYWxpemVfZnJhZ21lbnQgPSBlbnNfbm9ybWFsaXplX2ZyYWdtZW50O1xuZXhwb3J0cy5lbnNfc3BsaXQgPSBlbnNfc3BsaXQ7XG5leHBvcnRzLmVuc190b2tlbml6ZSA9IGVuc190b2tlbml6ZTtcbmV4cG9ydHMuaXNfY29tYmluaW5nX21hcmsgPSBpc19jb21iaW5pbmdfbWFyaztcbmV4cG9ydHMubmZjID0gbmZjO1xuZXhwb3J0cy5uZmQgPSBuZmQ7XG5leHBvcnRzLnNhZmVfc3RyX2Zyb21fY3BzID0gc2FmZV9zdHJfZnJvbV9jcHM7XG5leHBvcnRzLnNob3VsZF9lc2NhcGUgPSBzaG91bGRfZXNjYXBlO1xuIl0sIm5hbWVzIjpbIkNPTVBSRVNTRUQkMSIsIkZFTkNFRCIsIk1hcCIsIk5TTV9NQVgiLCJkZWNvZGVfYXJpdGhtZXRpYyIsImJ5dGVzIiwicG9zIiwidTE2Iiwic3ltYm9sX2NvdW50IiwidG90YWwiLCJhY2MiLCJpIiwicHVzaCIsInNraXAiLCJwb3NfcGF5bG9hZCIsInJlYWRfd2lkdGgiLCJyZWFkX2J1ZmZlciIsInJlYWRfYml0IiwiTiIsIkZVTEwiLCJIQUxGIiwiUVJUUiIsIk1BU0siLCJyZWdpc3RlciIsInN5bWJvbHMiLCJsb3ciLCJyYW5nZSIsInZhbHVlIiwiTWF0aCIsImZsb29yIiwic3RhcnQiLCJlbmQiLCJtaWQiLCJhIiwiYiIsIm9mZnNldCIsIm1hcCIsIngiLCJyZWFkX3BheWxvYWQiLCJ2IiwicmVhZF9jb21wcmVzc2VkX3BheWxvYWQiLCJzIiwidW5zYWZlX2F0b2IiLCJsb29rdXAiLCJmb3JFYWNoIiwiYyIsImNoYXJDb2RlQXQiLCJuIiwibGVuZ3RoIiwicmV0IiwiVWludDhBcnJheSIsIndpZHRoIiwiY2FycnkiLCJzaWduZWQiLCJyZWFkX2RlbHRhcyIsIm5leHQiLCJBcnJheSIsInJlYWRfc29ydGVkIiwicHJldiIsInJlYWRfc29ydGVkX2FycmF5cyIsInJlYWRfYXJyYXlfd2hpbGUiLCJyZWFkX21hcHBlZCIsInciLCJyZWFkX2xpbmVhcl90YWJsZSIsInJlYWRfcmVwbGFjZW1lbnRfdGFibGUiLCJmbGF0IiwicmVhZF90cmFuc3Bvc2VkIiwibSIsImZpbGwiLCJqIiwiZHgiLCJkeSIsInZOIiwiZmxhdE1hcCIsInlzIiwiXyIsImpfZHkiLCJ5Iiwic2xpY2UiLCJyZWFkX3RyaWUiLCJzb3J0ZWQiLCJleHBhbmQiLCJkZWNvZGUiLCJRIiwiUyIsIkIiLCJjcHMiLCJzYXZlZCIsImJyIiwiY3AiLCJoZXhfY3AiLCJ0b1N0cmluZyIsInRvVXBwZXJDYXNlIiwicGFkU3RhcnQiLCJxdW90ZV9jcCIsImV4cGxvZGVfY3AiLCJsZW4iLCJjb2RlUG9pbnRBdCIsInN0cl9mcm9tX2NwcyIsImNodW5rIiwiU3RyaW5nIiwiZnJvbUNvZGVQb2ludCIsImJ1ZiIsImpvaW4iLCJjb21wYXJlX2FycmF5cyIsIkNPTVBSRVNTRUQiLCJTMCIsIkwwIiwiVjAiLCJUMCIsIkxfQ09VTlQiLCJWX0NPVU5UIiwiVF9DT1VOVCIsIk5fQ09VTlQiLCJTX0NPVU5UIiwiUzEiLCJMMSIsIlYxIiwiVDEiLCJ1bnBhY2tfY2MiLCJwYWNrZWQiLCJ1bnBhY2tfY3AiLCJTSElGVEVEX1JBTksiLCJFWENMVVNJT05TIiwiREVDT01QIiwiUkVDT01QIiwiaW5pdCQxIiwiciIsIlNldCIsImhhcyIsImJ1Y2tldCIsImdldCIsInNldCIsInJldmVyc2UiLCJpc19oYW5ndWwiLCJjb21wb3NlX3BhaXIiLCJyZWNvbXAiLCJkZWNvbXBvc2VkIiwiY2hlY2tfb3JkZXIiLCJhZGQiLCJjYyIsInNfaW5kZXgiLCJsX2luZGV4Iiwidl9pbmRleCIsInRfaW5kZXgiLCJtYXBwZWQiLCJwb3AiLCJwcmV2X2NjIiwidG1wIiwiY29tcG9zZWRfZnJvbV9kZWNvbXBvc2VkIiwic3RhY2siLCJwcmV2X2NwIiwiY29tcG9zZWQiLCJuZmQiLCJuZmMiLCJIWVBIRU4iLCJTVE9QIiwiU1RPUF9DSCIsIkZFMEYiLCJVTklRVUVfUEgiLCJBcnJheV9mcm9tIiwiZnJvbSIsImdyb3VwX2hhc19jcCIsImciLCJQIiwiRW1vamkiLCJpc19lbW9qaSIsIk1BUFBFRCIsIklHTk9SRUQiLCJDTSIsIk5TTSIsIkVTQ0FQRSIsIk5GQ19DSEVDSyIsIkdST1VQUyIsIldIT0xFX1ZBTElEIiwiV0hPTEVfTUFQIiwiVkFMSUQiLCJFTU9KSV9MSVNUIiwiRU1PSklfUk9PVCIsImluaXQiLCJyZWFkX3NvcnRlZF9hcnJheSIsInJlYWRfc29ydGVkX3NldCIsImNodW5rcyIsInVucmVzdHJpY3RlZCIsInJlYWRfY2h1bmtlZCIsImNvbmNhdCIsIlIiLCJNIiwid2hvbGVzIiwic29ydCIsImQiLCJWIiwidmFsdWVzIiwicmVjcyIsImdzIiwiZmlsdGVyIiwicmVjIiwiZmluZCIsIkciLCJzb21lIiwidW5pb24iLCJjb21wbGVtZW50IiwibXVsdGkiLCJhZGRfdG9fdW5pb24iLCJub2RlIiwiY2hpbGQiLCJxdW90ZWRfY3AiLCJzaG91bGRfZXNjYXBlIiwiYmlkaV9xcSIsInNhZmVfc3RyX2Zyb21fY3BzIiwiY2hlY2tfbGFiZWxfZXh0ZW5zaW9uIiwiRXJyb3IiLCJjaGVja19sZWFkaW5nX3VuZGVyc2NvcmUiLCJVTkRFUlNDT1JFIiwibGFzdEluZGV4T2YiLCJjaGVja19mZW5jZWQiLCJlcnJvcl9wbGFjZW1lbnQiLCJsYXN0IiwibWF0Y2giLCJxdW90ZXIiLCJpc19jb21iaW5pbmdfbWFyayIsImVuc19lbW9qaSIsImVuc19ub3JtYWxpemVfZnJhZ21lbnQiLCJmcmFnIiwiZGVjb21wb3NlIiwibmYiLCJzcGxpdCIsImxhYmVsIiwidG9rZW5zX2Zyb21fc3RyIiwiZmlsdGVyX2ZlMGYiLCJlbnNfbm9ybWFsaXplIiwibmFtZSIsImZsYXR0ZW4iLCJlbnNfYmVhdXRpZnkiLCJsYWJlbHMiLCJ0eXBlIiwib3V0cHV0IiwiZXJyb3IiLCJpbmRleE9mIiwiZW5zX3NwbGl0IiwicHJlc2VydmVfZW1vamkiLCJlZiIsImlucHV0IiwiaW5mbyIsInRva2VucyIsInRva2VuX2NvdW50Iiwibm9ybSIsImVtb2ppIiwiZXZlcnkiLCJjaGFycyIsInVuaXF1ZSIsImRldGVybWluZV9ncm91cCIsImNoZWNrX2dyb3VwIiwiY2hlY2tfd2hvbGUiLCJlcnIiLCJncm91cCIsIm1ha2VyIiwic2hhcmVkIiwid2hvbGUiLCJncm91cHMiLCJlcnJvcl9kaXNhbGxvd2VkIiwiZXJyb3JfZ3JvdXBfbWVtYmVyIiwibXNnIiwibWVzc2FnZSIsInF1b3RlZCIsImdnIiwid2hlcmUiLCJlIiwiayIsImNvbnN1bWVfZW1vamlfcmV2ZXJzZWQiLCJlYXRlbiIsIlRZX1ZBTElEIiwiVFlfTUFQUEVEIiwiVFlfSUdOT1JFRCIsIlRZX0RJU0FMTE9XRUQiLCJUWV9FTU9KSSIsIlRZX05GQyIsIlRZX1NUT1AiLCJlbnNfdG9rZW5pemUiLCJ0b2tlbiIsImlzX3ZhbGlkX29yX21hcHBlZCIsInJlcXVpcmVzX2NoZWNrIiwiY3BzMCIsInNwbGljZSIsInRva2VuczAiLCJjb2xsYXBzZV92YWxpZF90b2tlbnMiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@adraffy/ens-normalize/dist/index.cjs\n");

/***/ })

};
;