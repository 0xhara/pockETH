"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/safe-stable-stringify";
exports.ids = ["vendor-chunks/safe-stable-stringify"];
exports.modules = {

/***/ "(ssr)/./node_modules/safe-stable-stringify/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/safe-stable-stringify/index.js ***!
  \*****************************************************/
/***/ ((module, exports) => {

eval("\nconst { hasOwnProperty } = Object.prototype;\nconst stringify = configure();\n// @ts-expect-error\nstringify.configure = configure;\n// @ts-expect-error\nstringify.stringify = stringify;\n// @ts-expect-error\nstringify.default = stringify;\n// @ts-expect-error used for named export\nexports.stringify = stringify;\n// @ts-expect-error used for named export\nexports.configure = configure;\nmodule.exports = stringify;\n// eslint-disable-next-line no-control-regex\nconst strEscapeSequencesRegExp = /[\\u0000-\\u001f\\u0022\\u005c\\ud800-\\udfff]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?:[^\\ud800-\\udbff]|^)[\\udc00-\\udfff]/;\n// Escape C0 control characters, double quotes, the backslash and every code\n// unit with a numeric value in the inclusive range 0xD800 to 0xDFFF.\nfunction strEscape(str) {\n    // Some magic numbers that worked out fine while benchmarking with v8 8.0\n    if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {\n        return `\"${str}\"`;\n    }\n    return JSON.stringify(str);\n}\nfunction insertSort(array) {\n    // Insertion sort is very efficient for small input sizes but it has a bad\n    // worst case complexity. Thus, use native array sort for bigger values.\n    if (array.length > 2e2) {\n        return array.sort();\n    }\n    for(let i = 1; i < array.length; i++){\n        const currentValue = array[i];\n        let position = i;\n        while(position !== 0 && array[position - 1] > currentValue){\n            array[position] = array[position - 1];\n            position--;\n        }\n        array[position] = currentValue;\n    }\n    return array;\n}\nconst typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array())), Symbol.toStringTag).get;\nfunction isTypedArrayWithEntries(value) {\n    return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0;\n}\nfunction stringifyTypedArray(array, separator, maximumBreadth) {\n    if (array.length < maximumBreadth) {\n        maximumBreadth = array.length;\n    }\n    const whitespace = separator === \",\" ? \"\" : \" \";\n    let res = `\"0\":${whitespace}${array[0]}`;\n    for(let i = 1; i < maximumBreadth; i++){\n        res += `${separator}\"${i}\":${whitespace}${array[i]}`;\n    }\n    return res;\n}\nfunction getCircularValueOption(options) {\n    if (hasOwnProperty.call(options, \"circularValue\")) {\n        const circularValue = options.circularValue;\n        if (typeof circularValue === \"string\") {\n            return `\"${circularValue}\"`;\n        }\n        if (circularValue == null) {\n            return circularValue;\n        }\n        if (circularValue === Error || circularValue === TypeError) {\n            return {\n                toString () {\n                    throw new TypeError(\"Converting circular structure to JSON\");\n                }\n            };\n        }\n        throw new TypeError('The \"circularValue\" argument must be of type string or the value null or undefined');\n    }\n    return '\"[Circular]\"';\n}\nfunction getBooleanOption(options, key) {\n    let value;\n    if (hasOwnProperty.call(options, key)) {\n        value = options[key];\n        if (typeof value !== \"boolean\") {\n            throw new TypeError(`The \"${key}\" argument must be of type boolean`);\n        }\n    }\n    return value === undefined ? true : value;\n}\nfunction getPositiveIntegerOption(options, key) {\n    let value;\n    if (hasOwnProperty.call(options, key)) {\n        value = options[key];\n        if (typeof value !== \"number\") {\n            throw new TypeError(`The \"${key}\" argument must be of type number`);\n        }\n        if (!Number.isInteger(value)) {\n            throw new TypeError(`The \"${key}\" argument must be an integer`);\n        }\n        if (value < 1) {\n            throw new RangeError(`The \"${key}\" argument must be >= 1`);\n        }\n    }\n    return value === undefined ? Infinity : value;\n}\nfunction getItemCount(number) {\n    if (number === 1) {\n        return \"1 item\";\n    }\n    return `${number} items`;\n}\nfunction getUniqueReplacerSet(replacerArray) {\n    const replacerSet = new Set();\n    for (const value of replacerArray){\n        if (typeof value === \"string\" || typeof value === \"number\") {\n            replacerSet.add(String(value));\n        }\n    }\n    return replacerSet;\n}\nfunction getStrictOption(options) {\n    if (hasOwnProperty.call(options, \"strict\")) {\n        const value = options.strict;\n        if (typeof value !== \"boolean\") {\n            throw new TypeError('The \"strict\" argument must be of type boolean');\n        }\n        if (value) {\n            return (value)=>{\n                let message = `Object can not safely be stringified. Received type ${typeof value}`;\n                if (typeof value !== \"function\") message += ` (${value.toString()})`;\n                throw new Error(message);\n            };\n        }\n    }\n}\nfunction configure(options) {\n    options = {\n        ...options\n    };\n    const fail = getStrictOption(options);\n    if (fail) {\n        if (options.bigint === undefined) {\n            options.bigint = false;\n        }\n        if (!(\"circularValue\" in options)) {\n            options.circularValue = Error;\n        }\n    }\n    const circularValue = getCircularValueOption(options);\n    const bigint = getBooleanOption(options, \"bigint\");\n    const deterministic = getBooleanOption(options, \"deterministic\");\n    const maximumDepth = getPositiveIntegerOption(options, \"maximumDepth\");\n    const maximumBreadth = getPositiveIntegerOption(options, \"maximumBreadth\");\n    function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {\n        let value = parent[key];\n        if (typeof value === \"object\" && value !== null && typeof value.toJSON === \"function\") {\n            value = value.toJSON(key);\n        }\n        value = replacer.call(parent, key, value);\n        switch(typeof value){\n            case \"string\":\n                return strEscape(value);\n            case \"object\":\n                {\n                    if (value === null) {\n                        return \"null\";\n                    }\n                    if (stack.indexOf(value) !== -1) {\n                        return circularValue;\n                    }\n                    let res = \"\";\n                    let join = \",\";\n                    const originalIndentation = indentation;\n                    if (Array.isArray(value)) {\n                        if (value.length === 0) {\n                            return \"[]\";\n                        }\n                        if (maximumDepth < stack.length + 1) {\n                            return '\"[Array]\"';\n                        }\n                        stack.push(value);\n                        if (spacer !== \"\") {\n                            indentation += spacer;\n                            res += `\\n${indentation}`;\n                            join = `,\\n${indentation}`;\n                        }\n                        const maximumValuesToStringify = Math.min(value.length, maximumBreadth);\n                        let i = 0;\n                        for(; i < maximumValuesToStringify - 1; i++){\n                            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);\n                            res += tmp !== undefined ? tmp : \"null\";\n                            res += join;\n                        }\n                        const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);\n                        res += tmp !== undefined ? tmp : \"null\";\n                        if (value.length - 1 > maximumBreadth) {\n                            const removedKeys = value.length - maximumBreadth - 1;\n                            res += `${join}\"... ${getItemCount(removedKeys)} not stringified\"`;\n                        }\n                        if (spacer !== \"\") {\n                            res += `\\n${originalIndentation}`;\n                        }\n                        stack.pop();\n                        return `[${res}]`;\n                    }\n                    let keys = Object.keys(value);\n                    const keyLength = keys.length;\n                    if (keyLength === 0) {\n                        return \"{}\";\n                    }\n                    if (maximumDepth < stack.length + 1) {\n                        return '\"[Object]\"';\n                    }\n                    let whitespace = \"\";\n                    let separator = \"\";\n                    if (spacer !== \"\") {\n                        indentation += spacer;\n                        join = `,\\n${indentation}`;\n                        whitespace = \" \";\n                    }\n                    const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);\n                    if (deterministic && !isTypedArrayWithEntries(value)) {\n                        keys = insertSort(keys);\n                    }\n                    stack.push(value);\n                    for(let i = 0; i < maximumPropertiesToStringify; i++){\n                        const key = keys[i];\n                        const tmp = stringifyFnReplacer(key, value, stack, replacer, spacer, indentation);\n                        if (tmp !== undefined) {\n                            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`;\n                            separator = join;\n                        }\n                    }\n                    if (keyLength > maximumBreadth) {\n                        const removedKeys = keyLength - maximumBreadth;\n                        res += `${separator}\"...\":${whitespace}\"${getItemCount(removedKeys)} not stringified\"`;\n                        separator = join;\n                    }\n                    if (spacer !== \"\" && separator.length > 1) {\n                        res = `\\n${indentation}${res}\\n${originalIndentation}`;\n                    }\n                    stack.pop();\n                    return `{${res}}`;\n                }\n            case \"number\":\n                return isFinite(value) ? String(value) : fail ? fail(value) : \"null\";\n            case \"boolean\":\n                return value === true ? \"true\" : \"false\";\n            case \"undefined\":\n                return undefined;\n            case \"bigint\":\n                if (bigint) {\n                    return String(value);\n                }\n            // fallthrough\n            default:\n                return fail ? fail(value) : undefined;\n        }\n    }\n    function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {\n        if (typeof value === \"object\" && value !== null && typeof value.toJSON === \"function\") {\n            value = value.toJSON(key);\n        }\n        switch(typeof value){\n            case \"string\":\n                return strEscape(value);\n            case \"object\":\n                {\n                    if (value === null) {\n                        return \"null\";\n                    }\n                    if (stack.indexOf(value) !== -1) {\n                        return circularValue;\n                    }\n                    const originalIndentation = indentation;\n                    let res = \"\";\n                    let join = \",\";\n                    if (Array.isArray(value)) {\n                        if (value.length === 0) {\n                            return \"[]\";\n                        }\n                        if (maximumDepth < stack.length + 1) {\n                            return '\"[Array]\"';\n                        }\n                        stack.push(value);\n                        if (spacer !== \"\") {\n                            indentation += spacer;\n                            res += `\\n${indentation}`;\n                            join = `,\\n${indentation}`;\n                        }\n                        const maximumValuesToStringify = Math.min(value.length, maximumBreadth);\n                        let i = 0;\n                        for(; i < maximumValuesToStringify - 1; i++){\n                            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);\n                            res += tmp !== undefined ? tmp : \"null\";\n                            res += join;\n                        }\n                        const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);\n                        res += tmp !== undefined ? tmp : \"null\";\n                        if (value.length - 1 > maximumBreadth) {\n                            const removedKeys = value.length - maximumBreadth - 1;\n                            res += `${join}\"... ${getItemCount(removedKeys)} not stringified\"`;\n                        }\n                        if (spacer !== \"\") {\n                            res += `\\n${originalIndentation}`;\n                        }\n                        stack.pop();\n                        return `[${res}]`;\n                    }\n                    stack.push(value);\n                    let whitespace = \"\";\n                    if (spacer !== \"\") {\n                        indentation += spacer;\n                        join = `,\\n${indentation}`;\n                        whitespace = \" \";\n                    }\n                    let separator = \"\";\n                    for (const key of replacer){\n                        const tmp = stringifyArrayReplacer(key, value[key], stack, replacer, spacer, indentation);\n                        if (tmp !== undefined) {\n                            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`;\n                            separator = join;\n                        }\n                    }\n                    if (spacer !== \"\" && separator.length > 1) {\n                        res = `\\n${indentation}${res}\\n${originalIndentation}`;\n                    }\n                    stack.pop();\n                    return `{${res}}`;\n                }\n            case \"number\":\n                return isFinite(value) ? String(value) : fail ? fail(value) : \"null\";\n            case \"boolean\":\n                return value === true ? \"true\" : \"false\";\n            case \"undefined\":\n                return undefined;\n            case \"bigint\":\n                if (bigint) {\n                    return String(value);\n                }\n            // fallthrough\n            default:\n                return fail ? fail(value) : undefined;\n        }\n    }\n    function stringifyIndent(key, value, stack, spacer, indentation) {\n        switch(typeof value){\n            case \"string\":\n                return strEscape(value);\n            case \"object\":\n                {\n                    if (value === null) {\n                        return \"null\";\n                    }\n                    if (typeof value.toJSON === \"function\") {\n                        value = value.toJSON(key);\n                        // Prevent calling `toJSON` again.\n                        if (typeof value !== \"object\") {\n                            return stringifyIndent(key, value, stack, spacer, indentation);\n                        }\n                        if (value === null) {\n                            return \"null\";\n                        }\n                    }\n                    if (stack.indexOf(value) !== -1) {\n                        return circularValue;\n                    }\n                    const originalIndentation = indentation;\n                    if (Array.isArray(value)) {\n                        if (value.length === 0) {\n                            return \"[]\";\n                        }\n                        if (maximumDepth < stack.length + 1) {\n                            return '\"[Array]\"';\n                        }\n                        stack.push(value);\n                        indentation += spacer;\n                        let res = `\\n${indentation}`;\n                        const join = `,\\n${indentation}`;\n                        const maximumValuesToStringify = Math.min(value.length, maximumBreadth);\n                        let i = 0;\n                        for(; i < maximumValuesToStringify - 1; i++){\n                            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);\n                            res += tmp !== undefined ? tmp : \"null\";\n                            res += join;\n                        }\n                        const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);\n                        res += tmp !== undefined ? tmp : \"null\";\n                        if (value.length - 1 > maximumBreadth) {\n                            const removedKeys = value.length - maximumBreadth - 1;\n                            res += `${join}\"... ${getItemCount(removedKeys)} not stringified\"`;\n                        }\n                        res += `\\n${originalIndentation}`;\n                        stack.pop();\n                        return `[${res}]`;\n                    }\n                    let keys = Object.keys(value);\n                    const keyLength = keys.length;\n                    if (keyLength === 0) {\n                        return \"{}\";\n                    }\n                    if (maximumDepth < stack.length + 1) {\n                        return '\"[Object]\"';\n                    }\n                    indentation += spacer;\n                    const join = `,\\n${indentation}`;\n                    let res = \"\";\n                    let separator = \"\";\n                    let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);\n                    if (isTypedArrayWithEntries(value)) {\n                        res += stringifyTypedArray(value, join, maximumBreadth);\n                        keys = keys.slice(value.length);\n                        maximumPropertiesToStringify -= value.length;\n                        separator = join;\n                    }\n                    if (deterministic) {\n                        keys = insertSort(keys);\n                    }\n                    stack.push(value);\n                    for(let i = 0; i < maximumPropertiesToStringify; i++){\n                        const key = keys[i];\n                        const tmp = stringifyIndent(key, value[key], stack, spacer, indentation);\n                        if (tmp !== undefined) {\n                            res += `${separator}${strEscape(key)}: ${tmp}`;\n                            separator = join;\n                        }\n                    }\n                    if (keyLength > maximumBreadth) {\n                        const removedKeys = keyLength - maximumBreadth;\n                        res += `${separator}\"...\": \"${getItemCount(removedKeys)} not stringified\"`;\n                        separator = join;\n                    }\n                    if (separator !== \"\") {\n                        res = `\\n${indentation}${res}\\n${originalIndentation}`;\n                    }\n                    stack.pop();\n                    return `{${res}}`;\n                }\n            case \"number\":\n                return isFinite(value) ? String(value) : fail ? fail(value) : \"null\";\n            case \"boolean\":\n                return value === true ? \"true\" : \"false\";\n            case \"undefined\":\n                return undefined;\n            case \"bigint\":\n                if (bigint) {\n                    return String(value);\n                }\n            // fallthrough\n            default:\n                return fail ? fail(value) : undefined;\n        }\n    }\n    function stringifySimple(key, value, stack) {\n        switch(typeof value){\n            case \"string\":\n                return strEscape(value);\n            case \"object\":\n                {\n                    if (value === null) {\n                        return \"null\";\n                    }\n                    if (typeof value.toJSON === \"function\") {\n                        value = value.toJSON(key);\n                        // Prevent calling `toJSON` again\n                        if (typeof value !== \"object\") {\n                            return stringifySimple(key, value, stack);\n                        }\n                        if (value === null) {\n                            return \"null\";\n                        }\n                    }\n                    if (stack.indexOf(value) !== -1) {\n                        return circularValue;\n                    }\n                    let res = \"\";\n                    if (Array.isArray(value)) {\n                        if (value.length === 0) {\n                            return \"[]\";\n                        }\n                        if (maximumDepth < stack.length + 1) {\n                            return '\"[Array]\"';\n                        }\n                        stack.push(value);\n                        const maximumValuesToStringify = Math.min(value.length, maximumBreadth);\n                        let i = 0;\n                        for(; i < maximumValuesToStringify - 1; i++){\n                            const tmp = stringifySimple(String(i), value[i], stack);\n                            res += tmp !== undefined ? tmp : \"null\";\n                            res += \",\";\n                        }\n                        const tmp = stringifySimple(String(i), value[i], stack);\n                        res += tmp !== undefined ? tmp : \"null\";\n                        if (value.length - 1 > maximumBreadth) {\n                            const removedKeys = value.length - maximumBreadth - 1;\n                            res += `,\"... ${getItemCount(removedKeys)} not stringified\"`;\n                        }\n                        stack.pop();\n                        return `[${res}]`;\n                    }\n                    let keys = Object.keys(value);\n                    const keyLength = keys.length;\n                    if (keyLength === 0) {\n                        return \"{}\";\n                    }\n                    if (maximumDepth < stack.length + 1) {\n                        return '\"[Object]\"';\n                    }\n                    let separator = \"\";\n                    let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);\n                    if (isTypedArrayWithEntries(value)) {\n                        res += stringifyTypedArray(value, \",\", maximumBreadth);\n                        keys = keys.slice(value.length);\n                        maximumPropertiesToStringify -= value.length;\n                        separator = \",\";\n                    }\n                    if (deterministic) {\n                        keys = insertSort(keys);\n                    }\n                    stack.push(value);\n                    for(let i = 0; i < maximumPropertiesToStringify; i++){\n                        const key = keys[i];\n                        const tmp = stringifySimple(key, value[key], stack);\n                        if (tmp !== undefined) {\n                            res += `${separator}${strEscape(key)}:${tmp}`;\n                            separator = \",\";\n                        }\n                    }\n                    if (keyLength > maximumBreadth) {\n                        const removedKeys = keyLength - maximumBreadth;\n                        res += `${separator}\"...\":\"${getItemCount(removedKeys)} not stringified\"`;\n                    }\n                    stack.pop();\n                    return `{${res}}`;\n                }\n            case \"number\":\n                return isFinite(value) ? String(value) : fail ? fail(value) : \"null\";\n            case \"boolean\":\n                return value === true ? \"true\" : \"false\";\n            case \"undefined\":\n                return undefined;\n            case \"bigint\":\n                if (bigint) {\n                    return String(value);\n                }\n            // fallthrough\n            default:\n                return fail ? fail(value) : undefined;\n        }\n    }\n    function stringify(value, replacer, space) {\n        if (arguments.length > 1) {\n            let spacer = \"\";\n            if (typeof space === \"number\") {\n                spacer = \" \".repeat(Math.min(space, 10));\n            } else if (typeof space === \"string\") {\n                spacer = space.slice(0, 10);\n            }\n            if (replacer != null) {\n                if (typeof replacer === \"function\") {\n                    return stringifyFnReplacer(\"\", {\n                        \"\": value\n                    }, [], replacer, spacer, \"\");\n                }\n                if (Array.isArray(replacer)) {\n                    return stringifyArrayReplacer(\"\", value, [], getUniqueReplacerSet(replacer), spacer, \"\");\n                }\n            }\n            if (spacer.length !== 0) {\n                return stringifyIndent(\"\", value, [], spacer, \"\");\n            }\n        }\n        return stringifySimple(\"\", value, []);\n    }\n    return stringify;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2FmZS1zdGFibGUtc3RyaW5naWZ5L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxjQUFjLEVBQUUsR0FBR0MsT0FBT0MsU0FBUztBQUUzQyxNQUFNQyxZQUFZQztBQUVsQixtQkFBbUI7QUFDbkJELFVBQVVDLFNBQVMsR0FBR0E7QUFDdEIsbUJBQW1CO0FBQ25CRCxVQUFVQSxTQUFTLEdBQUdBO0FBRXRCLG1CQUFtQjtBQUNuQkEsVUFBVUUsT0FBTyxHQUFHRjtBQUVwQix5Q0FBeUM7QUFDekNHLGlCQUFpQixHQUFHSDtBQUNwQix5Q0FBeUM7QUFDekNHLGlCQUFpQixHQUFHRjtBQUVwQkcsT0FBT0QsT0FBTyxHQUFHSDtBQUVqQiw0Q0FBNEM7QUFDNUMsTUFBTUssMkJBQTJCO0FBRWpDLDRFQUE0RTtBQUM1RSxxRUFBcUU7QUFDckUsU0FBU0MsVUFBV0MsR0FBRztJQUNyQix5RUFBeUU7SUFDekUsSUFBSUEsSUFBSUMsTUFBTSxHQUFHLFFBQVEsQ0FBQ0gseUJBQXlCSSxJQUFJLENBQUNGLE1BQU07UUFDNUQsT0FBTyxDQUFDLENBQUMsRUFBRUEsSUFBSSxDQUFDLENBQUM7SUFDbkI7SUFDQSxPQUFPRyxLQUFLVixTQUFTLENBQUNPO0FBQ3hCO0FBRUEsU0FBU0ksV0FBWUMsS0FBSztJQUN4QiwwRUFBMEU7SUFDMUUsd0VBQXdFO0lBQ3hFLElBQUlBLE1BQU1KLE1BQU0sR0FBRyxLQUFLO1FBQ3RCLE9BQU9JLE1BQU1DLElBQUk7SUFDbkI7SUFDQSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsTUFBTUosTUFBTSxFQUFFTSxJQUFLO1FBQ3JDLE1BQU1DLGVBQWVILEtBQUssQ0FBQ0UsRUFBRTtRQUM3QixJQUFJRSxXQUFXRjtRQUNmLE1BQU9FLGFBQWEsS0FBS0osS0FBSyxDQUFDSSxXQUFXLEVBQUUsR0FBR0QsYUFBYztZQUMzREgsS0FBSyxDQUFDSSxTQUFTLEdBQUdKLEtBQUssQ0FB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b2RlX21vZHVsZXMvc2FmZS1zdGFibGUtc3RyaW5naWZ5L2luZGV4LmpzP2Q0YjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgaGFzT3duUHJvcGVydHkgfSA9IE9iamVjdC5wcm90b3R5cGVcblxuY29uc3Qgc3RyaW5naWZ5ID0gY29uZmlndXJlKClcblxuLy8gQHRzLWV4cGVjdC1lcnJvclxuc3RyaW5naWZ5LmNvbmZpZ3VyZSA9IGNvbmZpZ3VyZVxuLy8gQHRzLWV4cGVjdC1lcnJvclxuc3RyaW5naWZ5LnN0cmluZ2lmeSA9IHN0cmluZ2lmeVxuXG4vLyBAdHMtZXhwZWN0LWVycm9yXG5zdHJpbmdpZnkuZGVmYXVsdCA9IHN0cmluZ2lmeVxuXG4vLyBAdHMtZXhwZWN0LWVycm9yIHVzZWQgZm9yIG5hbWVkIGV4cG9ydFxuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnlcbi8vIEB0cy1leHBlY3QtZXJyb3IgdXNlZCBmb3IgbmFtZWQgZXhwb3J0XG5leHBvcnRzLmNvbmZpZ3VyZSA9IGNvbmZpZ3VyZVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ2lmeVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuY29uc3Qgc3RyRXNjYXBlU2VxdWVuY2VzUmVnRXhwID0gL1tcXHUwMDAwLVxcdTAwMWZcXHUwMDIyXFx1MDA1Y1xcdWQ4MDAtXFx1ZGZmZl18W1xcdWQ4MDAtXFx1ZGJmZl0oPyFbXFx1ZGMwMC1cXHVkZmZmXSl8KD86W15cXHVkODAwLVxcdWRiZmZdfF4pW1xcdWRjMDAtXFx1ZGZmZl0vXG5cbi8vIEVzY2FwZSBDMCBjb250cm9sIGNoYXJhY3RlcnMsIGRvdWJsZSBxdW90ZXMsIHRoZSBiYWNrc2xhc2ggYW5kIGV2ZXJ5IGNvZGVcbi8vIHVuaXQgd2l0aCBhIG51bWVyaWMgdmFsdWUgaW4gdGhlIGluY2x1c2l2ZSByYW5nZSAweEQ4MDAgdG8gMHhERkZGLlxuZnVuY3Rpb24gc3RyRXNjYXBlIChzdHIpIHtcbiAgLy8gU29tZSBtYWdpYyBudW1iZXJzIHRoYXQgd29ya2VkIG91dCBmaW5lIHdoaWxlIGJlbmNobWFya2luZyB3aXRoIHY4IDguMFxuICBpZiAoc3RyLmxlbmd0aCA8IDUwMDAgJiYgIXN0ckVzY2FwZVNlcXVlbmNlc1JlZ0V4cC50ZXN0KHN0cikpIHtcbiAgICByZXR1cm4gYFwiJHtzdHJ9XCJgXG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0cilcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U29ydCAoYXJyYXkpIHtcbiAgLy8gSW5zZXJ0aW9uIHNvcnQgaXMgdmVyeSBlZmZpY2llbnQgZm9yIHNtYWxsIGlucHV0IHNpemVzIGJ1dCBpdCBoYXMgYSBiYWRcbiAgLy8gd29yc3QgY2FzZSBjb21wbGV4aXR5LiBUaHVzLCB1c2UgbmF0aXZlIGFycmF5IHNvcnQgZm9yIGJpZ2dlciB2YWx1ZXMuXG4gIGlmIChhcnJheS5sZW5ndGggPiAyZTIpIHtcbiAgICByZXR1cm4gYXJyYXkuc29ydCgpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGFycmF5W2ldXG4gICAgbGV0IHBvc2l0aW9uID0gaVxuICAgIHdoaWxlIChwb3NpdGlvbiAhPT0gMCAmJiBhcnJheVtwb3NpdGlvbiAtIDFdID4gY3VycmVudFZhbHVlKSB7XG4gICAgICBhcnJheVtwb3NpdGlvbl0gPSBhcnJheVtwb3NpdGlvbiAtIDFdXG4gICAgICBwb3NpdGlvbi0tXG4gICAgfVxuICAgIGFycmF5W3Bvc2l0aW9uXSA9IGN1cnJlbnRWYWx1ZVxuICB9XG4gIHJldHVybiBhcnJheVxufVxuXG5jb25zdCB0eXBlZEFycmF5UHJvdG90eXBlR2V0U3ltYm9sVG9TdHJpbmdUYWcgPVxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihcbiAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihcbiAgICAgICAgbmV3IEludDhBcnJheSgpXG4gICAgICApXG4gICAgKSxcbiAgICBTeW1ib2wudG9TdHJpbmdUYWdcbiAgKS5nZXRcblxuZnVuY3Rpb24gaXNUeXBlZEFycmF5V2l0aEVudHJpZXMgKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlZEFycmF5UHJvdG90eXBlR2V0U3ltYm9sVG9TdHJpbmdUYWcuY2FsbCh2YWx1ZSkgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5sZW5ndGggIT09IDBcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5VHlwZWRBcnJheSAoYXJyYXksIHNlcGFyYXRvciwgbWF4aW11bUJyZWFkdGgpIHtcbiAgaWYgKGFycmF5Lmxlbmd0aCA8IG1heGltdW1CcmVhZHRoKSB7XG4gICAgbWF4aW11bUJyZWFkdGggPSBhcnJheS5sZW5ndGhcbiAgfVxuICBjb25zdCB3aGl0ZXNwYWNlID0gc2VwYXJhdG9yID09PSAnLCcgPyAnJyA6ICcgJ1xuICBsZXQgcmVzID0gYFwiMFwiOiR7d2hpdGVzcGFjZX0ke2FycmF5WzBdfWBcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBtYXhpbXVtQnJlYWR0aDsgaSsrKSB7XG4gICAgcmVzICs9IGAke3NlcGFyYXRvcn1cIiR7aX1cIjoke3doaXRlc3BhY2V9JHthcnJheVtpXX1gXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRDaXJjdWxhclZhbHVlT3B0aW9uIChvcHRpb25zKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdjaXJjdWxhclZhbHVlJykpIHtcbiAgICBjb25zdCBjaXJjdWxhclZhbHVlID0gb3B0aW9ucy5jaXJjdWxhclZhbHVlXG4gICAgaWYgKHR5cGVvZiBjaXJjdWxhclZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGBcIiR7Y2lyY3VsYXJWYWx1ZX1cImBcbiAgICB9XG4gICAgaWYgKGNpcmN1bGFyVmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNpcmN1bGFyVmFsdWVcbiAgICB9XG4gICAgaWYgKGNpcmN1bGFyVmFsdWUgPT09IEVycm9yIHx8IGNpcmN1bGFyVmFsdWUgPT09IFR5cGVFcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9TdHJpbmcgKCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbnZlcnRpbmcgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEpTT04nKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImNpcmN1bGFyVmFsdWVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nIG9yIHRoZSB2YWx1ZSBudWxsIG9yIHVuZGVmaW5lZCcpXG4gIH1cbiAgcmV0dXJuICdcIltDaXJjdWxhcl1cIidcbn1cblxuZnVuY3Rpb24gZ2V0Qm9vbGVhbk9wdGlvbiAob3B0aW9ucywga2V5KSB7XG4gIGxldCB2YWx1ZVxuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBrZXkpKSB7XG4gICAgdmFsdWUgPSBvcHRpb25zW2tleV1cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7a2V5fVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBib29sZWFuYClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB0cnVlIDogdmFsdWVcbn1cblxuZnVuY3Rpb24gZ2V0UG9zaXRpdmVJbnRlZ2VyT3B0aW9uIChvcHRpb25zLCBrZXkpIHtcbiAgbGV0IHZhbHVlXG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIGtleSkpIHtcbiAgICB2YWx1ZSA9IG9wdGlvbnNba2V5XVxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke2tleX1cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyYClcbiAgICB9XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtrZXl9XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBpbnRlZ2VyYClcbiAgICB9XG4gICAgaWYgKHZhbHVlIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFRoZSBcIiR7a2V5fVwiIGFyZ3VtZW50IG11c3QgYmUgPj0gMWApXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gSW5maW5pdHkgOiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBnZXRJdGVtQ291bnQgKG51bWJlcikge1xuICBpZiAobnVtYmVyID09PSAxKSB7XG4gICAgcmV0dXJuICcxIGl0ZW0nXG4gIH1cbiAgcmV0dXJuIGAke251bWJlcn0gaXRlbXNgXG59XG5cbmZ1bmN0aW9uIGdldFVuaXF1ZVJlcGxhY2VyU2V0IChyZXBsYWNlckFycmF5KSB7XG4gIGNvbnN0IHJlcGxhY2VyU2V0ID0gbmV3IFNldCgpXG4gIGZvciAoY29uc3QgdmFsdWUgb2YgcmVwbGFjZXJBcnJheSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJlcGxhY2VyU2V0LmFkZChTdHJpbmcodmFsdWUpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVwbGFjZXJTZXRcbn1cblxuZnVuY3Rpb24gZ2V0U3RyaWN0T3B0aW9uIChvcHRpb25zKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdzdHJpY3QnKSkge1xuICAgIGNvbnN0IHZhbHVlID0gb3B0aW9ucy5zdHJpY3RcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInN0cmljdFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBib29sZWFuJylcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gYE9iamVjdCBjYW4gbm90IHNhZmVseSBiZSBzdHJpbmdpZmllZC4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiB2YWx1ZX1gXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIG1lc3NhZ2UgKz0gYCAoJHt2YWx1ZS50b1N0cmluZygpfSlgXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb25maWd1cmUgKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9XG4gIGNvbnN0IGZhaWwgPSBnZXRTdHJpY3RPcHRpb24ob3B0aW9ucylcbiAgaWYgKGZhaWwpIHtcbiAgICBpZiAob3B0aW9ucy5iaWdpbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy5iaWdpbnQgPSBmYWxzZVxuICAgIH1cbiAgICBpZiAoISgnY2lyY3VsYXJWYWx1ZScgaW4gb3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnMuY2lyY3VsYXJWYWx1ZSA9IEVycm9yXG4gICAgfVxuICB9XG4gIGNvbnN0IGNpcmN1bGFyVmFsdWUgPSBnZXRDaXJjdWxhclZhbHVlT3B0aW9uKG9wdGlvbnMpXG4gIGNvbnN0IGJpZ2ludCA9IGdldEJvb2xlYW5PcHRpb24ob3B0aW9ucywgJ2JpZ2ludCcpXG4gIGNvbnN0IGRldGVybWluaXN0aWMgPSBnZXRCb29sZWFuT3B0aW9uKG9wdGlvbnMsICdkZXRlcm1pbmlzdGljJylcbiAgY29uc3QgbWF4aW11bURlcHRoID0gZ2V0UG9zaXRpdmVJbnRlZ2VyT3B0aW9uKG9wdGlvbnMsICdtYXhpbXVtRGVwdGgnKVxuICBjb25zdCBtYXhpbXVtQnJlYWR0aCA9IGdldFBvc2l0aXZlSW50ZWdlck9wdGlvbihvcHRpb25zLCAnbWF4aW11bUJyZWFkdGgnKVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeUZuUmVwbGFjZXIgKGtleSwgcGFyZW50LCBzdGFjaywgcmVwbGFjZXIsIHNwYWNlciwgaW5kZW50YXRpb24pIHtcbiAgICBsZXQgdmFsdWUgPSBwYXJlbnRba2V5XVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oa2V5KVxuICAgIH1cbiAgICB2YWx1ZSA9IHJlcGxhY2VyLmNhbGwocGFyZW50LCBrZXksIHZhbHVlKVxuXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiBzdHJFc2NhcGUodmFsdWUpXG4gICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAnbnVsbCdcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhY2suaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIGNpcmN1bGFyVmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXMgPSAnJ1xuICAgICAgICBsZXQgam9pbiA9ICcsJ1xuICAgICAgICBjb25zdCBvcmlnaW5hbEluZGVudGF0aW9uID0gaW5kZW50YXRpb25cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tdJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF4aW11bURlcHRoIDwgc3RhY2subGVuZ3RoICsgMSkge1xuICAgICAgICAgICAgcmV0dXJuICdcIltBcnJheV1cIidcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSlcbiAgICAgICAgICBpZiAoc3BhY2VyICE9PSAnJykge1xuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gc3BhY2VyXG4gICAgICAgICAgICByZXMgKz0gYFxcbiR7aW5kZW50YXRpb259YFxuICAgICAgICAgICAgam9pbiA9IGAsXFxuJHtpbmRlbnRhdGlvbn1gXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG1heGltdW1WYWx1ZXNUb1N0cmluZ2lmeSA9IE1hdGgubWluKHZhbHVlLmxlbmd0aCwgbWF4aW11bUJyZWFkdGgpXG4gICAgICAgICAgbGV0IGkgPSAwXG4gICAgICAgICAgZm9yICg7IGkgPCBtYXhpbXVtVmFsdWVzVG9TdHJpbmdpZnkgLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IHN0cmluZ2lmeUZuUmVwbGFjZXIoU3RyaW5nKGkpLCB2YWx1ZSwgc3RhY2ssIHJlcGxhY2VyLCBzcGFjZXIsIGluZGVudGF0aW9uKVxuICAgICAgICAgICAgcmVzICs9IHRtcCAhPT0gdW5kZWZpbmVkID8gdG1wIDogJ251bGwnXG4gICAgICAgICAgICByZXMgKz0gam9pblxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0bXAgPSBzdHJpbmdpZnlGblJlcGxhY2VyKFN0cmluZyhpKSwgdmFsdWUsIHN0YWNrLCByZXBsYWNlciwgc3BhY2VyLCBpbmRlbnRhdGlvbilcbiAgICAgICAgICByZXMgKz0gdG1wICE9PSB1bmRlZmluZWQgPyB0bXAgOiAnbnVsbCdcbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoIC0gMSA+IG1heGltdW1CcmVhZHRoKSB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVkS2V5cyA9IHZhbHVlLmxlbmd0aCAtIG1heGltdW1CcmVhZHRoIC0gMVxuICAgICAgICAgICAgcmVzICs9IGAke2pvaW59XCIuLi4gJHtnZXRJdGVtQ291bnQocmVtb3ZlZEtleXMpfSBub3Qgc3RyaW5naWZpZWRcImBcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNwYWNlciAhPT0gJycpIHtcbiAgICAgICAgICAgIHJlcyArPSBgXFxuJHtvcmlnaW5hbEluZGVudGF0aW9ufWBcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhY2sucG9wKClcbiAgICAgICAgICByZXR1cm4gYFske3Jlc31dYFxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSlcbiAgICAgICAgY29uc3Qga2V5TGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICAgaWYgKGtleUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiAne30nXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heGltdW1EZXB0aCA8IHN0YWNrLmxlbmd0aCArIDEpIHtcbiAgICAgICAgICByZXR1cm4gJ1wiW09iamVjdF1cIidcbiAgICAgICAgfVxuICAgICAgICBsZXQgd2hpdGVzcGFjZSA9ICcnXG4gICAgICAgIGxldCBzZXBhcmF0b3IgPSAnJ1xuICAgICAgICBpZiAoc3BhY2VyICE9PSAnJykge1xuICAgICAgICAgIGluZGVudGF0aW9uICs9IHNwYWNlclxuICAgICAgICAgIGpvaW4gPSBgLFxcbiR7aW5kZW50YXRpb259YFxuICAgICAgICAgIHdoaXRlc3BhY2UgPSAnICdcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXhpbXVtUHJvcGVydGllc1RvU3RyaW5naWZ5ID0gTWF0aC5taW4oa2V5TGVuZ3RoLCBtYXhpbXVtQnJlYWR0aClcbiAgICAgICAgaWYgKGRldGVybWluaXN0aWMgJiYgIWlzVHlwZWRBcnJheVdpdGhFbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICAgIGtleXMgPSBpbnNlcnRTb3J0KGtleXMpXG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhpbXVtUHJvcGVydGllc1RvU3RyaW5naWZ5OyBpKyspIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG4gICAgICAgICAgY29uc3QgdG1wID0gc3RyaW5naWZ5Rm5SZXBsYWNlcihrZXksIHZhbHVlLCBzdGFjaywgcmVwbGFjZXIsIHNwYWNlciwgaW5kZW50YXRpb24pXG4gICAgICAgICAgaWYgKHRtcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXMgKz0gYCR7c2VwYXJhdG9yfSR7c3RyRXNjYXBlKGtleSl9OiR7d2hpdGVzcGFjZX0ke3RtcH1gXG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBqb2luXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlMZW5ndGggPiBtYXhpbXVtQnJlYWR0aCkge1xuICAgICAgICAgIGNvbnN0IHJlbW92ZWRLZXlzID0ga2V5TGVuZ3RoIC0gbWF4aW11bUJyZWFkdGhcbiAgICAgICAgICByZXMgKz0gYCR7c2VwYXJhdG9yfVwiLi4uXCI6JHt3aGl0ZXNwYWNlfVwiJHtnZXRJdGVtQ291bnQocmVtb3ZlZEtleXMpfSBub3Qgc3RyaW5naWZpZWRcImBcbiAgICAgICAgICBzZXBhcmF0b3IgPSBqb2luXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwYWNlciAhPT0gJycgJiYgc2VwYXJhdG9yLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXMgPSBgXFxuJHtpbmRlbnRhdGlvbn0ke3Jlc31cXG4ke29yaWdpbmFsSW5kZW50YXRpb259YFxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnBvcCgpXG4gICAgICAgIHJldHVybiBgeyR7cmVzfX1gXG4gICAgICB9XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6IGZhaWwgPyBmYWlsKHZhbHVlKSA6ICdudWxsJ1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSA/ICd0cnVlJyA6ICdmYWxzZSdcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICAgIGlmIChiaWdpbnQpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKVxuICAgICAgICB9XG4gICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFpbCA/IGZhaWwodmFsdWUpIDogdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXlSZXBsYWNlciAoa2V5LCB2YWx1ZSwgc3RhY2ssIHJlcGxhY2VyLCBzcGFjZXIsIGluZGVudGF0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oa2V5KVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gc3RyRXNjYXBlKHZhbHVlKVxuICAgICAgY2FzZSAnb2JqZWN0Jzoge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gJ251bGwnXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YWNrLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiBjaXJjdWxhclZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvcmlnaW5hbEluZGVudGF0aW9uID0gaW5kZW50YXRpb25cbiAgICAgICAgbGV0IHJlcyA9ICcnXG4gICAgICAgIGxldCBqb2luID0gJywnXG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdbXSdcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1heGltdW1EZXB0aCA8IHN0YWNrLmxlbmd0aCArIDEpIHtcbiAgICAgICAgICAgIHJldHVybiAnXCJbQXJyYXldXCInXG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpXG4gICAgICAgICAgaWYgKHNwYWNlciAhPT0gJycpIHtcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHNwYWNlclxuICAgICAgICAgICAgcmVzICs9IGBcXG4ke2luZGVudGF0aW9ufWBcbiAgICAgICAgICAgIGpvaW4gPSBgLFxcbiR7aW5kZW50YXRpb259YFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBtYXhpbXVtVmFsdWVzVG9TdHJpbmdpZnkgPSBNYXRoLm1pbih2YWx1ZS5sZW5ndGgsIG1heGltdW1CcmVhZHRoKVxuICAgICAgICAgIGxldCBpID0gMFxuICAgICAgICAgIGZvciAoOyBpIDwgbWF4aW11bVZhbHVlc1RvU3RyaW5naWZ5IC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0bXAgPSBzdHJpbmdpZnlBcnJheVJlcGxhY2VyKFN0cmluZyhpKSwgdmFsdWVbaV0sIHN0YWNrLCByZXBsYWNlciwgc3BhY2VyLCBpbmRlbnRhdGlvbilcbiAgICAgICAgICAgIHJlcyArPSB0bXAgIT09IHVuZGVmaW5lZCA/IHRtcCA6ICdudWxsJ1xuICAgICAgICAgICAgcmVzICs9IGpvaW5cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdG1wID0gc3RyaW5naWZ5QXJyYXlSZXBsYWNlcihTdHJpbmcoaSksIHZhbHVlW2ldLCBzdGFjaywgcmVwbGFjZXIsIHNwYWNlciwgaW5kZW50YXRpb24pXG4gICAgICAgICAgcmVzICs9IHRtcCAhPT0gdW5kZWZpbmVkID8gdG1wIDogJ251bGwnXG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAtIDEgPiBtYXhpbXVtQnJlYWR0aCkge1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZEtleXMgPSB2YWx1ZS5sZW5ndGggLSBtYXhpbXVtQnJlYWR0aCAtIDFcbiAgICAgICAgICAgIHJlcyArPSBgJHtqb2lufVwiLi4uICR7Z2V0SXRlbUNvdW50KHJlbW92ZWRLZXlzKX0gbm90IHN0cmluZ2lmaWVkXCJgXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzcGFjZXIgIT09ICcnKSB7XG4gICAgICAgICAgICByZXMgKz0gYFxcbiR7b3JpZ2luYWxJbmRlbnRhdGlvbn1gXG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YWNrLnBvcCgpXG4gICAgICAgICAgcmV0dXJuIGBbJHtyZXN9XWBcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wdXNoKHZhbHVlKVxuICAgICAgICBsZXQgd2hpdGVzcGFjZSA9ICcnXG4gICAgICAgIGlmIChzcGFjZXIgIT09ICcnKSB7XG4gICAgICAgICAgaW5kZW50YXRpb24gKz0gc3BhY2VyXG4gICAgICAgICAgam9pbiA9IGAsXFxuJHtpbmRlbnRhdGlvbn1gXG4gICAgICAgICAgd2hpdGVzcGFjZSA9ICcgJ1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZXBhcmF0b3IgPSAnJ1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiByZXBsYWNlcikge1xuICAgICAgICAgIGNvbnN0IHRtcCA9IHN0cmluZ2lmeUFycmF5UmVwbGFjZXIoa2V5LCB2YWx1ZVtrZXldLCBzdGFjaywgcmVwbGFjZXIsIHNwYWNlciwgaW5kZW50YXRpb24pXG4gICAgICAgICAgaWYgKHRtcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXMgKz0gYCR7c2VwYXJhdG9yfSR7c3RyRXNjYXBlKGtleSl9OiR7d2hpdGVzcGFjZX0ke3RtcH1gXG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBqb2luXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzcGFjZXIgIT09ICcnICYmIHNlcGFyYXRvci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmVzID0gYFxcbiR7aW5kZW50YXRpb259JHtyZXN9XFxuJHtvcmlnaW5hbEluZGVudGF0aW9ufWBcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wb3AoKVxuICAgICAgICByZXR1cm4gYHske3Jlc319YFxuICAgICAgfVxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiBmYWlsID8gZmFpbCh2YWx1ZSkgOiAnbnVsbCdcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgPyAndHJ1ZScgOiAnZmFsc2UnXG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICBpZiAoYmlnaW50KSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhaWwgPyBmYWlsKHZhbHVlKSA6IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeUluZGVudCAoa2V5LCB2YWx1ZSwgc3RhY2ssIHNwYWNlciwgaW5kZW50YXRpb24pIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIHN0ckVzY2FwZSh2YWx1ZSlcbiAgICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICdudWxsJ1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oa2V5KVxuICAgICAgICAgIC8vIFByZXZlbnQgY2FsbGluZyBgdG9KU09OYCBhZ2Fpbi5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUluZGVudChrZXksIHZhbHVlLCBzdGFjaywgc3BhY2VyLCBpbmRlbnRhdGlvbilcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJ251bGwnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFjay5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gY2lyY3VsYXJWYWx1ZVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsSW5kZW50YXRpb24gPSBpbmRlbnRhdGlvblxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnW10nXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhpbXVtRGVwdGggPCBzdGFjay5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1wiW0FycmF5XVwiJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKVxuICAgICAgICAgIGluZGVudGF0aW9uICs9IHNwYWNlclxuICAgICAgICAgIGxldCByZXMgPSBgXFxuJHtpbmRlbnRhdGlvbn1gXG4gICAgICAgICAgY29uc3Qgam9pbiA9IGAsXFxuJHtpbmRlbnRhdGlvbn1gXG4gICAgICAgICAgY29uc3QgbWF4aW11bVZhbHVlc1RvU3RyaW5naWZ5ID0gTWF0aC5taW4odmFsdWUubGVuZ3RoLCBtYXhpbXVtQnJlYWR0aClcbiAgICAgICAgICBsZXQgaSA9IDBcbiAgICAgICAgICBmb3IgKDsgaSA8IG1heGltdW1WYWx1ZXNUb1N0cmluZ2lmeSAtIDE7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdG1wID0gc3RyaW5naWZ5SW5kZW50KFN0cmluZyhpKSwgdmFsdWVbaV0sIHN0YWNrLCBzcGFjZXIsIGluZGVudGF0aW9uKVxuICAgICAgICAgICAgcmVzICs9IHRtcCAhPT0gdW5kZWZpbmVkID8gdG1wIDogJ251bGwnXG4gICAgICAgICAgICByZXMgKz0gam9pblxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0bXAgPSBzdHJpbmdpZnlJbmRlbnQoU3RyaW5nKGkpLCB2YWx1ZVtpXSwgc3RhY2ssIHNwYWNlciwgaW5kZW50YXRpb24pXG4gICAgICAgICAgcmVzICs9IHRtcCAhPT0gdW5kZWZpbmVkID8gdG1wIDogJ251bGwnXG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAtIDEgPiBtYXhpbXVtQnJlYWR0aCkge1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZEtleXMgPSB2YWx1ZS5sZW5ndGggLSBtYXhpbXVtQnJlYWR0aCAtIDFcbiAgICAgICAgICAgIHJlcyArPSBgJHtqb2lufVwiLi4uICR7Z2V0SXRlbUNvdW50KHJlbW92ZWRLZXlzKX0gbm90IHN0cmluZ2lmaWVkXCJgXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcyArPSBgXFxuJHtvcmlnaW5hbEluZGVudGF0aW9ufWBcbiAgICAgICAgICBzdGFjay5wb3AoKVxuICAgICAgICAgIHJldHVybiBgWyR7cmVzfV1gXG4gICAgICAgIH1cblxuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKVxuICAgICAgICBjb25zdCBrZXlMZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgICBpZiAoa2V5TGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuICd7fSdcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4aW11bURlcHRoIDwgc3RhY2subGVuZ3RoICsgMSkge1xuICAgICAgICAgIHJldHVybiAnXCJbT2JqZWN0XVwiJ1xuICAgICAgICB9XG4gICAgICAgIGluZGVudGF0aW9uICs9IHNwYWNlclxuICAgICAgICBjb25zdCBqb2luID0gYCxcXG4ke2luZGVudGF0aW9ufWBcbiAgICAgICAgbGV0IHJlcyA9ICcnXG4gICAgICAgIGxldCBzZXBhcmF0b3IgPSAnJ1xuICAgICAgICBsZXQgbWF4aW11bVByb3BlcnRpZXNUb1N0cmluZ2lmeSA9IE1hdGgubWluKGtleUxlbmd0aCwgbWF4aW11bUJyZWFkdGgpXG4gICAgICAgIGlmIChpc1R5cGVkQXJyYXlXaXRoRW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICByZXMgKz0gc3RyaW5naWZ5VHlwZWRBcnJheSh2YWx1ZSwgam9pbiwgbWF4aW11bUJyZWFkdGgpXG4gICAgICAgICAga2V5cyA9IGtleXMuc2xpY2UodmFsdWUubGVuZ3RoKVxuICAgICAgICAgIG1heGltdW1Qcm9wZXJ0aWVzVG9TdHJpbmdpZnkgLT0gdmFsdWUubGVuZ3RoXG4gICAgICAgICAgc2VwYXJhdG9yID0gam9pblxuICAgICAgICB9XG4gICAgICAgIGlmIChkZXRlcm1pbmlzdGljKSB7XG4gICAgICAgICAga2V5cyA9IGluc2VydFNvcnQoa2V5cylcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wdXNoKHZhbHVlKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heGltdW1Qcm9wZXJ0aWVzVG9TdHJpbmdpZnk7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV1cbiAgICAgICAgICBjb25zdCB0bXAgPSBzdHJpbmdpZnlJbmRlbnQoa2V5LCB2YWx1ZVtrZXldLCBzdGFjaywgc3BhY2VyLCBpbmRlbnRhdGlvbilcbiAgICAgICAgICBpZiAodG1wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlcyArPSBgJHtzZXBhcmF0b3J9JHtzdHJFc2NhcGUoa2V5KX06ICR7dG1wfWBcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IGpvaW5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleUxlbmd0aCA+IG1heGltdW1CcmVhZHRoKSB7XG4gICAgICAgICAgY29uc3QgcmVtb3ZlZEtleXMgPSBrZXlMZW5ndGggLSBtYXhpbXVtQnJlYWR0aFxuICAgICAgICAgIHJlcyArPSBgJHtzZXBhcmF0b3J9XCIuLi5cIjogXCIke2dldEl0ZW1Db3VudChyZW1vdmVkS2V5cyl9IG5vdCBzdHJpbmdpZmllZFwiYFxuICAgICAgICAgIHNlcGFyYXRvciA9IGpvaW5cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VwYXJhdG9yICE9PSAnJykge1xuICAgICAgICAgIHJlcyA9IGBcXG4ke2luZGVudGF0aW9ufSR7cmVzfVxcbiR7b3JpZ2luYWxJbmRlbnRhdGlvbn1gXG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucG9wKClcbiAgICAgICAgcmV0dXJuIGB7JHtyZXN9fWBcbiAgICAgIH1cbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogZmFpbCA/IGZhaWwodmFsdWUpIDogJ251bGwnXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlID8gJ3RydWUnIDogJ2ZhbHNlJ1xuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgY2FzZSAnYmlnaW50JzpcbiAgICAgICAgaWYgKGJpZ2ludCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpXG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWlsID8gZmFpbCh2YWx1ZSkgOiB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnlTaW1wbGUgKGtleSwgdmFsdWUsIHN0YWNrKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiBzdHJFc2NhcGUodmFsdWUpXG4gICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAnbnVsbCdcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSlcbiAgICAgICAgICAvLyBQcmV2ZW50IGNhbGxpbmcgYHRvSlNPTmAgYWdhaW5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeVNpbXBsZShrZXksIHZhbHVlLCBzdGFjaylcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJ251bGwnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFjay5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gY2lyY3VsYXJWYWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlcyA9ICcnXG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdbXSdcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1heGltdW1EZXB0aCA8IHN0YWNrLmxlbmd0aCArIDEpIHtcbiAgICAgICAgICAgIHJldHVybiAnXCJbQXJyYXldXCInXG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpXG4gICAgICAgICAgY29uc3QgbWF4aW11bVZhbHVlc1RvU3RyaW5naWZ5ID0gTWF0aC5taW4odmFsdWUubGVuZ3RoLCBtYXhpbXVtQnJlYWR0aClcbiAgICAgICAgICBsZXQgaSA9IDBcbiAgICAgICAgICBmb3IgKDsgaSA8IG1heGltdW1WYWx1ZXNUb1N0cmluZ2lmeSAtIDE7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdG1wID0gc3RyaW5naWZ5U2ltcGxlKFN0cmluZyhpKSwgdmFsdWVbaV0sIHN0YWNrKVxuICAgICAgICAgICAgcmVzICs9IHRtcCAhPT0gdW5kZWZpbmVkID8gdG1wIDogJ251bGwnXG4gICAgICAgICAgICByZXMgKz0gJywnXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRtcCA9IHN0cmluZ2lmeVNpbXBsZShTdHJpbmcoaSksIHZhbHVlW2ldLCBzdGFjaylcbiAgICAgICAgICByZXMgKz0gdG1wICE9PSB1bmRlZmluZWQgPyB0bXAgOiAnbnVsbCdcbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoIC0gMSA+IG1heGltdW1CcmVhZHRoKSB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVkS2V5cyA9IHZhbHVlLmxlbmd0aCAtIG1heGltdW1CcmVhZHRoIC0gMVxuICAgICAgICAgICAgcmVzICs9IGAsXCIuLi4gJHtnZXRJdGVtQ291bnQocmVtb3ZlZEtleXMpfSBub3Qgc3RyaW5naWZpZWRcImBcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhY2sucG9wKClcbiAgICAgICAgICByZXR1cm4gYFske3Jlc31dYFxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSlcbiAgICAgICAgY29uc3Qga2V5TGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICAgaWYgKGtleUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiAne30nXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heGltdW1EZXB0aCA8IHN0YWNrLmxlbmd0aCArIDEpIHtcbiAgICAgICAgICByZXR1cm4gJ1wiW09iamVjdF1cIidcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VwYXJhdG9yID0gJydcbiAgICAgICAgbGV0IG1heGltdW1Qcm9wZXJ0aWVzVG9TdHJpbmdpZnkgPSBNYXRoLm1pbihrZXlMZW5ndGgsIG1heGltdW1CcmVhZHRoKVxuICAgICAgICBpZiAoaXNUeXBlZEFycmF5V2l0aEVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgcmVzICs9IHN0cmluZ2lmeVR5cGVkQXJyYXkodmFsdWUsICcsJywgbWF4aW11bUJyZWFkdGgpXG4gICAgICAgICAga2V5cyA9IGtleXMuc2xpY2UodmFsdWUubGVuZ3RoKVxuICAgICAgICAgIG1heGltdW1Qcm9wZXJ0aWVzVG9TdHJpbmdpZnkgLT0gdmFsdWUubGVuZ3RoXG4gICAgICAgICAgc2VwYXJhdG9yID0gJywnXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRldGVybWluaXN0aWMpIHtcbiAgICAgICAgICBrZXlzID0gaW5zZXJ0U29ydChrZXlzKVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2godmFsdWUpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4aW11bVByb3BlcnRpZXNUb1N0cmluZ2lmeTsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgICAgICAgIGNvbnN0IHRtcCA9IHN0cmluZ2lmeVNpbXBsZShrZXksIHZhbHVlW2tleV0sIHN0YWNrKVxuICAgICAgICAgIGlmICh0bXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzICs9IGAke3NlcGFyYXRvcn0ke3N0ckVzY2FwZShrZXkpfToke3RtcH1gXG4gICAgICAgICAgICBzZXBhcmF0b3IgPSAnLCdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleUxlbmd0aCA+IG1heGltdW1CcmVhZHRoKSB7XG4gICAgICAgICAgY29uc3QgcmVtb3ZlZEtleXMgPSBrZXlMZW5ndGggLSBtYXhpbXVtQnJlYWR0aFxuICAgICAgICAgIHJlcyArPSBgJHtzZXBhcmF0b3J9XCIuLi5cIjpcIiR7Z2V0SXRlbUNvdW50KHJlbW92ZWRLZXlzKX0gbm90IHN0cmluZ2lmaWVkXCJgXG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucG9wKClcbiAgICAgICAgcmV0dXJuIGB7JHtyZXN9fWBcbiAgICAgIH1cbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogZmFpbCA/IGZhaWwodmFsdWUpIDogJ251bGwnXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlID8gJ3RydWUnIDogJ2ZhbHNlJ1xuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgY2FzZSAnYmlnaW50JzpcbiAgICAgICAgaWYgKGJpZ2ludCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpXG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWlsID8gZmFpbCh2YWx1ZSkgOiB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnkgKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGxldCBzcGFjZXIgPSAnJ1xuICAgICAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc3BhY2VyID0gJyAnLnJlcGVhdChNYXRoLm1pbihzcGFjZSwgMTApKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNwYWNlciA9IHNwYWNlLnNsaWNlKDAsIDEwKVxuICAgICAgfVxuICAgICAgaWYgKHJlcGxhY2VyICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBzdHJpbmdpZnlGblJlcGxhY2VyKCcnLCB7ICcnOiB2YWx1ZSB9LCBbXSwgcmVwbGFjZXIsIHNwYWNlciwgJycpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVwbGFjZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5UmVwbGFjZXIoJycsIHZhbHVlLCBbXSwgZ2V0VW5pcXVlUmVwbGFjZXJTZXQocmVwbGFjZXIpLCBzcGFjZXIsICcnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3BhY2VyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5SW5kZW50KCcnLCB2YWx1ZSwgW10sIHNwYWNlciwgJycpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdpZnlTaW1wbGUoJycsIHZhbHVlLCBbXSlcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdpZnlcbn1cbiJdLCJuYW1lcyI6WyJoYXNPd25Qcm9wZXJ0eSIsIk9iamVjdCIsInByb3RvdHlwZSIsInN0cmluZ2lmeSIsImNvbmZpZ3VyZSIsImRlZmF1bHQiLCJleHBvcnRzIiwibW9kdWxlIiwic3RyRXNjYXBlU2VxdWVuY2VzUmVnRXhwIiwic3RyRXNjYXBlIiwic3RyIiwibGVuZ3RoIiwidGVzdCIsIkpTT04iLCJpbnNlcnRTb3J0IiwiYXJyYXkiLCJzb3J0IiwiaSIsImN1cnJlbnRWYWx1ZSIsInBvc2l0aW9uIiwidHlwZWRBcnJheVByb3RvdHlwZUdldFN5bWJvbFRvU3RyaW5nVGFnIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0UHJvdG90eXBlT2YiLCJJbnQ4QXJyYXkiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsImdldCIsImlzVHlwZWRBcnJheVdpdGhFbnRyaWVzIiwidmFsdWUiLCJjYWxsIiwidW5kZWZpbmVkIiwic3RyaW5naWZ5VHlwZWRBcnJheSIsInNlcGFyYXRvciIsIm1heGltdW1CcmVhZHRoIiwid2hpdGVzcGFjZSIsInJlcyIsImdldENpcmN1bGFyVmFsdWVPcHRpb24iLCJvcHRpb25zIiwiY2lyY3VsYXJWYWx1ZSIsIkVycm9yIiwiVHlwZUVycm9yIiwidG9TdHJpbmciLCJnZXRCb29sZWFuT3B0aW9uIiwia2V5IiwiZ2V0UG9zaXRpdmVJbnRlZ2VyT3B0aW9uIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiUmFuZ2VFcnJvciIsIkluZmluaXR5IiwiZ2V0SXRlbUNvdW50IiwibnVtYmVyIiwiZ2V0VW5pcXVlUmVwbGFjZXJTZXQiLCJyZXBsYWNlckFycmF5IiwicmVwbGFjZXJTZXQiLCJTZXQiLCJhZGQiLCJTdHJpbmciLCJnZXRTdHJpY3RPcHRpb24iLCJzdHJpY3QiLCJtZXNzYWdlIiwiZmFpbCIsImJpZ2ludCIsImRldGVybWluaXN0aWMiLCJtYXhpbXVtRGVwdGgiLCJzdHJpbmdpZnlGblJlcGxhY2VyIiwicGFyZW50Iiwic3RhY2siLCJyZXBsYWNlciIsInNwYWNlciIsImluZGVudGF0aW9uIiwidG9KU09OIiwiaW5kZXhPZiIsImpvaW4iLCJvcmlnaW5hbEluZGVudGF0aW9uIiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsIm1heGltdW1WYWx1ZXNUb1N0cmluZ2lmeSIsIk1hdGgiLCJtaW4iLCJ0bXAiLCJyZW1vdmVkS2V5cyIsInBvcCIsImtleXMiLCJrZXlMZW5ndGgiLCJtYXhpbXVtUHJvcGVydGllc1RvU3RyaW5naWZ5IiwiaXNGaW5pdGUiLCJzdHJpbmdpZnlBcnJheVJlcGxhY2VyIiwic3RyaW5naWZ5SW5kZW50Iiwic2xpY2UiLCJzdHJpbmdpZnlTaW1wbGUiLCJzcGFjZSIsImFyZ3VtZW50cyIsInJlcGVhdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/safe-stable-stringify/index.js\n");

/***/ })

};
;