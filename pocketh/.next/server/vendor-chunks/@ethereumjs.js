"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ethereumjs";
exports.ids = ["vendor-chunks/@ethereumjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@ethereumjs/rlp/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@ethereumjs/rlp/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RLP = exports.utils = exports.decode = exports.encode = void 0;\n/**\n * RLP Encoding based on https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/\n * This function takes in data, converts it to Uint8Array if not,\n * and adds a length for recursion.\n * @param input Will be converted to Uint8Array\n * @returns Uint8Array of encoded data\n **/ function encode(input) {\n    if (Array.isArray(input)) {\n        const output = [];\n        let outputLength = 0;\n        for(let i = 0; i < input.length; i++){\n            const encoded = encode(input[i]);\n            output.push(encoded);\n            outputLength += encoded.length;\n        }\n        return concatBytes(encodeLength(outputLength, 192), ...output);\n    }\n    const inputBuf = toBytes(input);\n    if (inputBuf.length === 1 && inputBuf[0] < 128) {\n        return inputBuf;\n    }\n    return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);\n}\nexports.encode = encode;\n/**\n * Slices a Uint8Array, throws if the slice goes out-of-bounds of the Uint8Array.\n * E.g. `safeSlice(hexToBytes('aa'), 1, 2)` will throw.\n * @param input\n * @param start\n * @param end\n */ function safeSlice(input, start, end) {\n    if (end > input.length) {\n        throw new Error(\"invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds\");\n    }\n    return input.slice(start, end);\n}\n/**\n * Parse integers. Check if there is no leading zeros\n * @param v The value to parse\n */ function decodeLength(v) {\n    if (v[0] === 0) {\n        throw new Error(\"invalid RLP: extra zeros\");\n    }\n    return parseHexByte(bytesToHex(v));\n}\nfunction encodeLength(len, offset) {\n    if (len < 56) {\n        return Uint8Array.from([\n            len + offset\n        ]);\n    }\n    const hexLength = numberToHex(len);\n    const lLength = hexLength.length / 2;\n    const firstByte = numberToHex(offset + 55 + lLength);\n    return Uint8Array.from(hexToBytes(firstByte + hexLength));\n}\nfunction decode(input, stream = false) {\n    if (typeof input === \"undefined\" || input === null || input.length === 0) {\n        return Uint8Array.from([]);\n    }\n    const inputBytes = toBytes(input);\n    const decoded = _decode(inputBytes);\n    if (stream) {\n        return decoded;\n    }\n    if (decoded.remainder.length !== 0) {\n        throw new Error(\"invalid RLP: remainder must be zero\");\n    }\n    return decoded.data;\n}\nexports.decode = decode;\n/** Decode an input with RLP */ function _decode(input) {\n    let length, llength, data, innerRemainder, d;\n    const decoded = [];\n    const firstByte = input[0];\n    if (firstByte <= 0x7f) {\n        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.\n        return {\n            data: input.slice(0, 1),\n            remainder: input.slice(1)\n        };\n    } else if (firstByte <= 0xb7) {\n        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string\n        // The range of the first byte is [0x80, 0xb7]\n        length = firstByte - 0x7f;\n        // set 0x80 null to 0\n        if (firstByte === 0x80) {\n            data = Uint8Array.from([]);\n        } else {\n            data = safeSlice(input, 1, length);\n        }\n        if (length === 2 && data[0] < 0x80) {\n            throw new Error(\"invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed\");\n        }\n        return {\n            data,\n            remainder: input.slice(length)\n        };\n    } else if (firstByte <= 0xbf) {\n        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),\n        // followed by the length, followed by the string\n        llength = firstByte - 0xb6;\n        if (input.length - 1 < llength) {\n            throw new Error(\"invalid RLP: not enough bytes for string length\");\n        }\n        length = decodeLength(safeSlice(input, 1, llength));\n        if (length <= 55) {\n            throw new Error(\"invalid RLP: expected string length to be greater than 55\");\n        }\n        data = safeSlice(input, llength, length + llength);\n        return {\n            data,\n            remainder: input.slice(length + llength)\n        };\n    } else if (firstByte <= 0xf7) {\n        // a list between 0-55 bytes long\n        length = firstByte - 0xbf;\n        innerRemainder = safeSlice(input, 1, length);\n        while(innerRemainder.length){\n            d = _decode(innerRemainder);\n            decoded.push(d.data);\n            innerRemainder = d.remainder;\n        }\n        return {\n            data: decoded,\n            remainder: input.slice(length)\n        };\n    } else {\n        // a list over 55 bytes long\n        llength = firstByte - 0xf6;\n        length = decodeLength(safeSlice(input, 1, llength));\n        if (length < 56) {\n            throw new Error(\"invalid RLP: encoded list too short\");\n        }\n        const totalLength = llength + length;\n        if (totalLength > input.length) {\n            throw new Error(\"invalid RLP: total length is larger than the data\");\n        }\n        innerRemainder = safeSlice(input, llength, totalLength);\n        while(innerRemainder.length){\n            d = _decode(innerRemainder);\n            decoded.push(d.data);\n            innerRemainder = d.remainder;\n        }\n        return {\n            data: decoded,\n            remainder: input.slice(totalLength)\n        };\n    }\n}\nconst cachedHexes = Array.from({\n    length: 256\n}, (_v, i)=>i.toString(16).padStart(2, \"0\"));\nfunction bytesToHex(uint8a) {\n    // Pre-caching chars with `cachedHexes` speeds this up 6x\n    let hex = \"\";\n    for(let i = 0; i < uint8a.length; i++){\n        hex += cachedHexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction parseHexByte(hexByte) {\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte)) throw new Error(\"Invalid byte sequence\");\n    return byte;\n}\n// Caching slows it down 2-3x\nfunction hexToBytes(hex) {\n    if (typeof hex !== \"string\") {\n        throw new TypeError(\"hexToBytes: expected string, got \" + typeof hex);\n    }\n    if (hex.length % 2) throw new Error(\"hexToBytes: received invalid unpadded hex\");\n    const array = new Uint8Array(hex.length / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        array[i] = parseHexByte(hex.slice(j, j + 2));\n    }\n    return array;\n}\n/** Concatenates two Uint8Arrays into one. */ function concatBytes(...arrays) {\n    if (arrays.length === 1) return arrays[0];\n    const length = arrays.reduce((a, arr)=>a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nfunction utf8ToBytes(utf) {\n    return new TextEncoder().encode(utf);\n}\n/** Transform an integer into its hexadecimal value */ function numberToHex(integer) {\n    if (integer < 0) {\n        throw new Error(\"Invalid integer as argument, must be unsigned!\");\n    }\n    const hex = integer.toString(16);\n    return hex.length % 2 ? `0${hex}` : hex;\n}\n/** Pad a string to be even */ function padToEven(a) {\n    return a.length % 2 ? `0${a}` : a;\n}\n/** Check if a string is prefixed by 0x */ function isHexPrefixed(str) {\n    return str.length >= 2 && str[0] === \"0\" && str[1] === \"x\";\n}\n/** Removes 0x from a given String */ function stripHexPrefix(str) {\n    if (typeof str !== \"string\") {\n        return str;\n    }\n    return isHexPrefixed(str) ? str.slice(2) : str;\n}\n/** Transform anything into a Uint8Array */ function toBytes(v) {\n    if (v instanceof Uint8Array) {\n        return v;\n    }\n    if (typeof v === \"string\") {\n        if (isHexPrefixed(v)) {\n            return hexToBytes(padToEven(stripHexPrefix(v)));\n        }\n        return utf8ToBytes(v);\n    }\n    if (typeof v === \"number\" || typeof v === \"bigint\") {\n        if (!v) {\n            return Uint8Array.from([]);\n        }\n        return hexToBytes(numberToHex(v));\n    }\n    if (v === null || v === undefined) {\n        return Uint8Array.from([]);\n    }\n    throw new Error(\"toBytes: received unsupported type \" + typeof v);\n}\nexports.utils = {\n    bytesToHex,\n    concatBytes,\n    hexToBytes,\n    utf8ToBytes\n};\nexports.RLP = {\n    encode,\n    decode\n}; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvcmxwL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELFdBQVcsR0FBR0EsYUFBYSxHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBRyxLQUFLO0FBQ3JFOzs7Ozs7RUFNRSxHQUNGLFNBQVNLLE9BQU9DLEtBQUs7SUFDakIsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixRQUFRO1FBQ3RCLE1BQU1HLFNBQVMsRUFBRTtRQUNqQixJQUFJQyxlQUFlO1FBQ25CLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTCxNQUFNTSxNQUFNLEVBQUVELElBQUs7WUFDbkMsTUFBTUUsVUFBVVIsT0FBT0MsS0FBSyxDQUFDSyxFQUFFO1lBQy9CRixPQUFPSyxJQUFJLENBQUNEO1lBQ1pILGdCQUFnQkcsUUFBUUQsTUFBTTtRQUNsQztRQUNBLE9BQU9HLFlBQVlDLGFBQWFOLGNBQWMsU0FBU0Q7SUFDM0Q7SUFDQSxNQUFNUSxXQUFXQyxRQUFRWjtJQUN6QixJQUFJVyxTQUFTTCxNQUFNLEtBQUssS0FBS0ssUUFBUSxDQUFDLEVBQUUsR0FBRyxLQUFLO1FBQzVDLE9BQU9BO0lBQ1g7SUFDQSxPQUFPRixZQUFZQyxhQUFhQyxTQUFTTCxNQUFNLEVBQUUsTUFBTUs7QUFDM0Q7QUFDQWpCLGNBQWMsR0FBR0s7QUFDakI7Ozs7OztDQU1DLEdBQ0QsU0FBU2MsVUFBVWIsS0FBSyxFQUFFYyxLQUFLLEVBQUVDLEdBQUc7SUFDaEMsSUFBSUEsTUFBTWYsTUFBTU0sTUFBTSxFQUFFO1FBQ3BCLE1BQU0sSUFBSVUsTUFBTTtJQUNwQjtJQUNBLE9BQU9oQixNQUFNaUIsS0FBSyxDQUFDSCxPQUFPQztBQUM5QjtBQUNBOzs7Q0FHQyxHQUNELFNBQVNHLGFBQWFDLENBQUM7SUFDbkIsSUFBSUEsQ0FBQyxDQUFDLEVBQUUsS0FBSyxHQUFHO1FBQ1osTUFBTSxJQUFJSCxNQUFNO0lBQ3BCO0lBQ0EsT0FBT0ksYUFBYUMsV0FBV0Y7QUFDbkM7QUFDQSxTQUFTVCxhQUFhWSxHQUFHLEVBQUVDLE1BQU07SUFDN0IsSUFBSUQsTUFBTSxJQUFJO1FBQ1YsT0FBT0UsV0FBV0MsSUFBSSxDQUFDO1lBQUNILE1BQU1DO1NBQU87SUFDekM7SUFDQSxNQUFNRyxZQUFZQyxZQUFZTDtJQUM5QixNQUFNTSxVQUFVRixVQUFVcEIsTUFBTSxHQUFHO0lBQ25DLE1BQU11QixZQUFZRixZQUFZSixTQUFTLEtBQUtLO0lBQzVDLE9BQU9KLFdBQVdDLElBQUksQ0FBQ0ssV0FBV0QsWUFBWUg7QUFDbEQ7QUFDQSxTQUFTNUIsT0FBT0UsS0FBSyxFQUFFK0IsU0FBUyxLQUFLO0lBQ2pDLElBQUksT0FBTy9CLFVBQVUsZUFBZUEsVUFBVSxRQUFRQSxNQUFNTSxNQUFNLEtBQUssR0FBRztRQUN0RSxPQUFPa0IsV0FBV0MsSUFBSSxDQUFDLEVBQUU7SUFDN0I7SUFDQSxNQUFNTyxhQUFhcEIsUUFBUVo7SUFDM0IsTUFBTWlDLFVBQVVDLFFBQVFGO0lBQ3hCLElBQUlELFFBQVE7UUFDUixPQUFPRTtJQUNYO0lBQ0EsSUFBSUEsUUFBUUUsU0FBUyxDQUFDN0IsTUFBTSxLQUFLLEdBQUc7UUFDaEMsTUFBTSxJQUFJVSxNQUFNO0lBQ3BCO0lBQ0EsT0FBT2lCLFFBQVFHLElBQUk7QUFDdkI7QUFDQTFDLGNBQWMsR0FBR0k7QUFDakIsNkJBQTZCLEdBQzdCLFNBQVNvQyxRQUFRbEMsS0FBSztJQUNsQixJQUFJTSxRQUFRK0IsU0FBU0QsTUFBTUUsZ0JBQWdCQztJQUMzQyxNQUFNTixVQUFVLEVBQUU7SUFDbEIsTUFBTUosWUFBWTdCLEtBQUssQ0FBQyxFQUFFO0lBQzFCLElBQUk2QixhQUFhLE1BQU07UUFDbkIsNkZBQTZGO1FBQzdGLE9BQU87WUFDSE8sTUFBTXBDLE1BQU1pQixLQUFLLENBQUMsR0FBRztZQUNyQmtCLFdBQVduQyxNQUFNaUIsS0FBSyxDQUFDO1FBQzNCO0lBQ0osT0FDSyxJQUFJWSxhQUFhLE1BQU07UUFDeEIsZ0hBQWdIO1FBQ2hILDhDQUE4QztRQUM5Q3ZCLFNBQVN1QixZQUFZO1FBQ3JCLHFCQUFxQjtRQUNyQixJQUFJQSxjQUFjLE1BQU07WUFDcEJPLE9BQU9aLFdBQVdDLElBQUksQ0FBQyxFQUFFO1FBQzdCLE9BQ0s7WUFDRFcsT0FBT3ZCLFVBQVViLE9BQU8sR0FBR007UUFDL0I7UUFDQSxJQUFJQSxXQUFXLEtBQUs4QixJQUFJLENBQUMsRUFBRSxHQUFHLE1BQU07WUFDaEMsTUFBTSxJQUFJcEIsTUFBTTtRQUNwQjtRQUNBLE9BQU87WUFDSG9CO1lBQ0FELFdBQVduQyxNQUFNaUIsS0FBSyxDQUFDWDtRQUMzQjtJQUNKLE9BQ0ssSUFBSXVCLGFBQWEsTUFBTTtRQUN4QiwyR0FBMkc7UUFDM0csaURBQWlEO1FBQ2pEUSxVQUFVUixZQUFZO1FBQ3RCLElBQUk3QixNQUFNTSxNQUFNLEdBQUcsSUFBSStCLFNBQVM7WUFDNUIsTUFBTSxJQUFJckIsTUFBTTtRQUNwQjtRQUNBVixTQUFTWSxhQUFhTCxVQUFVYixPQUFPLEdBQUdxQztRQUMxQyxJQUFJL0IsVUFBVSxJQUFJO1lBQ2QsTUFBTSxJQUFJVSxNQUFNO1FBQ3BCO1FBQ0FvQixPQUFPdkIsVUFBVWIsT0FBT3FDLFNBQVMvQixTQUFTK0I7UUFDMUMsT0FBTztZQUNIRDtZQUNBRCxXQUFXbkMsTUFBTWlCLEtBQUssQ0FBQ1gsU0FBUytCO1FBQ3BDO0lBQ0osT0FDSyxJQUFJUixhQUFhLE1BQU07UUFDeEIsaUNBQWlDO1FBQ2pDdkIsU0FBU3VCLFlBQVk7UUFDckJTLGlCQUFpQnpCLFVBQVViLE9BQU8sR0FBR007UUFDckMsTUFBT2dDLGVBQWVoQyxNQUFNLENBQUU7WUFDMUJpQyxJQUFJTCxRQUFRSTtZQUNaTCxRQUFRekIsSUFBSSxDQUFDK0IsRUFBRUgsSUFBSTtZQUNuQkUsaUJBQWlCQyxFQUFFSixTQUFTO1FBQ2hDO1FBQ0EsT0FBTztZQUNIQyxNQUFNSDtZQUNORSxXQUFXbkMsTUFBTWlCLEtBQUssQ0FBQ1g7UUFDM0I7SUFDSixPQUNLO1FBQ0QsNEJBQTRCO1FBQzVCK0IsVUFBVVIsWUFBWTtRQUN0QnZCLFNBQVNZLGFBQWFMLFVBQVViLE9BQU8sR0FBR3FDO1FBQzFDLElBQUkvQixTQUFTLElBQUk7WUFDYixNQUFNLElBQUlVLE1BQU07UUFDcEI7UUFDQSxNQUFNd0IsY0FBY0gsVUFBVS9CO1FBQzlCLElBQUlrQyxjQUFjeEMsTUFBTU0sTUFBTSxFQUFFO1lBQzVCLE1BQU0sSUFBSVUsTUFBTTtRQUNwQjtRQUNBc0IsaUJBQWlCekIsVUFBVWIsT0FBT3FDLFNBQVNHO1FBQzNDLE1BQU9GLGVBQWVoQyxNQUFNLENBQUU7WUFDMUJpQyxJQUFJTCxRQUFRSTtZQUNaTCxRQUFRekIsSUFBSSxDQUFDK0IsRUFBRUgsSUFBSTtZQUNuQkUsaUJBQWlCQyxFQUFFSixTQUFTO1FBQ2hDO1FBQ0EsT0FBTztZQUNIQyxNQUFNSDtZQUNORSxXQUFXbkMsTUFBTWlCLEtBQUssQ0FBQ3VCO1FBQzNCO0lBQ0o7QUFDSjtBQUNBLE1BQU1DLGNBQWN4QyxNQUFNd0IsSUFBSSxDQUFDO0lBQUVuQixRQUFRO0FBQUksR0FBRyxDQUFDb0MsSUFBSXJDLElBQU1BLEVBQUVzQyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUc7QUFDdEYsU0FBU3ZCLFdBQVd3QixNQUFNO0lBQ3RCLHlEQUF5RDtJQUN6RCxJQUFJQyxNQUFNO0lBQ1YsSUFBSyxJQUFJekMsSUFBSSxHQUFHQSxJQUFJd0MsT0FBT3ZDLE1BQU0sRUFBRUQsSUFBSztRQUNwQ3lDLE9BQU9MLFdBQVcsQ0FBQ0ksTUFBTSxDQUFDeEMsRUFBRSxDQUFDO0lBQ2pDO0lBQ0EsT0FBT3lDO0FBQ1g7QUFDQSxTQUFTMUIsYUFBYTJCLE9BQU87SUFDekIsTUFBTUMsT0FBT0MsT0FBT0MsUUFBUSxDQUFDSCxTQUFTO0lBQ3RDLElBQUlFLE9BQU9FLEtBQUssQ0FBQ0gsT0FDYixNQUFNLElBQUloQyxNQUFNO0lBQ3BCLE9BQU9nQztBQUNYO0FBQ0EsNkJBQTZCO0FBQzdCLFNBQVNsQixXQUFXZ0IsR0FBRztJQUNuQixJQUFJLE9BQU9BLFFBQVEsVUFBVTtRQUN6QixNQUFNLElBQUlNLFVBQVUsc0NBQXNDLE9BQU9OO0lBQ3JFO0lBQ0EsSUFBSUEsSUFBSXhDLE1BQU0sR0FBRyxHQUNiLE1BQU0sSUFBSVUsTUFBTTtJQUNwQixNQUFNcUMsUUFBUSxJQUFJN0IsV0FBV3NCLElBQUl4QyxNQUFNLEdBQUc7SUFDMUMsSUFBSyxJQUFJRCxJQUFJLEdBQUdBLElBQUlnRCxNQUFNL0MsTUFBTSxFQUFFRCxJQUFLO1FBQ25DLE1BQU1pRCxJQUFJakQsSUFBSTtRQUNkZ0QsS0FBSyxDQUFDaEQsRUFBRSxHQUFHZSxhQUFhMEIsSUFBSTdCLEtBQUssQ0FBQ3FDLEdBQUdBLElBQUk7SUFDN0M7SUFDQSxPQUFPRDtBQUNYO0FBQ0EsMkNBQTJDLEdBQzNDLFNBQVM1QyxZQUFZLEdBQUc4QyxNQUFNO0lBQzFCLElBQUlBLE9BQU9qRCxNQUFNLEtBQUssR0FDbEIsT0FBT2lELE1BQU0sQ0FBQyxFQUFFO0lBQ3BCLE1BQU1qRCxTQUFTaUQsT0FBT0MsTUFBTSxDQUFDLENBQUNDLEdBQUdDLE1BQVFELElBQUlDLElBQUlwRCxNQUFNLEVBQUU7SUFDekQsTUFBTXFELFNBQVMsSUFBSW5DLFdBQVdsQjtJQUM5QixJQUFLLElBQUlELElBQUksR0FBR3VELE1BQU0sR0FBR3ZELElBQUlrRCxPQUFPakQsTUFBTSxFQUFFRCxJQUFLO1FBQzdDLE1BQU1xRCxNQUFNSCxNQUFNLENBQUNsRCxFQUFFO1FBQ3JCc0QsT0FBT0UsR0FBRyxDQUFDSCxLQUFLRTtRQUNoQkEsT0FBT0YsSUFBSXBELE1BQU07SUFDckI7SUFDQSxPQUFPcUQ7QUFDWDtBQUNBLFNBQVNHLFlBQVlDLEdBQUc7SUFDcEIsT0FBTyxJQUFJQyxjQUFjakUsTUFBTSxDQUFDZ0U7QUFDcEM7QUFDQSxvREFBb0QsR0FDcEQsU0FBU3BDLFlBQVlzQyxPQUFPO0lBQ3hCLElBQUlBLFVBQVUsR0FBRztRQUNiLE1BQU0sSUFBSWpELE1BQU07SUFDcEI7SUFDQSxNQUFNOEIsTUFBTW1CLFFBQVF0QixRQUFRLENBQUM7SUFDN0IsT0FBT0csSUFBSXhDLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFd0MsSUFBSSxDQUFDLEdBQUdBO0FBQ3hDO0FBQ0EsNEJBQTRCLEdBQzVCLFNBQVNvQixVQUFVVCxDQUFDO0lBQ2hCLE9BQU9BLEVBQUVuRCxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsRUFBRW1ELEVBQUUsQ0FBQyxHQUFHQTtBQUNwQztBQUNBLHdDQUF3QyxHQUN4QyxTQUFTVSxjQUFjQyxHQUFHO0lBQ3RCLE9BQU9BLElBQUk5RCxNQUFNLElBQUksS0FBSzhELEdBQUcsQ0FBQyxFQUFFLEtBQUssT0FBT0EsR0FBRyxDQUFDLEVBQUUsS0FBSztBQUMzRDtBQUNBLG1DQUFtQyxHQUNuQyxTQUFTQyxlQUFlRCxHQUFHO0lBQ3ZCLElBQUksT0FBT0EsUUFBUSxVQUFVO1FBQ3pCLE9BQU9BO0lBQ1g7SUFDQSxPQUFPRCxjQUFjQyxPQUFPQSxJQUFJbkQsS0FBSyxDQUFDLEtBQUttRDtBQUMvQztBQUNBLHlDQUF5QyxHQUN6QyxTQUFTeEQsUUFBUU8sQ0FBQztJQUNkLElBQUlBLGFBQWFLLFlBQVk7UUFDekIsT0FBT0w7SUFDWDtJQUNBLElBQUksT0FBT0EsTUFBTSxVQUFVO1FBQ3ZCLElBQUlnRCxjQUFjaEQsSUFBSTtZQUNsQixPQUFPVyxXQUFXb0MsVUFBVUcsZUFBZWxEO1FBQy9DO1FBQ0EsT0FBTzJDLFlBQVkzQztJQUN2QjtJQUNBLElBQUksT0FBT0EsTUFBTSxZQUFZLE9BQU9BLE1BQU0sVUFBVTtRQUNoRCxJQUFJLENBQUNBLEdBQUc7WUFDSixPQUFPSyxXQUFXQyxJQUFJLENBQUMsRUFBRTtRQUM3QjtRQUNBLE9BQU9LLFdBQVdILFlBQVlSO0lBQ2xDO0lBQ0EsSUFBSUEsTUFBTSxRQUFRQSxNQUFNbUQsV0FBVztRQUMvQixPQUFPOUMsV0FBV0MsSUFBSSxDQUFDLEVBQUU7SUFDN0I7SUFDQSxNQUFNLElBQUlULE1BQU0sd0NBQXdDLE9BQU9HO0FBQ25FO0FBQ0F6QixhQUFhLEdBQUc7SUFDWjJCO0lBQ0FaO0lBQ0FxQjtJQUNBZ0M7QUFDSjtBQUNBcEUsV0FBVyxHQUFHO0lBQUVLO0lBQVFEO0FBQU8sR0FDL0IsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy9ybHAvZGlzdC9pbmRleC5qcz9kNjhkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5STFAgPSBleHBvcnRzLnV0aWxzID0gZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLmVuY29kZSA9IHZvaWQgMDtcbi8qKlxuICogUkxQIEVuY29kaW5nIGJhc2VkIG9uIGh0dHBzOi8vZXRoZXJldW0ub3JnL2VuL2RldmVsb3BlcnMvZG9jcy9kYXRhLXN0cnVjdHVyZXMtYW5kLWVuY29kaW5nL3JscC9cbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgaW4gZGF0YSwgY29udmVydHMgaXQgdG8gVWludDhBcnJheSBpZiBub3QsXG4gKiBhbmQgYWRkcyBhIGxlbmd0aCBmb3IgcmVjdXJzaW9uLlxuICogQHBhcmFtIGlucHV0IFdpbGwgYmUgY29udmVydGVkIHRvIFVpbnQ4QXJyYXlcbiAqIEByZXR1cm5zIFVpbnQ4QXJyYXkgb2YgZW5jb2RlZCBkYXRhXG4gKiovXG5mdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICAgIGxldCBvdXRwdXRMZW5ndGggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkID0gZW5jb2RlKGlucHV0W2ldKTtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGVuY29kZWQpO1xuICAgICAgICAgICAgb3V0cHV0TGVuZ3RoICs9IGVuY29kZWQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyhlbmNvZGVMZW5ndGgob3V0cHV0TGVuZ3RoLCAxOTIpLCAuLi5vdXRwdXQpO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dEJ1ZiA9IHRvQnl0ZXMoaW5wdXQpO1xuICAgIGlmIChpbnB1dEJ1Zi5sZW5ndGggPT09IDEgJiYgaW5wdXRCdWZbMF0gPCAxMjgpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0QnVmO1xuICAgIH1cbiAgICByZXR1cm4gY29uY2F0Qnl0ZXMoZW5jb2RlTGVuZ3RoKGlucHV0QnVmLmxlbmd0aCwgMTI4KSwgaW5wdXRCdWYpO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4vKipcbiAqIFNsaWNlcyBhIFVpbnQ4QXJyYXksIHRocm93cyBpZiB0aGUgc2xpY2UgZ29lcyBvdXQtb2YtYm91bmRzIG9mIHRoZSBVaW50OEFycmF5LlxuICogRS5nLiBgc2FmZVNsaWNlKGhleFRvQnl0ZXMoJ2FhJyksIDEsIDIpYCB3aWxsIHRocm93LlxuICogQHBhcmFtIGlucHV0XG4gKiBAcGFyYW0gc3RhcnRcbiAqIEBwYXJhbSBlbmRcbiAqL1xuZnVuY3Rpb24gc2FmZVNsaWNlKGlucHV0LCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKGVuZCA+IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQIChzYWZlU2xpY2UpOiBlbmQgc2xpY2Ugb2YgVWludDhBcnJheSBvdXQtb2YtYm91bmRzJyk7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dC5zbGljZShzdGFydCwgZW5kKTtcbn1cbi8qKlxuICogUGFyc2UgaW50ZWdlcnMuIENoZWNrIGlmIHRoZXJlIGlzIG5vIGxlYWRpbmcgemVyb3NcbiAqIEBwYXJhbSB2IFRoZSB2YWx1ZSB0byBwYXJzZVxuICovXG5mdW5jdGlvbiBkZWNvZGVMZW5ndGgodikge1xuICAgIGlmICh2WzBdID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IGV4dHJhIHplcm9zJyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUhleEJ5dGUoYnl0ZXNUb0hleCh2KSk7XG59XG5mdW5jdGlvbiBlbmNvZGVMZW5ndGgobGVuLCBvZmZzZXQpIHtcbiAgICBpZiAobGVuIDwgNTYpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShbbGVuICsgb2Zmc2V0XSk7XG4gICAgfVxuICAgIGNvbnN0IGhleExlbmd0aCA9IG51bWJlclRvSGV4KGxlbik7XG4gICAgY29uc3QgbExlbmd0aCA9IGhleExlbmd0aC5sZW5ndGggLyAyO1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IG51bWJlclRvSGV4KG9mZnNldCArIDU1ICsgbExlbmd0aCk7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShoZXhUb0J5dGVzKGZpcnN0Qnl0ZSArIGhleExlbmd0aCkpO1xufVxuZnVuY3Rpb24gZGVjb2RlKGlucHV0LCBzdHJlYW0gPSBmYWxzZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnIHx8IGlucHV0ID09PSBudWxsIHx8IGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKFtdKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRCeXRlcyA9IHRvQnl0ZXMoaW5wdXQpO1xuICAgIGNvbnN0IGRlY29kZWQgPSBfZGVjb2RlKGlucHV0Qnl0ZXMpO1xuICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZWQ7XG4gICAgfVxuICAgIGlmIChkZWNvZGVkLnJlbWFpbmRlci5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogcmVtYWluZGVyIG11c3QgYmUgemVybycpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlZC5kYXRhO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4vKiogRGVjb2RlIGFuIGlucHV0IHdpdGggUkxQICovXG5mdW5jdGlvbiBfZGVjb2RlKGlucHV0KSB7XG4gICAgbGV0IGxlbmd0aCwgbGxlbmd0aCwgZGF0YSwgaW5uZXJSZW1haW5kZXIsIGQ7XG4gICAgY29uc3QgZGVjb2RlZCA9IFtdO1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGlucHV0WzBdO1xuICAgIGlmIChmaXJzdEJ5dGUgPD0gMHg3Zikge1xuICAgICAgICAvLyBhIHNpbmdsZSBieXRlIHdob3NlIHZhbHVlIGlzIGluIHRoZSBbMHgwMCwgMHg3Zl0gcmFuZ2UsIHRoYXQgYnl0ZSBpcyBpdHMgb3duIFJMUCBlbmNvZGluZy5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGlucHV0LnNsaWNlKDAsIDEpLFxuICAgICAgICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZSgxKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4YjcpIHtcbiAgICAgICAgLy8gc3RyaW5nIGlzIDAtNTUgYnl0ZXMgbG9uZy4gQSBzaW5nbGUgYnl0ZSB3aXRoIHZhbHVlIDB4ODAgcGx1cyB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgZm9sbG93ZWQgYnkgdGhlIHN0cmluZ1xuICAgICAgICAvLyBUaGUgcmFuZ2Ugb2YgdGhlIGZpcnN0IGJ5dGUgaXMgWzB4ODAsIDB4YjddXG4gICAgICAgIGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4N2Y7XG4gICAgICAgIC8vIHNldCAweDgwIG51bGwgdG8gMFxuICAgICAgICBpZiAoZmlyc3RCeXRlID09PSAweDgwKSB7XG4gICAgICAgICAgICBkYXRhID0gVWludDhBcnJheS5mcm9tKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBzYWZlU2xpY2UoaW5wdXQsIDEsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMiAmJiBkYXRhWzBdIDwgMHg4MCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUCBlbmNvZGluZzogaW52YWxpZCBwcmVmaXgsIHNpbmdsZSBieXRlIDwgMHg4MCBhcmUgbm90IHByZWZpeGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKGxlbmd0aCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGJmKSB7XG4gICAgICAgIC8vIHN0cmluZyBpcyBncmVhdGVyIHRoYW4gNTUgYnl0ZXMgbG9uZy4gQSBzaW5nbGUgYnl0ZSB3aXRoIHRoZSB2YWx1ZSAoMHhiNyBwbHVzIHRoZSBsZW5ndGggb2YgdGhlIGxlbmd0aCksXG4gICAgICAgIC8vIGZvbGxvd2VkIGJ5IHRoZSBsZW5ndGgsIGZvbGxvd2VkIGJ5IHRoZSBzdHJpbmdcbiAgICAgICAgbGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4YjY7XG4gICAgICAgIGlmIChpbnB1dC5sZW5ndGggLSAxIDwgbGxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogbm90IGVub3VnaCBieXRlcyBmb3Igc3RyaW5nIGxlbmd0aCcpO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCA9IGRlY29kZUxlbmd0aChzYWZlU2xpY2UoaW5wdXQsIDEsIGxsZW5ndGgpKTtcbiAgICAgICAgaWYgKGxlbmd0aCA8PSA1NSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogZXhwZWN0ZWQgc3RyaW5nIGxlbmd0aCB0byBiZSBncmVhdGVyIHRoYW4gNTUnKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gc2FmZVNsaWNlKGlucHV0LCBsbGVuZ3RoLCBsZW5ndGggKyBsbGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKGxlbmd0aCArIGxsZW5ndGgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhmNykge1xuICAgICAgICAvLyBhIGxpc3QgYmV0d2VlbiAwLTU1IGJ5dGVzIGxvbmdcbiAgICAgICAgbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhiZjtcbiAgICAgICAgaW5uZXJSZW1haW5kZXIgPSBzYWZlU2xpY2UoaW5wdXQsIDEsIGxlbmd0aCk7XG4gICAgICAgIHdoaWxlIChpbm5lclJlbWFpbmRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGQgPSBfZGVjb2RlKGlubmVyUmVtYWluZGVyKTtcbiAgICAgICAgICAgIGRlY29kZWQucHVzaChkLmRhdGEpO1xuICAgICAgICAgICAgaW5uZXJSZW1haW5kZXIgPSBkLnJlbWFpbmRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogZGVjb2RlZCxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UobGVuZ3RoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGEgbGlzdCBvdmVyIDU1IGJ5dGVzIGxvbmdcbiAgICAgICAgbGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4ZjY7XG4gICAgICAgIGxlbmd0aCA9IGRlY29kZUxlbmd0aChzYWZlU2xpY2UoaW5wdXQsIDEsIGxsZW5ndGgpKTtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDU2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiBlbmNvZGVkIGxpc3QgdG9vIHNob3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG90YWxMZW5ndGggPSBsbGVuZ3RoICsgbGVuZ3RoO1xuICAgICAgICBpZiAodG90YWxMZW5ndGggPiBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IHRvdGFsIGxlbmd0aCBpcyBsYXJnZXIgdGhhbiB0aGUgZGF0YScpO1xuICAgICAgICB9XG4gICAgICAgIGlubmVyUmVtYWluZGVyID0gc2FmZVNsaWNlKGlucHV0LCBsbGVuZ3RoLCB0b3RhbExlbmd0aCk7XG4gICAgICAgIHdoaWxlIChpbm5lclJlbWFpbmRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGQgPSBfZGVjb2RlKGlubmVyUmVtYWluZGVyKTtcbiAgICAgICAgICAgIGRlY29kZWQucHVzaChkLmRhdGEpO1xuICAgICAgICAgICAgaW5uZXJSZW1haW5kZXIgPSBkLnJlbWFpbmRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogZGVjb2RlZCxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UodG90YWxMZW5ndGgpLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmNvbnN0IGNhY2hlZEhleGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfdiwgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG5mdW5jdGlvbiBieXRlc1RvSGV4KHVpbnQ4YSkge1xuICAgIC8vIFByZS1jYWNoaW5nIGNoYXJzIHdpdGggYGNhY2hlZEhleGVzYCBzcGVlZHMgdGhpcyB1cCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVpbnQ4YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gY2FjaGVkSGV4ZXNbdWludDhhW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmZ1bmN0aW9uIHBhcnNlSGV4Qnl0ZShoZXhCeXRlKSB7XG4gICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgaWYgKE51bWJlci5pc05hTihieXRlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICByZXR1cm4gYnl0ZTtcbn1cbi8vIENhY2hpbmcgc2xvd3MgaXQgZG93biAyLTN4XG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoZXhUb0J5dGVzOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgfVxuICAgIGlmIChoZXgubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXhUb0J5dGVzOiByZWNlaXZlZCBpbnZhbGlkIHVucGFkZGVkIGhleCcpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoaGV4Lmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBhcnJheVtpXSA9IHBhcnNlSGV4Qnl0ZShoZXguc2xpY2UoaiwgaiArIDIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLyoqIENvbmNhdGVuYXRlcyB0d28gVWludDhBcnJheXMgaW50byBvbmUuICovXG5mdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBpZiAoYXJyYXlzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGFycmF5c1swXTtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheXMucmVkdWNlKChhLCBhcnIpID0+IGEgKyBhcnIubGVuZ3RoLCAwKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzdWx0LnNldChhcnIsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhcnIubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXRmOFRvQnl0ZXModXRmKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh1dGYpO1xufVxuLyoqIFRyYW5zZm9ybSBhbiBpbnRlZ2VyIGludG8gaXRzIGhleGFkZWNpbWFsIHZhbHVlICovXG5mdW5jdGlvbiBudW1iZXJUb0hleChpbnRlZ2VyKSB7XG4gICAgaWYgKGludGVnZXIgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnRlZ2VyIGFzIGFyZ3VtZW50LCBtdXN0IGJlIHVuc2lnbmVkIScpO1xuICAgIH1cbiAgICBjb25zdCBoZXggPSBpbnRlZ2VyLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAlIDIgPyBgMCR7aGV4fWAgOiBoZXg7XG59XG4vKiogUGFkIGEgc3RyaW5nIHRvIGJlIGV2ZW4gKi9cbmZ1bmN0aW9uIHBhZFRvRXZlbihhKSB7XG4gICAgcmV0dXJuIGEubGVuZ3RoICUgMiA/IGAwJHthfWAgOiBhO1xufVxuLyoqIENoZWNrIGlmIGEgc3RyaW5nIGlzIHByZWZpeGVkIGJ5IDB4ICovXG5mdW5jdGlvbiBpc0hleFByZWZpeGVkKHN0cikge1xuICAgIHJldHVybiBzdHIubGVuZ3RoID49IDIgJiYgc3RyWzBdID09PSAnMCcgJiYgc3RyWzFdID09PSAneCc7XG59XG4vKiogUmVtb3ZlcyAweCBmcm9tIGEgZ2l2ZW4gU3RyaW5nICovXG5mdW5jdGlvbiBzdHJpcEhleFByZWZpeChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIGlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ci5zbGljZSgyKSA6IHN0cjtcbn1cbi8qKiBUcmFuc2Zvcm0gYW55dGhpbmcgaW50byBhIFVpbnQ4QXJyYXkgKi9cbmZ1bmN0aW9uIHRvQnl0ZXModikge1xuICAgIGlmICh2IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoaXNIZXhQcmVmaXhlZCh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXMocGFkVG9FdmVuKHN0cmlwSGV4UHJlZml4KHYpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHYpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2ID09PSAnYmlnaW50Jykge1xuICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oW10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4KHYpKTtcbiAgICB9XG4gICAgaWYgKHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oW10pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvQnl0ZXM6IHJlY2VpdmVkIHVuc3VwcG9ydGVkIHR5cGUgJyArIHR5cGVvZiB2KTtcbn1cbmV4cG9ydHMudXRpbHMgPSB7XG4gICAgYnl0ZXNUb0hleCxcbiAgICBjb25jYXRCeXRlcyxcbiAgICBoZXhUb0J5dGVzLFxuICAgIHV0ZjhUb0J5dGVzLFxufTtcbmV4cG9ydHMuUkxQID0geyBlbmNvZGUsIGRlY29kZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUkxQIiwidXRpbHMiLCJkZWNvZGUiLCJlbmNvZGUiLCJpbnB1dCIsIkFycmF5IiwiaXNBcnJheSIsIm91dHB1dCIsIm91dHB1dExlbmd0aCIsImkiLCJsZW5ndGgiLCJlbmNvZGVkIiwicHVzaCIsImNvbmNhdEJ5dGVzIiwiZW5jb2RlTGVuZ3RoIiwiaW5wdXRCdWYiLCJ0b0J5dGVzIiwic2FmZVNsaWNlIiwic3RhcnQiLCJlbmQiLCJFcnJvciIsInNsaWNlIiwiZGVjb2RlTGVuZ3RoIiwidiIsInBhcnNlSGV4Qnl0ZSIsImJ5dGVzVG9IZXgiLCJsZW4iLCJvZmZzZXQiLCJVaW50OEFycmF5IiwiZnJvbSIsImhleExlbmd0aCIsIm51bWJlclRvSGV4IiwibExlbmd0aCIsImZpcnN0Qnl0ZSIsImhleFRvQnl0ZXMiLCJzdHJlYW0iLCJpbnB1dEJ5dGVzIiwiZGVjb2RlZCIsIl9kZWNvZGUiLCJyZW1haW5kZXIiLCJkYXRhIiwibGxlbmd0aCIsImlubmVyUmVtYWluZGVyIiwiZCIsInRvdGFsTGVuZ3RoIiwiY2FjaGVkSGV4ZXMiLCJfdiIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJ1aW50OGEiLCJoZXgiLCJoZXhCeXRlIiwiYnl0ZSIsIk51bWJlciIsInBhcnNlSW50IiwiaXNOYU4iLCJUeXBlRXJyb3IiLCJhcnJheSIsImoiLCJhcnJheXMiLCJyZWR1Y2UiLCJhIiwiYXJyIiwicmVzdWx0IiwicGFkIiwic2V0IiwidXRmOFRvQnl0ZXMiLCJ1dGYiLCJUZXh0RW5jb2RlciIsImludGVnZXIiLCJwYWRUb0V2ZW4iLCJpc0hleFByZWZpeGVkIiwic3RyIiwic3RyaXBIZXhQcmVmaXgiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethereumjs/rlp/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethereumjs/util/dist/account.js":
/*!*******************************************************!*\
  !*** ./node_modules/@ethereumjs/util/dist/account.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.accountBodyToRLP = exports.accountBodyToSlim = exports.accountBodyFromSlim = exports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\nconst rlp_1 = __webpack_require__(/*! @ethereumjs/rlp */ \"(ssr)/./node_modules/@ethereumjs/rlp/dist/index.js\");\nconst keccak_1 = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(ssr)/./node_modules/ethereum-cryptography/keccak.js\");\nconst secp256k1_1 = __webpack_require__(/*! ethereum-cryptography/secp256k1 */ \"(ssr)/./node_modules/ethereum-cryptography/secp256k1.js\");\nconst utils_1 = __webpack_require__(/*! ethereum-cryptography/utils */ \"(ssr)/./node_modules/ethereum-cryptography/utils.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/@ethereumjs/util/dist/bytes.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@ethereumjs/util/dist/constants.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@ethereumjs/util/dist/helpers.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/@ethereumjs/util/dist/internal.js\");\nconst _0n = BigInt(0);\nclass Account {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating an Account from varying data types.\n     */ constructor(nonce = _0n, balance = _0n, storageRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL){\n        this.nonce = nonce;\n        this.balance = balance;\n        this.storageRoot = storageRoot;\n        this.codeHash = codeHash;\n        this._validate();\n    }\n    static fromAccountData(accountData) {\n        const { nonce, balance, storageRoot, codeHash } = accountData;\n        return new Account(nonce !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(nonce)) : undefined, balance !== undefined ? (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(balance)) : undefined, storageRoot !== undefined ? (0, bytes_1.toBuffer)(storageRoot) : undefined, codeHash !== undefined ? (0, bytes_1.toBuffer)(codeHash) : undefined);\n    }\n    static fromRlpSerializedAccount(serialized) {\n        const values = (0, bytes_1.arrToBufArr)(rlp_1.RLP.decode(Uint8Array.from(serialized)));\n        if (!Array.isArray(values)) {\n            throw new Error(\"Invalid serialized account input. Must be array\");\n        }\n        return this.fromValuesArray(values);\n    }\n    static fromValuesArray(values) {\n        const [nonce, balance, storageRoot, codeHash] = values;\n        return new Account((0, bytes_1.bufferToBigInt)(nonce), (0, bytes_1.bufferToBigInt)(balance), storageRoot, codeHash);\n    }\n    _validate() {\n        if (this.nonce < _0n) {\n            throw new Error(\"nonce must be greater than zero\");\n        }\n        if (this.balance < _0n) {\n            throw new Error(\"balance must be greater than zero\");\n        }\n        if (this.storageRoot.length !== 32) {\n            throw new Error(\"storageRoot must have a length of 32\");\n        }\n        if (this.codeHash.length !== 32) {\n            throw new Error(\"codeHash must have a length of 32\");\n        }\n    }\n    /**\n     * Returns a Buffer Array of the raw Buffers for the account, in order.\n     */ raw() {\n        return [\n            (0, bytes_1.bigIntToUnpaddedBuffer)(this.nonce),\n            (0, bytes_1.bigIntToUnpaddedBuffer)(this.balance),\n            this.storageRoot,\n            this.codeHash\n        ];\n    }\n    /**\n     * Returns the RLP serialization of the account as a `Buffer`.\n     */ serialize() {\n        return Buffer.from(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)(this.raw())));\n    }\n    /**\n     * Returns a `Boolean` determining if the account is a contract.\n     */ isContract() {\n        return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n    /**\n     * Returns a `Boolean` determining if the account is empty complying to the definition of\n     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n     * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n     */ isEmpty() {\n        return this.balance === _0n && this.nonce === _0n && this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n}\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */ const isValidAddress = function(hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    } catch (e) {\n        return false;\n    }\n    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\nexports.isValidAddress = isValidAddress;\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */ const toChecksumAddress = function(hexAddress, eip1191ChainId) {\n    (0, helpers_1.assertIsHexString)(hexAddress);\n    const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\n    let prefix = \"\";\n    if (eip1191ChainId !== undefined) {\n        const chainId = (0, bytes_1.bufferToBigInt)((0, bytes_1.toBuffer)(eip1191ChainId));\n        prefix = chainId.toString() + \"0x\";\n    }\n    const buf = Buffer.from(prefix + address, \"utf8\");\n    const hash = (0, utils_1.bytesToHex)((0, keccak_1.keccak256)(buf));\n    let ret = \"0x\";\n    for(let i = 0; i < address.length; i++){\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        } else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */ const isValidChecksumAddress = function(hexAddress, eip1191ChainId) {\n    return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\n};\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */ const generateAddress = function(from, nonce) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(nonce);\n    if ((0, bytes_1.bufferToBigInt)(nonce) === BigInt(0)) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([\n            from,\n            null\n        ])))).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return Buffer.from((0, keccak_1.keccak256)(rlp_1.RLP.encode((0, bytes_1.bufArrToArr)([\n        from,\n        nonce\n    ])))).slice(-20);\n};\nexports.generateAddress = generateAddress;\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */ const generateAddress2 = function(from, salt, initCode) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(salt);\n    (0, helpers_1.assertIsBuffer)(initCode);\n    if (from.length !== 20) {\n        throw new Error(\"Expected from to be of length 20\");\n    }\n    if (salt.length !== 32) {\n        throw new Error(\"Expected salt to be of length 32\");\n    }\n    const address = (0, keccak_1.keccak256)(Buffer.concat([\n        Buffer.from(\"ff\", \"hex\"),\n        from,\n        salt,\n        (0, keccak_1.keccak256)(initCode)\n    ]));\n    return (0, bytes_1.toBuffer)(address).slice(-20);\n};\nexports.generateAddress2 = generateAddress2;\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */ const isValidPrivate = function(privateKey) {\n    return secp256k1_1.secp256k1.utils.isValidPrivateKey(privateKey);\n};\nexports.isValidPrivate = isValidPrivate;\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */ const isValidPublic = function(publicKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        // Automatically checks whether point is on curve\n        try {\n            secp256k1_1.secp256k1.ProjectivePoint.fromHex(Buffer.concat([\n                Buffer.from([\n                    4\n                ]),\n                publicKey\n            ]));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n    if (!sanitize) {\n        return false;\n    }\n    try {\n        secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey);\n        return true;\n    } catch (e) {\n        return false;\n    }\n};\nexports.isValidPublic = isValidPublic;\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */ const pubToAddress = function(pubKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1));\n    }\n    if (pubKey.length !== 64) {\n        throw new Error(\"Expected pubKey to be of length 64\");\n    }\n    // Only take the lower 160bits of the hash\n    return Buffer.from((0, keccak_1.keccak256)(pubKey)).slice(-20);\n};\nexports.pubToAddress = pubToAddress;\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */ const privateToPublic = function(privateKey) {\n    (0, helpers_1.assertIsBuffer)(privateKey);\n    // skip the type flag and use the X, Y points\n    return Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1));\n};\nexports.privateToPublic = privateToPublic;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */ const privateToAddress = function(privateKey) {\n    return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\n};\nexports.privateToAddress = privateToAddress;\n/**\n * Converts a public key to the Ethereum format.\n */ const importPublic = function(publicKey) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = Buffer.from(secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(false).slice(1));\n    }\n    return publicKey;\n};\nexports.importPublic = importPublic;\n/**\n * Returns the zero address.\n */ const zeroAddress = function() {\n    const addressLength = 20;\n    const addr = (0, bytes_1.zeros)(addressLength);\n    return (0, bytes_1.bufferToHex)(addr);\n};\nexports.zeroAddress = zeroAddress;\n/**\n * Checks if a given address is the zero address.\n */ const isZeroAddress = function(hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    } catch (e) {\n        return false;\n    }\n    const zeroAddr = (0, exports.zeroAddress)();\n    return zeroAddr === hexAddress;\n};\nexports.isZeroAddress = isZeroAddress;\nfunction accountBodyFromSlim(body) {\n    const [nonce, balance, storageRoot, codeHash] = body;\n    return [\n        nonce,\n        balance,\n        (0, bytes_1.arrToBufArr)(storageRoot).length === 0 ? constants_1.KECCAK256_RLP : storageRoot,\n        (0, bytes_1.arrToBufArr)(codeHash).length === 0 ? constants_1.KECCAK256_NULL : codeHash\n    ];\n}\nexports.accountBodyFromSlim = accountBodyFromSlim;\nconst emptyUint8Arr = new Uint8Array(0);\nfunction accountBodyToSlim(body) {\n    const [nonce, balance, storageRoot, codeHash] = body;\n    return [\n        nonce,\n        balance,\n        (0, bytes_1.arrToBufArr)(storageRoot).equals(constants_1.KECCAK256_RLP) ? emptyUint8Arr : storageRoot,\n        (0, bytes_1.arrToBufArr)(codeHash).equals(constants_1.KECCAK256_NULL) ? emptyUint8Arr : codeHash\n    ];\n}\nexports.accountBodyToSlim = accountBodyToSlim;\n/**\n * Converts a slim account (per snap protocol spec) to the RLP encoded version of the account\n * @param body Array of 4 Buffer-like items to represent the account\n * @returns RLP encoded version of the account\n */ function accountBodyToRLP(body, couldBeSlim = true) {\n    const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body;\n    return (0, bytes_1.arrToBufArr)(rlp_1.RLP.encode(accountBody));\n}\nexports.accountBodyToRLP = accountBodyToRLP; //# sourceMappingURL=account.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2FjY291bnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHdCQUF3QixHQUFHQSx5QkFBeUIsR0FBR0EsMkJBQTJCLEdBQUdBLHFCQUFxQixHQUFHQSxtQkFBbUIsR0FBR0Esb0JBQW9CLEdBQUdBLHdCQUF3QixHQUFHQSx1QkFBdUIsR0FBR0EsdUJBQXVCLEdBQUdBLG9CQUFvQixHQUFHQSxxQkFBcUIsR0FBR0Esc0JBQXNCLEdBQUdBLHdCQUF3QixHQUFHQSx1QkFBdUIsR0FBR0EsOEJBQThCLEdBQUdBLHlCQUF5QixHQUFHQSxzQkFBc0IsR0FBR0EsZUFBZSxHQUFHLEtBQUs7QUFDbmQsTUFBTW9CLFFBQVFDLG1CQUFPQSxDQUFDLDJFQUFpQjtBQUN2QyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQywwRkFBOEI7QUFDdkQsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsZ0dBQWlDO0FBQzdELE1BQU1HLFVBQVVILG1CQUFPQSxDQUFDLHdGQUE2QjtBQUNyRCxNQUFNSSxVQUFVSixtQkFBT0EsQ0FBQyxvRUFBUztBQUNqQyxNQUFNSyxjQUFjTCxtQkFBT0EsQ0FBQyw0RUFBYTtBQUN6QyxNQUFNTSxZQUFZTixtQkFBT0EsQ0FBQyx3RUFBVztBQUNyQyxNQUFNTyxhQUFhUCxtQkFBT0EsQ0FBQywwRUFBWTtBQUN2QyxNQUFNUSxNQUFNQyxPQUFPO0FBQ25CLE1BQU1YO0lBQ0Y7OztLQUdDLEdBQ0RZLFlBQVlDLFFBQVFILEdBQUcsRUFBRUksVUFBVUosR0FBRyxFQUFFSyxjQUFjUixZQUFZUyxhQUFhLEVBQUVDLFdBQVdWLFlBQVlXLGNBQWMsQ0FBRTtRQUNwSCxJQUFJLENBQUNMLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLFdBQVcsR0FBR0E7UUFDbkIsSUFBSSxD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QixNQUFNLENBQUN0QyxZQUFZUyxhQUFhLElBQUl5RSxnQkFBZ0IxRTtRQUN6RixJQUFHVCxRQUFRc0IsV0FBVyxFQUFFWCxVQUFVNEIsTUFBTSxDQUFDdEMsWUFBWVcsY0FBYyxJQUFJdUUsZ0JBQWdCeEU7S0FDM0Y7QUFDTDtBQUNBcEMseUJBQXlCLEdBQUdHO0FBQzVCOzs7O0NBSUMsR0FDRCxTQUFTRCxpQkFBaUJ5RyxJQUFJLEVBQUVFLGNBQWMsSUFBSTtJQUM5QyxNQUFNQyxjQUFjRCxjQUFjekcsb0JBQW9CdUcsUUFBUUE7SUFDOUQsT0FBTyxDQUFDLEdBQUdsRixRQUFRc0IsV0FBVyxFQUFFM0IsTUFBTTRCLEdBQUcsQ0FBQ2EsTUFBTSxDQUFDaUQ7QUFDckQ7QUFDQTlHLHdCQUF3QixHQUFHRSxrQkFDM0IsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy91dGlsL2Rpc3QvYWNjb3VudC5qcz85ZjNjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hY2NvdW50Qm9keVRvUkxQID0gZXhwb3J0cy5hY2NvdW50Qm9keVRvU2xpbSA9IGV4cG9ydHMuYWNjb3VudEJvZHlGcm9tU2xpbSA9IGV4cG9ydHMuaXNaZXJvQWRkcmVzcyA9IGV4cG9ydHMuemVyb0FkZHJlc3MgPSBleHBvcnRzLmltcG9ydFB1YmxpYyA9IGV4cG9ydHMucHJpdmF0ZVRvQWRkcmVzcyA9IGV4cG9ydHMucHJpdmF0ZVRvUHVibGljID0gZXhwb3J0cy5wdWJsaWNUb0FkZHJlc3MgPSBleHBvcnRzLnB1YlRvQWRkcmVzcyA9IGV4cG9ydHMuaXNWYWxpZFB1YmxpYyA9IGV4cG9ydHMuaXNWYWxpZFByaXZhdGUgPSBleHBvcnRzLmdlbmVyYXRlQWRkcmVzczIgPSBleHBvcnRzLmdlbmVyYXRlQWRkcmVzcyA9IGV4cG9ydHMuaXNWYWxpZENoZWNrc3VtQWRkcmVzcyA9IGV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRBZGRyZXNzID0gZXhwb3J0cy5BY2NvdW50ID0gdm9pZCAwO1xuY29uc3QgcmxwXzEgPSByZXF1aXJlKFwiQGV0aGVyZXVtanMvcmxwXCIpO1xuY29uc3Qga2VjY2FrXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nha1wiKTtcbmNvbnN0IHNlY3AyNTZrMV8xID0gcmVxdWlyZShcImV0aGVyZXVtLWNyeXB0b2dyYXBoeS9zZWNwMjU2azFcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcImV0aGVyZXVtLWNyeXB0b2dyYXBoeS91dGlsc1wiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgaGVscGVyc18xID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcbmNvbnN0IGludGVybmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbFwiKTtcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNsYXNzIEFjY291bnQge1xuICAgIC8qKlxuICAgICAqIFRoaXMgY29uc3RydWN0b3IgYXNzaWducyBhbmQgdmFsaWRhdGVzIHRoZSB2YWx1ZXMuXG4gICAgICogVXNlIHRoZSBzdGF0aWMgZmFjdG9yeSBtZXRob2RzIHRvIGFzc2lzdCBpbiBjcmVhdGluZyBhbiBBY2NvdW50IGZyb20gdmFyeWluZyBkYXRhIHR5cGVzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5vbmNlID0gXzBuLCBiYWxhbmNlID0gXzBuLCBzdG9yYWdlUm9vdCA9IGNvbnN0YW50c18xLktFQ0NBSzI1Nl9STFAsIGNvZGVIYXNoID0gY29uc3RhbnRzXzEuS0VDQ0FLMjU2X05VTEwpIHtcbiAgICAgICAgdGhpcy5ub25jZSA9IG5vbmNlO1xuICAgICAgICB0aGlzLmJhbGFuY2UgPSBiYWxhbmNlO1xuICAgICAgICB0aGlzLnN0b3JhZ2VSb290ID0gc3RvcmFnZVJvb3Q7XG4gICAgICAgIHRoaXMuY29kZUhhc2ggPSBjb2RlSGFzaDtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGUoKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21BY2NvdW50RGF0YShhY2NvdW50RGF0YSkge1xuICAgICAgICBjb25zdCB7IG5vbmNlLCBiYWxhbmNlLCBzdG9yYWdlUm9vdCwgY29kZUhhc2ggfSA9IGFjY291bnREYXRhO1xuICAgICAgICByZXR1cm4gbmV3IEFjY291bnQobm9uY2UgIT09IHVuZGVmaW5lZCA/ICgwLCBieXRlc18xLmJ1ZmZlclRvQmlnSW50KSgoMCwgYnl0ZXNfMS50b0J1ZmZlcikobm9uY2UpKSA6IHVuZGVmaW5lZCwgYmFsYW5jZSAhPT0gdW5kZWZpbmVkID8gKDAsIGJ5dGVzXzEuYnVmZmVyVG9CaWdJbnQpKCgwLCBieXRlc18xLnRvQnVmZmVyKShiYWxhbmNlKSkgOiB1bmRlZmluZWQsIHN0b3JhZ2VSb290ICE9PSB1bmRlZmluZWQgPyAoMCwgYnl0ZXNfMS50b0J1ZmZlcikoc3RvcmFnZVJvb3QpIDogdW5kZWZpbmVkLCBjb2RlSGFzaCAhPT0gdW5kZWZpbmVkID8gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKGNvZGVIYXNoKSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUmxwU2VyaWFsaXplZEFjY291bnQoc2VyaWFsaXplZCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSAoMCwgYnl0ZXNfMS5hcnJUb0J1ZkFycikocmxwXzEuUkxQLmRlY29kZShVaW50OEFycmF5LmZyb20oc2VyaWFsaXplZCkpKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJpYWxpemVkIGFjY291bnQgaW5wdXQuIE11c3QgYmUgYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tVmFsdWVzQXJyYXkodmFsdWVzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21WYWx1ZXNBcnJheSh2YWx1ZXMpIHtcbiAgICAgICAgY29uc3QgW25vbmNlLCBiYWxhbmNlLCBzdG9yYWdlUm9vdCwgY29kZUhhc2hdID0gdmFsdWVzO1xuICAgICAgICByZXR1cm4gbmV3IEFjY291bnQoKDAsIGJ5dGVzXzEuYnVmZmVyVG9CaWdJbnQpKG5vbmNlKSwgKDAsIGJ5dGVzXzEuYnVmZmVyVG9CaWdJbnQpKGJhbGFuY2UpLCBzdG9yYWdlUm9vdCwgY29kZUhhc2gpO1xuICAgIH1cbiAgICBfdmFsaWRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vbmNlIDwgXzBuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vbmNlIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5iYWxhbmNlIDwgXzBuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhbGFuY2UgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVybycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0b3JhZ2VSb290Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RvcmFnZVJvb3QgbXVzdCBoYXZlIGEgbGVuZ3RoIG9mIDMyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29kZUhhc2gubGVuZ3RoICE9PSAzMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb2RlSGFzaCBtdXN0IGhhdmUgYSBsZW5ndGggb2YgMzInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQnVmZmVyIEFycmF5IG9mIHRoZSByYXcgQnVmZmVycyBmb3IgdGhlIGFjY291bnQsIGluIG9yZGVyLlxuICAgICAqL1xuICAgIHJhdygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICgwLCBieXRlc18xLmJpZ0ludFRvVW5wYWRkZWRCdWZmZXIpKHRoaXMubm9uY2UpLFxuICAgICAgICAgICAgKDAsIGJ5dGVzXzEuYmlnSW50VG9VbnBhZGRlZEJ1ZmZlcikodGhpcy5iYWxhbmNlKSxcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZVJvb3QsXG4gICAgICAgICAgICB0aGlzLmNvZGVIYXNoLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBSTFAgc2VyaWFsaXphdGlvbiBvZiB0aGUgYWNjb3VudCBhcyBhIGBCdWZmZXJgLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHJscF8xLlJMUC5lbmNvZGUoKDAsIGJ5dGVzXzEuYnVmQXJyVG9BcnIpKHRoaXMucmF3KCkpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgQm9vbGVhbmAgZGV0ZXJtaW5pbmcgaWYgdGhlIGFjY291bnQgaXMgYSBjb250cmFjdC5cbiAgICAgKi9cbiAgICBpc0NvbnRyYWN0KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29kZUhhc2guZXF1YWxzKGNvbnN0YW50c18xLktFQ0NBSzI1Nl9OVUxMKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGBCb29sZWFuYCBkZXRlcm1pbmluZyBpZiB0aGUgYWNjb3VudCBpcyBlbXB0eSBjb21wbHlpbmcgdG8gdGhlIGRlZmluaXRpb24gb2ZcbiAgICAgKiBhY2NvdW50IGVtcHRpbmVzcyBpbiBbRUlQLTE2MV0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xNjEpOlxuICAgICAqIFwiQW4gYWNjb3VudCBpcyBjb25zaWRlcmVkIGVtcHR5IHdoZW4gaXQgaGFzIG5vIGNvZGUgYW5kIHplcm8gbm9uY2UgYW5kIHplcm8gYmFsYW5jZS5cIlxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2UgPT09IF8wbiAmJiB0aGlzLm5vbmNlID09PSBfMG4gJiYgdGhpcy5jb2RlSGFzaC5lcXVhbHMoY29uc3RhbnRzXzEuS0VDQ0FLMjU2X05VTEwpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWNjb3VudCA9IEFjY291bnQ7XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYWRkcmVzcyBpcyBhIHZhbGlkLiBBY2NlcHRzIGNoZWNrc3VtbWVkIGFkZHJlc3NlcyB0b28uXG4gKi9cbmNvbnN0IGlzVmFsaWRBZGRyZXNzID0gZnVuY3Rpb24gKGhleEFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgICAoMCwgaGVscGVyc18xLmFzc2VydElzU3RyaW5nKShoZXhBZGRyZXNzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gL14weFswLTlhLWZBLUZdezQwfSQvLnRlc3QoaGV4QWRkcmVzcyk7XG59O1xuZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGlzVmFsaWRBZGRyZXNzO1xuLyoqXG4gKiBSZXR1cm5zIGEgY2hlY2tzdW1tZWQgYWRkcmVzcy5cbiAqXG4gKiBJZiBhbiBlaXAxMTkxQ2hhaW5JZCBpcyBwcm92aWRlZCwgdGhlIGNoYWluSWQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgY2hlY2tzdW0gY2FsY3VsYXRpb24uIFRoaXNcbiAqIGhhcyB0aGUgZWZmZWN0IG9mIGNoZWNrc3VtbWVkIGFkZHJlc3NlcyBmb3Igb25lIGNoYWluIGhhdmluZyBpbnZhbGlkIGNoZWNrc3VtcyBmb3Igb3RoZXJzLlxuICogRm9yIG1vcmUgZGV0YWlscyBzZWUgW0VJUC0xMTkxXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTExOTEpLlxuICpcbiAqIFdBUk5JTkc6IENoZWNrc3VtcyB3aXRoIGFuZCB3aXRob3V0IHRoZSBjaGFpbklkIHdpbGwgZGlmZmVyIGFuZCB0aGUgRUlQLTExOTEgY2hlY2tzdW0gaXMgbm90XG4gKiBiYWNrd2FyZHMgY29tcGF0aWJsZSB0byB0aGUgb3JpZ2luYWwgd2lkZWx5IGFkb3B0ZWQgY2hlY2tzdW0gZm9ybWF0IHN0YW5kYXJkIGludHJvZHVjZWQgaW5cbiAqIFtFSVAtNTVdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNTUpLCBzbyB0aGlzIHdpbGwgYnJlYWsgaW4gZXhpc3RpbmcgYXBwbGljYXRpb25zLlxuICogVXNhZ2Ugb2YgdGhpcyBFSVAgaXMgdGhlcmVmb3JlIGRpc2NvdXJhZ2VkIHVubGVzcyB5b3UgaGF2ZSBhIHZlcnkgdGFyZ2V0ZWQgdXNlIGNhc2UuXG4gKi9cbmNvbnN0IHRvQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGhleEFkZHJlc3MsIGVpcDExOTFDaGFpbklkKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0hleFN0cmluZykoaGV4QWRkcmVzcyk7XG4gICAgY29uc3QgYWRkcmVzcyA9ICgwLCBpbnRlcm5hbF8xLnN0cmlwSGV4UHJlZml4KShoZXhBZGRyZXNzKS50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCBwcmVmaXggPSAnJztcbiAgICBpZiAoZWlwMTE5MUNoYWluSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBjaGFpbklkID0gKDAsIGJ5dGVzXzEuYnVmZmVyVG9CaWdJbnQpKCgwLCBieXRlc18xLnRvQnVmZmVyKShlaXAxMTkxQ2hhaW5JZCkpO1xuICAgICAgICBwcmVmaXggPSBjaGFpbklkLnRvU3RyaW5nKCkgKyAnMHgnO1xuICAgIH1cbiAgICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbShwcmVmaXggKyBhZGRyZXNzLCAndXRmOCcpO1xuICAgIGNvbnN0IGhhc2ggPSAoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KShidWYpKTtcbiAgICBsZXQgcmV0ID0gJzB4JztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZHJlc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBhcnNlSW50KGhhc2hbaV0sIDE2KSA+PSA4KSB7XG4gICAgICAgICAgICByZXQgKz0gYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0ICs9IGFkZHJlc3NbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5leHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzID0gdG9DaGVja3N1bUFkZHJlc3M7XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYWRkcmVzcyBpcyBhIHZhbGlkIGNoZWNrc3VtbWVkIGFkZHJlc3MuXG4gKlxuICogU2VlIHRvQ2hlY2tzdW1BZGRyZXNzJyBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzIGFib3V0IHRoZSBlaXAxMTkxQ2hhaW5JZCBwYXJhbWV0ZXIuXG4gKi9cbmNvbnN0IGlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoaGV4QWRkcmVzcywgZWlwMTE5MUNoYWluSWQpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuaXNWYWxpZEFkZHJlc3MpKGhleEFkZHJlc3MpICYmICgwLCBleHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzKShoZXhBZGRyZXNzLCBlaXAxMTkxQ2hhaW5JZCkgPT09IGhleEFkZHJlc3M7XG59O1xuZXhwb3J0cy5pc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gaXNWYWxpZENoZWNrc3VtQWRkcmVzcztcbi8qKlxuICogR2VuZXJhdGVzIGFuIGFkZHJlc3Mgb2YgYSBuZXdseSBjcmVhdGVkIGNvbnRyYWN0LlxuICogQHBhcmFtIGZyb20gVGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICogQHBhcmFtIG5vbmNlIFRoZSBub25jZSBvZiB0aGUgZnJvbSBhY2NvdW50XG4gKi9cbmNvbnN0IGdlbmVyYXRlQWRkcmVzcyA9IGZ1bmN0aW9uIChmcm9tLCBub25jZSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKGZyb20pO1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKG5vbmNlKTtcbiAgICBpZiAoKDAsIGJ5dGVzXzEuYnVmZmVyVG9CaWdJbnQpKG5vbmNlKSA9PT0gQmlnSW50KDApKSB7XG4gICAgICAgIC8vIGluIFJMUCB3ZSB3YW50IHRvIGVuY29kZSBudWxsIGluIHRoZSBjYXNlIG9mIHplcm8gbm9uY2VcbiAgICAgICAgLy8gcmVhZCB0aGUgUkxQIGRvY3VtZW50YXRpb24gZm9yIGFuIGFuc3dlciBpZiB5b3UgZGFyZVxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIGtlY2Nha18xLmtlY2NhazI1NikocmxwXzEuUkxQLmVuY29kZSgoMCwgYnl0ZXNfMS5idWZBcnJUb0FycikoW2Zyb20sIG51bGxdKSkpKS5zbGljZSgtMjApO1xuICAgIH1cbiAgICAvLyBPbmx5IHRha2UgdGhlIGxvd2VyIDE2MGJpdHMgb2YgdGhlIGhhc2hcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIGtlY2Nha18xLmtlY2NhazI1NikocmxwXzEuUkxQLmVuY29kZSgoMCwgYnl0ZXNfMS5idWZBcnJUb0FycikoW2Zyb20sIG5vbmNlXSkpKSkuc2xpY2UoLTIwKTtcbn07XG5leHBvcnRzLmdlbmVyYXRlQWRkcmVzcyA9IGdlbmVyYXRlQWRkcmVzcztcbi8qKlxuICogR2VuZXJhdGVzIGFuIGFkZHJlc3MgZm9yIGEgY29udHJhY3QgY3JlYXRlZCB1c2luZyBDUkVBVEUyLlxuICogQHBhcmFtIGZyb20gVGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICogQHBhcmFtIHNhbHQgQSBzYWx0XG4gKiBAcGFyYW0gaW5pdENvZGUgVGhlIGluaXQgY29kZSBvZiB0aGUgY29udHJhY3QgYmVpbmcgY3JlYXRlZFxuICovXG5jb25zdCBnZW5lcmF0ZUFkZHJlc3MyID0gZnVuY3Rpb24gKGZyb20sIHNhbHQsIGluaXRDb2RlKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikoZnJvbSk7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikoc2FsdCk7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikoaW5pdENvZGUpO1xuICAgIGlmIChmcm9tLmxlbmd0aCAhPT0gMjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBmcm9tIHRvIGJlIG9mIGxlbmd0aCAyMCcpO1xuICAgIH1cbiAgICBpZiAoc2FsdC5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgc2FsdCB0byBiZSBvZiBsZW5ndGggMzInKTtcbiAgICB9XG4gICAgY29uc3QgYWRkcmVzcyA9ICgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKCdmZicsICdoZXgnKSwgZnJvbSwgc2FsdCwgKDAsIGtlY2Nha18xLmtlY2NhazI1NikoaW5pdENvZGUpXSkpO1xuICAgIHJldHVybiAoMCwgYnl0ZXNfMS50b0J1ZmZlcikoYWRkcmVzcykuc2xpY2UoLTIwKTtcbn07XG5leHBvcnRzLmdlbmVyYXRlQWRkcmVzczIgPSBnZW5lcmF0ZUFkZHJlc3MyO1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByaXZhdGUga2V5IHNhdGlzZmllcyB0aGUgcnVsZXMgb2YgdGhlIGN1cnZlIHNlY3AyNTZrMS5cbiAqL1xuY29uc3QgaXNWYWxpZFByaXZhdGUgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzZWNwMjU2azFfMS5zZWNwMjU2azEudXRpbHMuaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSk7XG59O1xuZXhwb3J0cy5pc1ZhbGlkUHJpdmF0ZSA9IGlzVmFsaWRQcml2YXRlO1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHB1YmxpYyBrZXkgc2F0aXNmaWVzIHRoZSBydWxlcyBvZiB0aGUgY3VydmUgc2VjcDI1NmsxXG4gKiBhbmQgdGhlIHJlcXVpcmVtZW50cyBvZiBFdGhlcmV1bS5cbiAqIEBwYXJhbSBwdWJsaWNLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleSwgdW5sZXNzIHNhbml0aXplIGlzIGVuYWJsZWRcbiAqIEBwYXJhbSBzYW5pdGl6ZSBBY2NlcHQgcHVibGljIGtleXMgaW4gb3RoZXIgZm9ybWF0c1xuICovXG5jb25zdCBpc1ZhbGlkUHVibGljID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgc2FuaXRpemUgPSBmYWxzZSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKHB1YmxpY0tleSk7XG4gICAgaWYgKHB1YmxpY0tleS5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgIC8vIENvbnZlcnQgdG8gU0VDMSBmb3Igc2VjcDI1NmsxXG4gICAgICAgIC8vIEF1dG9tYXRpY2FsbHkgY2hlY2tzIHdoZXRoZXIgcG9pbnQgaXMgb24gY3VydmVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlY3AyNTZrMV8xLnNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbNF0pLCBwdWJsaWNLZXldKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghc2FuaXRpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBzZWNwMjU2azFfMS5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuZXhwb3J0cy5pc1ZhbGlkUHVibGljID0gaXNWYWxpZFB1YmxpYztcbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gYWRkcmVzcyBvZiBhIGdpdmVuIHB1YmxpYyBrZXkuXG4gKiBBY2NlcHRzIFwiRXRoZXJldW0gcHVibGljIGtleXNcIiBhbmQgU0VDMSBlbmNvZGVkIGtleXMuXG4gKiBAcGFyYW0gcHViS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXksIHVubGVzcyBzYW5pdGl6ZSBpcyBlbmFibGVkXG4gKiBAcGFyYW0gc2FuaXRpemUgQWNjZXB0IHB1YmxpYyBrZXlzIGluIG90aGVyIGZvcm1hdHNcbiAqL1xuY29uc3QgcHViVG9BZGRyZXNzID0gZnVuY3Rpb24gKHB1YktleSwgc2FuaXRpemUgPSBmYWxzZSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKHB1YktleSk7XG4gICAgaWYgKHNhbml0aXplICYmIHB1YktleS5sZW5ndGggIT09IDY0KSB7XG4gICAgICAgIHB1YktleSA9IEJ1ZmZlci5mcm9tKHNlY3AyNTZrMV8xLnNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChwdWJLZXkpLnRvUmF3Qnl0ZXMoZmFsc2UpLnNsaWNlKDEpKTtcbiAgICB9XG4gICAgaWYgKHB1YktleS5sZW5ndGggIT09IDY0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcHViS2V5IHRvIGJlIG9mIGxlbmd0aCA2NCcpO1xuICAgIH1cbiAgICAvLyBPbmx5IHRha2UgdGhlIGxvd2VyIDE2MGJpdHMgb2YgdGhlIGhhc2hcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIGtlY2Nha18xLmtlY2NhazI1NikocHViS2V5KSkuc2xpY2UoLTIwKTtcbn07XG5leHBvcnRzLnB1YlRvQWRkcmVzcyA9IHB1YlRvQWRkcmVzcztcbmV4cG9ydHMucHVibGljVG9BZGRyZXNzID0gZXhwb3J0cy5wdWJUb0FkZHJlc3M7XG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIHB1YmxpYyBrZXkgb2YgYSBnaXZlbiBwcml2YXRlIGtleS5cbiAqIEBwYXJhbSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXG4gKi9cbmNvbnN0IHByaXZhdGVUb1B1YmxpYyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikocHJpdmF0ZUtleSk7XG4gICAgLy8gc2tpcCB0aGUgdHlwZSBmbGFnIGFuZCB1c2UgdGhlIFgsIFkgcG9pbnRzXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMV8xLnNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkudG9SYXdCeXRlcyhmYWxzZSkuc2xpY2UoMSkpO1xufTtcbmV4cG9ydHMucHJpdmF0ZVRvUHVibGljID0gcHJpdmF0ZVRvUHVibGljO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICovXG5jb25zdCBwcml2YXRlVG9BZGRyZXNzID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMucHVibGljVG9BZGRyZXNzKSgoMCwgZXhwb3J0cy5wcml2YXRlVG9QdWJsaWMpKHByaXZhdGVLZXkpKTtcbn07XG5leHBvcnRzLnByaXZhdGVUb0FkZHJlc3MgPSBwcml2YXRlVG9BZGRyZXNzO1xuLyoqXG4gKiBDb252ZXJ0cyBhIHB1YmxpYyBrZXkgdG8gdGhlIEV0aGVyZXVtIGZvcm1hdC5cbiAqL1xuY29uc3QgaW1wb3J0UHVibGljID0gZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKHB1YmxpY0tleSk7XG4gICAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDY0KSB7XG4gICAgICAgIHB1YmxpY0tleSA9IEJ1ZmZlci5mcm9tKHNlY3AyNTZrMV8xLnNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpLnRvUmF3Qnl0ZXMoZmFsc2UpLnNsaWNlKDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHB1YmxpY0tleTtcbn07XG5leHBvcnRzLmltcG9ydFB1YmxpYyA9IGltcG9ydFB1YmxpYztcbi8qKlxuICogUmV0dXJucyB0aGUgemVybyBhZGRyZXNzLlxuICovXG5jb25zdCB6ZXJvQWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBhZGRyZXNzTGVuZ3RoID0gMjA7XG4gICAgY29uc3QgYWRkciA9ICgwLCBieXRlc18xLnplcm9zKShhZGRyZXNzTGVuZ3RoKTtcbiAgICByZXR1cm4gKDAsIGJ5dGVzXzEuYnVmZmVyVG9IZXgpKGFkZHIpO1xufTtcbmV4cG9ydHMuemVyb0FkZHJlc3MgPSB6ZXJvQWRkcmVzcztcbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYWRkcmVzcyBpcyB0aGUgemVybyBhZGRyZXNzLlxuICovXG5jb25zdCBpc1plcm9BZGRyZXNzID0gZnVuY3Rpb24gKGhleEFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgICAoMCwgaGVscGVyc18xLmFzc2VydElzU3RyaW5nKShoZXhBZGRyZXNzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB6ZXJvQWRkciA9ICgwLCBleHBvcnRzLnplcm9BZGRyZXNzKSgpO1xuICAgIHJldHVybiB6ZXJvQWRkciA9PT0gaGV4QWRkcmVzcztcbn07XG5leHBvcnRzLmlzWmVyb0FkZHJlc3MgPSBpc1plcm9BZGRyZXNzO1xuZnVuY3Rpb24gYWNjb3VudEJvZHlGcm9tU2xpbShib2R5KSB7XG4gICAgY29uc3QgW25vbmNlLCBiYWxhbmNlLCBzdG9yYWdlUm9vdCwgY29kZUhhc2hdID0gYm9keTtcbiAgICByZXR1cm4gW1xuICAgICAgICBub25jZSxcbiAgICAgICAgYmFsYW5jZSxcbiAgICAgICAgKDAsIGJ5dGVzXzEuYXJyVG9CdWZBcnIpKHN0b3JhZ2VSb290KS5sZW5ndGggPT09IDAgPyBjb25zdGFudHNfMS5LRUNDQUsyNTZfUkxQIDogc3RvcmFnZVJvb3QsXG4gICAgICAgICgwLCBieXRlc18xLmFyclRvQnVmQXJyKShjb2RlSGFzaCkubGVuZ3RoID09PSAwID8gY29uc3RhbnRzXzEuS0VDQ0FLMjU2X05VTEwgOiBjb2RlSGFzaCxcbiAgICBdO1xufVxuZXhwb3J0cy5hY2NvdW50Qm9keUZyb21TbGltID0gYWNjb3VudEJvZHlGcm9tU2xpbTtcbmNvbnN0IGVtcHR5VWludDhBcnIgPSBuZXcgVWludDhBcnJheSgwKTtcbmZ1bmN0aW9uIGFjY291bnRCb2R5VG9TbGltKGJvZHkpIHtcbiAgICBjb25zdCBbbm9uY2UsIGJhbGFuY2UsIHN0b3JhZ2VSb290LCBjb2RlSGFzaF0gPSBib2R5O1xuICAgIHJldHVybiBbXG4gICAgICAgIG5vbmNlLFxuICAgICAgICBiYWxhbmNlLFxuICAgICAgICAoMCwgYnl0ZXNfMS5hcnJUb0J1ZkFycikoc3RvcmFnZVJvb3QpLmVxdWFscyhjb25zdGFudHNfMS5LRUNDQUsyNTZfUkxQKSA/IGVtcHR5VWludDhBcnIgOiBzdG9yYWdlUm9vdCxcbiAgICAgICAgKDAsIGJ5dGVzXzEuYXJyVG9CdWZBcnIpKGNvZGVIYXNoKS5lcXVhbHMoY29uc3RhbnRzXzEuS0VDQ0FLMjU2X05VTEwpID8gZW1wdHlVaW50OEFyciA6IGNvZGVIYXNoLFxuICAgIF07XG59XG5leHBvcnRzLmFjY291bnRCb2R5VG9TbGltID0gYWNjb3VudEJvZHlUb1NsaW07XG4vKipcbiAqIENvbnZlcnRzIGEgc2xpbSBhY2NvdW50IChwZXIgc25hcCBwcm90b2NvbCBzcGVjKSB0byB0aGUgUkxQIGVuY29kZWQgdmVyc2lvbiBvZiB0aGUgYWNjb3VudFxuICogQHBhcmFtIGJvZHkgQXJyYXkgb2YgNCBCdWZmZXItbGlrZSBpdGVtcyB0byByZXByZXNlbnQgdGhlIGFjY291bnRcbiAqIEByZXR1cm5zIFJMUCBlbmNvZGVkIHZlcnNpb24gb2YgdGhlIGFjY291bnRcbiAqL1xuZnVuY3Rpb24gYWNjb3VudEJvZHlUb1JMUChib2R5LCBjb3VsZEJlU2xpbSA9IHRydWUpIHtcbiAgICBjb25zdCBhY2NvdW50Qm9keSA9IGNvdWxkQmVTbGltID8gYWNjb3VudEJvZHlGcm9tU2xpbShib2R5KSA6IGJvZHk7XG4gICAgcmV0dXJuICgwLCBieXRlc18xLmFyclRvQnVmQXJyKShybHBfMS5STFAuZW5jb2RlKGFjY291bnRCb2R5KSk7XG59XG5leHBvcnRzLmFjY291bnRCb2R5VG9STFAgPSBhY2NvdW50Qm9keVRvUkxQO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjb3VudC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhY2NvdW50Qm9keVRvUkxQIiwiYWNjb3VudEJvZHlUb1NsaW0iLCJhY2NvdW50Qm9keUZyb21TbGltIiwiaXNaZXJvQWRkcmVzcyIsInplcm9BZGRyZXNzIiwiaW1wb3J0UHVibGljIiwicHJpdmF0ZVRvQWRkcmVzcyIsInByaXZhdGVUb1B1YmxpYyIsInB1YmxpY1RvQWRkcmVzcyIsInB1YlRvQWRkcmVzcyIsImlzVmFsaWRQdWJsaWMiLCJpc1ZhbGlkUHJpdmF0ZSIsImdlbmVyYXRlQWRkcmVzczIiLCJnZW5lcmF0ZUFkZHJlc3MiLCJpc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzIiwidG9DaGVja3N1bUFkZHJlc3MiLCJpc1ZhbGlkQWRkcmVzcyIsIkFjY291bnQiLCJybHBfMSIsInJlcXVpcmUiLCJrZWNjYWtfMSIsInNlY3AyNTZrMV8xIiwidXRpbHNfMSIsImJ5dGVzXzEiLCJjb25zdGFudHNfMSIsImhlbHBlcnNfMSIsImludGVybmFsXzEiLCJfMG4iLCJCaWdJbnQiLCJjb25zdHJ1Y3RvciIsIm5vbmNlIiwiYmFsYW5jZSIsInN0b3JhZ2VSb290IiwiS0VDQ0FLMjU2X1JMUCIsImNvZGVIYXNoIiwiS0VDQ0FLMjU2X05VTEwiLCJfdmFsaWRhdGUiLCJmcm9tQWNjb3VudERhdGEiLCJhY2NvdW50RGF0YSIsInVuZGVmaW5lZCIsImJ1ZmZlclRvQmlnSW50IiwidG9CdWZmZXIiLCJmcm9tUmxwU2VyaWFsaXplZEFjY291bnQiLCJzZXJpYWxpemVkIiwidmFsdWVzIiwiYXJyVG9CdWZBcnIiLCJSTFAiLCJkZWNvZGUiLCJVaW50OEFycmF5IiwiZnJvbSIsIkFycmF5IiwiaXNBcnJheSIsIkVycm9yIiwiZnJvbVZhbHVlc0FycmF5IiwibGVuZ3RoIiwicmF3IiwiYmlnSW50VG9VbnBhZGRlZEJ1ZmZlciIsInNlcmlhbGl6ZSIsIkJ1ZmZlciIsImVuY29kZSIsImJ1ZkFyclRvQXJyIiwiaXNDb250cmFjdCIsImVxdWFscyIsImlzRW1wdHkiLCJoZXhBZGRyZXNzIiwiYXNzZXJ0SXNTdHJpbmciLCJlIiwidGVzdCIsImVpcDExOTFDaGFpbklkIiwiYXNzZXJ0SXNIZXhTdHJpbmciLCJhZGRyZXNzIiwic3RyaXBIZXhQcmVmaXgiLCJ0b0xvd2VyQ2FzZSIsInByZWZpeCIsImNoYWluSWQiLCJ0b1N0cmluZyIsImJ1ZiIsImhhc2giLCJieXRlc1RvSGV4Iiwia2VjY2FrMjU2IiwicmV0IiwiaSIsInBhcnNlSW50IiwidG9VcHBlckNhc2UiLCJhc3NlcnRJc0J1ZmZlciIsInNsaWNlIiwic2FsdCIsImluaXRDb2RlIiwiY29uY2F0IiwicHJpdmF0ZUtleSIsInNlY3AyNTZrMSIsInV0aWxzIiwiaXNWYWxpZFByaXZhdGVLZXkiLCJwdWJsaWNLZXkiLCJzYW5pdGl6ZSIsIlByb2plY3RpdmVQb2ludCIsImZyb21IZXgiLCJwdWJLZXkiLCJ0b1Jhd0J5dGVzIiwiZnJvbVByaXZhdGVLZXkiLCJhZGRyZXNzTGVuZ3RoIiwiYWRkciIsInplcm9zIiwiYnVmZmVyVG9IZXgiLCJ6ZXJvQWRkciIsImJvZHkiLCJlbXB0eVVpbnQ4QXJyIiwiY291bGRCZVNsaW0iLCJhY2NvdW50Qm9keSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethereumjs/util/dist/account.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethereumjs/util/dist/address.js":
/*!*******************************************************!*\
  !*** ./node_modules/@ethereumjs/util/dist/address.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Address = void 0;\nconst account_1 = __webpack_require__(/*! ./account */ \"(ssr)/./node_modules/@ethereumjs/util/dist/account.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/@ethereumjs/util/dist/bytes.js\");\n/**\n * Handling and generating Ethereum addresses\n */ class Address {\n    constructor(buf){\n        if (buf.length !== 20) {\n            throw new Error(\"Invalid address length\");\n        }\n        this.buf = buf;\n    }\n    /**\n     * Returns the zero address.\n     */ static zero() {\n        return new Address((0, bytes_1.zeros)(20));\n    }\n    /**\n     * Returns an Address object from a hex-encoded string.\n     * @param str - Hex-encoded address\n     */ static fromString(str) {\n        if (!(0, account_1.isValidAddress)(str)) {\n            throw new Error(\"Invalid address\");\n        }\n        return new Address((0, bytes_1.toBuffer)(str));\n    }\n    /**\n     * Returns an address for a given public key.\n     * @param pubKey The two points of an uncompressed key\n     */ static fromPublicKey(pubKey) {\n        if (!Buffer.isBuffer(pubKey)) {\n            throw new Error(\"Public key should be Buffer\");\n        }\n        const buf = (0, account_1.pubToAddress)(pubKey);\n        return new Address(buf);\n    }\n    /**\n     * Returns an address for a given private key.\n     * @param privateKey A private key must be 256 bits wide\n     */ static fromPrivateKey(privateKey) {\n        if (!Buffer.isBuffer(privateKey)) {\n            throw new Error(\"Private key should be Buffer\");\n        }\n        const buf = (0, account_1.privateToAddress)(privateKey);\n        return new Address(buf);\n    }\n    /**\n     * Generates an address for a newly created contract.\n     * @param from The address which is creating this new address\n     * @param nonce The nonce of the from account\n     */ static generate(from, nonce) {\n        if (typeof nonce !== \"bigint\") {\n            throw new Error(\"Expected nonce to be a bigint\");\n        }\n        return new Address((0, account_1.generateAddress)(from.buf, (0, bytes_1.bigIntToBuffer)(nonce)));\n    }\n    /**\n     * Generates an address for a contract created using CREATE2.\n     * @param from The address which is creating this new address\n     * @param salt A salt\n     * @param initCode The init code of the contract being created\n     */ static generate2(from, salt, initCode) {\n        if (!Buffer.isBuffer(salt)) {\n            throw new Error(\"Expected salt to be a Buffer\");\n        }\n        if (!Buffer.isBuffer(initCode)) {\n            throw new Error(\"Expected initCode to be a Buffer\");\n        }\n        return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n    }\n    /**\n     * Is address equal to another.\n     */ equals(address) {\n        return this.buf.equals(address.buf);\n    }\n    /**\n     * Is address zero.\n     */ isZero() {\n        return this.equals(Address.zero());\n    }\n    /**\n     * True if address is in the address range defined\n     * by EIP-1352\n     */ isPrecompileOrSystemAddress() {\n        const address = (0, bytes_1.bufferToBigInt)(this.buf);\n        const rangeMin = BigInt(0);\n        const rangeMax = BigInt(\"0xffff\");\n        return address >= rangeMin && address <= rangeMax;\n    }\n    /**\n     * Returns hex encoding of address.\n     */ toString() {\n        return \"0x\" + this.buf.toString(\"hex\");\n    }\n    /**\n     * Returns Buffer representation of address.\n     */ toBuffer() {\n        return Buffer.from(this.buf);\n    }\n}\nexports.Address = Address; //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGVBQWUsR0FBRyxLQUFLO0FBQ3ZCLE1BQU1HLFlBQVlDLG1CQUFPQSxDQUFDLHdFQUFXO0FBQ3JDLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLG9FQUFTO0FBQ2pDOztDQUVDLEdBQ0QsTUFBTUY7SUFDRkksWUFBWUMsR0FBRyxDQUFFO1FBQ2IsSUFBSUEsSUFBSUMsTUFBTSxLQUFLLElBQUk7WUFDbkIsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxDQUFDRixHQUFHLEdBQUdBO0lBQ2Y7SUFDQTs7S0FFQyxHQUNELE9BQU9HLE9BQU87UUFDVixPQUFPLElBQUlSLFFBQVEsQ0FBQyxHQUFHRyxRQUFRTSxLQUFLLEVBQUU7SUFDMUM7SUFDQTs7O0tBR0MsR0FDRCxPQUFPQyxXQUFXQyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDLENBQUMsR0FBR1YsVUFBVVcsY0FBYyxFQUFFRCxNQUFNO1lBQ3JDLE1BQU0sSUFBSUosTUFBTTtRQUNwQjtRQUNBLE9BQU8sSUFBSVAsUUFBUSxDQUFDLEdBQUdHLFFBQVFVLFFBQVEsRUFBRUY7SUFDN0M7SUFDQTs7O0tBR0MsR0FDRCxPQUFPRyxjQUFjQyxNQUFNLEVBQUU7UUFDekIsSUFBSSxDQUFDQyxPQUFPQyxRQUFRLENBQUNGLFNBQVM7WUFDMUIsTUFBTSxJQUFJUixNQUFNO1FBQ3BCO1FBQ0EsTUFBTUYsTUFBTSxDQUFDLEdBQUdKLFVBQVVpQixZQUFZLEVBQUVIO1FBQ3hDLE9BQU8sSUFBSWYsUUFBUUs7SUFDdkI7SUFDQTs7O0tBR0MsR0FDRCxPQUFPYyxlQUFlQyxVQUFVLEVBQUU7UUFDOUIsSUFBSSxDQUFDSixPQUFPQyxRQUFRLENBQUNHLGFBQWE7WUFDOUIsTUFBTSxJQUFJYixNQUFNO1FBQ3BCO1FBQ0EsTUFBTUYsTUFBTSxDQUFDLEdBQUdKLFVBQVVvQixnQkFBZ0IsRUFBRUQ7UUFDNUMsT0FBTyxJQUFJcEIsUUFBUUs7SUFDdkI7SUFDQTs7OztLQUlDLEdBQ0QsT0FBT2lCLFNBQVNDLElBQUksRUFBRUMsS0FBSyxFQUFFO1FBQ3pCLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBQzNCLE1BQU0sSUFBSWpCLE1BQU07UUFDcEI7UUFDQSxPQUFPLElBQUlQLFFBQVEsQ0FBQyxHQUFHQyxVQUFVd0IsZUFBZSxFQUFFRixLQUFLbEIsR0FBRyxFQUFFLENBQUMsR0FBR0YsUUFBUXVCLGNBQWMsRUFBRUY7SUFDNUY7SUFDQTs7Ozs7S0FLQyxHQUNELE9BQU9HLFVBQVVKLElBQUksRUFBRUssSUFBSSxFQUFFQyxRQUFRLEVBQUU7UUFDbkMsSUFBSSxDQUFDYixPQUFPQyxRQUFRLENBQUNXLE9BQU87WUFDeEIsTUFBTSxJQUFJckIsTUFBTTtRQUNwQjtRQUNBLElBQUksQ0FBQ1MsT0FBT0MsUUFBUSxDQUFDWSxXQUFXO1lBQzVCLE1BQU0sSUFBSXRCLE1BQU07UUFDcEI7UUFDQSxPQUFPLElBQUlQLFFBQVEsQ0FBQyxHQUFHQyxVQUFVNkIsZ0JBQWdCLEVBQUVQLEtBQUtsQixHQUFHLEVBQUV1QixNQUFNQztJQUN2RTtJQUNBOztLQUVDLEdBQ0RFLE9BQU9DLE9BQU8sRUFBRTtRQUNaLE9BQU8sSUFBSSxDQUFDM0IsR0FBRyxDQUFDMEIsTUFBTSxDQUFDQyxRQUFRM0IsR0FBRztJQUN0QztJQUNBOztLQUVDLEdBQ0Q0QixTQUFTO1FBQ0wsT0FBTyxJQUFJLENBQUNGLE1BQU0sQ0FBQy9CLFFBQVFRLElBQUk7SUFDbkM7SUFDQTs7O0tBR0MsR0FDRDBCLDhCQUE4QjtRQUMxQixNQUFNRixVQUFVLENBQUMsR0FBRzdCLFFBQVFnQyxjQUFjLEVBQUUsSUFBSSxDQUFDOUIsR0FBRztRQUNwRCxNQUFNK0IsV0FBV0MsT0FBTztRQUN4QixNQUFNQyxXQUFXRCxPQUFPO1FBQ3hCLE9BQU9MLFdBQVdJLFlBQVlKLFdBQVdNO0lBQzdDO0lBQ0E7O0tBRUMsR0FDREMsV0FBVztRQUNQLE9BQU8sT0FBTyxJQUFJLENBQUNsQyxHQUFHLENBQUNrQyxRQUFRLENBQUM7SUFDcEM7SUFDQTs7S0FFQyxHQUNEMUIsV0FBVztRQUNQLE9BQU9HLE9BQU9PLElBQUksQ0FBQyxJQUFJLENBQUNsQixHQUFHO0lBQy9CO0FBQ0o7QUFDQVAsZUFBZSxHQUFHRSxTQUNsQixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9hZGRyZXNzLmpzP2FhNmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFkZHJlc3MgPSB2b2lkIDA7XG5jb25zdCBhY2NvdW50XzEgPSByZXF1aXJlKFwiLi9hY2NvdW50XCIpO1xuY29uc3QgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuLyoqXG4gKiBIYW5kbGluZyBhbmQgZ2VuZXJhdGluZyBFdGhlcmV1bSBhZGRyZXNzZXNcbiAqL1xuY2xhc3MgQWRkcmVzcyB7XG4gICAgY29uc3RydWN0b3IoYnVmKSB7XG4gICAgICAgIGlmIChidWYubGVuZ3RoICE9PSAyMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MgbGVuZ3RoJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWYgPSBidWY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHplcm8gYWRkcmVzcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgemVybygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKCgwLCBieXRlc18xLnplcm9zKSgyMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIEFkZHJlc3Mgb2JqZWN0IGZyb20gYSBoZXgtZW5jb2RlZCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHN0ciAtIEhleC1lbmNvZGVkIGFkZHJlc3NcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhzdHIpIHtcbiAgICAgICAgaWYgKCEoMCwgYWNjb3VudF8xLmlzVmFsaWRBZGRyZXNzKShzdHIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzcygoMCwgYnl0ZXNfMS50b0J1ZmZlcikoc3RyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYWRkcmVzcyBmb3IgYSBnaXZlbiBwdWJsaWMga2V5LlxuICAgICAqIEBwYXJhbSBwdWJLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUHVibGljS2V5KHB1YktleSkge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwdWJLZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1B1YmxpYyBrZXkgc2hvdWxkIGJlIEJ1ZmZlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZiA9ICgwLCBhY2NvdW50XzEucHViVG9BZGRyZXNzKShwdWJLZXkpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoYnVmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhZGRyZXNzIGZvciBhIGdpdmVuIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJpdmF0ZSBrZXkgc2hvdWxkIGJlIEJ1ZmZlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZiA9ICgwLCBhY2NvdW50XzEucHJpdmF0ZVRvQWRkcmVzcykocHJpdmF0ZUtleSk7XG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzcyhidWYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gYWRkcmVzcyBmb3IgYSBuZXdseSBjcmVhdGVkIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSBmcm9tIFRoZSBhZGRyZXNzIHdoaWNoIGlzIGNyZWF0aW5nIHRoaXMgbmV3IGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gbm9uY2UgVGhlIG5vbmNlIG9mIHRoZSBmcm9tIGFjY291bnRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2VuZXJhdGUoZnJvbSwgbm9uY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBub25jZSAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbm9uY2UgdG8gYmUgYSBiaWdpbnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoKDAsIGFjY291bnRfMS5nZW5lcmF0ZUFkZHJlc3MpKGZyb20uYnVmLCAoMCwgYnl0ZXNfMS5iaWdJbnRUb0J1ZmZlcikobm9uY2UpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIGZvciBhIGNvbnRyYWN0IGNyZWF0ZWQgdXNpbmcgQ1JFQVRFMi5cbiAgICAgKiBAcGFyYW0gZnJvbSBUaGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXG4gICAgICogQHBhcmFtIHNhbHQgQSBzYWx0XG4gICAgICogQHBhcmFtIGluaXRDb2RlIFRoZSBpbml0IGNvZGUgb2YgdGhlIGNvbnRyYWN0IGJlaW5nIGNyZWF0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2VuZXJhdGUyKGZyb20sIHNhbHQsIGluaXRDb2RlKSB7XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHNhbHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHNhbHQgdG8gYmUgYSBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihpbml0Q29kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5pdENvZGUgdG8gYmUgYSBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoKDAsIGFjY291bnRfMS5nZW5lcmF0ZUFkZHJlc3MyKShmcm9tLmJ1Ziwgc2FsdCwgaW5pdENvZGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgYWRkcmVzcyBlcXVhbCB0byBhbm90aGVyLlxuICAgICAqL1xuICAgIGVxdWFscyhhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5lcXVhbHMoYWRkcmVzcy5idWYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyBhZGRyZXNzIHplcm8uXG4gICAgICovXG4gICAgaXNaZXJvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoQWRkcmVzcy56ZXJvKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIGFkZHJlc3MgaXMgaW4gdGhlIGFkZHJlc3MgcmFuZ2UgZGVmaW5lZFxuICAgICAqIGJ5IEVJUC0xMzUyXG4gICAgICovXG4gICAgaXNQcmVjb21waWxlT3JTeXN0ZW1BZGRyZXNzKCkge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gKDAsIGJ5dGVzXzEuYnVmZmVyVG9CaWdJbnQpKHRoaXMuYnVmKTtcbiAgICAgICAgY29uc3QgcmFuZ2VNaW4gPSBCaWdJbnQoMCk7XG4gICAgICAgIGNvbnN0IHJhbmdlTWF4ID0gQmlnSW50KCcweGZmZmYnKTtcbiAgICAgICAgcmV0dXJuIGFkZHJlc3MgPj0gcmFuZ2VNaW4gJiYgYWRkcmVzcyA8PSByYW5nZU1heDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBoZXggZW5jb2Rpbmcgb2YgYWRkcmVzcy5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICcweCcgKyB0aGlzLmJ1Zi50b1N0cmluZygnaGV4Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgQnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIGFkZHJlc3MuXG4gICAgICovXG4gICAgdG9CdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLmJ1Zik7XG4gICAgfVxufVxuZXhwb3J0cy5BZGRyZXNzID0gQWRkcmVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQWRkcmVzcyIsImFjY291bnRfMSIsInJlcXVpcmUiLCJieXRlc18xIiwiY29uc3RydWN0b3IiLCJidWYiLCJsZW5ndGgiLCJFcnJvciIsInplcm8iLCJ6ZXJvcyIsImZyb21TdHJpbmciLCJzdHIiLCJpc1ZhbGlkQWRkcmVzcyIsInRvQnVmZmVyIiwiZnJvbVB1YmxpY0tleSIsInB1YktleSIsIkJ1ZmZlciIsImlzQnVmZmVyIiwicHViVG9BZGRyZXNzIiwiZnJvbVByaXZhdGVLZXkiLCJwcml2YXRlS2V5IiwicHJpdmF0ZVRvQWRkcmVzcyIsImdlbmVyYXRlIiwiZnJvbSIsIm5vbmNlIiwiZ2VuZXJhdGVBZGRyZXNzIiwiYmlnSW50VG9CdWZmZXIiLCJnZW5lcmF0ZTIiLCJzYWx0IiwiaW5pdENvZGUiLCJnZW5lcmF0ZUFkZHJlc3MyIiwiZXF1YWxzIiwiYWRkcmVzcyIsImlzWmVybyIsImlzUHJlY29tcGlsZU9yU3lzdGVtQWRkcmVzcyIsImJ1ZmZlclRvQmlnSW50IiwicmFuZ2VNaW4iLCJCaWdJbnQiLCJyYW5nZU1heCIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethereumjs/util/dist/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethereumjs/util/dist/asyncEventEmitter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethereumjs/util/dist/asyncEventEmitter.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Ported to Typescript from original implementation below:\n * https://github.com/ahultgren/async-eventemitter -- MIT licensed\n *\n * Type Definitions based on work by: patarapolw <https://github.com/patarapolw> -- MIT licensed\n * that was contributed to Definitely Typed below:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/async-eventemitter\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsyncEventEmitter = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nasync function runInSeries(context, tasks, data) {\n    let error;\n    for await (const task of tasks){\n        try {\n            if (task.length < 2) {\n                //sync\n                task.call(context, data);\n            } else {\n                await new Promise((resolve, reject)=>{\n                    task.call(context, data, (error)=>{\n                        if (error) {\n                            reject(error);\n                        } else {\n                            resolve();\n                        }\n                    });\n                });\n            }\n        } catch (e) {\n            error = e;\n        }\n    }\n    if (error) {\n        throw error;\n    }\n}\nclass AsyncEventEmitter extends events_1.EventEmitter {\n    emit(event, ...args) {\n        let [data, callback] = args;\n        const self = this;\n        let listeners = self._events[event] ?? [];\n        // Optional data argument\n        if (callback === undefined && typeof data === \"function\") {\n            callback = data;\n            data = undefined;\n        }\n        // Special treatment of internal newListener and removeListener events\n        if (event === \"newListener\" || event === \"removeListener\") {\n            data = {\n                event: data,\n                fn: callback\n            };\n            callback = undefined;\n        }\n        // A single listener is just a function not an array...\n        listeners = Array.isArray(listeners) ? listeners : [\n            listeners\n        ];\n        runInSeries(self, listeners.slice(), data).then(callback).catch(callback);\n        return self.listenerCount(event) > 0;\n    }\n    once(event, listener) {\n        const self = this;\n        let g;\n        if (typeof listener !== \"function\") {\n            throw new TypeError(\"listener must be a function\");\n        }\n        // Hack to support set arity\n        if (listener.length >= 2) {\n            g = function(e, next) {\n                self.removeListener(event, g);\n                void listener(e, next);\n            };\n        } else {\n            g = function(e) {\n                self.removeListener(event, g);\n                void listener(e, g);\n            };\n        }\n        self.on(event, g);\n        return self;\n    }\n    first(event, listener) {\n        let listeners = this._events[event] ?? [];\n        // Contract\n        if (typeof listener !== \"function\") {\n            throw new TypeError(\"listener must be a function\");\n        }\n        // Listeners are not always an array\n        if (!Array.isArray(listeners)) {\n            ;\n            this._events[event] = listeners = [\n                listeners\n            ];\n        }\n        listeners.unshift(listener);\n        return this;\n    }\n    before(event, target, listener) {\n        return this.beforeOrAfter(event, target, listener);\n    }\n    after(event, target, listener) {\n        return this.beforeOrAfter(event, target, listener, \"after\");\n    }\n    beforeOrAfter(event, target, listener, beforeOrAfter) {\n        let listeners = this._events[event] ?? [];\n        let i;\n        let index;\n        const add = beforeOrAfter === \"after\" ? 1 : 0;\n        // Contract\n        if (typeof listener !== \"function\") {\n            throw new TypeError(\"listener must be a function\");\n        }\n        if (typeof target !== \"function\") {\n            throw new TypeError(\"target must be a function\");\n        }\n        // Listeners are not always an array\n        if (!Array.isArray(listeners)) {\n            ;\n            this._events[event] = listeners = [\n                listeners\n            ];\n        }\n        index = listeners.length;\n        for(i = listeners.length; i--;){\n            if (listeners[i] === target) {\n                index = i + add;\n                break;\n            }\n        }\n        listeners.splice(index, 0, listener);\n        return this;\n    }\n    on(event, listener) {\n        return super.on(event, listener);\n    }\n    addListener(event, listener) {\n        return super.addListener(event, listener);\n    }\n    prependListener(event, listener) {\n        return super.prependListener(event, listener);\n    }\n    prependOnceListener(event, listener) {\n        return super.prependOnceListener(event, listener);\n    }\n    removeAllListeners(event) {\n        return super.removeAllListeners(event);\n    }\n    removeListener(event, listener) {\n        return super.removeListener(event, listener);\n    }\n    eventNames() {\n        return super.eventNames();\n    }\n    listeners(event) {\n        return super.listeners(event);\n    }\n    listenerCount(event) {\n        return super.listenerCount(event);\n    }\n    getMaxListeners() {\n        return super.getMaxListeners();\n    }\n    setMaxListeners(maxListeners) {\n        return super.setMaxListeners(maxListeners);\n    }\n}\nexports.AsyncEventEmitter = AsyncEventEmitter; //# sourceMappingURL=asyncEventEmitter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2FzeW5jRXZlbnRFbWl0dGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Q0FPQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQseUJBQXlCLEdBQUcsS0FBSztBQUNqQyxNQUFNRyxXQUFXQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxlQUFlQyxZQUFZQyxPQUFPLEVBQUVDLEtBQUssRUFBRUMsSUFBSTtJQUMzQyxJQUFJQztJQUNKLFdBQVcsTUFBTUMsUUFBUUgsTUFBTztRQUM1QixJQUFJO1lBQ0EsSUFBSUcsS0FBS0MsTUFBTSxHQUFHLEdBQUc7Z0JBQ2pCLE1BQU07Z0JBQ05ELEtBQUtFLElBQUksQ0FBQ04sU0FBU0U7WUFDdkIsT0FDSztnQkFDRCxNQUFNLElBQUlLLFFBQVEsQ0FBQ0MsU0FBU0M7b0JBQ3hCTCxLQUFLRSxJQUFJLENBQUNOLFNBQVNFLE1BQU0sQ0FBQ0M7d0JBQ3RCLElBQUlBLE9BQU87NEJBQ1BNLE9BQU9OO3dCQUNYLE9BQ0s7NEJBQ0RLO3dCQUNKO29CQUNKO2dCQUNKO1lBQ0o7UUFDSixFQUNBLE9BQU9FLEdBQUc7WUFDTlAsUUFBUU87UUFDWjtJQUNKO0lBQ0EsSUFBSVAsT0FBTztRQUNQLE1BQU1BO0lBQ1Y7QUFDSjtBQUNBLE1BQU1QLDBCQUEwQkMsU0FBU2MsWUFBWTtJQUNqREMsS0FBS0MsS0FBSyxFQUFFLEdBQUdDLElBQUksRUFBRTtRQUNqQixJQUFJLENBQUNaLE1BQU1hLFNBQVMsR0FBR0Q7UUFDdkIsTUFBTUUsT0FBTyxJQUFJO1FBQ2pCLElBQUlDLFlBQVlELEtBQUtFLE9BQU8sQ0FBQ0wsTUFBTSxJQUFJLEVBQUU7UUFDekMseUJBQXlCO1FBQ3pCLElBQUlFLGFBQWFJLGFBQWEsT0FBT2pCLFNBQVMsWUFBWTtZQUN0RGEsV0FBV2I7WUFDWEEsT0FBT2lCO1FBQ1g7UUFDQSxzRUFBc0U7UUFD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QixPQUFPLElBQUk7SUFDZjtJQUNBSyxHQUFHcEIsS0FBSyxFQUFFZSxRQUFRLEVBQUU7UUFDaEIsT0FBTyxLQUFLLENBQUNLLEdBQUdwQixPQUFPZTtJQUMzQjtJQUNBZ0IsWUFBWS9CLEtBQUssRUFBRWUsUUFBUSxFQUFFO1FBQ3pCLE9BQU8sS0FBSyxDQUFDZ0IsWUFBWS9CLE9BQU9lO0lBQ3BDO0lBQ0FpQixnQkFBZ0JoQyxLQUFLLEVBQUVlLFFBQVEsRUFBRTtRQUM3QixPQUFPLEtBQUssQ0FBQ2lCLGdCQUFnQmhDLE9BQU9lO0lBQ3hDO0lBQ0FrQixvQkFBb0JqQyxLQUFLLEVBQUVlLFFBQVEsRUFBRTtRQUNqQyxPQUFPLEtBQUssQ0FBQ2tCLG9CQUFvQmpDLE9BQU9lO0lBQzVDO0lBQ0FtQixtQkFBbUJsQyxLQUFLLEVBQUU7UUFDdEIsT0FBTyxLQUFLLENBQUNrQyxtQkFBbUJsQztJQUNwQztJQUNBbUIsZUFBZW5CLEtBQUssRUFBRWUsUUFBUSxFQUFFO1FBQzVCLE9BQU8sS0FBSyxDQUFDSSxlQUFlbkIsT0FBT2U7SUFDdkM7SUFDQW9CLGFBQWE7UUFDVCxPQUFPLEtBQUssQ0FBQ0E7SUFDakI7SUFDQS9CLFVBQVVKLEtBQUssRUFBRTtRQUNiLE9BQU8sS0FBSyxDQUFDSSxVQUFVSjtJQUMzQjtJQUNBYSxjQUFjYixLQUFLLEVBQUU7UUFDakIsT0FBTyxLQUFLLENBQUNhLGNBQWNiO0lBQy9CO0lBQ0FvQyxrQkFBa0I7UUFDZCxPQUFPLEtBQUssQ0FBQ0E7SUFDakI7SUFDQUMsZ0JBQWdCQyxZQUFZLEVBQUU7UUFDMUIsT0FBTyxLQUFLLENBQUNELGdCQUFnQkM7SUFDakM7QUFDSjtBQUNBekQseUJBQXlCLEdBQUdFLG1CQUM1Qiw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9hc3luY0V2ZW50RW1pdHRlci5qcz84OTQyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBQb3J0ZWQgdG8gVHlwZXNjcmlwdCBmcm9tIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uIGJlbG93OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FodWx0Z3Jlbi9hc3luYy1ldmVudGVtaXR0ZXIgLS0gTUlUIGxpY2Vuc2VkXG4gKlxuICogVHlwZSBEZWZpbml0aW9ucyBiYXNlZCBvbiB3b3JrIGJ5OiBwYXRhcmFwb2x3IDxodHRwczovL2dpdGh1Yi5jb20vcGF0YXJhcG9sdz4gLS0gTUlUIGxpY2Vuc2VkXG4gKiB0aGF0IHdhcyBjb250cmlidXRlZCB0byBEZWZpbml0ZWx5IFR5cGVkIGJlbG93OlxuICogaHR0cHM6Ly9naXRodWIuY29tL0RlZmluaXRlbHlUeXBlZC9EZWZpbml0ZWx5VHlwZWQvdHJlZS9tYXN0ZXIvdHlwZXMvYXN5bmMtZXZlbnRlbWl0dGVyXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXN5bmNFdmVudEVtaXR0ZXIgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5hc3luYyBmdW5jdGlvbiBydW5JblNlcmllcyhjb250ZXh0LCB0YXNrcywgZGF0YSkge1xuICAgIGxldCBlcnJvcjtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHRhc2sgb2YgdGFza3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0YXNrLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAvL3N5bmNcbiAgICAgICAgICAgICAgICB0YXNrLmNhbGwoY29udGV4dCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2suY2FsbChjb250ZXh0LCBkYXRhLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmNsYXNzIEFzeW5jRXZlbnRFbWl0dGVyIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIGxldCBbZGF0YSwgY2FsbGJhY2tdID0gYXJncztcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCBsaXN0ZW5lcnMgPSBzZWxmLl9ldmVudHNbZXZlbnRdID8/IFtdO1xuICAgICAgICAvLyBPcHRpb25hbCBkYXRhIGFyZ3VtZW50XG4gICAgICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNwZWNpYWwgdHJlYXRtZW50IG9mIGludGVybmFsIG5ld0xpc3RlbmVyIGFuZCByZW1vdmVMaXN0ZW5lciBldmVudHNcbiAgICAgICAgaWYgKGV2ZW50ID09PSAnbmV3TGlzdGVuZXInIHx8IGV2ZW50ID09PSAncmVtb3ZlTGlzdGVuZXInKSB7XG4gICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBkYXRhLFxuICAgICAgICAgICAgICAgIGZuOiBjYWxsYmFjayxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHNpbmdsZSBsaXN0ZW5lciBpcyBqdXN0IGEgZnVuY3Rpb24gbm90IGFuIGFycmF5Li4uXG4gICAgICAgIGxpc3RlbmVycyA9IEFycmF5LmlzQXJyYXkobGlzdGVuZXJzKSA/IGxpc3RlbmVycyA6IFtsaXN0ZW5lcnNdO1xuICAgICAgICBydW5JblNlcmllcyhzZWxmLCBsaXN0ZW5lcnMuc2xpY2UoKSwgZGF0YSkudGhlbihjYWxsYmFjaykuY2F0Y2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gc2VsZi5saXN0ZW5lckNvdW50KGV2ZW50KSA+IDA7XG4gICAgfVxuICAgIG9uY2UoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgZztcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFjayB0byBzdXBwb3J0IHNldCBhcml0eVxuICAgICAgICBpZiAobGlzdGVuZXIubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIGcgPSBmdW5jdGlvbiAoZSwgbmV4dCkge1xuICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGcpO1xuICAgICAgICAgICAgICAgIHZvaWQgbGlzdGVuZXIoZSwgbmV4dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcihldmVudCwgZyk7XG4gICAgICAgICAgICAgICAgdm9pZCBsaXN0ZW5lcihlLCBnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5vbihldmVudCwgZyk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICBmaXJzdChldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldmVudF0gPz8gW107XG4gICAgICAgIC8vIENvbnRyYWN0XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExpc3RlbmVycyBhcmUgbm90IGFsd2F5cyBhbiBhcnJheVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdGVuZXJzKSkge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IGxpc3RlbmVycyA9IFtsaXN0ZW5lcnNdO1xuICAgICAgICB9XG4gICAgICAgIGxpc3RlbmVycy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJlZm9yZShldmVudCwgdGFyZ2V0LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVPckFmdGVyKGV2ZW50LCB0YXJnZXQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgYWZ0ZXIoZXZlbnQsIHRhcmdldCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlT3JBZnRlcihldmVudCwgdGFyZ2V0LCBsaXN0ZW5lciwgJ2FmdGVyJyk7XG4gICAgfVxuICAgIGJlZm9yZU9yQWZ0ZXIoZXZlbnQsIHRhcmdldCwgbGlzdGVuZXIsIGJlZm9yZU9yQWZ0ZXIpIHtcbiAgICAgICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldmVudF0gPz8gW107XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgaW5kZXg7XG4gICAgICAgIGNvbnN0IGFkZCA9IGJlZm9yZU9yQWZ0ZXIgPT09ICdhZnRlcicgPyAxIDogMDtcbiAgICAgICAgLy8gQ29udHJhY3RcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMaXN0ZW5lcnMgYXJlIG5vdCBhbHdheXMgYW4gYXJyYXlcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3RlbmVycykpIHtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSBsaXN0ZW5lcnMgPSBbbGlzdGVuZXJzXTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0gPT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaSArIGFkZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAwLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIGFkZExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gc3VwZXIuYWRkTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcHJlcGVuZExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gc3VwZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHByZXBlbmRPbmNlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5wcmVwZW5kT25jZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgICAgICByZXR1cm4gc3VwZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KTtcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBldmVudE5hbWVzKCkge1xuICAgICAgICByZXR1cm4gc3VwZXIuZXZlbnROYW1lcygpO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmxpc3RlbmVycyhldmVudCk7XG4gICAgfVxuICAgIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmxpc3RlbmVyQ291bnQoZXZlbnQpO1xuICAgIH1cbiAgICBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5nZXRNYXhMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgc2V0TWF4TGlzdGVuZXJzKG1heExpc3RlbmVycykge1xuICAgICAgICByZXR1cm4gc3VwZXIuc2V0TWF4TGlzdGVuZXJzKG1heExpc3RlbmVycyk7XG4gICAgfVxufVxuZXhwb3J0cy5Bc3luY0V2ZW50RW1pdHRlciA9IEFzeW5jRXZlbnRFbWl0dGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN5bmNFdmVudEVtaXR0ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQXN5bmNFdmVudEVtaXR0ZXIiLCJldmVudHNfMSIsInJlcXVpcmUiLCJydW5JblNlcmllcyIsImNvbnRleHQiLCJ0YXNrcyIsImRhdGEiLCJlcnJvciIsInRhc2siLCJsZW5ndGgiLCJjYWxsIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJlIiwiRXZlbnRFbWl0dGVyIiwiZW1pdCIsImV2ZW50IiwiYXJncyIsImNhbGxiYWNrIiwic2VsZiIsImxpc3RlbmVycyIsIl9ldmVudHMiLCJ1bmRlZmluZWQiLCJmbiIsIkFycmF5IiwiaXNBcnJheSIsInNsaWNlIiwidGhlbiIsImNhdGNoIiwibGlzdGVuZXJDb3VudCIsIm9uY2UiLCJsaXN0ZW5lciIsImciLCJUeXBlRXJyb3IiLCJuZXh0IiwicmVtb3ZlTGlzdGVuZXIiLCJvbiIsImZpcnN0IiwidW5zaGlmdCIsImJlZm9yZSIsInRhcmdldCIsImJlZm9yZU9yQWZ0ZXIiLCJhZnRlciIsImkiLCJpbmRleCIsImFkZCIsInNwbGljZSIsImFkZExpc3RlbmVyIiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImV2ZW50TmFtZXMiLCJnZXRNYXhMaXN0ZW5lcnMiLCJzZXRNYXhMaXN0ZW5lcnMiLCJtYXhMaXN0ZW5lcnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethereumjs/util/dist/asyncEventEmitter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethereumjs/util/dist/bytes.js":
/*!*****************************************************!*\
  !*** ./node_modules/@ethereumjs/util/dist/bytes.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.intToUnpaddedBuffer = exports.bigIntToUnpaddedBuffer = exports.bigIntToHex = exports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.short = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToInt = exports.bigIntToBuffer = exports.bufferToBigInt = exports.bufferToHex = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@ethereumjs/util/dist/helpers.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/@ethereumjs/util/dist/internal.js\");\n/**\n * Converts a `Number` into a hex `String`\n * @param {Number} i\n * @return {String}\n */ const intToHex = function(i) {\n    if (!Number.isSafeInteger(i) || i < 0) {\n        throw new Error(`Received an invalid integer type: ${i}`);\n    }\n    return `0x${i.toString(16)}`;\n};\nexports.intToHex = intToHex;\n/**\n * Converts an `Number` to a `Buffer`\n * @param {Number} i\n * @return {Buffer}\n */ const intToBuffer = function(i) {\n    const hex = (0, exports.intToHex)(i);\n    return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), \"hex\");\n};\nexports.intToBuffer = intToBuffer;\n/**\n * Returns a buffer filled with 0s.\n * @param bytes the number of bytes the buffer should be\n */ const zeros = function(bytes) {\n    return Buffer.allocUnsafe(bytes).fill(0);\n};\nexports.zeros = zeros;\n/**\n * Pads a `Buffer` with zeros till it has `length` bytes.\n * Truncates the beginning or end of input if its length exceeds `length`.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @param right whether to start padding form the left or right\n * @return (Buffer)\n */ const setLength = function(msg, length, right) {\n    const buf = (0, exports.zeros)(length);\n    if (right) {\n        if (msg.length < length) {\n            msg.copy(buf);\n            return buf;\n        }\n        return msg.slice(0, length);\n    } else {\n        if (msg.length < length) {\n            msg.copy(buf, length - msg.length);\n            return buf;\n        }\n        return msg.slice(-length);\n    }\n};\n/**\n * Left Pads a `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */ const setLengthLeft = function(msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, false);\n};\nexports.setLengthLeft = setLengthLeft;\n/**\n * Right Pads a `Buffer` with trailing zeros till it has `length` bytes.\n * it truncates the end if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */ const setLengthRight = function(msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, true);\n};\nexports.setLengthRight = setLengthRight;\n/**\n * Trims leading zeros from a `Buffer`, `String` or `Number[]`.\n * @param a (Buffer|Array|String)\n * @return (Buffer|Array|String)\n */ const stripZeros = function(a) {\n    let first = a[0];\n    while(a.length > 0 && first.toString() === \"0\"){\n        a = a.slice(1);\n        first = a[0];\n    }\n    return a;\n};\n/**\n * Trims leading zeros from a `Buffer`.\n * @param a (Buffer)\n * @return (Buffer)\n */ const unpadBuffer = function(a) {\n    (0, helpers_1.assertIsBuffer)(a);\n    return stripZeros(a);\n};\nexports.unpadBuffer = unpadBuffer;\n/**\n * Trims leading zeros from an `Array` (of numbers).\n * @param a (number[])\n * @return (number[])\n */ const unpadArray = function(a) {\n    (0, helpers_1.assertIsArray)(a);\n    return stripZeros(a);\n};\nexports.unpadArray = unpadArray;\n/**\n * Trims leading zeros from a hex-prefixed `String`.\n * @param a (String)\n * @return (String)\n */ const unpadHexString = function(a) {\n    (0, helpers_1.assertIsHexString)(a);\n    a = (0, internal_1.stripHexPrefix)(a);\n    return \"0x\" + stripZeros(a);\n};\nexports.unpadHexString = unpadHexString;\n/**\n * Attempts to turn a value into a `Buffer`.\n * Inputs supported: `Buffer`, `String` (hex-prefixed), `Number`, null/undefined, `BigInt` and other objects\n * with a `toArray()` or `toBuffer()` method.\n * @param v the value\n */ const toBuffer = function(v) {\n    if (v === null || v === undefined) {\n        return Buffer.allocUnsafe(0);\n    }\n    if (Buffer.isBuffer(v)) {\n        return Buffer.from(v);\n    }\n    if (Array.isArray(v) || v instanceof Uint8Array) {\n        return Buffer.from(v);\n    }\n    if (typeof v === \"string\") {\n        if (!(0, internal_1.isHexString)(v)) {\n            throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);\n        }\n        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), \"hex\");\n    }\n    if (typeof v === \"number\") {\n        return (0, exports.intToBuffer)(v);\n    }\n    if (typeof v === \"bigint\") {\n        if (v < BigInt(0)) {\n            throw new Error(`Cannot convert negative bigint to buffer. Given: ${v}`);\n        }\n        let n = v.toString(16);\n        if (n.length % 2) n = \"0\" + n;\n        return Buffer.from(n, \"hex\");\n    }\n    if (v.toArray) {\n        // converts a BN to a Buffer\n        return Buffer.from(v.toArray());\n    }\n    if (v.toBuffer) {\n        return Buffer.from(v.toBuffer());\n    }\n    throw new Error(\"invalid type\");\n};\nexports.toBuffer = toBuffer;\n/**\n * Converts a `Buffer` into a `0x`-prefixed hex `String`.\n * @param buf `Buffer` object to convert\n */ const bufferToHex = function(buf) {\n    buf = (0, exports.toBuffer)(buf);\n    return \"0x\" + buf.toString(\"hex\");\n};\nexports.bufferToHex = bufferToHex;\n/**\n * Converts a {@link Buffer} to a {@link bigint}\n */ function bufferToBigInt(buf) {\n    const hex = (0, exports.bufferToHex)(buf);\n    if (hex === \"0x\") {\n        return BigInt(0);\n    }\n    return BigInt(hex);\n}\nexports.bufferToBigInt = bufferToBigInt;\n/**\n * Converts a {@link bigint} to a {@link Buffer}\n */ function bigIntToBuffer(num) {\n    return (0, exports.toBuffer)(\"0x\" + num.toString(16));\n}\nexports.bigIntToBuffer = bigIntToBuffer;\n/**\n * Converts a `Buffer` to a `Number`.\n * @param buf `Buffer` object to convert\n * @throws If the input number exceeds 53 bits.\n */ const bufferToInt = function(buf) {\n    const res = Number(bufferToBigInt(buf));\n    if (!Number.isSafeInteger(res)) throw new Error(\"Number exceeds 53 bits\");\n    return res;\n};\nexports.bufferToInt = bufferToInt;\n/**\n * Interprets a `Buffer` as a signed integer and returns a `BigInt`. Assumes 256-bit numbers.\n * @param num Signed integer value\n */ const fromSigned = function(num) {\n    return BigInt.asIntN(256, bufferToBigInt(num));\n};\nexports.fromSigned = fromSigned;\n/**\n * Converts a `BigInt` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\n * @param num\n */ const toUnsigned = function(num) {\n    return bigIntToBuffer(BigInt.asUintN(256, num));\n};\nexports.toUnsigned = toUnsigned;\n/**\n * Adds \"0x\" to a given `String` if it does not already start with \"0x\".\n */ const addHexPrefix = function(str) {\n    if (typeof str !== \"string\") {\n        return str;\n    }\n    return (0, internal_1.isHexPrefixed)(str) ? str : \"0x\" + str;\n};\nexports.addHexPrefix = addHexPrefix;\n/**\n * Shortens a string  or buffer's hex string representation to maxLength (default 50).\n *\n * Examples:\n *\n * Input:  '657468657265756d000000000000000000000000000000000000000000000000'\n * Output: '657468657265756d0000000000000000000000000000000000…'\n */ function short(buffer, maxLength = 50) {\n    const bufferStr = Buffer.isBuffer(buffer) ? buffer.toString(\"hex\") : buffer;\n    if (bufferStr.length <= maxLength) {\n        return bufferStr;\n    }\n    return bufferStr.slice(0, maxLength) + \"…\";\n}\nexports.short = short;\n/**\n * Returns the utf8 string representation from a hex string.\n *\n * Examples:\n *\n * Input 1: '657468657265756d000000000000000000000000000000000000000000000000'\n * Input 2: '657468657265756d'\n * Input 3: '000000000000000000000000000000000000000000000000657468657265756d'\n *\n * Output (all 3 input variants): 'ethereum'\n *\n * Note that this method is not intended to be used with hex strings\n * representing quantities in both big endian or little endian notation.\n *\n * @param string Hex string, should be `0x` prefixed\n * @return Utf8 string\n */ const toUtf8 = function(hex) {\n    const zerosRegexp = /^(00)+|(00)+$/g;\n    hex = (0, internal_1.stripHexPrefix)(hex);\n    if (hex.length % 2 !== 0) {\n        throw new Error(\"Invalid non-even hex string input for toUtf8() provided\");\n    }\n    const bufferVal = Buffer.from(hex.replace(zerosRegexp, \"\"), \"hex\");\n    return bufferVal.toString(\"utf8\");\n};\nexports.toUtf8 = toUtf8;\n/**\n * Converts a `Buffer` or `Array` to JSON.\n * @param ba (Buffer|Array)\n * @return (Array|String|null)\n */ const baToJSON = function(ba) {\n    if (Buffer.isBuffer(ba)) {\n        return `0x${ba.toString(\"hex\")}`;\n    } else if (ba instanceof Array) {\n        const array = [];\n        for(let i = 0; i < ba.length; i++){\n            array.push((0, exports.baToJSON)(ba[i]));\n        }\n        return array;\n    }\n};\nexports.baToJSON = baToJSON;\n/**\n * Checks provided Buffers for leading zeroes and throws if found.\n *\n * Examples:\n *\n * Valid values: 0x1, 0x, 0x01, 0x1234\n * Invalid values: 0x0, 0x00, 0x001, 0x0001\n *\n * Note: This method is useful for validating that RLP encoded integers comply with the rule that all\n * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes\n * @param values An object containing string keys and Buffer values\n * @throws if any provided value is found to have leading zero bytes\n */ const validateNoLeadingZeroes = function(values) {\n    for (const [k, v] of Object.entries(values)){\n        if (v !== undefined && v.length > 0 && v[0] === 0) {\n            throw new Error(`${k} cannot have leading zeroes, received: ${v.toString(\"hex\")}`);\n        }\n    }\n};\nexports.validateNoLeadingZeroes = validateNoLeadingZeroes;\nfunction arrToBufArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Buffer.from(arr);\n    }\n    return arr.map((a)=>arrToBufArr(a));\n}\nexports.arrToBufArr = arrToBufArr;\nfunction bufArrToArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Uint8Array.from(arr ?? []);\n    }\n    return arr.map((a)=>bufArrToArr(a));\n}\nexports.bufArrToArr = bufArrToArr;\n/**\n * Converts a {@link bigint} to a `0x` prefixed hex string\n */ const bigIntToHex = (num)=>{\n    return \"0x\" + num.toString(16);\n};\nexports.bigIntToHex = bigIntToHex;\n/**\n * Convert value from bigint to an unpadded Buffer\n * (useful for RLP transport)\n * @param value value to convert\n */ function bigIntToUnpaddedBuffer(value) {\n    return (0, exports.unpadBuffer)(bigIntToBuffer(value));\n}\nexports.bigIntToUnpaddedBuffer = bigIntToUnpaddedBuffer;\nfunction intToUnpaddedBuffer(value) {\n    return (0, exports.unpadBuffer)((0, exports.intToBuffer)(value));\n}\nexports.intToUnpaddedBuffer = intToUnpaddedBuffer; //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2J5dGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQkFBMkIsR0FBR0EsOEJBQThCLEdBQUdBLG1CQUFtQixHQUFHQSxtQkFBbUIsR0FBR0EsbUJBQW1CLEdBQUdBLCtCQUErQixHQUFHQSxnQkFBZ0IsR0FBR0EsY0FBYyxHQUFHQSxhQUFhLEdBQUdBLG9CQUFvQixHQUFHQSxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLG1CQUFtQixHQUFHQSxzQkFBc0IsR0FBR0Esc0JBQXNCLEdBQUdBLG1CQUFtQixHQUFHQSxnQkFBZ0IsR0FBR0Esc0JBQXNCLEdBQUdBLGtCQUFrQixHQUFHQSxtQkFBbUIsR0FBR0Esc0JBQXNCLEdBQUdBLHFCQUFxQixHQUFHQSxhQUFhLEdBQUdBLG1CQUFtQixHQUFHQSxnQkFBZ0IsR0FBRyxLQUFLO0FBQzVqQixNQUFNMkIsWUFBWUMsbUJBQU9BLENBQUMsd0VBQVc7QUFDckMsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsMEVBQVk7QUFDdkM7Ozs7Q0FJQyxHQUNELE1BQU1GLFdBQVcsU0FBVUksQ0FBQztJQUN4QixJQUFJLENBQUNDLE9BQU9DLGFBQWEsQ0FBQ0YsTUFBTUEsSUFBSSxHQUFHO1FBQ25DLE1BQU0sSUFBSUcsTUFBTSxDQUFDLGtDQUFrQyxFQUFFSCxFQUFFLENBQUM7SUFDNUQ7SUFDQSxPQUFPLENBQUMsRUFBRSxFQUFFQSxFQUFFSSxRQUFRLENBQUMsSUFBSSxDQUFDO0FBQ2hDO0FBQ0FsQyxnQkFBZ0IsR0FBRzBCO0FBQ25COzs7O0NBSUMsR0FDRCxNQUFNRCxjQUFjLFNBQVVLLENBQUM7SUFDM0IsTUFBTUssTUFBTSxDQUFDLEdBQUduQyxRQUFRMEIsUUFBUSxFQUFFSTtJQUNsQyxPQUFPTSxPQUFPQyxJQUFJLENBQUMsQ0FBQyxHQUFHUixXQUFXUyxTQUFTLEVB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L3BvY2tldGgvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2J5dGVzLmpzPzNiYWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmludFRvVW5wYWRkZWRCdWZmZXIgPSBleHBvcnRzLmJpZ0ludFRvVW5wYWRkZWRCdWZmZXIgPSBleHBvcnRzLmJpZ0ludFRvSGV4ID0gZXhwb3J0cy5idWZBcnJUb0FyciA9IGV4cG9ydHMuYXJyVG9CdWZBcnIgPSBleHBvcnRzLnZhbGlkYXRlTm9MZWFkaW5nWmVyb2VzID0gZXhwb3J0cy5iYVRvSlNPTiA9IGV4cG9ydHMudG9VdGY4ID0gZXhwb3J0cy5zaG9ydCA9IGV4cG9ydHMuYWRkSGV4UHJlZml4ID0gZXhwb3J0cy50b1Vuc2lnbmVkID0gZXhwb3J0cy5mcm9tU2lnbmVkID0gZXhwb3J0cy5idWZmZXJUb0ludCA9IGV4cG9ydHMuYmlnSW50VG9CdWZmZXIgPSBleHBvcnRzLmJ1ZmZlclRvQmlnSW50ID0gZXhwb3J0cy5idWZmZXJUb0hleCA9IGV4cG9ydHMudG9CdWZmZXIgPSBleHBvcnRzLnVucGFkSGV4U3RyaW5nID0gZXhwb3J0cy51bnBhZEFycmF5ID0gZXhwb3J0cy51bnBhZEJ1ZmZlciA9IGV4cG9ydHMuc2V0TGVuZ3RoUmlnaHQgPSBleHBvcnRzLnNldExlbmd0aExlZnQgPSBleHBvcnRzLnplcm9zID0gZXhwb3J0cy5pbnRUb0J1ZmZlciA9IGV4cG9ydHMuaW50VG9IZXggPSB2b2lkIDA7XG5jb25zdCBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xuY29uc3QgaW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsXCIpO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBOdW1iZXJgIGludG8gYSBoZXggYFN0cmluZ2BcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IGludFRvSGV4ID0gZnVuY3Rpb24gKGkpIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGkpIHx8IGkgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjZWl2ZWQgYW4gaW52YWxpZCBpbnRlZ2VyIHR5cGU6ICR7aX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGAweCR7aS50b1N0cmluZygxNil9YDtcbn07XG5leHBvcnRzLmludFRvSGV4ID0gaW50VG9IZXg7XG4vKipcbiAqIENvbnZlcnRzIGFuIGBOdW1iZXJgIHRvIGEgYEJ1ZmZlcmBcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmNvbnN0IGludFRvQnVmZmVyID0gZnVuY3Rpb24gKGkpIHtcbiAgICBjb25zdCBoZXggPSAoMCwgZXhwb3J0cy5pbnRUb0hleCkoaSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBpbnRlcm5hbF8xLnBhZFRvRXZlbikoaGV4LnNsaWNlKDIpKSwgJ2hleCcpO1xufTtcbmV4cG9ydHMuaW50VG9CdWZmZXIgPSBpbnRUb0J1ZmZlcjtcbi8qKlxuICogUmV0dXJucyBhIGJ1ZmZlciBmaWxsZWQgd2l0aCAwcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBidWZmZXIgc2hvdWxkIGJlXG4gKi9cbmNvbnN0IHplcm9zID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShieXRlcykuZmlsbCgwKTtcbn07XG5leHBvcnRzLnplcm9zID0gemVyb3M7XG4vKipcbiAqIFBhZHMgYSBgQnVmZmVyYCB3aXRoIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogVHJ1bmNhdGVzIHRoZSBiZWdpbm5pbmcgb3IgZW5kIG9mIGlucHV0IGlmIGl0cyBsZW5ndGggZXhjZWVkcyBgbGVuZ3RoYC5cbiAqIEBwYXJhbSBtc2cgdGhlIHZhbHVlIHRvIHBhZCAoQnVmZmVyKVxuICogQHBhcmFtIGxlbmd0aCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBvdXRwdXQgc2hvdWxkIGJlXG4gKiBAcGFyYW0gcmlnaHQgd2hldGhlciB0byBzdGFydCBwYWRkaW5nIGZvcm0gdGhlIGxlZnQgb3IgcmlnaHRcbiAqIEByZXR1cm4gKEJ1ZmZlcilcbiAqL1xuY29uc3Qgc2V0TGVuZ3RoID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoLCByaWdodCkge1xuICAgIGNvbnN0IGJ1ZiA9ICgwLCBleHBvcnRzLnplcm9zKShsZW5ndGgpO1xuICAgIGlmIChyaWdodCkge1xuICAgICAgICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgbXNnLmNvcHkoYnVmKTtcbiAgICAgICAgICAgIHJldHVybiBidWY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1zZy5zbGljZSgwLCBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG1zZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIG1zZy5jb3B5KGJ1ZiwgbGVuZ3RoIC0gbXNnLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtc2cuc2xpY2UoLWxlbmd0aCk7XG4gICAgfVxufTtcbi8qKlxuICogTGVmdCBQYWRzIGEgYEJ1ZmZlcmAgd2l0aCBsZWFkaW5nIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogT3IgaXQgdHJ1bmNhdGVzIHRoZSBiZWdpbm5pbmcgaWYgaXQgZXhjZWVkcy5cbiAqIEBwYXJhbSBtc2cgdGhlIHZhbHVlIHRvIHBhZCAoQnVmZmVyKVxuICogQHBhcmFtIGxlbmd0aCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBvdXRwdXQgc2hvdWxkIGJlXG4gKiBAcmV0dXJuIChCdWZmZXIpXG4gKi9cbmNvbnN0IHNldExlbmd0aExlZnQgPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShtc2cpO1xuICAgIHJldHVybiBzZXRMZW5ndGgobXNnLCBsZW5ndGgsIGZhbHNlKTtcbn07XG5leHBvcnRzLnNldExlbmd0aExlZnQgPSBzZXRMZW5ndGhMZWZ0O1xuLyoqXG4gKiBSaWdodCBQYWRzIGEgYEJ1ZmZlcmAgd2l0aCB0cmFpbGluZyB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIGl0IHRydW5jYXRlcyB0aGUgZW5kIGlmIGl0IGV4Y2VlZHMuXG4gKiBAcGFyYW0gbXNnIHRoZSB2YWx1ZSB0byBwYWQgKEJ1ZmZlcilcbiAqIEBwYXJhbSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHJldHVybiAoQnVmZmVyKVxuICovXG5jb25zdCBzZXRMZW5ndGhSaWdodCA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKG1zZyk7XG4gICAgcmV0dXJuIHNldExlbmd0aChtc2csIGxlbmd0aCwgdHJ1ZSk7XG59O1xuZXhwb3J0cy5zZXRMZW5ndGhSaWdodCA9IHNldExlbmd0aFJpZ2h0O1xuLyoqXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYSBgQnVmZmVyYCwgYFN0cmluZ2Agb3IgYE51bWJlcltdYC5cbiAqIEBwYXJhbSBhIChCdWZmZXJ8QXJyYXl8U3RyaW5nKVxuICogQHJldHVybiAoQnVmZmVyfEFycmF5fFN0cmluZylcbiAqL1xuY29uc3Qgc3RyaXBaZXJvcyA9IGZ1bmN0aW9uIChhKSB7XG4gICAgbGV0IGZpcnN0ID0gYVswXTtcbiAgICB3aGlsZSAoYS5sZW5ndGggPiAwICYmIGZpcnN0LnRvU3RyaW5nKCkgPT09ICcwJykge1xuICAgICAgICBhID0gYS5zbGljZSgxKTtcbiAgICAgICAgZmlyc3QgPSBhWzBdO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIGBCdWZmZXJgLlxuICogQHBhcmFtIGEgKEJ1ZmZlcilcbiAqIEByZXR1cm4gKEJ1ZmZlcilcbiAqL1xuY29uc3QgdW5wYWRCdWZmZXIgPSBmdW5jdGlvbiAoYSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKGEpO1xuICAgIHJldHVybiBzdHJpcFplcm9zKGEpO1xufTtcbmV4cG9ydHMudW5wYWRCdWZmZXIgPSB1bnBhZEJ1ZmZlcjtcbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGFuIGBBcnJheWAgKG9mIG51bWJlcnMpLlxuICogQHBhcmFtIGEgKG51bWJlcltdKVxuICogQHJldHVybiAobnVtYmVyW10pXG4gKi9cbmNvbnN0IHVucGFkQXJyYXkgPSBmdW5jdGlvbiAoYSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNBcnJheSkoYSk7XG4gICAgcmV0dXJuIHN0cmlwWmVyb3MoYSk7XG59O1xuZXhwb3J0cy51bnBhZEFycmF5ID0gdW5wYWRBcnJheTtcbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEgaGV4LXByZWZpeGVkIGBTdHJpbmdgLlxuICogQHBhcmFtIGEgKFN0cmluZylcbiAqIEByZXR1cm4gKFN0cmluZylcbiAqL1xuY29uc3QgdW5wYWRIZXhTdHJpbmcgPSBmdW5jdGlvbiAoYSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNIZXhTdHJpbmcpKGEpO1xuICAgIGEgPSAoMCwgaW50ZXJuYWxfMS5zdHJpcEhleFByZWZpeCkoYSk7XG4gICAgcmV0dXJuICgnMHgnICsgc3RyaXBaZXJvcyhhKSk7XG59O1xuZXhwb3J0cy51bnBhZEhleFN0cmluZyA9IHVucGFkSGV4U3RyaW5nO1xuLyoqXG4gKiBBdHRlbXB0cyB0byB0dXJuIGEgdmFsdWUgaW50byBhIGBCdWZmZXJgLlxuICogSW5wdXRzIHN1cHBvcnRlZDogYEJ1ZmZlcmAsIGBTdHJpbmdgIChoZXgtcHJlZml4ZWQpLCBgTnVtYmVyYCwgbnVsbC91bmRlZmluZWQsIGBCaWdJbnRgIGFuZCBvdGhlciBvYmplY3RzXG4gKiB3aXRoIGEgYHRvQXJyYXkoKWAgb3IgYHRvQnVmZmVyKClgIG1ldGhvZC5cbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZVxuICovXG5jb25zdCB0b0J1ZmZlciA9IGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgfVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodikpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSB8fCB2IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCEoMCwgaW50ZXJuYWxfMS5pc0hleFN0cmluZykodikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbnZlcnQgc3RyaW5nIHRvIGJ1ZmZlci4gdG9CdWZmZXIgb25seSBzdXBwb3J0cyAweC1wcmVmaXhlZCBoZXggc3RyaW5ncyBhbmQgdGhpcyBzdHJpbmcgd2FzIGdpdmVuOiAke3Z9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBpbnRlcm5hbF8xLnBhZFRvRXZlbikoKDAsIGludGVybmFsXzEuc3RyaXBIZXhQcmVmaXgpKHYpKSwgJ2hleCcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5pbnRUb0J1ZmZlcikodik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgaWYgKHYgPCBCaWdJbnQoMCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbnZlcnQgbmVnYXRpdmUgYmlnaW50IHRvIGJ1ZmZlci4gR2l2ZW46ICR7dn1gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbiA9IHYudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAobi5sZW5ndGggJSAyKVxuICAgICAgICAgICAgbiA9ICcwJyArIG47XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShuLCAnaGV4Jyk7XG4gICAgfVxuICAgIGlmICh2LnRvQXJyYXkpIHtcbiAgICAgICAgLy8gY29udmVydHMgYSBCTiB0byBhIEJ1ZmZlclxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odi50b0FycmF5KCkpO1xuICAgIH1cbiAgICBpZiAodi50b0J1ZmZlcikge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odi50b0J1ZmZlcigpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUnKTtcbn07XG5leHBvcnRzLnRvQnVmZmVyID0gdG9CdWZmZXI7XG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgaW50byBhIGAweGAtcHJlZml4ZWQgaGV4IGBTdHJpbmdgLlxuICogQHBhcmFtIGJ1ZiBgQnVmZmVyYCBvYmplY3QgdG8gY29udmVydFxuICovXG5jb25zdCBidWZmZXJUb0hleCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICBidWYgPSAoMCwgZXhwb3J0cy50b0J1ZmZlcikoYnVmKTtcbiAgICByZXR1cm4gJzB4JyArIGJ1Zi50b1N0cmluZygnaGV4Jyk7XG59O1xuZXhwb3J0cy5idWZmZXJUb0hleCA9IGJ1ZmZlclRvSGV4O1xuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBCdWZmZXJ9IHRvIGEge0BsaW5rIGJpZ2ludH1cbiAqL1xuZnVuY3Rpb24gYnVmZmVyVG9CaWdJbnQoYnVmKSB7XG4gICAgY29uc3QgaGV4ID0gKDAsIGV4cG9ydHMuYnVmZmVyVG9IZXgpKGJ1Zik7XG4gICAgaWYgKGhleCA9PT0gJzB4Jykge1xuICAgICAgICByZXR1cm4gQmlnSW50KDApO1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50KGhleCk7XG59XG5leHBvcnRzLmJ1ZmZlclRvQmlnSW50ID0gYnVmZmVyVG9CaWdJbnQ7XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIGJpZ2ludH0gdG8gYSB7QGxpbmsgQnVmZmVyfVxuICovXG5mdW5jdGlvbiBiaWdJbnRUb0J1ZmZlcihudW0pIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMudG9CdWZmZXIpKCcweCcgKyBudW0udG9TdHJpbmcoMTYpKTtcbn1cbmV4cG9ydHMuYmlnSW50VG9CdWZmZXIgPSBiaWdJbnRUb0J1ZmZlcjtcbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCB0byBhIGBOdW1iZXJgLlxuICogQHBhcmFtIGJ1ZiBgQnVmZmVyYCBvYmplY3QgdG8gY29udmVydFxuICogQHRocm93cyBJZiB0aGUgaW5wdXQgbnVtYmVyIGV4Y2VlZHMgNTMgYml0cy5cbiAqL1xuY29uc3QgYnVmZmVyVG9JbnQgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgY29uc3QgcmVzID0gTnVtYmVyKGJ1ZmZlclRvQmlnSW50KGJ1ZikpO1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIocmVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgZXhjZWVkcyA1MyBiaXRzJyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5leHBvcnRzLmJ1ZmZlclRvSW50ID0gYnVmZmVyVG9JbnQ7XG4vKipcbiAqIEludGVycHJldHMgYSBgQnVmZmVyYCBhcyBhIHNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGEgYEJpZ0ludGAuIEFzc3VtZXMgMjU2LWJpdCBudW1iZXJzLlxuICogQHBhcmFtIG51bSBTaWduZWQgaW50ZWdlciB2YWx1ZVxuICovXG5jb25zdCBmcm9tU2lnbmVkID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHJldHVybiBCaWdJbnQuYXNJbnROKDI1NiwgYnVmZmVyVG9CaWdJbnQobnVtKSk7XG59O1xuZXhwb3J0cy5mcm9tU2lnbmVkID0gZnJvbVNpZ25lZDtcbi8qKlxuICogQ29udmVydHMgYSBgQmlnSW50YCB0byBhbiB1bnNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0IGFzIGEgYEJ1ZmZlcmAuIEFzc3VtZXMgMjU2LWJpdCBudW1iZXJzLlxuICogQHBhcmFtIG51bVxuICovXG5jb25zdCB0b1Vuc2lnbmVkID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHJldHVybiBiaWdJbnRUb0J1ZmZlcihCaWdJbnQuYXNVaW50TigyNTYsIG51bSkpO1xufTtcbmV4cG9ydHMudG9VbnNpZ25lZCA9IHRvVW5zaWduZWQ7XG4vKipcbiAqIEFkZHMgXCIweFwiIHRvIGEgZ2l2ZW4gYFN0cmluZ2AgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBzdGFydCB3aXRoIFwiMHhcIi5cbiAqL1xuY29uc3QgYWRkSGV4UHJlZml4ID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGludGVybmFsXzEuaXNIZXhQcmVmaXhlZCkoc3RyKSA/IHN0ciA6ICcweCcgKyBzdHI7XG59O1xuZXhwb3J0cy5hZGRIZXhQcmVmaXggPSBhZGRIZXhQcmVmaXg7XG4vKipcbiAqIFNob3J0ZW5zIGEgc3RyaW5nICBvciBidWZmZXIncyBoZXggc3RyaW5nIHJlcHJlc2VudGF0aW9uIHRvIG1heExlbmd0aCAoZGVmYXVsdCA1MCkuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogSW5wdXQ6ICAnNjU3NDY4NjU3MjY1NzU2ZDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAqIE91dHB1dDogJzY1NzQ2ODY1NzI2NTc1NmQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw4oCmJ1xuICovXG5mdW5jdGlvbiBzaG9ydChidWZmZXIsIG1heExlbmd0aCA9IDUwKSB7XG4gICAgY29uc3QgYnVmZmVyU3RyID0gQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikgPyBidWZmZXIudG9TdHJpbmcoJ2hleCcpIDogYnVmZmVyO1xuICAgIGlmIChidWZmZXJTdHIubGVuZ3RoIDw9IG1heExlbmd0aCkge1xuICAgICAgICByZXR1cm4gYnVmZmVyU3RyO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyU3RyLnNsaWNlKDAsIG1heExlbmd0aCkgKyAn4oCmJztcbn1cbmV4cG9ydHMuc2hvcnQgPSBzaG9ydDtcbi8qKlxuICogUmV0dXJucyB0aGUgdXRmOCBzdHJpbmcgcmVwcmVzZW50YXRpb24gZnJvbSBhIGhleCBzdHJpbmcuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogSW5wdXQgMTogJzY1NzQ2ODY1NzI2NTc1NmQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gKiBJbnB1dCAyOiAnNjU3NDY4NjU3MjY1NzU2ZCdcbiAqIElucHV0IDM6ICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2NTc0Njg2NTcyNjU3NTZkJ1xuICpcbiAqIE91dHB1dCAoYWxsIDMgaW5wdXQgdmFyaWFudHMpOiAnZXRoZXJldW0nXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGlzIG5vdCBpbnRlbmRlZCB0byBiZSB1c2VkIHdpdGggaGV4IHN0cmluZ3NcbiAqIHJlcHJlc2VudGluZyBxdWFudGl0aWVzIGluIGJvdGggYmlnIGVuZGlhbiBvciBsaXR0bGUgZW5kaWFuIG5vdGF0aW9uLlxuICpcbiAqIEBwYXJhbSBzdHJpbmcgSGV4IHN0cmluZywgc2hvdWxkIGJlIGAweGAgcHJlZml4ZWRcbiAqIEByZXR1cm4gVXRmOCBzdHJpbmdcbiAqL1xuY29uc3QgdG9VdGY4ID0gZnVuY3Rpb24gKGhleCkge1xuICAgIGNvbnN0IHplcm9zUmVnZXhwID0gL14oMDApK3woMDApKyQvZztcbiAgICBoZXggPSAoMCwgaW50ZXJuYWxfMS5zdHJpcEhleFByZWZpeCkoaGV4KTtcbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG5vbi1ldmVuIGhleCBzdHJpbmcgaW5wdXQgZm9yIHRvVXRmOCgpIHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlclZhbCA9IEJ1ZmZlci5mcm9tKGhleC5yZXBsYWNlKHplcm9zUmVnZXhwLCAnJyksICdoZXgnKTtcbiAgICByZXR1cm4gYnVmZmVyVmFsLnRvU3RyaW5nKCd1dGY4Jyk7XG59O1xuZXhwb3J0cy50b1V0ZjggPSB0b1V0Zjg7XG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgb3IgYEFycmF5YCB0byBKU09OLlxuICogQHBhcmFtIGJhIChCdWZmZXJ8QXJyYXkpXG4gKiBAcmV0dXJuIChBcnJheXxTdHJpbmd8bnVsbClcbiAqL1xuY29uc3QgYmFUb0pTT04gPSBmdW5jdGlvbiAoYmEpIHtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJhKSkge1xuICAgICAgICByZXR1cm4gYDB4JHtiYS50b1N0cmluZygnaGV4Jyl9YDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBjb25zdCBhcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheS5wdXNoKCgwLCBleHBvcnRzLmJhVG9KU09OKShiYVtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG59O1xuZXhwb3J0cy5iYVRvSlNPTiA9IGJhVG9KU09OO1xuLyoqXG4gKiBDaGVja3MgcHJvdmlkZWQgQnVmZmVycyBmb3IgbGVhZGluZyB6ZXJvZXMgYW5kIHRocm93cyBpZiBmb3VuZC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiBWYWxpZCB2YWx1ZXM6IDB4MSwgMHgsIDB4MDEsIDB4MTIzNFxuICogSW52YWxpZCB2YWx1ZXM6IDB4MCwgMHgwMCwgMHgwMDEsIDB4MDAwMVxuICpcbiAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBmb3IgdmFsaWRhdGluZyB0aGF0IFJMUCBlbmNvZGVkIGludGVnZXJzIGNvbXBseSB3aXRoIHRoZSBydWxlIHRoYXQgYWxsXG4gKiBpbnRlZ2VyIHZhbHVlcyBlbmNvZGVkIHRvIFJMUCBtdXN0IGJlIGluIHRoZSBtb3N0IGNvbXBhY3QgZm9ybSBhbmQgY29udGFpbiBubyBsZWFkaW5nIHplcm8gYnl0ZXNcbiAqIEBwYXJhbSB2YWx1ZXMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgc3RyaW5nIGtleXMgYW5kIEJ1ZmZlciB2YWx1ZXNcbiAqIEB0aHJvd3MgaWYgYW55IHByb3ZpZGVkIHZhbHVlIGlzIGZvdW5kIHRvIGhhdmUgbGVhZGluZyB6ZXJvIGJ5dGVzXG4gKi9cbmNvbnN0IHZhbGlkYXRlTm9MZWFkaW5nWmVyb2VzID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlcykpIHtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCAmJiB2Lmxlbmd0aCA+IDAgJiYgdlswXSA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2t9IGNhbm5vdCBoYXZlIGxlYWRpbmcgemVyb2VzLCByZWNlaXZlZDogJHt2LnRvU3RyaW5nKCdoZXgnKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnRzLnZhbGlkYXRlTm9MZWFkaW5nWmVyb2VzID0gdmFsaWRhdGVOb0xlYWRpbmdaZXJvZXM7XG5mdW5jdGlvbiBhcnJUb0J1ZkFycihhcnIpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyci5tYXAoKGEpID0+IGFyclRvQnVmQXJyKGEpKTtcbn1cbmV4cG9ydHMuYXJyVG9CdWZBcnIgPSBhcnJUb0J1ZkFycjtcbmZ1bmN0aW9uIGJ1ZkFyclRvQXJyKGFycikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYXJyID8/IFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyci5tYXAoKGEpID0+IGJ1ZkFyclRvQXJyKGEpKTtcbn1cbmV4cG9ydHMuYnVmQXJyVG9BcnIgPSBidWZBcnJUb0Fycjtcbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgYmlnaW50fSB0byBhIGAweGAgcHJlZml4ZWQgaGV4IHN0cmluZ1xuICovXG5jb25zdCBiaWdJbnRUb0hleCA9IChudW0pID0+IHtcbiAgICByZXR1cm4gJzB4JyArIG51bS50b1N0cmluZygxNik7XG59O1xuZXhwb3J0cy5iaWdJbnRUb0hleCA9IGJpZ0ludFRvSGV4O1xuLyoqXG4gKiBDb252ZXJ0IHZhbHVlIGZyb20gYmlnaW50IHRvIGFuIHVucGFkZGVkIEJ1ZmZlclxuICogKHVzZWZ1bCBmb3IgUkxQIHRyYW5zcG9ydClcbiAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSB0byBjb252ZXJ0XG4gKi9cbmZ1bmN0aW9uIGJpZ0ludFRvVW5wYWRkZWRCdWZmZXIodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMudW5wYWRCdWZmZXIpKGJpZ0ludFRvQnVmZmVyKHZhbHVlKSk7XG59XG5leHBvcnRzLmJpZ0ludFRvVW5wYWRkZWRCdWZmZXIgPSBiaWdJbnRUb1VucGFkZGVkQnVmZmVyO1xuZnVuY3Rpb24gaW50VG9VbnBhZGRlZEJ1ZmZlcih2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy51bnBhZEJ1ZmZlcikoKDAsIGV4cG9ydHMuaW50VG9CdWZmZXIpKHZhbHVlKSk7XG59XG5leHBvcnRzLmludFRvVW5wYWRkZWRCdWZmZXIgPSBpbnRUb1VucGFkZGVkQnVmZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaW50VG9VbnBhZGRlZEJ1ZmZlciIsImJpZ0ludFRvVW5wYWRkZWRCdWZmZXIiLCJiaWdJbnRUb0hleCIsImJ1ZkFyclRvQXJyIiwiYXJyVG9CdWZBcnIiLCJ2YWxpZGF0ZU5vTGVhZGluZ1plcm9lcyIsImJhVG9KU09OIiwidG9VdGY4Iiwic2hvcnQiLCJhZGRIZXhQcmVmaXgiLCJ0b1Vuc2lnbmVkIiwiZnJvbVNpZ25lZCIsImJ1ZmZlclRvSW50IiwiYmlnSW50VG9CdWZmZXIiLCJidWZmZXJUb0JpZ0ludCIsImJ1ZmZlclRvSGV4IiwidG9CdWZmZXIiLCJ1bnBhZEhleFN0cmluZyIsInVucGFkQXJyYXkiLCJ1bnBhZEJ1ZmZlciIsInNldExlbmd0aFJpZ2h0Iiwic2V0TGVuZ3RoTGVmdCIsInplcm9zIiwiaW50VG9CdWZmZXIiLCJpbnRUb0hleCIsImhlbHBlcnNfMSIsInJlcXVpcmUiLCJpbnRlcm5hbF8xIiwiaSIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJFcnJvciIsInRvU3RyaW5nIiwiaGV4IiwiQnVmZmVyIiwiZnJvbSIsInBhZFRvRXZlbiIsInNsaWNlIiwiYnl0ZXMiLCJhbGxvY1Vuc2FmZSIsImZpbGwiLCJzZXRMZW5ndGgiLCJtc2ciLCJsZW5ndGgiLCJyaWdodCIsImJ1ZiIsImNvcHkiLCJhc3NlcnRJc0J1ZmZlciIsInN0cmlwWmVyb3MiLCJhIiwiZmlyc3QiLCJhc3NlcnRJc0FycmF5IiwiYXNzZXJ0SXNIZXhTdHJpbmciLCJzdHJpcEhleFByZWZpeCIsInYiLCJ1bmRlZmluZWQiLCJpc0J1ZmZlciIsIkFycmF5IiwiaXNBcnJheSIsIlVpbnQ4QXJyYXkiLCJpc0hleFN0cmluZyIsIkJpZ0ludCIsIm4iLCJ0b0FycmF5IiwibnVtIiwicmVzIiwiYXNJbnROIiwiYXNVaW50TiIsInN0ciIsImlzSGV4UHJlZml4ZWQiLCJidWZmZXIiLCJtYXhMZW5ndGgiLCJidWZmZXJTdHIiLCJ6ZXJvc1JlZ2V4cCIsImJ1ZmZlclZhbCIsInJlcGxhY2UiLCJiYSIsImFycmF5IiwicHVzaCIsInZhbHVlcyIsImsiLCJlbnRyaWVzIiwiYXJyIiwibWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethereumjs/util/dist/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethereumjs/util/dist/constants.js":
/*!*********************************************************!*\
  !*** ./node_modules/@ethereumjs/util/dist/constants.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.MAX_WITHDRAWALS_PER_PAYLOAD = exports.RLP_EMPTY_STRING = exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.SECP256K1_ORDER_DIV_2 = exports.SECP256K1_ORDER = exports.MAX_INTEGER_BIGINT = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nconst secp256k1_1 = __webpack_require__(/*! ethereum-cryptography/secp256k1 */ \"(ssr)/./node_modules/ethereum-cryptography/secp256k1.js\");\n/**\n * 2^64-1\n */ exports.MAX_UINT64 = BigInt(\"0xffffffffffffffff\");\n/**\n * The max integer that the evm can handle (2^256-1)\n */ exports.MAX_INTEGER = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n/**\n * The max integer that the evm can handle (2^256-1) as a bigint\n * 2^256-1 equals to 340282366920938463463374607431768211455\n * We use literal value instead of calculated value for compatibility issue.\n */ exports.MAX_INTEGER_BIGINT = BigInt(\"115792089237316195423570985008687907853269984665640564039457584007913129639935\");\nexports.SECP256K1_ORDER = secp256k1_1.secp256k1.CURVE.n;\nexports.SECP256K1_ORDER_DIV_2 = secp256k1_1.secp256k1.CURVE.n / BigInt(2);\n/**\n * 2^256\n */ exports.TWO_POW256 = BigInt(\"0x10000000000000000000000000000000000000000000000000000000000000000\");\n/**\n * Keccak-256 hash of null\n */ exports.KECCAK256_NULL_S = \"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\";\n/**\n * Keccak-256 hash of null\n */ exports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, \"hex\");\n/**\n * Keccak-256 of an RLP of an empty array\n */ exports.KECCAK256_RLP_ARRAY_S = \"1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\";\n/**\n * Keccak-256 of an RLP of an empty array\n */ exports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, \"hex\");\n/**\n * Keccak-256 hash of the RLP of null\n */ exports.KECCAK256_RLP_S = \"56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\";\n/**\n * Keccak-256 hash of the RLP of null\n */ exports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, \"hex\");\n/**\n *  RLP encoded empty string\n */ exports.RLP_EMPTY_STRING = buffer_1.Buffer.from([\n    0x80\n]);\nexports.MAX_WITHDRAWALS_PER_PAYLOAD = 16; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUNBQW1DLEdBQUdBLHdCQUF3QixHQUFHQSxxQkFBcUIsR0FBR0EsdUJBQXVCLEdBQUdBLDJCQUEyQixHQUFHQSw2QkFBNkIsR0FBR0Esc0JBQXNCLEdBQUdBLHdCQUF3QixHQUFHQSxrQkFBa0IsR0FBR0EsNkJBQTZCLEdBQUdBLHVCQUF1QixHQUFHQSwwQkFBMEIsR0FBR0EsbUJBQW1CLEdBQUdBLGtCQUFrQixHQUFHLEtBQUs7QUFDalksTUFBTWdCLFdBQVdDLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLGdHQUFpQztBQUM3RDs7Q0FFQyxHQUNEakIsa0JBQWtCLEdBQUdtQixPQUFPO0FBQzVCOztDQUVDLEdBQ0RuQixtQkFBbUIsR0FBR21CLE9BQU87QUFDN0I7Ozs7Q0FJQyxHQUNEbkIsMEJBQTBCLEdBQUdtQixPQUFPO0FBQ3BDbkIsdUJBQXVCLEdBQUdrQixZQUFZRSxTQUFTLENBQUNDLEtBQUssQ0FBQ0MsQ0FBQztBQUN2RHRCLDZCQUE2QixHQUFHa0IsWUFBWUUsU0FBUyxDQUFDQyxLQUFLLENBQUNDLENBQUMsR0FBR0gsT0FBTztBQUN2RTs7Q0FFQyxHQUNEbkIsa0JBQWtCLEdBQUdtQixPQUFPO0FBQzVCOztDQUVDLEdBQ0RuQix3QkFBd0IsR0FBRztBQUMzQjs7Q0FFQyxHQUNEQSxzQkFBc0IsR0FBR2dCLFNBQVNPLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDeEIsUUFBUVMsZ0JBQWdCLEVBQUU7QUFDeEU7O0NBRUMsR0FDRFQsNkJBQTZCLEdBQUc7QUFDaEM7O0NBRUMsR0FDREEsMkJBQTJCLEdBQUdnQixTQUFTTyxNQUFNLENBQUNDLElBQUksQ0FBQ3hCLFFBQVFPLHFCQUFxQixFQUFFO0FBQ2xGOztDQUVDLEdBQ0RQLHVCQUF1QixHQUFHO0FBQzFCOztDQUVDLEdBQ0RBLHFCQUFxQixHQUFHZ0IsU0FBU08sTUFBTSxDQUFDQyxJQUFJLENBQUN4QixRQUFRSyxlQUFlLEVBQUU7QUFDdEU7O0NBRUMsR0FDREwsd0JBQXdCLEdBQUdnQixTQUFTTyxNQUFNLENBQUNDLElBQUksQ0FBQztJQUFDO0NBQUs7QUFDdER4QixtQ0FBbUMsR0FBRyxJQUN0QyxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9jb25zdGFudHMuanM/N2JkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTUFYX1dJVEhEUkFXQUxTX1BFUl9QQVlMT0FEID0gZXhwb3J0cy5STFBfRU1QVFlfU1RSSU5HID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVkgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X05VTEwgPSBleHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1MgPSBleHBvcnRzLlRXT19QT1cyNTYgPSBleHBvcnRzLlNFQ1AyNTZLMV9PUkRFUl9ESVZfMiA9IGV4cG9ydHMuU0VDUDI1NksxX09SREVSID0gZXhwb3J0cy5NQVhfSU5URUdFUl9CSUdJTlQgPSBleHBvcnRzLk1BWF9JTlRFR0VSID0gZXhwb3J0cy5NQVhfVUlOVDY0ID0gdm9pZCAwO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuY29uc3Qgc2VjcDI1NmsxXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3NlY3AyNTZrMVwiKTtcbi8qKlxuICogMl42NC0xXG4gKi9cbmV4cG9ydHMuTUFYX1VJTlQ2NCA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJyk7XG4vKipcbiAqIFRoZSBtYXggaW50ZWdlciB0aGF0IHRoZSBldm0gY2FuIGhhbmRsZSAoMl4yNTYtMSlcbiAqL1xuZXhwb3J0cy5NQVhfSU5URUdFUiA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJyk7XG4vKipcbiAqIFRoZSBtYXggaW50ZWdlciB0aGF0IHRoZSBldm0gY2FuIGhhbmRsZSAoMl4yNTYtMSkgYXMgYSBiaWdpbnRcbiAqIDJeMjU2LTEgZXF1YWxzIHRvIDM0MDI4MjM2NjkyMDkzODQ2MzQ2MzM3NDYwNzQzMTc2ODIxMTQ1NVxuICogV2UgdXNlIGxpdGVyYWwgdmFsdWUgaW5zdGVhZCBvZiBjYWxjdWxhdGVkIHZhbHVlIGZvciBjb21wYXRpYmlsaXR5IGlzc3VlLlxuICovXG5leHBvcnRzLk1BWF9JTlRFR0VSX0JJR0lOVCA9IEJpZ0ludCgnMTE1NzkyMDg5MjM3MzE2MTk1NDIzNTcwOTg1MDA4Njg3OTA3ODUzMjY5OTg0NjY1NjQwNTY0MDM5NDU3NTg0MDA3OTEzMTI5NjM5OTM1Jyk7XG5leHBvcnRzLlNFQ1AyNTZLMV9PUkRFUiA9IHNlY3AyNTZrMV8xLnNlY3AyNTZrMS5DVVJWRS5uO1xuZXhwb3J0cy5TRUNQMjU2SzFfT1JERVJfRElWXzIgPSBzZWNwMjU2azFfMS5zZWNwMjU2azEuQ1VSVkUubiAvIEJpZ0ludCgyKTtcbi8qKlxuICogMl4yNTZcbiAqL1xuZXhwb3J0cy5UV09fUE9XMjU2ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyk7XG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiBudWxsXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUyA9ICdjNWQyNDYwMTg2ZjcyMzNjOTI3ZTdkYjJkY2M3MDNjMGU1MDBiNjUzY2E4MjI3M2I3YmZhZDgwNDVkODVhNDcwJztcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGxcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfTlVMTCA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUywgJ2hleCcpO1xuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheVxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUyA9ICcxZGNjNGRlOGRlYzc1ZDdhYWI4NWI1NjdiNmNjZDQxYWQzMTI0NTFiOTQ4YTc0MTNmMGExNDJmZDQwZDQ5MzQ3Jztcbi8qKlxuICogS2VjY2FrLTI1NiBvZiBhbiBSTFAgb2YgYW4gZW1wdHkgYXJyYXlcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MsICdoZXgnKTtcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfUyA9ICc1NmU4MWYxNzFiY2M1NWE2ZmY4MzQ1ZTY5MmMwZjg2ZTViNDhlMDFiOTk2Y2FkYzAwMTYyMmZiNWUzNjNiNDIxJztcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFAgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfUywgJ2hleCcpO1xuLyoqXG4gKiAgUkxQIGVuY29kZWQgZW1wdHkgc3RyaW5nXG4gKi9cbmV4cG9ydHMuUkxQX0VNUFRZX1NUUklORyA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKFsweDgwXSk7XG5leHBvcnRzLk1BWF9XSVRIRFJBV0FMU19QRVJfUEFZTE9BRCA9IDE2O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIk1BWF9XSVRIRFJBV0FMU19QRVJfUEFZTE9BRCIsIlJMUF9FTVBUWV9TVFJJTkciLCJLRUNDQUsyNTZfUkxQIiwiS0VDQ0FLMjU2X1JMUF9TIiwiS0VDQ0FLMjU2X1JMUF9BUlJBWSIsIktFQ0NBSzI1Nl9STFBfQVJSQVlfUyIsIktFQ0NBSzI1Nl9OVUxMIiwiS0VDQ0FLMjU2X05VTExfUyIsIlRXT19QT1cyNTYiLCJTRUNQMjU2SzFfT1JERVJfRElWXzIiLCJTRUNQMjU2SzFfT1JERVIiLCJNQVhfSU5URUdFUl9CSUdJTlQiLCJNQVhfSU5URUdFUiIsIk1BWF9VSU5UNjQiLCJidWZmZXJfMSIsInJlcXVpcmUiLCJzZWNwMjU2azFfMSIsIkJpZ0ludCIsInNlY3AyNTZrMSIsIkNVUlZFIiwibiIsIkJ1ZmZlciIsImZyb20iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethereumjs/util/dist/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethereumjs/util/dist/encoding.js":
/*!********************************************************!*\
  !*** ./node_modules/@ethereumjs/util/dist/encoding.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.compactBytesToNibbles = exports.bytesToNibbles = exports.nibblesToCompactBytes = exports.nibblesToBytes = exports.hasTerminator = void 0;\n// Reference: https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/\n/**\n *\n * @param s byte sequence\n * @returns boolean indicating if input hex nibble sequence has terminator indicating leaf-node\n *          terminator is represented with 16 because a nibble ranges from 0 - 15(f)\n */ const hasTerminator = (nibbles)=>{\n    return nibbles.length > 0 && nibbles[nibbles.length - 1] === 16;\n};\nexports.hasTerminator = hasTerminator;\nconst nibblesToBytes = (nibbles, bytes)=>{\n    for(let bi = 0, ni = 0; ni < nibbles.length; bi += 1, ni += 2){\n        bytes[bi] = nibbles[ni] << 4 | nibbles[ni + 1];\n    }\n};\nexports.nibblesToBytes = nibblesToBytes;\nconst nibblesToCompactBytes = (nibbles)=>{\n    let terminator = 0;\n    if ((0, exports.hasTerminator)(nibbles)) {\n        terminator = 1;\n        // Remove the terminator from the sequence\n        nibbles = nibbles.subarray(0, nibbles.length - 1);\n    }\n    const buf = new Uint8Array(nibbles.length / 2 + 1);\n    // Shift the terminator info into the first nibble of buf[0]\n    buf[0] = terminator << 5;\n    // If odd length, then add that flag into the first nibble and put the odd nibble to\n    // second part of buf[0] which otherwise will be left padded with a 0\n    if ((nibbles.length & 1) === 1) {\n        buf[0] |= 1 << 4;\n        buf[0] |= nibbles[0];\n        nibbles = nibbles.subarray(1);\n    }\n    // create bytes out of the rest even nibbles\n    (0, exports.nibblesToBytes)(nibbles, buf.subarray(1));\n    return buf;\n};\nexports.nibblesToCompactBytes = nibblesToCompactBytes;\nconst bytesToNibbles = (str)=>{\n    const l = str.length * 2 + 1;\n    const nibbles = new Uint8Array(l);\n    for(let i = 0; i < str.length; i++){\n        const b = str[i];\n        nibbles[i * 2] = b / 16;\n        nibbles[i * 2 + 1] = b % 16;\n    }\n    // This will get removed from calling function if the first nibble\n    // indicates that terminator is not present\n    nibbles[l - 1] = 16;\n    return nibbles;\n};\nexports.bytesToNibbles = bytesToNibbles;\nconst compactBytesToNibbles = (compact)=>{\n    if (compact.length === 0) {\n        return compact;\n    }\n    let base = (0, exports.bytesToNibbles)(compact);\n    // delete terminator flag if terminator flag was not in first nibble\n    if (base[0] < 2) {\n        base = base.subarray(0, base.length - 1);\n    }\n    // chop the terminator nibble and the even padding (if there is one)\n    // i.e.  chop 2 left nibbles when even else 1 when odd\n    const chop = 2 - (base[0] & 1);\n    return base.subarray(chop);\n};\nexports.compactBytesToNibbles = compactBytesToNibbles; /**\n * A test helper to generates compact path for a subset of key bytes\n *\n * TODO: Commenting the code for now as this seems to be helper function\n * (from geth codebase )\n *\n */  //\n //\n // export const getPathTo = (tillBytes: number, key: Buffer) => {\n //   const hexNibbles = bytesToNibbles(key).subarray(0, tillBytes)\n //   // Remove the terminator if its there, although it would be there only if tillBytes >= key.length\n //   // This seems to be a test helper to generate paths so correctness of this isn't necessary\n //   hexNibbles[hexNibbles.length - 1] = 0\n //   const compactBytes = nibblesToCompactBytes(hexNibbles)\n //   return [Buffer.from(compactBytes)]\n // }\n //# sourceMappingURL=encoding.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2VuY29kaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw2QkFBNkIsR0FBR0Esc0JBQXNCLEdBQUdBLDZCQUE2QixHQUFHQSxzQkFBc0IsR0FBR0EscUJBQXFCLEdBQUcsS0FBSztBQUMvSSx3R0FBd0c7QUFDeEc7Ozs7O0NBS0MsR0FDRCxNQUFNTSxnQkFBZ0IsQ0FBQ0M7SUFDbkIsT0FBT0EsUUFBUUMsTUFBTSxHQUFHLEtBQUtELE9BQU8sQ0FBQ0EsUUFBUUMsTUFBTSxHQUFHLEVBQUUsS0FBSztBQUNqRTtBQUNBUixxQkFBcUIsR0FBR007QUFDeEIsTUFBTUQsaUJBQWlCLENBQUNFLFNBQVNFO0lBQzdCLElBQUssSUFBSUMsS0FBSyxHQUFHQyxLQUFLLEdBQUdBLEtBQUtKLFFBQVFDLE1BQU0sRUFBRUUsTUFBTSxHQUFHQyxNQUFNLEVBQUc7UUFDNURGLEtBQUssQ0FBQ0MsR0FBRyxHQUFHLE9BQVEsQ0FBQ0MsR0FBRyxJQUFJLElBQUtKLE9BQU8sQ0FBQ0ksS0FBSyxFQUFFO0lBQ3BEO0FBQ0o7QUFDQVgsc0JBQXNCLEdBQUdLO0FBQ3pCLE1BQU1ELHdCQUF3QixDQUFDRztJQUMzQixJQUFJSyxhQUFhO0lBQ2pCLElBQUksQ0FBQyxHQUFHWixRQUFRTSxhQUFhLEVBQUVDLFVBQVU7UUFDckNLLGFBQWE7UUFDYiwwQ0FBMEM7UUFDMUNMLFVBQVVBLFFBQVFNLFFBQVEsQ0FBQyxHQUFHTixRQUFRQyxNQUFNLEdBQUc7SUFDbkQ7SUFDQSxNQUFNTSxNQUFNLElBQUlDLFdBQVdSLFFBQVFDLE1BQU0sR0FBRyxJQUFJO0lBQ2hELDREQUE0RDtJQUM1RE0sR0FBRyxDQUFDLEVBQUUsR0FBR0YsY0FBYztJQUN2QixvRkFBb0Y7SUFDcEYscUVBQXFFO0lBQ3JFLElBQUksQ0FBQ0wsUUFBUUMsTUFBTSxHQUFHLE9BQU8sR0FBRztRQUM1Qk0sR0FBRyxDQUFDLEVBQUUsSUFBSSxLQUFLO1FBQ2ZBLEdBQUcsQ0FBQyxFQUFFLElBQUlQLE9BQU8sQ0FBQyxFQUFFO1FBQ3BCQSxVQUFVQSxRQUFRTSxRQUFRLENBQUM7SUFDL0I7SUFDQSw0Q0FBNEM7SUFDM0MsSUFBR2IsUUFBUUssY0FBYyxFQUFFRSxTQUFTTyxJQUFJRCxRQUFRLENBQUM7SUFDbEQsT0FBT0M7QUFDWDtBQUNBZCw2QkFBNkIsR0FBR0k7QUFDaEMsTUFBTUQsaUJBQWlCLENBQUNhO0lBQ3BCLE1BQU1DLElBQUlELElBQUlSLE1BQU0sR0FBRyxJQUFJO0lBQzNCLE1BQU1ELFVBQVUsSUFBSVEsV0FBV0U7SUFDL0IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLElBQUlSLE1BQU0sRUFBRVUsSUFBSztRQUNqQyxNQUFNQyxJQUFJSCxHQUFHLENBQUNFLEVBQUU7UUFDaEJYLE9BQU8sQ0FBQ1csSUFBSSxFQUFFLEdBQUdDLElBQUk7UUFDckJaLE9BQU8sQ0FBQ1csSUFBSSxJQUFJLEVBQUUsR0FBR0MsSUFBSTtJQUM3QjtJQUNBLGtFQUFrRTtJQUNsRSwyQ0FBMkM7SUFDM0NaLE9BQU8sQ0FBQ1UsSUFBSSxFQUFFLEdBQUc7SUFDakIsT0FBT1Y7QUFDWDtBQUNBUCxzQkFBc0IsR0FBR0c7QUFDekIsTUFBTUQsd0JBQXdCLENBQUNrQjtJQUMzQixJQUFJQSxRQUFRWixNQUFNLEtBQUssR0FBRztRQUN0QixPQUFPWTtJQUNYO0lBQ0EsSUFBSUMsT0FBTyxDQUFDLEdBQUdyQixRQUFRRyxjQUFjLEVBQUVpQjtJQUN2QyxvRUFBb0U7SUFDcEUsSUFBSUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxHQUFHO1FBQ2JBLE9BQU9BLEtBQUtSLFFBQVEsQ0FBQyxHQUFHUSxLQUFLYixNQUFNLEdBQUc7SUFDMUM7SUFDQSxvRUFBb0U7SUFDcEUsc0RBQXNEO0lBQ3RELE1BQU1jLE9BQU8sSUFBS0QsQ0FBQUEsSUFBSSxDQUFDLEVBQUUsR0FBRztJQUM1QixPQUFPQSxLQUFLUixRQUFRLENBQUNTO0FBQ3pCO0FBQ0F0Qiw2QkFBNkIsR0FBR0UsdUJBQ2hDOzs7Ozs7Q0FNQyxJQUNELEVBQUU7Q0FDRixFQUFFO0NBQ0YsaUVBQWlFO0NBQ2pFLGtFQUFrRTtDQUNsRSxzR0FBc0c7Q0FDdEcsK0ZBQStGO0NBQy9GLDBDQUEwQztDQUMxQywyREFBMkQ7Q0FDM0QsdUNBQXVDO0NBQ3ZDLElBQUk7Q0FDSixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BldGhlcmV1bWpzL3V0aWwvZGlzdC9lbmNvZGluZy5qcz83YWU4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb21wYWN0Qnl0ZXNUb05pYmJsZXMgPSBleHBvcnRzLmJ5dGVzVG9OaWJibGVzID0gZXhwb3J0cy5uaWJibGVzVG9Db21wYWN0Qnl0ZXMgPSBleHBvcnRzLm5pYmJsZXNUb0J5dGVzID0gZXhwb3J0cy5oYXNUZXJtaW5hdG9yID0gdm9pZCAwO1xuLy8gUmVmZXJlbmNlOiBodHRwczovL2V0aGVyZXVtLm9yZy9lbi9kZXZlbG9wZXJzL2RvY3MvZGF0YS1zdHJ1Y3R1cmVzLWFuZC1lbmNvZGluZy9wYXRyaWNpYS1tZXJrbGUtdHJpZS9cbi8qKlxuICpcbiAqIEBwYXJhbSBzIGJ5dGUgc2VxdWVuY2VcbiAqIEByZXR1cm5zIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBpbnB1dCBoZXggbmliYmxlIHNlcXVlbmNlIGhhcyB0ZXJtaW5hdG9yIGluZGljYXRpbmcgbGVhZi1ub2RlXG4gKiAgICAgICAgICB0ZXJtaW5hdG9yIGlzIHJlcHJlc2VudGVkIHdpdGggMTYgYmVjYXVzZSBhIG5pYmJsZSByYW5nZXMgZnJvbSAwIC0gMTUoZilcbiAqL1xuY29uc3QgaGFzVGVybWluYXRvciA9IChuaWJibGVzKSA9PiB7XG4gICAgcmV0dXJuIG5pYmJsZXMubGVuZ3RoID4gMCAmJiBuaWJibGVzW25pYmJsZXMubGVuZ3RoIC0gMV0gPT09IDE2O1xufTtcbmV4cG9ydHMuaGFzVGVybWluYXRvciA9IGhhc1Rlcm1pbmF0b3I7XG5jb25zdCBuaWJibGVzVG9CeXRlcyA9IChuaWJibGVzLCBieXRlcykgPT4ge1xuICAgIGZvciAobGV0IGJpID0gMCwgbmkgPSAwOyBuaSA8IG5pYmJsZXMubGVuZ3RoOyBiaSArPSAxLCBuaSArPSAyKSB7XG4gICAgICAgIGJ5dGVzW2JpXSA9IChuaWJibGVzW25pXSA8PCA0KSB8IG5pYmJsZXNbbmkgKyAxXTtcbiAgICB9XG59O1xuZXhwb3J0cy5uaWJibGVzVG9CeXRlcyA9IG5pYmJsZXNUb0J5dGVzO1xuY29uc3QgbmliYmxlc1RvQ29tcGFjdEJ5dGVzID0gKG5pYmJsZXMpID0+IHtcbiAgICBsZXQgdGVybWluYXRvciA9IDA7XG4gICAgaWYgKCgwLCBleHBvcnRzLmhhc1Rlcm1pbmF0b3IpKG5pYmJsZXMpKSB7XG4gICAgICAgIHRlcm1pbmF0b3IgPSAxO1xuICAgICAgICAvLyBSZW1vdmUgdGhlIHRlcm1pbmF0b3IgZnJvbSB0aGUgc2VxdWVuY2VcbiAgICAgICAgbmliYmxlcyA9IG5pYmJsZXMuc3ViYXJyYXkoMCwgbmliYmxlcy5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobmliYmxlcy5sZW5ndGggLyAyICsgMSk7XG4gICAgLy8gU2hpZnQgdGhlIHRlcm1pbmF0b3IgaW5mbyBpbnRvIHRoZSBmaXJzdCBuaWJibGUgb2YgYnVmWzBdXG4gICAgYnVmWzBdID0gdGVybWluYXRvciA8PCA1O1xuICAgIC8vIElmIG9kZCBsZW5ndGgsIHRoZW4gYWRkIHRoYXQgZmxhZyBpbnRvIHRoZSBmaXJzdCBuaWJibGUgYW5kIHB1dCB0aGUgb2RkIG5pYmJsZSB0b1xuICAgIC8vIHNlY29uZCBwYXJ0IG9mIGJ1ZlswXSB3aGljaCBvdGhlcndpc2Ugd2lsbCBiZSBsZWZ0IHBhZGRlZCB3aXRoIGEgMFxuICAgIGlmICgobmliYmxlcy5sZW5ndGggJiAxKSA9PT0gMSkge1xuICAgICAgICBidWZbMF0gfD0gMSA8PCA0O1xuICAgICAgICBidWZbMF0gfD0gbmliYmxlc1swXTtcbiAgICAgICAgbmliYmxlcyA9IG5pYmJsZXMuc3ViYXJyYXkoMSk7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBieXRlcyBvdXQgb2YgdGhlIHJlc3QgZXZlbiBuaWJibGVzXG4gICAgKDAsIGV4cG9ydHMubmliYmxlc1RvQnl0ZXMpKG5pYmJsZXMsIGJ1Zi5zdWJhcnJheSgxKSk7XG4gICAgcmV0dXJuIGJ1Zjtcbn07XG5leHBvcnRzLm5pYmJsZXNUb0NvbXBhY3RCeXRlcyA9IG5pYmJsZXNUb0NvbXBhY3RCeXRlcztcbmNvbnN0IGJ5dGVzVG9OaWJibGVzID0gKHN0cikgPT4ge1xuICAgIGNvbnN0IGwgPSBzdHIubGVuZ3RoICogMiArIDE7XG4gICAgY29uc3QgbmliYmxlcyA9IG5ldyBVaW50OEFycmF5KGwpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGIgPSBzdHJbaV07XG4gICAgICAgIG5pYmJsZXNbaSAqIDJdID0gYiAvIDE2O1xuICAgICAgICBuaWJibGVzW2kgKiAyICsgMV0gPSBiICUgMTY7XG4gICAgfVxuICAgIC8vIFRoaXMgd2lsbCBnZXQgcmVtb3ZlZCBmcm9tIGNhbGxpbmcgZnVuY3Rpb24gaWYgdGhlIGZpcnN0IG5pYmJsZVxuICAgIC8vIGluZGljYXRlcyB0aGF0IHRlcm1pbmF0b3IgaXMgbm90IHByZXNlbnRcbiAgICBuaWJibGVzW2wgLSAxXSA9IDE2O1xuICAgIHJldHVybiBuaWJibGVzO1xufTtcbmV4cG9ydHMuYnl0ZXNUb05pYmJsZXMgPSBieXRlc1RvTmliYmxlcztcbmNvbnN0IGNvbXBhY3RCeXRlc1RvTmliYmxlcyA9IChjb21wYWN0KSA9PiB7XG4gICAgaWYgKGNvbXBhY3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjb21wYWN0O1xuICAgIH1cbiAgICBsZXQgYmFzZSA9ICgwLCBleHBvcnRzLmJ5dGVzVG9OaWJibGVzKShjb21wYWN0KTtcbiAgICAvLyBkZWxldGUgdGVybWluYXRvciBmbGFnIGlmIHRlcm1pbmF0b3IgZmxhZyB3YXMgbm90IGluIGZpcnN0IG5pYmJsZVxuICAgIGlmIChiYXNlWzBdIDwgMikge1xuICAgICAgICBiYXNlID0gYmFzZS5zdWJhcnJheSgwLCBiYXNlLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICAvLyBjaG9wIHRoZSB0ZXJtaW5hdG9yIG5pYmJsZSBhbmQgdGhlIGV2ZW4gcGFkZGluZyAoaWYgdGhlcmUgaXMgb25lKVxuICAgIC8vIGkuZS4gIGNob3AgMiBsZWZ0IG5pYmJsZXMgd2hlbiBldmVuIGVsc2UgMSB3aGVuIG9kZFxuICAgIGNvbnN0IGNob3AgPSAyIC0gKGJhc2VbMF0gJiAxKTtcbiAgICByZXR1cm4gYmFzZS5zdWJhcnJheShjaG9wKTtcbn07XG5leHBvcnRzLmNvbXBhY3RCeXRlc1RvTmliYmxlcyA9IGNvbXBhY3RCeXRlc1RvTmliYmxlcztcbi8qKlxuICogQSB0ZXN0IGhlbHBlciB0byBnZW5lcmF0ZXMgY29tcGFjdCBwYXRoIGZvciBhIHN1YnNldCBvZiBrZXkgYnl0ZXNcbiAqXG4gKiBUT0RPOiBDb21tZW50aW5nIHRoZSBjb2RlIGZvciBub3cgYXMgdGhpcyBzZWVtcyB0byBiZSBoZWxwZXIgZnVuY3Rpb25cbiAqIChmcm9tIGdldGggY29kZWJhc2UgKVxuICpcbiAqL1xuLy9cbi8vXG4vLyBleHBvcnQgY29uc3QgZ2V0UGF0aFRvID0gKHRpbGxCeXRlczogbnVtYmVyLCBrZXk6IEJ1ZmZlcikgPT4ge1xuLy8gICBjb25zdCBoZXhOaWJibGVzID0gYnl0ZXNUb05pYmJsZXMoa2V5KS5zdWJhcnJheSgwLCB0aWxsQnl0ZXMpXG4vLyAgIC8vIFJlbW92ZSB0aGUgdGVybWluYXRvciBpZiBpdHMgdGhlcmUsIGFsdGhvdWdoIGl0IHdvdWxkIGJlIHRoZXJlIG9ubHkgaWYgdGlsbEJ5dGVzID49IGtleS5sZW5ndGhcbi8vICAgLy8gVGhpcyBzZWVtcyB0byBiZSBhIHRlc3QgaGVscGVyIHRvIGdlbmVyYXRlIHBhdGhzIHNvIGNvcnJlY3RuZXNzIG9mIHRoaXMgaXNuJ3QgbmVjZXNzYXJ5XG4vLyAgIGhleE5pYmJsZXNbaGV4TmliYmxlcy5sZW5ndGggLSAxXSA9IDBcbi8vICAgY29uc3QgY29tcGFjdEJ5dGVzID0gbmliYmxlc1RvQ29tcGFjdEJ5dGVzKGhleE5pYmJsZXMpXG4vLyAgIHJldHVybiBbQnVmZmVyLmZyb20oY29tcGFjdEJ5dGVzKV1cbi8vIH1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuY29kaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNvbXBhY3RCeXRlc1RvTmliYmxlcyIsImJ5dGVzVG9OaWJibGVzIiwibmliYmxlc1RvQ29tcGFjdEJ5dGVzIiwibmliYmxlc1RvQnl0ZXMiLCJoYXNUZXJtaW5hdG9yIiwibmliYmxlcyIsImxlbmd0aCIsImJ5dGVzIiwiYmkiLCJuaSIsInRlcm1pbmF0b3IiLCJzdWJhcnJheSIsImJ1ZiIsIlVpbnQ4QXJyYXkiLCJzdHIiLCJsIiwiaSIsImIiLCJjb21wYWN0IiwiYmFzZSIsImNob3AiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethereumjs/util/dist/encoding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethereumjs/util/dist/helpers.js":
/*!*******************************************************!*\
  !*** ./node_modules/@ethereumjs/util/dist/helpers.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.assertIsString = exports.assertIsArray = exports.assertIsBuffer = exports.assertIsHexString = void 0;\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/@ethereumjs/util/dist/internal.js\");\n/**\n * Throws if a string is not hex prefixed\n * @param {string} input string to check hex prefix of\n */ const assertIsHexString = function(input) {\n    if (!(0, internal_1.isHexString)(input)) {\n        const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsHexString = assertIsHexString;\n/**\n * Throws if input is not a buffer\n * @param {Buffer} input value to check\n */ const assertIsBuffer = function(input) {\n    if (!Buffer.isBuffer(input)) {\n        const msg = `This method only supports Buffer but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsBuffer = assertIsBuffer;\n/**\n * Throws if input is not an array\n * @param {number[]} input value to check\n */ const assertIsArray = function(input) {\n    if (!Array.isArray(input)) {\n        const msg = `This method only supports number arrays but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsArray = assertIsArray;\n/**\n * Throws if input is not a string\n * @param {string} input value to check\n */ const assertIsString = function(input) {\n    if (typeof input !== \"string\") {\n        const msg = `This method only supports strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsString = assertIsString; //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHNCQUFzQixHQUFHQSxxQkFBcUIsR0FBR0Esc0JBQXNCLEdBQUdBLHlCQUF5QixHQUFHLEtBQUs7QUFDM0csTUFBTU0sYUFBYUMsbUJBQU9BLENBQUMsMEVBQVk7QUFDdkM7OztDQUdDLEdBQ0QsTUFBTUYsb0JBQW9CLFNBQVVHLEtBQUs7SUFDckMsSUFBSSxDQUFDLENBQUMsR0FBR0YsV0FBV0csV0FBVyxFQUFFRCxRQUFRO1FBQ3JDLE1BQU1FLE1BQU0sQ0FBQyxpRUFBaUUsRUFBRUYsTUFBTSxDQUFDO1FBQ3ZGLE1BQU0sSUFBSUcsTUFBTUQ7SUFDcEI7QUFDSjtBQUNBVix5QkFBeUIsR0FBR0s7QUFDNUI7OztDQUdDLEdBQ0QsTUFBTUQsaUJBQWlCLFNBQVVJLEtBQUs7SUFDbEMsSUFBSSxDQUFDSSxPQUFPQyxRQUFRLENBQUNMLFFBQVE7UUFDekIsTUFBTUUsTUFBTSxDQUFDLGdEQUFnRCxFQUFFRixNQUFNLENBQUM7UUFDdEUsTUFBTSxJQUFJRyxNQUFNRDtJQUNwQjtBQUNKO0FBQ0FWLHNCQUFzQixHQUFHSTtBQUN6Qjs7O0NBR0MsR0FDRCxNQUFNRCxnQkFBZ0IsU0FBVUssS0FBSztJQUNqQyxJQUFJLENBQUNNLE1BQU1DLE9BQU8sQ0FBQ1AsUUFBUTtRQUN2QixNQUFNRSxNQUFNLENBQUMsdURBQXVELEVBQUVGLE1BQU0sQ0FBQztRQUM3RSxNQUFNLElBQUlHLE1BQU1EO0lBQ3BCO0FBQ0o7QUFDQVYscUJBQXFCLEdBQUdHO0FBQ3hCOzs7Q0FHQyxHQUNELE1BQU1ELGlCQUFpQixTQUFVTSxLQUFLO0lBQ2xDLElBQUksT0FBT0EsVUFBVSxVQUFVO1FBQzNCLE1BQU1FLE1BQU0sQ0FBQyxpREFBaUQsRUFBRUYsTUFBTSxDQUFDO1FBQ3ZFLE1BQU0sSUFBSUcsTUFBTUQ7SUFDcEI7QUFDSjtBQUNBVixzQkFBc0IsR0FBR0UsZ0JBQ3pCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2hlbHBlcnMuanM/OTFkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzZXJ0SXNTdHJpbmcgPSBleHBvcnRzLmFzc2VydElzQXJyYXkgPSBleHBvcnRzLmFzc2VydElzQnVmZmVyID0gZXhwb3J0cy5hc3NlcnRJc0hleFN0cmluZyA9IHZvaWQgMDtcbmNvbnN0IGludGVybmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbFwiKTtcbi8qKlxuICogVGhyb3dzIGlmIGEgc3RyaW5nIGlzIG5vdCBoZXggcHJlZml4ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBzdHJpbmcgdG8gY2hlY2sgaGV4IHByZWZpeCBvZlxuICovXG5jb25zdCBhc3NlcnRJc0hleFN0cmluZyA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmICghKDAsIGludGVybmFsXzEuaXNIZXhTdHJpbmcpKGlucHV0KSkge1xuICAgICAgICBjb25zdCBtc2cgPSBgVGhpcyBtZXRob2Qgb25seSBzdXBwb3J0cyAweC1wcmVmaXhlZCBoZXggc3RyaW5ncyBidXQgaW5wdXQgd2FzOiAke2lucHV0fWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn07XG5leHBvcnRzLmFzc2VydElzSGV4U3RyaW5nID0gYXNzZXJ0SXNIZXhTdHJpbmc7XG4vKipcbiAqIFRocm93cyBpZiBpbnB1dCBpcyBub3QgYSBidWZmZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBpbnB1dCB2YWx1ZSB0byBjaGVja1xuICovXG5jb25zdCBhc3NlcnRJc0J1ZmZlciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGlucHV0KSkge1xuICAgICAgICBjb25zdCBtc2cgPSBgVGhpcyBtZXRob2Qgb25seSBzdXBwb3J0cyBCdWZmZXIgYnV0IGlucHV0IHdhczogJHtpbnB1dH1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59O1xuZXhwb3J0cy5hc3NlcnRJc0J1ZmZlciA9IGFzc2VydElzQnVmZmVyO1xuLyoqXG4gKiBUaHJvd3MgaWYgaW5wdXQgaXMgbm90IGFuIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcltdfSBpbnB1dCB2YWx1ZSB0byBjaGVja1xuICovXG5jb25zdCBhc3NlcnRJc0FycmF5ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBjb25zdCBtc2cgPSBgVGhpcyBtZXRob2Qgb25seSBzdXBwb3J0cyBudW1iZXIgYXJyYXlzIGJ1dCBpbnB1dCB3YXM6ICR7aW5wdXR9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufTtcbmV4cG9ydHMuYXNzZXJ0SXNBcnJheSA9IGFzc2VydElzQXJyYXk7XG4vKipcbiAqIFRocm93cyBpZiBpbnB1dCBpcyBub3QgYSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCB2YWx1ZSB0byBjaGVja1xuICovXG5jb25zdCBhc3NlcnRJc1N0cmluZyA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGBUaGlzIG1ldGhvZCBvbmx5IHN1cHBvcnRzIHN0cmluZ3MgYnV0IGlucHV0IHdhczogJHtpbnB1dH1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59O1xuZXhwb3J0cy5hc3NlcnRJc1N0cmluZyA9IGFzc2VydElzU3RyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhc3NlcnRJc1N0cmluZyIsImFzc2VydElzQXJyYXkiLCJhc3NlcnRJc0J1ZmZlciIsImFzc2VydElzSGV4U3RyaW5nIiwiaW50ZXJuYWxfMSIsInJlcXVpcmUiLCJpbnB1dCIsImlzSGV4U3RyaW5nIiwibXNnIiwiRXJyb3IiLCJCdWZmZXIiLCJpc0J1ZmZlciIsIkFycmF5IiwiaXNBcnJheSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethereumjs/util/dist/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethereumjs/util/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@ethereumjs/util/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.toAscii = exports.stripHexPrefix = exports.padToEven = exports.isHexString = exports.isHexPrefixed = exports.getKeys = exports.getBinarySize = exports.fromUtf8 = exports.fromAscii = exports.arrayContainsArray = void 0;\n/**\n * Constants\n */ __exportStar(__webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@ethereumjs/util/dist/constants.js\"), exports);\n/**\n * Units helpers\n */ __exportStar(__webpack_require__(/*! ./units */ \"(ssr)/./node_modules/@ethereumjs/util/dist/units.js\"), exports);\n/**\n * Account class and helper functions\n */ __exportStar(__webpack_require__(/*! ./account */ \"(ssr)/./node_modules/@ethereumjs/util/dist/account.js\"), exports);\n/**\n * Address type\n */ __exportStar(__webpack_require__(/*! ./address */ \"(ssr)/./node_modules/@ethereumjs/util/dist/address.js\"), exports);\n/**\n * Withdrawal type\n */ __exportStar(__webpack_require__(/*! ./withdrawal */ \"(ssr)/./node_modules/@ethereumjs/util/dist/withdrawal.js\"), exports);\n/**\n * ECDSA signature\n */ __exportStar(__webpack_require__(/*! ./signature */ \"(ssr)/./node_modules/@ethereumjs/util/dist/signature.js\"), exports);\n/**\n * Utilities for manipulating Buffers, byte arrays, etc.\n */ __exportStar(__webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/@ethereumjs/util/dist/bytes.js\"), exports);\n/**\n * Helpful TypeScript types\n */ __exportStar(__webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@ethereumjs/util/dist/types.js\"), exports);\n/**\n * Helper function for working with compact encoding\n */ __exportStar(__webpack_require__(/*! ./encoding */ \"(ssr)/./node_modules/@ethereumjs/util/dist/encoding.js\"), exports);\n/**\n * Export ethjs-util methods\n */ __exportStar(__webpack_require__(/*! ./asyncEventEmitter */ \"(ssr)/./node_modules/@ethereumjs/util/dist/asyncEventEmitter.js\"), exports);\nvar internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/@ethereumjs/util/dist/internal.js\");\nObject.defineProperty(exports, \"arrayContainsArray\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.arrayContainsArray;\n    }\n}));\nObject.defineProperty(exports, \"fromAscii\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.fromAscii;\n    }\n}));\nObject.defineProperty(exports, \"fromUtf8\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.fromUtf8;\n    }\n}));\nObject.defineProperty(exports, \"getBinarySize\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.getBinarySize;\n    }\n}));\nObject.defineProperty(exports, \"getKeys\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.getKeys;\n    }\n}));\nObject.defineProperty(exports, \"isHexPrefixed\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.isHexPrefixed;\n    }\n}));\nObject.defineProperty(exports, \"isHexString\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.isHexString;\n    }\n}));\nObject.defineProperty(exports, \"padToEven\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.padToEven;\n    }\n}));\nObject.defineProperty(exports, \"stripHexPrefix\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.stripHexPrefix;\n    }\n}));\nObject.defineProperty(exports, \"toAscii\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.toAscii;\n    }\n}));\n__exportStar(__webpack_require__(/*! ./lock */ \"(ssr)/./node_modules/@ethereumjs/util/dist/lock.js\"), exports);\n__exportStar(__webpack_require__(/*! ./provider */ \"(ssr)/./node_modules/@ethereumjs/util/dist/provider.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLGVBQWUsSUFBSyxJQUFJLElBQUksQ0FBQ0EsWUFBWSxJQUFLLFNBQVNaLENBQUMsRUFBRWEsUUFBTztJQUNqRSxJQUFLLElBQUlDLEtBQUtkLEVBQUcsSUFBSWMsTUFBTSxhQUFhLENBQUNqQixPQUFPa0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osVUFBU0MsSUFBSWxCLGdCQUFnQmlCLFVBQVNiLEdBQUdjO0FBQzNIO0FBQ0FqQiw4Q0FBNkM7SUFBRXFCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RMLGVBQWUsR0FBR0Esc0JBQXNCLEdBQUdBLGlCQUFpQixHQUFHQSxtQkFBbUIsR0FBR0EscUJBQXFCLEdBQUdBLGVBQWUsR0FBR0EscUJBQXFCLEdBQUdBLGdCQUFnQixHQUFHQSxpQkFBaUIsR0FBR0EsMEJBQTBCLEdBQUcsS0FBSztBQUNoTzs7Q0FFQyxHQUNERCxhQUFhaUIsbUJBQU9BLENBQUMsNEVBQWEsR0FBR2hCO0FBQ3JDOztDQUVDLEdBQ0RELGFBQWFpQixtQkFBT0EsQ0FBQyxvRUFBUyxHQUFHaEI7QUFDakM7O0NBRUMsR0FDREQsYUFBYWlCLG1CQUFPQSxDQUFDLHdFQUFXLEdBQUdoQjtBQUNuQzs7Q0FFQyxHQUNERCxhQUFhaUIsbUJBQU9BLENBQUMsd0VBQVcsR0FBR2hCO0FBQ25DOztDQUVDLEdBQ0RELGFBQWFpQixtQkFBT0EsQ0FBQyw4RUFBYyxHQUFHaEI7QUFDdEM7O0NBRUMsR0FDREQsYUFBYWlCLG1CQUFPQSxDQUFDLDRFQUFhLEdBQUdoQjtBQUNyQzs7Q0FFQyxHQUNERCxhQUFhaUIsbUJBQU9BLENBQUMsb0VBQVMsR0FBR2hCO0FBQ2pDOztDQUVDLEdBQ0RELGFBQWFpQixtQkFBT0EsQ0FBQyxvRUFBUyxHQUFHaEI7QUFDakM7O0NBRUMsR0FDREQsYUFBYWlCLG1CQUFPQSxDQUFDLDBFQUFZLEdBQUdoQjtBQUNwQzs7Q0FFQyxHQUNERCxhQUFhaUIsbUJBQU9BLENBQUMsNEZBQXFCLEdBQUdoQjtBQUM3QyxJQUFJaUIsYUFBYUQsbUJBQU9BLENBQUMsMEVBQVk7QUFDckNoQyxzREFBcUQ7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFdBQVdGLGtCQUFrQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3RJL0IsNkNBQTRDO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXSCxTQUFTO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDcEg5Qiw0Q0FBMkM7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFdBQVdKLFFBQVE7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNsSDdCLGlEQUFnRDtJQUFFWSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPb0IsV0FBV0wsYUFBYTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzVINUIsMkNBQTBDO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXTixPQUFPO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDaEgzQixpREFBZ0Q7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFdBQVdQLGFBQWE7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM1SDFCLCtDQUE4QztJQUFFWSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPb0IsV0FBV1IsV0FBVztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3hIekIsNkNBQTRDO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXVCxTQUFTO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDcEh4QixrREFBaUQ7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFdBQVdWLGNBQWM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM5SHZCLDJDQUEwQztJQUFFWSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPb0IsV0FBV1gsT0FBTztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2hIUCxhQUFhaUIsbUJBQU9BLENBQUMsa0VBQVEsR0FBR2hCO0FBQ2hDRCxhQUFhaUIsbUJBQU9BLENBQUMsMEVBQVksR0FBR2hCLFVBQ3BDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2luZGV4LmpzP2VlNzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9Bc2NpaSA9IGV4cG9ydHMuc3RyaXBIZXhQcmVmaXggPSBleHBvcnRzLnBhZFRvRXZlbiA9IGV4cG9ydHMuaXNIZXhTdHJpbmcgPSBleHBvcnRzLmlzSGV4UHJlZml4ZWQgPSBleHBvcnRzLmdldEtleXMgPSBleHBvcnRzLmdldEJpbmFyeVNpemUgPSBleHBvcnRzLmZyb21VdGY4ID0gZXhwb3J0cy5mcm9tQXNjaWkgPSBleHBvcnRzLmFycmF5Q29udGFpbnNBcnJheSA9IHZvaWQgMDtcbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb25zdGFudHNcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBVbml0cyBoZWxwZXJzXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91bml0c1wiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEFjY291bnQgY2xhc3MgYW5kIGhlbHBlciBmdW5jdGlvbnNcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FjY291bnRcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBBZGRyZXNzIHR5cGVcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FkZHJlc3NcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBXaXRoZHJhd2FsIHR5cGVcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3dpdGhkcmF3YWxcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBFQ0RTQSBzaWduYXR1cmVcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NpZ25hdHVyZVwiKSwgZXhwb3J0cyk7XG4vKipcbiAqIFV0aWxpdGllcyBmb3IgbWFuaXB1bGF0aW5nIEJ1ZmZlcnMsIGJ5dGUgYXJyYXlzLCBldGMuXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ieXRlc1wiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEhlbHBmdWwgVHlwZVNjcmlwdCB0eXBlc1xuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXNcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHdvcmtpbmcgd2l0aCBjb21wYWN0IGVuY29kaW5nXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lbmNvZGluZ1wiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEV4cG9ydCBldGhqcy11dGlsIG1ldGhvZHNcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FzeW5jRXZlbnRFbWl0dGVyXCIpLCBleHBvcnRzKTtcbnZhciBpbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhcnJheUNvbnRhaW5zQXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuYXJyYXlDb250YWluc0FycmF5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZnJvbUFzY2lpXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLmZyb21Bc2NpaTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZyb21VdGY4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLmZyb21VdGY4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0QmluYXJ5U2l6ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5nZXRCaW5hcnlTaXplOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0S2V5c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5nZXRLZXlzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNIZXhQcmVmaXhlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5pc0hleFByZWZpeGVkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNIZXhTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuaXNIZXhTdHJpbmc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYWRUb0V2ZW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEucGFkVG9FdmVuOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaXBIZXhQcmVmaXhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuc3RyaXBIZXhQcmVmaXg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0FzY2lpXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLnRvQXNjaWk7IH0gfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbG9ja1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZXhwb3J0U3RhciIsImV4cG9ydHMiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmFsdWUiLCJ0b0FzY2lpIiwic3RyaXBIZXhQcmVmaXgiLCJwYWRUb0V2ZW4iLCJpc0hleFN0cmluZyIsImlzSGV4UHJlZml4ZWQiLCJnZXRLZXlzIiwiZ2V0QmluYXJ5U2l6ZSIsImZyb21VdGY4IiwiZnJvbUFzY2lpIiwiYXJyYXlDb250YWluc0FycmF5IiwicmVxdWlyZSIsImludGVybmFsXzEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethereumjs/util/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethereumjs/util/dist/internal.js":
/*!********************************************************!*\
  !*** ./node_modules/@ethereumjs/util/dist/internal.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\nThe MIT License\n\nCopyright (c) 2016 Nick Dodson. nickdodson.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;\n/**\n * Returns a `Boolean` on whether or not the a `String` starts with '0x'\n * @param str the string input value\n * @return a boolean if it is or is not hex prefixed\n * @throws if the str input is not a string\n */ function isHexPrefixed(str) {\n    if (typeof str !== \"string\") {\n        throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);\n    }\n    return str[0] === \"0\" && str[1] === \"x\";\n}\nexports.isHexPrefixed = isHexPrefixed;\n/**\n * Removes '0x' from a given `String` if present\n * @param str the string value\n * @returns the string without 0x prefix\n */ const stripHexPrefix = (str)=>{\n    if (typeof str !== \"string\") throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);\n    return isHexPrefixed(str) ? str.slice(2) : str;\n};\nexports.stripHexPrefix = stripHexPrefix;\n/**\n * Pads a `String` to have an even length\n * @param value\n * @return output\n */ function padToEven(value) {\n    let a = value;\n    if (typeof a !== \"string\") {\n        throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);\n    }\n    if (a.length % 2) a = `0${a}`;\n    return a;\n}\nexports.padToEven = padToEven;\n/**\n * Get the binary size of a string\n * @param str\n * @returns the number of bytes contained within the string\n */ function getBinarySize(str) {\n    if (typeof str !== \"string\") {\n        throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof str}`);\n    }\n    return Buffer.byteLength(str, \"utf8\");\n}\nexports.getBinarySize = getBinarySize;\n/**\n * Returns TRUE if the first specified array contains all elements\n * from the second one. FALSE otherwise.\n *\n * @param superset\n * @param subset\n *\n */ function arrayContainsArray(superset, subset, some) {\n    if (Array.isArray(superset) !== true) {\n        throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`);\n    }\n    if (Array.isArray(subset) !== true) {\n        throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`);\n    }\n    return subset[some === true ? \"some\" : \"every\"]((value)=>superset.indexOf(value) >= 0);\n}\nexports.arrayContainsArray = arrayContainsArray;\n/**\n * Should be called to get ascii from its hex representation\n *\n * @param string in hex\n * @returns ascii string representation of hex value\n */ function toAscii(hex) {\n    let str = \"\";\n    let i = 0;\n    const l = hex.length;\n    if (hex.substring(0, 2) === \"0x\") i = 2;\n    for(; i < l; i += 2){\n        const code = parseInt(hex.substr(i, 2), 16);\n        str += String.fromCharCode(code);\n    }\n    return str;\n}\nexports.toAscii = toAscii;\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n *\n * @param string\n * @param optional padding\n * @returns hex representation of input string\n */ function fromUtf8(stringValue) {\n    const str = Buffer.from(stringValue, \"utf8\");\n    return `0x${padToEven(str.toString(\"hex\")).replace(/^0+|0+$/g, \"\")}`;\n}\nexports.fromUtf8 = fromUtf8;\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n *\n * @param  string\n * @param  optional padding\n * @returns  hex representation of input string\n */ function fromAscii(stringValue) {\n    let hex = \"\";\n    for(let i = 0; i < stringValue.length; i++){\n        const code = stringValue.charCodeAt(i);\n        const n = code.toString(16);\n        hex += n.length < 2 ? `0${n}` : n;\n    }\n    return `0x${hex}`;\n}\nexports.fromAscii = fromAscii;\n/**\n * Returns the keys from an array of objects.\n * @example\n * ```js\n * getKeys([{a: '1', b: '2'}, {a: '3', b: '4'}], 'a') => ['1', '3']\n *````\n * @param  params\n * @param  key\n * @param  allowEmpty\n * @returns output just a simple array of output keys\n */ function getKeys(params, key, allowEmpty) {\n    if (!Array.isArray(params)) {\n        throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof params}`);\n    }\n    if (typeof key !== \"string\") {\n        throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`);\n    }\n    const result = [];\n    for(let i = 0; i < params.length; i++){\n        let value = params[i][key];\n        if (allowEmpty === true && !value) {\n            value = \"\";\n        } else if (typeof value !== \"string\") {\n            throw new Error(`invalid abi - expected type 'string', received ${typeof value}`);\n        }\n        result.push(value);\n    }\n    return result;\n}\nexports.getKeys = getKeys;\n/**\n * Is the string a hex string.\n *\n * @param  value\n * @param  length\n * @returns  output the string is a hex string\n */ function isHexString(value, length) {\n    if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) return false;\n    if (typeof length !== \"undefined\" && length > 0 && value.length !== 2 + 2 * length) return false;\n    return true;\n}\nexports.isHexString = isHexString; //# sourceMappingURL=internal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2ludGVybmFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzQkMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1CQUFtQixHQUFHQSxlQUFlLEdBQUdBLGlCQUFpQixHQUFHQSxnQkFBZ0IsR0FBR0EsZUFBZSxHQUFHQSwwQkFBMEIsR0FBR0EscUJBQXFCLEdBQUdBLGlCQUFpQixHQUFHQSxzQkFBc0IsR0FBR0EscUJBQXFCLEdBQUcsS0FBSztBQUNoTzs7Ozs7Q0FLQyxHQUNELFNBQVNXLGNBQWNDLEdBQUc7SUFDdEIsSUFBSSxPQUFPQSxRQUFRLFVBQVU7UUFDekIsTUFBTSxJQUFJQyxNQUFNLENBQUMsMkRBQTJELEVBQUUsT0FBT0QsSUFBSSxDQUFDO0lBQzlGO0lBQ0EsT0FBT0EsR0FBRyxDQUFDLEVBQUUsS0FBSyxPQUFPQSxHQUFHLENBQUMsRUFBRSxLQUFLO0FBQ3hDO0FBQ0FaLHFCQUFxQixHQUFHVztBQUN4Qjs7OztDQUlDLEdBQ0QsTUFBTUQsaUJBQWlCLENBQUNFO0lBQ3BCLElBQUksT0FBT0EsUUFBUSxVQUNmLE1BQU0sSUFBSUMsTUFBTSxDQUFDLHVEQUF1RCxFQUFFLE9BQU9ELElBQUksQ0FBQztJQUMxRixPQUFPRCxjQUFjQyxPQUFPQSxJQUFJRSxLQUFLLENBQUMsS0FBS0Y7QUFDL0M7QUFDQVosc0JBQXNCLEdBQUdVO0FBQ3pCOzs7O0NBSUMsR0FDRCxTQUFTRCxVQUFVUixLQUFLO0lBQ3BCLElBQUljLElBQUlkO0lBQ1IsSUFBSSxPQUFPYyxNQUFNLFVBQVU7UUFDdkIsTUFBTSxJQUFJRixNQUFNLENBQUMsa0RBQWtELEVBQUUsT0FBT0UsRUFBRSxDQUFDO0lBQ25GO0lBQ0EsSUFBSUEsRUFBRUMsTUFBTSxHQUFHLEdBQ1hELElBQUksQ0FBQyxDQUFDLEVBQUVBLEVBQUUsQ0FBQztJ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SUMsZUFBZSxRQUFRLENBQUN6QyxPQUFPO1lBQy9CQSxRQUFRO1FBQ1osT0FDSyxJQUFJLE9BQU9BLFVBQVUsVUFBVTtZQUNoQyxNQUFNLElBQUlZLE1BQU0sQ0FBQywrQ0FBK0MsRUFBRSxPQUFPWixNQUFNLENBQUM7UUFDcEY7UUFDQTBDLE9BQU9DLElBQUksQ0FBQzNDO0lBQ2hCO0lBQ0EsT0FBTzBDO0FBQ1g7QUFDQTNDLGVBQWUsR0FBR0c7QUFDbEI7Ozs7OztDQU1DLEdBQ0QsU0FBU0QsWUFBWUQsS0FBSyxFQUFFZSxNQUFNO0lBQzlCLElBQUksT0FBT2YsVUFBVSxZQUFZLENBQUNBLE1BQU00QyxLQUFLLENBQUMscUJBQzFDLE9BQU87SUFDWCxJQUFJLE9BQU83QixXQUFXLGVBQWVBLFNBQVMsS0FBS2YsTUFBTWUsTUFBTSxLQUFLLElBQUksSUFBSUEsUUFDeEUsT0FBTztJQUNYLE9BQU87QUFDWDtBQUNBaEIsbUJBQW1CLEdBQUdFLGFBQ3RCLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2ludGVybmFsLmpzP2MzZmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuVGhlIE1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgMjAxNiBOaWNrIERvZHNvbi4gbmlja2RvZHNvbi5jb21cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNIZXhTdHJpbmcgPSBleHBvcnRzLmdldEtleXMgPSBleHBvcnRzLmZyb21Bc2NpaSA9IGV4cG9ydHMuZnJvbVV0ZjggPSBleHBvcnRzLnRvQXNjaWkgPSBleHBvcnRzLmFycmF5Q29udGFpbnNBcnJheSA9IGV4cG9ydHMuZ2V0QmluYXJ5U2l6ZSA9IGV4cG9ydHMucGFkVG9FdmVuID0gZXhwb3J0cy5zdHJpcEhleFByZWZpeCA9IGV4cG9ydHMuaXNIZXhQcmVmaXhlZCA9IHZvaWQgMDtcbi8qKlxuICogUmV0dXJucyBhIGBCb29sZWFuYCBvbiB3aGV0aGVyIG9yIG5vdCB0aGUgYSBgU3RyaW5nYCBzdGFydHMgd2l0aCAnMHgnXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgaW5wdXQgdmFsdWVcbiAqIEByZXR1cm4gYSBib29sZWFuIGlmIGl0IGlzIG9yIGlzIG5vdCBoZXggcHJlZml4ZWRcbiAqIEB0aHJvd3MgaWYgdGhlIHN0ciBpbnB1dCBpcyBub3QgYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gaXNIZXhQcmVmaXhlZChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbaXNIZXhQcmVmaXhlZF0gaW5wdXQgbXVzdCBiZSB0eXBlICdzdHJpbmcnLCByZWNlaXZlZCB0eXBlICR7dHlwZW9mIHN0cn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0clswXSA9PT0gJzAnICYmIHN0clsxXSA9PT0gJ3gnO1xufVxuZXhwb3J0cy5pc0hleFByZWZpeGVkID0gaXNIZXhQcmVmaXhlZDtcbi8qKlxuICogUmVtb3ZlcyAnMHgnIGZyb20gYSBnaXZlbiBgU3RyaW5nYCBpZiBwcmVzZW50XG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdmFsdWVcbiAqIEByZXR1cm5zIHRoZSBzdHJpbmcgd2l0aG91dCAweCBwcmVmaXhcbiAqL1xuY29uc3Qgc3RyaXBIZXhQcmVmaXggPSAoc3RyKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtzdHJpcEhleFByZWZpeF0gaW5wdXQgbXVzdCBiZSB0eXBlICdzdHJpbmcnLCByZWNlaXZlZCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIGlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ci5zbGljZSgyKSA6IHN0cjtcbn07XG5leHBvcnRzLnN0cmlwSGV4UHJlZml4ID0gc3RyaXBIZXhQcmVmaXg7XG4vKipcbiAqIFBhZHMgYSBgU3RyaW5nYCB0byBoYXZlIGFuIGV2ZW4gbGVuZ3RoXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEByZXR1cm4gb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIHBhZFRvRXZlbih2YWx1ZSkge1xuICAgIGxldCBhID0gdmFsdWU7XG4gICAgaWYgKHR5cGVvZiBhICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtwYWRUb0V2ZW5dIHZhbHVlIG11c3QgYmUgdHlwZSAnc3RyaW5nJywgcmVjZWl2ZWQgJHt0eXBlb2YgYX1gKTtcbiAgICB9XG4gICAgaWYgKGEubGVuZ3RoICUgMilcbiAgICAgICAgYSA9IGAwJHthfWA7XG4gICAgcmV0dXJuIGE7XG59XG5leHBvcnRzLnBhZFRvRXZlbiA9IHBhZFRvRXZlbjtcbi8qKlxuICogR2V0IHRoZSBiaW5hcnkgc2l6ZSBvZiBhIHN0cmluZ1xuICogQHBhcmFtIHN0clxuICogQHJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyBjb250YWluZWQgd2l0aGluIHRoZSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZ2V0QmluYXJ5U2l6ZShzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbZ2V0QmluYXJ5U2l6ZV0gbWV0aG9kIHJlcXVpcmVzIGlucHV0IHR5cGUgJ3N0cmluZycsIHJlY2VpdmVkICR7dHlwZW9mIHN0cn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKHN0ciwgJ3V0ZjgnKTtcbn1cbmV4cG9ydHMuZ2V0QmluYXJ5U2l6ZSA9IGdldEJpbmFyeVNpemU7XG4vKipcbiAqIFJldHVybnMgVFJVRSBpZiB0aGUgZmlyc3Qgc3BlY2lmaWVkIGFycmF5IGNvbnRhaW5zIGFsbCBlbGVtZW50c1xuICogZnJvbSB0aGUgc2Vjb25kIG9uZS4gRkFMU0Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSBzdXBlcnNldFxuICogQHBhcmFtIHN1YnNldFxuICpcbiAqL1xuZnVuY3Rpb24gYXJyYXlDb250YWluc0FycmF5KHN1cGVyc2V0LCBzdWJzZXQsIHNvbWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdXBlcnNldCkgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbYXJyYXlDb250YWluc0FycmF5XSBtZXRob2QgcmVxdWlyZXMgaW5wdXQgJ3N1cGVyc2V0JyB0byBiZSBhbiBhcnJheSwgZ290IHR5cGUgJyR7dHlwZW9mIHN1cGVyc2V0fSdgKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3Vic2V0KSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFthcnJheUNvbnRhaW5zQXJyYXldIG1ldGhvZCByZXF1aXJlcyBpbnB1dCAnc3Vic2V0JyB0byBiZSBhbiBhcnJheSwgZ290IHR5cGUgJyR7dHlwZW9mIHN1YnNldH0nYCk7XG4gICAgfVxuICAgIHJldHVybiBzdWJzZXRbc29tZSA9PT0gdHJ1ZSA/ICdzb21lJyA6ICdldmVyeSddKCh2YWx1ZSkgPT4gc3VwZXJzZXQuaW5kZXhPZih2YWx1ZSkgPj0gMCk7XG59XG5leHBvcnRzLmFycmF5Q29udGFpbnNBcnJheSA9IGFycmF5Q29udGFpbnNBcnJheTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgYXNjaWkgZnJvbSBpdHMgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQHBhcmFtIHN0cmluZyBpbiBoZXhcbiAqIEByZXR1cm5zIGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9Bc2NpaShoZXgpIHtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGwgPSBoZXgubGVuZ3RoO1xuICAgIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKVxuICAgICAgICBpID0gMjtcbiAgICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgICAgICBjb25zdCBjb2RlID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmV4cG9ydHMudG9Bc2NpaSA9IHRvQXNjaWk7XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIHV0Zjggc3RyaW5nXG4gKlxuICogQHBhcmFtIHN0cmluZ1xuICogQHBhcmFtIG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zIGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZnJvbVV0Zjgoc3RyaW5nVmFsdWUpIHtcbiAgICBjb25zdCBzdHIgPSBCdWZmZXIuZnJvbShzdHJpbmdWYWx1ZSwgJ3V0ZjgnKTtcbiAgICByZXR1cm4gYDB4JHtwYWRUb0V2ZW4oc3RyLnRvU3RyaW5nKCdoZXgnKSkucmVwbGFjZSgvXjArfDArJC9nLCAnJyl9YDtcbn1cbmV4cG9ydHMuZnJvbVV0ZjggPSBmcm9tVXRmODtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgYXNjaWkgc3RyaW5nXG4gKlxuICogQHBhcmFtICBzdHJpbmdcbiAqIEBwYXJhbSAgb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMgIGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZnJvbUFzY2lpKHN0cmluZ1ZhbHVlKSB7XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHN0cmluZ1ZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGNvbnN0IG4gPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaGV4ICs9IG4ubGVuZ3RoIDwgMiA/IGAwJHtufWAgOiBuO1xuICAgIH1cbiAgICByZXR1cm4gYDB4JHtoZXh9YDtcbn1cbmV4cG9ydHMuZnJvbUFzY2lpID0gZnJvbUFzY2lpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBrZXlzIGZyb20gYW4gYXJyYXkgb2Ygb2JqZWN0cy5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogZ2V0S2V5cyhbe2E6ICcxJywgYjogJzInfSwge2E6ICczJywgYjogJzQnfV0sICdhJykgPT4gWycxJywgJzMnXVxuICpgYGBgXG4gKiBAcGFyYW0gIHBhcmFtc1xuICogQHBhcmFtICBrZXlcbiAqIEBwYXJhbSAgYWxsb3dFbXB0eVxuICogQHJldHVybnMgb3V0cHV0IGp1c3QgYSBzaW1wbGUgYXJyYXkgb2Ygb3V0cHV0IGtleXNcbiAqL1xuZnVuY3Rpb24gZ2V0S2V5cyhwYXJhbXMsIGtleSwgYWxsb3dFbXB0eSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW2dldEtleXNdIG1ldGhvZCBleHBlY3RzIGlucHV0ICdwYXJhbXMnIHRvIGJlIGFuIGFycmF5LCBnb3QgJHt0eXBlb2YgcGFyYW1zfWApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbZ2V0S2V5c10gbWV0aG9kIGV4cGVjdHMgaW5wdXQgJ2tleScgdG8gYmUgdHlwZSAnc3RyaW5nJywgZ290ICR7dHlwZW9mIHBhcmFtc31gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyYW1zW2ldW2tleV07XG4gICAgICAgIGlmIChhbGxvd0VtcHR5ID09PSB0cnVlICYmICF2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYWJpIC0gZXhwZWN0ZWQgdHlwZSAnc3RyaW5nJywgcmVjZWl2ZWQgJHt0eXBlb2YgdmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5nZXRLZXlzID0gZ2V0S2V5cztcbi8qKlxuICogSXMgdGhlIHN0cmluZyBhIGhleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB2YWx1ZVxuICogQHBhcmFtICBsZW5ndGhcbiAqIEByZXR1cm5zICBvdXRwdXQgdGhlIHN0cmluZyBpcyBhIGhleCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8ICF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICd1bmRlZmluZWQnICYmIGxlbmd0aCA+IDAgJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc0hleFN0cmluZyA9IGlzSGV4U3RyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJuYWwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaXNIZXhTdHJpbmciLCJnZXRLZXlzIiwiZnJvbUFzY2lpIiwiZnJvbVV0ZjgiLCJ0b0FzY2lpIiwiYXJyYXlDb250YWluc0FycmF5IiwiZ2V0QmluYXJ5U2l6ZSIsInBhZFRvRXZlbiIsInN0cmlwSGV4UHJlZml4IiwiaXNIZXhQcmVmaXhlZCIsInN0ciIsIkVycm9yIiwic2xpY2UiLCJhIiwibGVuZ3RoIiwiQnVmZmVyIiwiYnl0ZUxlbmd0aCIsInN1cGVyc2V0Iiwic3Vic2V0Iiwic29tZSIsIkFycmF5IiwiaXNBcnJheSIsImluZGV4T2YiLCJoZXgiLCJpIiwibCIsInN1YnN0cmluZyIsImNvZGUiLCJwYXJzZUludCIsInN1YnN0ciIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInN0cmluZ1ZhbHVlIiwiZnJvbSIsInRvU3RyaW5nIiwicmVwbGFjZSIsImNoYXJDb2RlQXQiLCJuIiwicGFyYW1zIiwia2V5IiwiYWxsb3dFbXB0eSIsInJlc3VsdCIsInB1c2giLCJtYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethereumjs/util/dist/internal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethereumjs/util/dist/lock.js":
/*!****************************************************!*\
  !*** ./node_modules/@ethereumjs/util/dist/lock.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Lock = void 0;\n// Based on https://github.com/jsoendermann/semaphore-async-await/blob/master/src/Semaphore.ts\nclass Lock {\n    constructor(){\n        this.permits = 1;\n        this.promiseResolverQueue = [];\n    }\n    /**\n     * Returns a promise used to wait for a permit to become available. This method should be awaited on.\n     * @returns  A promise that gets resolved when execution is allowed to proceed.\n     */ async acquire() {\n        if (this.permits > 0) {\n            this.permits -= 1;\n            return Promise.resolve(true);\n        }\n        // If there is no permit available, we return a promise that resolves once the semaphore gets\n        // signaled enough times that permits is equal to one.\n        return new Promise((resolver)=>this.promiseResolverQueue.push(resolver));\n    }\n    /**\n     * Increases the number of permits by one. If there are other functions waiting, one of them will\n     * continue to execute in a future iteration of the event loop.\n     */ release() {\n        this.permits += 1;\n        if (this.permits > 1 && this.promiseResolverQueue.length > 0) {\n            // eslint-disable-next-line no-console\n            console.warn(\"Lock.permits should never be > 0 when there is someone waiting.\");\n        } else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {\n            // If there is someone else waiting, immediately consume the permit that was released\n            // at the beginning of this function and let the waiting function resume.\n            this.permits -= 1;\n            const nextResolver = this.promiseResolverQueue.shift();\n            if (nextResolver) {\n                nextResolver(true);\n            }\n        }\n    }\n}\nexports.Lock = Lock; //# sourceMappingURL=lock.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2xvY2suanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELFlBQVksR0FBRyxLQUFLO0FBQ3BCLDhGQUE4RjtBQUM5RixNQUFNRTtJQUNGQyxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLG9CQUFvQixHQUFHLEVBQUU7SUFDbEM7SUFDQTs7O0tBR0MsR0FDRCxNQUFNQyxVQUFVO1FBQ1osSUFBSSxJQUFJLENBQUNGLE9BQU8sR0FBRyxHQUFHO1lBQ2xCLElBQUksQ0FBQ0EsT0FBTyxJQUFJO1lBQ2hCLE9BQU9HLFFBQVFDLE9BQU8sQ0FBQztRQUMzQjtRQUNBLDZGQUE2RjtRQUM3RixzREFBc0Q7UUFDdEQsT0FBTyxJQUFJRCxRQUFRLENBQUNFLFdBQWEsSUFBSSxDQUFDSixvQkFBb0IsQ0FBQ0ssSUFBSSxDQUFDRDtJQUNwRTtJQUNBOzs7S0FHQyxHQUNERSxVQUFVO1FBQ04sSUFBSSxDQUFDUCxPQUFPLElBQUk7UUFDaEIsSUFBSSxJQUFJLENBQUNBLE9BQU8sR0FBRyxLQUFLLElBQUksQ0FBQ0Msb0JBQW9CLENBQUNPLE1BQU0sR0FBRyxHQUFHO1lBQzFELHNDQUFzQztZQUN0Q0MsUUFBUUMsSUFBSSxDQUFDO1FBQ2pCLE9BQ0ssSUFBSSxJQUFJLENBQUNWLE9BQU8sS0FBSyxLQUFLLElBQUksQ0FBQ0Msb0JBQW9CLENBQUNPLE1BQU0sR0FBRyxHQUFHO1lBQ2pFLHFGQUFxRjtZQUNyRix5RUFBeUU7WUFDekUsSUFBSSxDQUFDUixPQUFPLElBQUk7WUFDaEIsTUFBTVcsZUFBZSxJQUFJLENBQUNWLG9CQUFvQixDQUFDVyxLQUFLO1lBQ3BELElBQUlELGNBQWM7Z0JBQ2RBLGFBQWE7WUFDakI7UUFDSjtJQUNKO0FBQ0o7QUFDQWYsWUFBWSxHQUFHRSxNQUNmLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L2xvY2suanM/N2JiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9jayA9IHZvaWQgMDtcbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9qc29lbmRlcm1hbm4vc2VtYXBob3JlLWFzeW5jLWF3YWl0L2Jsb2IvbWFzdGVyL3NyYy9TZW1hcGhvcmUudHNcbmNsYXNzIExvY2sge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnBlcm1pdHMgPSAxO1xuICAgICAgICB0aGlzLnByb21pc2VSZXNvbHZlclF1ZXVlID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHVzZWQgdG8gd2FpdCBmb3IgYSBwZXJtaXQgdG8gYmVjb21lIGF2YWlsYWJsZS4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGF3YWl0ZWQgb24uXG4gICAgICogQHJldHVybnMgIEEgcHJvbWlzZSB0aGF0IGdldHMgcmVzb2x2ZWQgd2hlbiBleGVjdXRpb24gaXMgYWxsb3dlZCB0byBwcm9jZWVkLlxuICAgICAqL1xuICAgIGFzeW5jIGFjcXVpcmUoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlcm1pdHMgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnBlcm1pdHMgLT0gMTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcGVybWl0IGF2YWlsYWJsZSwgd2UgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgdGhlIHNlbWFwaG9yZSBnZXRzXG4gICAgICAgIC8vIHNpZ25hbGVkIGVub3VnaCB0aW1lcyB0aGF0IHBlcm1pdHMgaXMgZXF1YWwgdG8gb25lLlxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmVyKSA9PiB0aGlzLnByb21pc2VSZXNvbHZlclF1ZXVlLnB1c2gocmVzb2x2ZXIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5jcmVhc2VzIHRoZSBudW1iZXIgb2YgcGVybWl0cyBieSBvbmUuIElmIHRoZXJlIGFyZSBvdGhlciBmdW5jdGlvbnMgd2FpdGluZywgb25lIG9mIHRoZW0gd2lsbFxuICAgICAqIGNvbnRpbnVlIHRvIGV4ZWN1dGUgaW4gYSBmdXR1cmUgaXRlcmF0aW9uIG9mIHRoZSBldmVudCBsb29wLlxuICAgICAqL1xuICAgIHJlbGVhc2UoKSB7XG4gICAgICAgIHRoaXMucGVybWl0cyArPSAxO1xuICAgICAgICBpZiAodGhpcy5wZXJtaXRzID4gMSAmJiB0aGlzLnByb21pc2VSZXNvbHZlclF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0xvY2sucGVybWl0cyBzaG91bGQgbmV2ZXIgYmUgPiAwIHdoZW4gdGhlcmUgaXMgc29tZW9uZSB3YWl0aW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGVybWl0cyA9PT0gMSAmJiB0aGlzLnByb21pc2VSZXNvbHZlclF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIHNvbWVvbmUgZWxzZSB3YWl0aW5nLCBpbW1lZGlhdGVseSBjb25zdW1lIHRoZSBwZXJtaXQgdGhhdCB3YXMgcmVsZWFzZWRcbiAgICAgICAgICAgIC8vIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBmdW5jdGlvbiBhbmQgbGV0IHRoZSB3YWl0aW5nIGZ1bmN0aW9uIHJlc3VtZS5cbiAgICAgICAgICAgIHRoaXMucGVybWl0cyAtPSAxO1xuICAgICAgICAgICAgY29uc3QgbmV4dFJlc29sdmVyID0gdGhpcy5wcm9taXNlUmVzb2x2ZXJRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKG5leHRSZXNvbHZlcikge1xuICAgICAgICAgICAgICAgIG5leHRSZXNvbHZlcih0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTG9jayA9IExvY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NrLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkxvY2siLCJjb25zdHJ1Y3RvciIsInBlcm1pdHMiLCJwcm9taXNlUmVzb2x2ZXJRdWV1ZSIsImFjcXVpcmUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlc29sdmVyIiwicHVzaCIsInJlbGVhc2UiLCJsZW5ndGgiLCJjb25zb2xlIiwid2FybiIsIm5leHRSZXNvbHZlciIsInNoaWZ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethereumjs/util/dist/lock.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethereumjs/util/dist/provider.js":
/*!********************************************************!*\
  !*** ./node_modules/@ethereumjs/util/dist/provider.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getProvider = exports.fetchFromProvider = void 0;\nconst micro_ftch_1 = __webpack_require__(/*! micro-ftch */ \"(ssr)/./node_modules/micro-ftch/index.js\");\nconst fetchFromProvider = async (url, params)=>{\n    const res = await (0, micro_ftch_1.default)(url, {\n        headers: {\n            \"content-type\": \"application/json\"\n        },\n        type: \"json\",\n        data: {\n            method: params.method,\n            params: params.params,\n            jsonrpc: \"2.0\",\n            id: 1\n        }\n    });\n    return res.result;\n};\nexports.fetchFromProvider = fetchFromProvider;\nconst getProvider = (provider)=>{\n    if (typeof provider === \"string\") {\n        return provider;\n    } else if (provider?.connection?.url !== undefined) {\n        return provider.connection.url;\n    } else {\n        throw new Error(\"Must provide valid provider URL or Web3Provider\");\n    }\n};\nexports.getProvider = getProvider; //# sourceMappingURL=provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L3Byb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQkFBbUIsR0FBR0EseUJBQXlCLEdBQUcsS0FBSztBQUN2RCxNQUFNSSxlQUFlQyxtQkFBT0EsQ0FBQyw0REFBWTtBQUN6QyxNQUFNRixvQkFBb0IsT0FBT0csS0FBS0M7SUFDbEMsTUFBTUMsTUFBTSxNQUFNLENBQUMsR0FBR0osYUFBYUssT0FBTyxFQUFFSCxLQUFLO1FBQzdDSSxTQUFTO1lBQ0wsZ0JBQWdCO1FBQ3BCO1FBQ0FDLE1BQU07UUFDTkMsTUFBTTtZQUNGQyxRQUFRTixPQUFPTSxNQUFNO1lBQ3JCTixRQUFRQSxPQUFPQSxNQUFNO1lBQ3JCTyxTQUFTO1lBQ1RDLElBQUk7UUFDUjtJQUNKO0lBQ0EsT0FBT1AsSUFBSVEsTUFBTTtBQUNyQjtBQUNBaEIseUJBQXlCLEdBQUdHO0FBQzVCLE1BQU1ELGNBQWMsQ0FBQ2U7SUFDakIsSUFBSSxPQUFPQSxhQUFhLFVBQVU7UUFDOUIsT0FBT0E7SUFDWCxPQUNLLElBQUlBLFVBQVVDLFlBQVlaLFFBQVFhLFdBQVc7UUFDOUMsT0FBT0YsU0FBU0MsVUFBVSxDQUFDWixHQUFHO0lBQ2xDLE9BQ0s7UUFDRCxNQUFNLElBQUljLE1BQU07SUFDcEI7QUFDSjtBQUNBcEIsbUJBQW1CLEdBQUdFLGFBQ3RCLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L3Byb3ZpZGVyLmpzP2UyNTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFByb3ZpZGVyID0gZXhwb3J0cy5mZXRjaEZyb21Qcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IG1pY3JvX2Z0Y2hfMSA9IHJlcXVpcmUoXCJtaWNyby1mdGNoXCIpO1xuY29uc3QgZmV0Y2hGcm9tUHJvdmlkZXIgPSBhc3luYyAodXJsLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCAoMCwgbWljcm9fZnRjaF8xLmRlZmF1bHQpKHVybCwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiAnanNvbicsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIG1ldGhvZDogcGFyYW1zLm1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLnBhcmFtcyxcbiAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG59O1xuZXhwb3J0cy5mZXRjaEZyb21Qcm92aWRlciA9IGZldGNoRnJvbVByb3ZpZGVyO1xuY29uc3QgZ2V0UHJvdmlkZXIgPSAocHJvdmlkZXIpID0+IHtcbiAgICBpZiAodHlwZW9mIHByb3ZpZGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcHJvdmlkZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3ZpZGVyPy5jb25uZWN0aW9uPy51cmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcHJvdmlkZXIuY29ubmVjdGlvbi51cmw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSB2YWxpZCBwcm92aWRlciBVUkwgb3IgV2ViM1Byb3ZpZGVyJyk7XG4gICAgfVxufTtcbmV4cG9ydHMuZ2V0UHJvdmlkZXIgPSBnZXRQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldFByb3ZpZGVyIiwiZmV0Y2hGcm9tUHJvdmlkZXIiLCJtaWNyb19mdGNoXzEiLCJyZXF1aXJlIiwidXJsIiwicGFyYW1zIiwicmVzIiwiZGVmYXVsdCIsImhlYWRlcnMiLCJ0eXBlIiwiZGF0YSIsIm1ldGhvZCIsImpzb25ycGMiLCJpZCIsInJlc3VsdCIsInByb3ZpZGVyIiwiY29ubmVjdGlvbiIsInVuZGVmaW5lZCIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethereumjs/util/dist/provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethereumjs/util/dist/signature.js":
/*!*********************************************************!*\
  !*** ./node_modules/@ethereumjs/util/dist/signature.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toCompactSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;\nconst keccak_1 = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(ssr)/./node_modules/ethereum-cryptography/keccak.js\");\nconst secp256k1_1 = __webpack_require__(/*! ethereum-cryptography/secp256k1 */ \"(ssr)/./node_modules/ethereum-cryptography/secp256k1.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/@ethereumjs/util/dist/bytes.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@ethereumjs/util/dist/constants.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@ethereumjs/util/dist/helpers.js\");\n/**\n * Returns the ECDSA signature of a message hash.\n *\n * If `chainId` is provided assume an EIP-155-style signature and calculate the `v` value\n * accordingly, otherwise return a \"static\" `v` just derived from the `recovery` bit\n */ function ecsign(msgHash, privateKey, chainId) {\n    const sig = secp256k1_1.secp256k1.sign(msgHash, privateKey);\n    const buf = sig.toCompactRawBytes();\n    const r = Buffer.from(buf.slice(0, 32));\n    const s = Buffer.from(buf.slice(32, 64));\n    const v = chainId === undefined ? BigInt(sig.recovery + 27) : BigInt(sig.recovery + 35) + BigInt(chainId) * BigInt(2);\n    return {\n        r,\n        s,\n        v\n    };\n}\nexports.ecsign = ecsign;\nfunction calculateSigRecovery(v, chainId) {\n    if (v === BigInt(0) || v === BigInt(1)) return v;\n    if (chainId === undefined) {\n        return v - BigInt(27);\n    }\n    return v - (chainId * BigInt(2) + BigInt(35));\n}\nfunction isValidSigRecovery(recovery) {\n    return recovery === BigInt(0) || recovery === BigInt(1);\n}\n/**\n * ECDSA public key recovery from signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Recovered public key\n */ const ecrecover = function(msgHash, v, r, s, chainId) {\n    const signature = Buffer.concat([\n        (0, bytes_1.setLengthLeft)(r, 32),\n        (0, bytes_1.setLengthLeft)(s, 32)\n    ], 64);\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error(\"Invalid signature v value\");\n    }\n    const sig = secp256k1_1.secp256k1.Signature.fromCompact(signature).addRecoveryBit(Number(recovery));\n    const senderPubKey = sig.recoverPublicKey(msgHash);\n    return Buffer.from(senderPubKey.toRawBytes(false).slice(1));\n};\nexports.ecrecover = ecrecover;\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */ const toRpcSig = function(v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error(\"Invalid signature v value\");\n    }\n    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n    return (0, bytes_1.bufferToHex)(Buffer.concat([\n        (0, bytes_1.setLengthLeft)(r, 32),\n        (0, bytes_1.setLengthLeft)(s, 32),\n        (0, bytes_1.toBuffer)(v)\n    ]));\n};\nexports.toRpcSig = toRpcSig;\n/**\n * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */ const toCompactSig = function(v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error(\"Invalid signature v value\");\n    }\n    let ss = s;\n    if (v > BigInt(28) && v % BigInt(2) === BigInt(1) || v === BigInt(1) || v === BigInt(28)) {\n        ss = Buffer.from(s);\n        ss[0] |= 0x80;\n    }\n    return (0, bytes_1.bufferToHex)(Buffer.concat([\n        (0, bytes_1.setLengthLeft)(r, 32),\n        (0, bytes_1.setLengthLeft)(ss, 32)\n    ]));\n};\nexports.toCompactSig = toCompactSig;\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n *\n * NOTE: For an extracted `v` value < 27 (see Geth bug https://github.com/ethereum/go-ethereum/issues/2053)\n * `v + 27` is returned for the `v` value\n * NOTE: After EIP1559, `v` could be `0` or `1` but this function assumes\n * it's a signed message (EIP-191 or EIP-712) adding `27` at the end. Remove if needed.\n */ const fromRpcSig = function(sig) {\n    const buf = (0, bytes_1.toBuffer)(sig);\n    let r;\n    let s;\n    let v;\n    if (buf.length >= 65) {\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = (0, bytes_1.bufferToBigInt)(buf.slice(64));\n    } else if (buf.length === 64) {\n        // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = BigInt((0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7);\n        s[0] &= 0x7f;\n    } else {\n        throw new Error(\"Invalid signature length\");\n    }\n    // support both versions of `eth_sign` responses\n    if (v < 27) {\n        v = v + BigInt(27);\n    }\n    return {\n        v,\n        r,\n        s\n    };\n};\nexports.fromRpcSig = fromRpcSig;\n/**\n * Validate a ECDSA signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */ const isValidSignature = function(v, r, s, homesteadOrLater = true, chainId) {\n    if (r.length !== 32 || s.length !== 32) {\n        return false;\n    }\n    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n        return false;\n    }\n    const rBigInt = (0, bytes_1.bufferToBigInt)(r);\n    const sBigInt = (0, bytes_1.bufferToBigInt)(s);\n    if (rBigInt === BigInt(0) || rBigInt >= constants_1.SECP256K1_ORDER || sBigInt === BigInt(0) || sBigInt >= constants_1.SECP256K1_ORDER) {\n        return false;\n    }\n    if (homesteadOrLater && sBigInt >= constants_1.SECP256K1_ORDER_DIV_2) {\n        return false;\n    }\n    return true;\n};\nexports.isValidSignature = isValidSignature;\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */ const hashPersonalMessage = function(message) {\n    (0, helpers_1.assertIsBuffer)(message);\n    const prefix = Buffer.from(`\\u0019Ethereum Signed Message:\\n${message.length}`, \"utf-8\");\n    return Buffer.from((0, keccak_1.keccak256)(Buffer.concat([\n        prefix,\n        message\n    ])));\n};\nexports.hashPersonalMessage = hashPersonalMessage; //# sourceMappingURL=signature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L3NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMkJBQTJCLEdBQUdBLHdCQUF3QixHQUFHQSxrQkFBa0IsR0FBR0Esb0JBQW9CLEdBQUdBLGdCQUFnQixHQUFHQSxpQkFBaUIsR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDbEssTUFBTVMsV0FBV0MsbUJBQU9BLENBQUMsMEZBQThCO0FBQ3ZELE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLGdHQUFpQztBQUM3RCxNQUFNRSxVQUFVRixtQkFBT0EsQ0FBQyxvRUFBUztBQUNqQyxNQUFNRyxjQUFjSCxtQkFBT0EsQ0FBQyw0RUFBYTtBQUN6QyxNQUFNSSxZQUFZSixtQkFBT0EsQ0FBQyx3RUFBVztBQUNyQzs7Ozs7Q0FLQyxHQUNELFNBQVNGLE9BQU9PLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxPQUFPO0lBQ3hDLE1BQU1DLE1BQU1QLFlBQVlRLFNBQVMsQ0FBQ0MsSUFBSSxDQUFDTCxTQUFTQztJQUNoRCxNQUFNSyxNQUFNSCxJQUFJSSxpQkFBaUI7SUFDakMsTUFBTUMsSUFBSUMsT0FBT0MsSUFBSSxDQUFDSixJQUFJSyxLQUFLLENBQUMsR0FBRztJQUNuQyxNQUFNQyxJQUFJSCxPQUFPQyxJQUFJLENBQUNKLElBQUlLLEtBQUssQ0FBQyxJQUFJO0lBQ3BDLE1BQU1FLElBQUlYLFlBQVlZLFlBQ2hCQyxPQUFPWixJQUFJYSxRQUFRLEdBQUcsTUFDdEJELE9BQU9aLElBQUlhLFFBQVEsR0FBRyxNQUFNRCxPQUFPYixXQUFXYSxPQUFPO0lBQzNELE9BQU87UUFBRVA7UUFBR0k7UUFBR0M7SUFBRTtBQUNyQjtBQUNBNUIsY0FBYyxHQUFHUTtBQUNqQixTQUFTd0IscUJBQXFCSixDQUFDLEVBQUVYLE9BQU87SUFDcEMsSUFBSVcsTUFBTUUsT0FBTyxNQUFNRixNQUFNRSxPQUFPLElBQ2hDLE9BQU9GO0lBQ1gsSUFBSVgsWUFBWVksV0FBVztRQUN2QixPQUFPRCxJQUFJRSxPQUFPO0lBQ3RCO0lBQ0EsT0FBT0YsSUFBS1gsQ0FBQUEsVUFBVWEsT0FBTyxLQUFLQSxPQUFPLEdBQUU7QUFDL0M7QUFDQSxTQUFTRyxtQkFBbUJGLFFBQVE7SUFDaEMsT0FBT0EsYUFBYUQsT0FBTyxNQUFNQyxhQUFhRCxPQUFPO0FBQ3pEO0FBQ0E7Ozs7Q0FJQyxHQUNELE1BQU12QixZQUFZLFNBQVVRLE9BQU8sRUFBRWEsQ0FBQyxFQUFFTCxDQUFDLEVBQUVJLENBQUMsRUFBRVYsT0FBTztJQUNqRCxNQUFNaUIsWUFBWVYsT0FBT1csTUFBTSxDQUFDO1FBQUUsSUFBR3ZCLFFBQVF3QixhQUFhLEVBQUViLEdBQUc7UUFBTSxJQUFHWCxRQUFRd0IsYUFBYSxFQUFFVCxHQUFHO0tBQUksRUFBRTtJQUN4RyxNQUFNSSxXQUFXQyxxQkFBcUJKLEdBQUdYO0lBQ3pDLElBQUksQ0FBQ2dCLG1CQUFtQkYsV0FBVztRQUMvQixNQUFNLElBQUlNLE1BQU07SUFDcEI7SUFDQSxNQUFNbkIsTUFBTVAsWUFBWVEsU0FBUyxDQUFDbUIsU0FBUyxDQUFDQyxXQUFXLENBQUNMLFdBQVdNLGNBQWMsQ0FBQ0MsT0FBT1Y7SUFDekYsTUFBTVcsZUFBZXhCLElBQUl5QixnQkFBZ0IsQ0FBQzVCO0lBQzFDLE9BQU9TLE9BQU9DLElBQUksQ0FBQ2lCLGFBQWFFLFVBQVUsQ0FBQyxPQUFPbEIsS0FBSyxDQUFDO0FBQzVEO0FBQ0ExQixpQkFBaUIsR0FBR087QUFDcEI7Ozs7Q0FJQyxHQUNELE1BQU1ELFdBQVcsU0FBVXNCLENBQUMsRUFBRUwsQ0FBQyxFQUFFSSxDQUFDLEVBQUVWLE9BQU87SUFDdkMsTUFBTWMsV0FBV0MscUJBQXFCSixHQUFHWDtJQUN6QyxJQUFJLENBQUNnQixtQkFBbUJGLFdBQVc7UUFDL0IsTUFBTSxJQUFJTSxNQUFNO0lBQ3BCO0lBQ0EsNkVBQTZFO0lBQzdFLE9BQU8sQ0FBQyxHQUFHekIsUUFBUWlDLFdBQVcsRUFBRXJCLE9BQU9XLE1BQU0sQ0FBQztRQUFFLElBQUd2QixRQUFRd0IsYUFBYSxFQUFFYixHQUFHO1FBQU0sSUFBR1gsUUFBUXdCLGFBQWEsRUFBRVQsR0FBRztRQUFNLElBQUdmLFFBQVFrQyxRQUFRLEVBQUVsQjtLQUFHO0FBQ2xKO0FBQ0E1QixnQkFBZ0IsR0FBR007QUFDbkI7Ozs7Q0FJQyxHQUNELE1BQU1ELGVBQWUsU0FBVXVCLENBQUMsRUFBRUwsQ0FBQyxFQUFFSSxDQUFDLEVBQUVWLE9BQU87SUFDM0MsTUFBTWMsV0FBV0MscUJBQXFCSixHQUFHWDtJQUN6QyxJQUFJLENBQUNnQixtQkFBbUJGLFdBQVc7UUFDL0IsTUFBTSxJQUFJTSxNQUFNO0lBQ3BCO0lBQ0EsSUFBSVUsS0FBS3BCO0lBQ1QsSUFBSSxJQUFLRyxPQUFPLE9BQU9GLElBQUlFLE9BQU8sT0FBT0EsT0FBTyxNQUFPRixNQUFNRSxPQUFPLE1BQU1GLE1BQU1FLE9BQU8sS0FBSztRQUN4RmlCLEtBQUt2QixPQUFPQyxJQUFJLENBQUNFO1FBQ2pCb0IsRUFBRSxDQUFDLEVBQUUsSUFBSTtJQUNiO0lBQ0EsT0FBTyxDQUFDLEdBQUduQyxRQUFRaUMsV0FBVyxFQUFFckIsT0FBT1csTUFBTSxDQUFDO1FBQUUsSUFBR3ZCLFFBQVF3QixhQUFhLEVBQUViLEdBQUc7UUFBTSxJQUFHWCxRQUFRd0IsYUFBYSxFQUFFVyxJQUFJO0tBQUk7QUFDekg7QUFDQS9DLG9CQUFvQixHQUFHSztBQUN2Qjs7Ozs7OztDQU9DLEdBQ0QsTUFBTUQsYUFBYSxTQUFVYyxHQUFHO0lBQzVCLE1BQU1HLE1BQU0sQ0FBQyxHQUFHVCxRQUFRa0MsUUFBUSxFQUFFNUI7SUFDbEMsSUFBSUs7SUFDSixJQUFJSTtJQUNKLElBQUlDO0lBQ0osSUFBSVAsSUFBSTJCLE1BQU0sSUFBSSxJQUFJO1FBQ2xCekIsSUFBSUYsSUFBSUssS0FBSyxDQUFDLEdBQUc7UUFDakJDLElBQUlOLElBQUlLLEtBQUssQ0FBQyxJQUFJO1FBQ2xCRSxJQUFJLENBQUMsR0FBR2hCLFFBQVFxQyxjQUFjLEVBQUU1QixJQUFJSyxLQUFLLENBQUM7SUFDOUMsT0FDSyxJQUFJTCxJQUFJMkIsTUFBTSxLQUFLLElBQUk7UUFDeEIsNkVBQTZFO1FBQzdFekIsSUFBSUYsSUFBSUssS0FBSyxDQUFDLEdBQUc7UUFDakJDLElBQUlOLElBQUlLLEtBQUssQ0FBQyxJQUFJO1FBQ2xCRSxJQUFJRSxPQUFPLENBQUMsR0FBR2xCLFFBQVFzQyxXQUFXLEVBQUU3QixJQUFJSyxLQUFLLENBQUMsSUFBSSxRQUFRO1FBQzFEQyxDQUFDLENBQUMsRUFBRSxJQUFJO0lBQ1osT0FDSztRQUNELE1BQU0sSUFBSVUsTUFBTTtJQUNwQjtJQUNBLGdEQUFnRDtJQUNoRCxJQUFJVCxJQUFJLElBQUk7UUFDUkEsSUFBSUEsSUFBSUUsT0FBTztJQUNuQjtJQUNBLE9BQU87UUFDSEY7UUFDQUw7UUFDQUk7SUFDSjtBQUNKO0FBQ0EzQixrQkFBa0IsR0FBR0k7QUFDckI7Ozs7Q0FJQyxHQUNELE1BQU1ELG1CQUFtQixTQUFVeUIsQ0FBQyxFQUFFTCxDQUFDLEVBQUVJLENBQUMsRUFBRXdCLG1CQUFtQixJQUFJLEVBQUVsQyxPQUFPO0lBQ3hFLElBQUlNLEVBQUV5QixNQUFNLEtBQUssTUFBTXJCLEVBQUVxQixNQUFNLEtBQUssSUFBSTtRQUNwQyxPQUFPO0lBQ1g7SUFDQSxJQUFJLENBQUNmLG1CQUFtQkQscUJBQXFCSixHQUFHWCxXQUFXO1FBQ3ZELE9BQU87SUFDWDtJQUNBLE1BQU1tQyxVQUFVLENBQUMsR0FBR3hDLFFBQVFxQyxjQUFjLEVBQUUxQjtJQUM1QyxNQUFNOEIsVUFBVSxDQUFDLEdBQUd6QyxRQUFRcUMsY0FBYyxFQUFFdEI7SUFDNUMsSUFBSXlCLFlBQVl0QixPQUFPLE1BQ25Cc0IsV0FBV3ZDLFlBQVl5QyxlQUFlLElBQ3RDRCxZQUFZdkIsT0FBTyxNQUNuQnVCLFdBQVd4QyxZQUFZeUMsZUFBZSxFQUFFO1FBQ3hDLE9BQU87SUFDWDtJQUNBLElBQUlILG9CQUFvQkUsV0FBV3hDLFlBQVkwQyxxQkFBcUIsRUFBRTtRQUNsRSxPQUFPO0lBQ1g7SUFDQSxPQUFPO0FBQ1g7QUFDQXZELHdCQUF3QixHQUFHRztBQUMzQjs7Ozs7Q0FLQyxHQUNELE1BQU1ELHNCQUFzQixTQUFVc0QsT0FBTztJQUN4QyxJQUFHMUMsVUFBVTJDLGNBQWMsRUFBRUQ7SUFDOUIsTUFBTUUsU0FBU2xDLE9BQU9DLElBQUksQ0FBQyxDQUFDLGdDQUFnQyxFQUFFK0IsUUFBUVIsTUFBTSxDQUFDLENBQUMsRUFBRTtJQUNoRixPQUFPeEIsT0FBT0MsSUFBSSxDQUFDLENBQUMsR0FBR2hCLFNBQVNrRCxTQUFTLEVBQUVuQyxPQUFPVyxNQUFNLENBQUM7UUFBQ3VCO1FBQVFGO0tBQVE7QUFDOUU7QUFDQXhELDJCQUEyQixHQUFHRSxxQkFDOUIscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy91dGlsL2Rpc3Qvc2lnbmF0dXJlLmpzPzhkZDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhc2hQZXJzb25hbE1lc3NhZ2UgPSBleHBvcnRzLmlzVmFsaWRTaWduYXR1cmUgPSBleHBvcnRzLmZyb21ScGNTaWcgPSBleHBvcnRzLnRvQ29tcGFjdFNpZyA9IGV4cG9ydHMudG9ScGNTaWcgPSBleHBvcnRzLmVjcmVjb3ZlciA9IGV4cG9ydHMuZWNzaWduID0gdm9pZCAwO1xuY29uc3Qga2VjY2FrXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nha1wiKTtcbmNvbnN0IHNlY3AyNTZrMV8xID0gcmVxdWlyZShcImV0aGVyZXVtLWNyeXB0b2dyYXBoeS9zZWNwMjU2azFcIik7XG5jb25zdCBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG4vKipcbiAqIFJldHVybnMgdGhlIEVDRFNBIHNpZ25hdHVyZSBvZiBhIG1lc3NhZ2UgaGFzaC5cbiAqXG4gKiBJZiBgY2hhaW5JZGAgaXMgcHJvdmlkZWQgYXNzdW1lIGFuIEVJUC0xNTUtc3R5bGUgc2lnbmF0dXJlIGFuZCBjYWxjdWxhdGUgdGhlIGB2YCB2YWx1ZVxuICogYWNjb3JkaW5nbHksIG90aGVyd2lzZSByZXR1cm4gYSBcInN0YXRpY1wiIGB2YCBqdXN0IGRlcml2ZWQgZnJvbSB0aGUgYHJlY292ZXJ5YCBiaXRcbiAqL1xuZnVuY3Rpb24gZWNzaWduKG1zZ0hhc2gsIHByaXZhdGVLZXksIGNoYWluSWQpIHtcbiAgICBjb25zdCBzaWcgPSBzZWNwMjU2azFfMS5zZWNwMjU2azEuc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KTtcbiAgICBjb25zdCBidWYgPSBzaWcudG9Db21wYWN0UmF3Qnl0ZXMoKTtcbiAgICBjb25zdCByID0gQnVmZmVyLmZyb20oYnVmLnNsaWNlKDAsIDMyKSk7XG4gICAgY29uc3QgcyA9IEJ1ZmZlci5mcm9tKGJ1Zi5zbGljZSgzMiwgNjQpKTtcbiAgICBjb25zdCB2ID0gY2hhaW5JZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gQmlnSW50KHNpZy5yZWNvdmVyeSArIDI3KVxuICAgICAgICA6IEJpZ0ludChzaWcucmVjb3ZlcnkgKyAzNSkgKyBCaWdJbnQoY2hhaW5JZCkgKiBCaWdJbnQoMik7XG4gICAgcmV0dXJuIHsgciwgcywgdiB9O1xufVxuZXhwb3J0cy5lY3NpZ24gPSBlY3NpZ247XG5mdW5jdGlvbiBjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKSB7XG4gICAgaWYgKHYgPT09IEJpZ0ludCgwKSB8fCB2ID09PSBCaWdJbnQoMSkpXG4gICAgICAgIHJldHVybiB2O1xuICAgIGlmIChjaGFpbklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHYgLSBCaWdJbnQoMjcpO1xuICAgIH1cbiAgICByZXR1cm4gdiAtIChjaGFpbklkICogQmlnSW50KDIpICsgQmlnSW50KDM1KSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkU2lnUmVjb3ZlcnkocmVjb3ZlcnkpIHtcbiAgICByZXR1cm4gcmVjb3ZlcnkgPT09IEJpZ0ludCgwKSB8fCByZWNvdmVyeSA9PT0gQmlnSW50KDEpO1xufVxuLyoqXG4gKiBFQ0RTQSBwdWJsaWMga2V5IHJlY292ZXJ5IGZyb20gc2lnbmF0dXJlLlxuICogTk9URTogQWNjZXB0cyBgdiA9PT0gMCB8IHYgPT09IDFgIGZvciBFSVAxNTU5IHRyYW5zYWN0aW9uc1xuICogQHJldHVybnMgUmVjb3ZlcmVkIHB1YmxpYyBrZXlcbiAqL1xuY29uc3QgZWNyZWNvdmVyID0gZnVuY3Rpb24gKG1zZ0hhc2gsIHYsIHIsIHMsIGNoYWluSWQpIHtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBCdWZmZXIuY29uY2F0KFsoMCwgYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KShyLCAzMiksICgwLCBieXRlc18xLnNldExlbmd0aExlZnQpKHMsIDMyKV0sIDY0KTtcbiAgICBjb25zdCByZWNvdmVyeSA9IGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpO1xuICAgIGlmICghaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIHYgdmFsdWUnKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLlNpZ25hdHVyZS5mcm9tQ29tcGFjdChzaWduYXR1cmUpLmFkZFJlY292ZXJ5Qml0KE51bWJlcihyZWNvdmVyeSkpO1xuICAgIGNvbnN0IHNlbmRlclB1YktleSA9IHNpZy5yZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZW5kZXJQdWJLZXkudG9SYXdCeXRlcyhmYWxzZSkuc2xpY2UoMSkpO1xufTtcbmV4cG9ydHMuZWNyZWNvdmVyID0gZWNyZWNvdmVyO1xuLyoqXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBwYXJhbWV0ZXJzIGludG8gdGhlIGZvcm1hdCBvZiBgZXRoX3NpZ25gIFJQQyBtZXRob2QuXG4gKiBOT1RFOiBBY2NlcHRzIGB2ID09PSAwIHwgdiA9PT0gMWAgZm9yIEVJUDE1NTkgdHJhbnNhY3Rpb25zXG4gKiBAcmV0dXJucyBTaWduYXR1cmVcbiAqL1xuY29uc3QgdG9ScGNTaWcgPSBmdW5jdGlvbiAodiwgciwgcywgY2hhaW5JZCkge1xuICAgIGNvbnN0IHJlY292ZXJ5ID0gY2FsY3VsYXRlU2lnUmVjb3ZlcnkodiwgY2hhaW5JZCk7XG4gICAgaWYgKCFpc1ZhbGlkU2lnUmVjb3ZlcnkocmVjb3ZlcnkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgdiB2YWx1ZScpO1xuICAgIH1cbiAgICAvLyBnZXRoIChhbmQgdGhlIFJQQyBldGhfc2lnbiBtZXRob2QpIHVzZXMgdGhlIDY1IGJ5dGUgZm9ybWF0IHVzZWQgYnkgQml0Y29pblxuICAgIHJldHVybiAoMCwgYnl0ZXNfMS5idWZmZXJUb0hleCkoQnVmZmVyLmNvbmNhdChbKDAsIGJ5dGVzXzEuc2V0TGVuZ3RoTGVmdCkociwgMzIpLCAoMCwgYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KShzLCAzMiksICgwLCBieXRlc18xLnRvQnVmZmVyKSh2KV0pKTtcbn07XG5leHBvcnRzLnRvUnBjU2lnID0gdG9ScGNTaWc7XG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIHBhcmFtZXRlcnMgaW50byB0aGUgZm9ybWF0IG9mIENvbXBhY3QgU2lnbmF0dXJlIFJlcHJlc2VudGF0aW9uIChFSVAtMjA5OCkuXG4gKiBOT1RFOiBBY2NlcHRzIGB2ID09PSAwIHwgdiA9PT0gMWAgZm9yIEVJUDE1NTkgdHJhbnNhY3Rpb25zXG4gKiBAcmV0dXJucyBTaWduYXR1cmVcbiAqL1xuY29uc3QgdG9Db21wYWN0U2lnID0gZnVuY3Rpb24gKHYsIHIsIHMsIGNoYWluSWQpIHtcbiAgICBjb25zdCByZWNvdmVyeSA9IGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpO1xuICAgIGlmICghaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIHYgdmFsdWUnKTtcbiAgICB9XG4gICAgbGV0IHNzID0gcztcbiAgICBpZiAoKHYgPiBCaWdJbnQoMjgpICYmIHYgJSBCaWdJbnQoMikgPT09IEJpZ0ludCgxKSkgfHwgdiA9PT0gQmlnSW50KDEpIHx8IHYgPT09IEJpZ0ludCgyOCkpIHtcbiAgICAgICAgc3MgPSBCdWZmZXIuZnJvbShzKTtcbiAgICAgICAgc3NbMF0gfD0gMHg4MDtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBieXRlc18xLmJ1ZmZlclRvSGV4KShCdWZmZXIuY29uY2F0KFsoMCwgYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KShyLCAzMiksICgwLCBieXRlc18xLnNldExlbmd0aExlZnQpKHNzLCAzMildKSk7XG59O1xuZXhwb3J0cy50b0NvbXBhY3RTaWcgPSB0b0NvbXBhY3RTaWc7XG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIGZvcm1hdCBvZiB0aGUgYGV0aF9zaWduYCBSUEMgbWV0aG9kIHRvIHNpZ25hdHVyZSBwYXJhbWV0ZXJzXG4gKlxuICogTk9URTogRm9yIGFuIGV4dHJhY3RlZCBgdmAgdmFsdWUgPCAyNyAoc2VlIEdldGggYnVnIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMjA1MylcbiAqIGB2ICsgMjdgIGlzIHJldHVybmVkIGZvciB0aGUgYHZgIHZhbHVlXG4gKiBOT1RFOiBBZnRlciBFSVAxNTU5LCBgdmAgY291bGQgYmUgYDBgIG9yIGAxYCBidXQgdGhpcyBmdW5jdGlvbiBhc3N1bWVzXG4gKiBpdCdzIGEgc2lnbmVkIG1lc3NhZ2UgKEVJUC0xOTEgb3IgRUlQLTcxMikgYWRkaW5nIGAyN2AgYXQgdGhlIGVuZC4gUmVtb3ZlIGlmIG5lZWRlZC5cbiAqL1xuY29uc3QgZnJvbVJwY1NpZyA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgICBjb25zdCBidWYgPSAoMCwgYnl0ZXNfMS50b0J1ZmZlcikoc2lnKTtcbiAgICBsZXQgcjtcbiAgICBsZXQgcztcbiAgICBsZXQgdjtcbiAgICBpZiAoYnVmLmxlbmd0aCA+PSA2NSkge1xuICAgICAgICByID0gYnVmLnNsaWNlKDAsIDMyKTtcbiAgICAgICAgcyA9IGJ1Zi5zbGljZSgzMiwgNjQpO1xuICAgICAgICB2ID0gKDAsIGJ5dGVzXzEuYnVmZmVyVG9CaWdJbnQpKGJ1Zi5zbGljZSg2NCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChidWYubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAvLyBDb21wYWN0IFNpZ25hdHVyZSBSZXByZXNlbnRhdGlvbiAoaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0yMDk4KVxuICAgICAgICByID0gYnVmLnNsaWNlKDAsIDMyKTtcbiAgICAgICAgcyA9IGJ1Zi5zbGljZSgzMiwgNjQpO1xuICAgICAgICB2ID0gQmlnSW50KCgwLCBieXRlc18xLmJ1ZmZlclRvSW50KShidWYuc2xpY2UoMzIsIDMzKSkgPj4gNyk7XG4gICAgICAgIHNbMF0gJj0gMHg3ZjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoJyk7XG4gICAgfVxuICAgIC8vIHN1cHBvcnQgYm90aCB2ZXJzaW9ucyBvZiBgZXRoX3NpZ25gIHJlc3BvbnNlc1xuICAgIGlmICh2IDwgMjcpIHtcbiAgICAgICAgdiA9IHYgKyBCaWdJbnQoMjcpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB2LFxuICAgICAgICByLFxuICAgICAgICBzLFxuICAgIH07XG59O1xuZXhwb3J0cy5mcm9tUnBjU2lnID0gZnJvbVJwY1NpZztcbi8qKlxuICogVmFsaWRhdGUgYSBFQ0RTQSBzaWduYXR1cmUuXG4gKiBOT1RFOiBBY2NlcHRzIGB2ID09PSAwIHwgdiA9PT0gMWAgZm9yIEVJUDE1NTkgdHJhbnNhY3Rpb25zXG4gKiBAcGFyYW0gaG9tZXN0ZWFkT3JMYXRlciBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGJlaW5nIHVzZWQgb24gZWl0aGVyIHRoZSBob21lc3RlYWQgaGFyZGZvcmsgb3IgYSBsYXRlciBvbmVcbiAqL1xuY29uc3QgaXNWYWxpZFNpZ25hdHVyZSA9IGZ1bmN0aW9uICh2LCByLCBzLCBob21lc3RlYWRPckxhdGVyID0gdHJ1ZSwgY2hhaW5JZCkge1xuICAgIGlmIChyLmxlbmd0aCAhPT0gMzIgfHwgcy5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc1ZhbGlkU2lnUmVjb3ZlcnkoY2FsY3VsYXRlU2lnUmVjb3ZlcnkodiwgY2hhaW5JZCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgckJpZ0ludCA9ICgwLCBieXRlc18xLmJ1ZmZlclRvQmlnSW50KShyKTtcbiAgICBjb25zdCBzQmlnSW50ID0gKDAsIGJ5dGVzXzEuYnVmZmVyVG9CaWdJbnQpKHMpO1xuICAgIGlmIChyQmlnSW50ID09PSBCaWdJbnQoMCkgfHxcbiAgICAgICAgckJpZ0ludCA+PSBjb25zdGFudHNfMS5TRUNQMjU2SzFfT1JERVIgfHxcbiAgICAgICAgc0JpZ0ludCA9PT0gQmlnSW50KDApIHx8XG4gICAgICAgIHNCaWdJbnQgPj0gY29uc3RhbnRzXzEuU0VDUDI1NksxX09SREVSKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGhvbWVzdGVhZE9yTGF0ZXIgJiYgc0JpZ0ludCA+PSBjb25zdGFudHNfMS5TRUNQMjU2SzFfT1JERVJfRElWXzIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5leHBvcnRzLmlzVmFsaWRTaWduYXR1cmUgPSBpc1ZhbGlkU2lnbmF0dXJlO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBrZWNjYWstMjU2IGhhc2ggb2YgYG1lc3NhZ2VgLCBwcmVmaXhlZCB3aXRoIHRoZSBoZWFkZXIgdXNlZCBieSB0aGUgYGV0aF9zaWduYCBSUEMgY2FsbC5cbiAqIFRoZSBvdXRwdXQgb2YgdGhpcyBmdW5jdGlvbiBjYW4gYmUgZmVkIGludG8gYGVjc2lnbmAgdG8gcHJvZHVjZSB0aGUgc2FtZSBzaWduYXR1cmUgYXMgdGhlIGBldGhfc2lnbmBcbiAqIGNhbGwgZm9yIGEgZ2l2ZW4gYG1lc3NhZ2VgLCBvciBmZWQgdG8gYGVjcmVjb3ZlcmAgYWxvbmcgd2l0aCBhIHNpZ25hdHVyZSB0byByZWNvdmVyIHRoZSBwdWJsaWMga2V5XG4gKiB1c2VkIHRvIHByb2R1Y2UgdGhlIHNpZ25hdHVyZS5cbiAqL1xuY29uc3QgaGFzaFBlcnNvbmFsTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikobWVzc2FnZSk7XG4gICAgY29uc3QgcHJlZml4ID0gQnVmZmVyLmZyb20oYFxcdTAwMTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG4ke21lc3NhZ2UubGVuZ3RofWAsICd1dGYtOCcpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KShCdWZmZXIuY29uY2F0KFtwcmVmaXgsIG1lc3NhZ2VdKSkpO1xufTtcbmV4cG9ydHMuaGFzaFBlcnNvbmFsTWVzc2FnZSA9IGhhc2hQZXJzb25hbE1lc3NhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduYXR1cmUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaGFzaFBlcnNvbmFsTWVzc2FnZSIsImlzVmFsaWRTaWduYXR1cmUiLCJmcm9tUnBjU2lnIiwidG9Db21wYWN0U2lnIiwidG9ScGNTaWciLCJlY3JlY292ZXIiLCJlY3NpZ24iLCJrZWNjYWtfMSIsInJlcXVpcmUiLCJzZWNwMjU2azFfMSIsImJ5dGVzXzEiLCJjb25zdGFudHNfMSIsImhlbHBlcnNfMSIsIm1zZ0hhc2giLCJwcml2YXRlS2V5IiwiY2hhaW5JZCIsInNpZyIsInNlY3AyNTZrMSIsInNpZ24iLCJidWYiLCJ0b0NvbXBhY3RSYXdCeXRlcyIsInIiLCJCdWZmZXIiLCJmcm9tIiwic2xpY2UiLCJzIiwidiIsInVuZGVmaW5lZCIsIkJpZ0ludCIsInJlY292ZXJ5IiwiY2FsY3VsYXRlU2lnUmVjb3ZlcnkiLCJpc1ZhbGlkU2lnUmVjb3ZlcnkiLCJzaWduYXR1cmUiLCJjb25jYXQiLCJzZXRMZW5ndGhMZWZ0IiwiRXJyb3IiLCJTaWduYXR1cmUiLCJmcm9tQ29tcGFjdCIsImFkZFJlY292ZXJ5Qml0IiwiTnVtYmVyIiwic2VuZGVyUHViS2V5IiwicmVjb3ZlclB1YmxpY0tleSIsInRvUmF3Qnl0ZXMiLCJidWZmZXJUb0hleCIsInRvQnVmZmVyIiwic3MiLCJsZW5ndGgiLCJidWZmZXJUb0JpZ0ludCIsImJ1ZmZlclRvSW50IiwiaG9tZXN0ZWFkT3JMYXRlciIsInJCaWdJbnQiLCJzQmlnSW50IiwiU0VDUDI1NksxX09SREVSIiwiU0VDUDI1NksxX09SREVSX0RJVl8yIiwibWVzc2FnZSIsImFzc2VydElzQnVmZmVyIiwicHJlZml4Iiwia2VjY2FrMjU2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethereumjs/util/dist/signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethereumjs/util/dist/types.js":
/*!*****************************************************!*\
  !*** ./node_modules/@ethereumjs/util/dist/types.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.toType = exports.TypeOutput = void 0;\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/@ethereumjs/util/dist/bytes.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/@ethereumjs/util/dist/internal.js\");\n/**\n * Type output options\n */ var TypeOutput;\n(function(TypeOutput) {\n    TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\n    TypeOutput[TypeOutput[\"BigInt\"] = 1] = \"BigInt\";\n    TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\n    TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\nfunction toType(input, outputType) {\n    if (input === null) {\n        return null;\n    }\n    if (input === undefined) {\n        return undefined;\n    }\n    if (typeof input === \"string\" && !(0, internal_1.isHexString)(input)) {\n        throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);\n    } else if (typeof input === \"number\" && !Number.isSafeInteger(input)) {\n        throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)\");\n    }\n    const output = (0, bytes_1.toBuffer)(input);\n    switch(outputType){\n        case TypeOutput.Buffer:\n            return output;\n        case TypeOutput.BigInt:\n            return (0, bytes_1.bufferToBigInt)(output);\n        case TypeOutput.Number:\n            {\n                const bigInt = (0, bytes_1.bufferToBigInt)(output);\n                if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {\n                    throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)\");\n                }\n                return Number(bigInt);\n            }\n        case TypeOutput.PrefixedHexString:\n            return (0, bytes_1.bufferToHex)(output);\n        default:\n            throw new Error(\"unknown outputType\");\n    }\n}\nexports.toType = toType; //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUdBLGtCQUFrQixHQUFHLEtBQUs7QUFDM0MsTUFBTUksVUFBVUMsbUJBQU9BLENBQUMsb0VBQVM7QUFDakMsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsMEVBQVk7QUFDdkM7O0NBRUMsR0FDRCxJQUFJRjtBQUNILFVBQVVBLFVBQVU7SUFDakJBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7SUFDdkNBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7SUFDdkNBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7SUFDdkNBLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDLG9CQUFvQixHQUFHLEVBQUUsR0FBRztBQUN0RCxHQUFHQSxhQUFhSCxRQUFRRyxVQUFVLElBQUtILENBQUFBLGtCQUFrQixHQUFHLENBQUM7QUFDN0QsU0FBU0UsT0FBT0ssS0FBSyxFQUFFQyxVQUFVO0lBQzdCLElBQUlELFVBQVUsTUFBTTtRQUNoQixPQUFPO0lBQ1g7SUFDQSxJQUFJQSxVQUFVRSxXQUFXO1FBQ3JCLE9BQU9BO0lBQ1g7SUFDQSxJQUFJLE9BQU9GLFVBQVUsWUFBWSxDQUFDLENBQUMsR0FBR0QsV0FBV0ksV0FBVyxFQUFFSCxRQUFRO1FBQ2xFLE1BQU0sSUFBSUksTUFBTSxDQUFDLG1EQUFtRCxFQUFFSixNQUFNLENBQUM7SUFDakYsT0FDSyxJQUFJLE9BQU9BLFVBQVUsWUFBWSxDQUFDSyxPQUFPQyxhQUFhLENBQUNOLFFBQVE7UUFDaEUsTUFBTSxJQUFJSSxNQUFNO0lBQ3BCO0lBQ0EsTUFBTUcsU0FBUyxDQUFDLEdBQUdWLFFBQVFXLFFBQVEsRUFBRVI7SUFDckMsT0FBUUM7UUFDSixLQUFLTCxXQUFXYSxNQUFNO1lBQ2xCLE9BQU9GO1FBQ1gsS0FBS1gsV0FBV2MsTUFBTTtZQUNsQixPQUFPLENBQUMsR0FBR2IsUUFBUWMsY0FBYyxFQUFFSjtRQUN2QyxLQUFLWCxXQUFXUyxNQUFNO1lBQUU7Z0JBQ3BCLE1BQU1PLFNBQVMsQ0FBQyxHQUFHZixRQUFRYyxjQUFjLEVBQUVKO2dCQUMzQyxJQUFJSyxTQUFTRixPQUFPTCxPQUFPUSxnQkFBZ0IsR0FBRztvQkFDMUMsTUFBTSxJQUFJVCxNQUFNO2dCQUNwQjtnQkFDQSxPQUFPQyxPQUFPTztZQUNsQjtRQUNBLEtBQUtoQixXQUFXa0IsaUJBQWlCO1lBQzdCLE9BQU8sQ0FBQyxHQUFHakIsUUFBUWtCLFdBQVcsRUFBRVI7UUFDcEM7WUFDSSxNQUFNLElBQUlILE1BQU07SUFDeEI7QUFDSjtBQUNBWCxjQUFjLEdBQUdFLFFBQ2pCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L3R5cGVzLmpzPzYxMzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRvVHlwZSA9IGV4cG9ydHMuVHlwZU91dHB1dCA9IHZvaWQgMDtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbmNvbnN0IGludGVybmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbFwiKTtcbi8qKlxuICogVHlwZSBvdXRwdXQgb3B0aW9uc1xuICovXG52YXIgVHlwZU91dHB1dDtcbihmdW5jdGlvbiAoVHlwZU91dHB1dCkge1xuICAgIFR5cGVPdXRwdXRbVHlwZU91dHB1dFtcIk51bWJlclwiXSA9IDBdID0gXCJOdW1iZXJcIjtcbiAgICBUeXBlT3V0cHV0W1R5cGVPdXRwdXRbXCJCaWdJbnRcIl0gPSAxXSA9IFwiQmlnSW50XCI7XG4gICAgVHlwZU91dHB1dFtUeXBlT3V0cHV0W1wiQnVmZmVyXCJdID0gMl0gPSBcIkJ1ZmZlclwiO1xuICAgIFR5cGVPdXRwdXRbVHlwZU91dHB1dFtcIlByZWZpeGVkSGV4U3RyaW5nXCJdID0gM10gPSBcIlByZWZpeGVkSGV4U3RyaW5nXCI7XG59KShUeXBlT3V0cHV0ID0gZXhwb3J0cy5UeXBlT3V0cHV0IHx8IChleHBvcnRzLlR5cGVPdXRwdXQgPSB7fSkpO1xuZnVuY3Rpb24gdG9UeXBlKGlucHV0LCBvdXRwdXRUeXBlKSB7XG4gICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyAmJiAhKDAsIGludGVybmFsXzEuaXNIZXhTdHJpbmcpKGlucHV0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgc3RyaW5nIG11c3QgYmUgcHJvdmlkZWQgd2l0aCBhIDB4LXByZWZpeCwgZ2l2ZW46ICR7aW5wdXR9YCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgJiYgIU51bWJlci5pc1NhZmVJbnRlZ2VyKGlucHV0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBudW1iZXIgaXMgZ3JlYXRlciB0aGFuIE1BWF9TQUZFX0lOVEVHRVIgKHBsZWFzZSB1c2UgYW4gYWx0ZXJuYXRpdmUgaW5wdXQgdHlwZSknKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0ID0gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKGlucHV0KTtcbiAgICBzd2l0Y2ggKG91dHB1dFR5cGUpIHtcbiAgICAgICAgY2FzZSBUeXBlT3V0cHV0LkJ1ZmZlcjpcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIGNhc2UgVHlwZU91dHB1dC5CaWdJbnQ6XG4gICAgICAgICAgICByZXR1cm4gKDAsIGJ5dGVzXzEuYnVmZmVyVG9CaWdJbnQpKG91dHB1dCk7XG4gICAgICAgIGNhc2UgVHlwZU91dHB1dC5OdW1iZXI6IHtcbiAgICAgICAgICAgIGNvbnN0IGJpZ0ludCA9ICgwLCBieXRlc18xLmJ1ZmZlclRvQmlnSW50KShvdXRwdXQpO1xuICAgICAgICAgICAgaWYgKGJpZ0ludCA+IEJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBudW1iZXIgaXMgZ3JlYXRlciB0aGFuIE1BWF9TQUZFX0lOVEVHRVIgKHBsZWFzZSB1c2UgYW4gYWx0ZXJuYXRpdmUgb3V0cHV0IHR5cGUpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKGJpZ0ludCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBUeXBlT3V0cHV0LlByZWZpeGVkSGV4U3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuICgwLCBieXRlc18xLmJ1ZmZlclRvSGV4KShvdXRwdXQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIG91dHB1dFR5cGUnKTtcbiAgICB9XG59XG5leHBvcnRzLnRvVHlwZSA9IHRvVHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInRvVHlwZSIsIlR5cGVPdXRwdXQiLCJieXRlc18xIiwicmVxdWlyZSIsImludGVybmFsXzEiLCJpbnB1dCIsIm91dHB1dFR5cGUiLCJ1bmRlZmluZWQiLCJpc0hleFN0cmluZyIsIkVycm9yIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIm91dHB1dCIsInRvQnVmZmVyIiwiQnVmZmVyIiwiQmlnSW50IiwiYnVmZmVyVG9CaWdJbnQiLCJiaWdJbnQiLCJNQVhfU0FGRV9JTlRFR0VSIiwiUHJlZml4ZWRIZXhTdHJpbmciLCJidWZmZXJUb0hleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethereumjs/util/dist/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethereumjs/util/dist/units.js":
/*!*****************************************************!*\
  !*** ./node_modules/@ethereumjs/util/dist/units.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.GWEI_TO_WEI = void 0;\n/** Easy conversion from Gwei to wei */ exports.GWEI_TO_WEI = BigInt(1000000000); //# sourceMappingURL=units.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L3VuaXRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQkFBbUIsR0FBRyxLQUFLO0FBQzNCLHFDQUFxQyxHQUNyQ0EsbUJBQW1CLEdBQUdHLE9BQU8sYUFDN0IsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AZXRoZXJldW1qcy91dGlsL2Rpc3QvdW5pdHMuanM/ZGI4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR1dFSV9UT19XRUkgPSB2b2lkIDA7XG4vKiogRWFzeSBjb252ZXJzaW9uIGZyb20gR3dlaSB0byB3ZWkgKi9cbmV4cG9ydHMuR1dFSV9UT19XRUkgPSBCaWdJbnQoMTAwMDAwMDAwMCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bml0cy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJHV0VJX1RPX1dFSSIsIkJpZ0ludCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethereumjs/util/dist/units.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethereumjs/util/dist/withdrawal.js":
/*!**********************************************************!*\
  !*** ./node_modules/@ethereumjs/util/dist/withdrawal.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Withdrawal = void 0;\nconst address_1 = __webpack_require__(/*! ./address */ \"(ssr)/./node_modules/@ethereumjs/util/dist/address.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/@ethereumjs/util/dist/bytes.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@ethereumjs/util/dist/types.js\");\n/**\n * Representation of EIP-4895 withdrawal data\n */ class Withdrawal {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating a Withdrawal object from varying data types.\n     * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot\n     */ constructor(index, validatorIndex, address, /**\n     * withdrawal amount in Gwei to match the CL repesentation and eventually ssz withdrawalsRoot\n     */ amount){\n        this.index = index;\n        this.validatorIndex = validatorIndex;\n        this.address = address;\n        this.amount = amount;\n    }\n    static fromWithdrawalData(withdrawalData) {\n        const { index: indexData, validatorIndex: validatorIndexData, address: addressData, amount: amountData } = withdrawalData;\n        const index = (0, types_1.toType)(indexData, types_1.TypeOutput.BigInt);\n        const validatorIndex = (0, types_1.toType)(validatorIndexData, types_1.TypeOutput.BigInt);\n        const address = new address_1.Address((0, types_1.toType)(addressData, types_1.TypeOutput.Buffer));\n        const amount = (0, types_1.toType)(amountData, types_1.TypeOutput.BigInt);\n        return new Withdrawal(index, validatorIndex, address, amount);\n    }\n    static fromValuesArray(withdrawalArray) {\n        if (withdrawalArray.length !== 4) {\n            throw Error(`Invalid withdrawalArray length expected=4 actual=${withdrawalArray.length}`);\n        }\n        const [index, validatorIndex, address, amount] = withdrawalArray;\n        return Withdrawal.fromWithdrawalData({\n            index,\n            validatorIndex,\n            address,\n            amount\n        });\n    }\n    /**\n     * Convert a withdrawal to a buffer array\n     * @param withdrawal the withdrawal to convert\n     * @returns buffer array of the withdrawal\n     */ static toBufferArray(withdrawal) {\n        const { index, validatorIndex, address, amount } = withdrawal;\n        const indexBuffer = (0, types_1.toType)(index, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(index, types_1.TypeOutput.Buffer);\n        const validatorIndexBuffer = (0, types_1.toType)(validatorIndex, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(validatorIndex, types_1.TypeOutput.Buffer);\n        let addressBuffer;\n        if (address instanceof address_1.Address) {\n            addressBuffer = address.buf;\n        } else {\n            addressBuffer = (0, types_1.toType)(address, types_1.TypeOutput.Buffer);\n        }\n        const amountBuffer = (0, types_1.toType)(amount, types_1.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, types_1.toType)(amount, types_1.TypeOutput.Buffer);\n        return [\n            indexBuffer,\n            validatorIndexBuffer,\n            addressBuffer,\n            amountBuffer\n        ];\n    }\n    raw() {\n        return Withdrawal.toBufferArray(this);\n    }\n    toValue() {\n        return {\n            index: this.index,\n            validatorIndex: this.validatorIndex,\n            address: this.address.buf,\n            amount: this.amount\n        };\n    }\n    toJSON() {\n        return {\n            index: (0, bytes_1.bigIntToHex)(this.index),\n            validatorIndex: (0, bytes_1.bigIntToHex)(this.validatorIndex),\n            address: \"0x\" + this.address.buf.toString(\"hex\"),\n            amount: (0, bytes_1.bigIntToHex)(this.amount)\n        };\n    }\n}\nexports.Withdrawal = Withdrawal; //# sourceMappingURL=withdrawal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L3dpdGhkcmF3YWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtCQUFrQixHQUFHLEtBQUs7QUFDMUIsTUFBTUcsWUFBWUMsbUJBQU9BLENBQUMsd0VBQVc7QUFDckMsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsb0VBQVM7QUFDakMsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMsb0VBQVM7QUFDakM7O0NBRUMsR0FDRCxNQUFNRjtJQUNGOzs7O0tBSUMsR0FDREssWUFBWUMsS0FBSyxFQUFFQyxjQUFjLEVBQUVDLE9BQU8sRUFDMUM7O0tBRUMsR0FDREMsTUFBTSxDQUFFO1FBQ0osSUFBSSxDQUFDSCxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxjQUFjLEdBQUdBO1FBQ3RCLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtJQUNsQjtJQUNBLE9BQU9DLG1CQUFtQkMsY0FBYyxFQUFFO1FBQ3RDLE1BQU0sRUFBRUwsT0FBT00sU0FBUyxFQUFFTCxnQkFBZ0JNLGtCQUFrQixFQUFFTCxTQUFTTSxXQUFXLEVBQUVMLFFBQVFNLFVBQVUsRUFBRyxHQUFHSjtRQUM1RyxNQUFNTCxRQUFRLENBQUMsR0FBR0YsUUFBUVksTUFBTSxFQUFFSixXQUFXUixRQUFRYSxVQUFVLENBQUNDLE1BQU07UUFDdEUsTUFBTVgsaUJBQWlCLENBQUMsR0FBR0gsUUFBUVksTUFBTSxFQUFFSCxvQkFBb0JULFFBQVFhLFVBQVUsQ0FBQ0MsTUFBTTtRQUN4RixNQUFNVixVQUFVLElBQUlQLFVBQVVrQixPQUFPLENBQUMsQ0FBQyxHQUFHZixRQUFRWSxNQUFNLEVBQUVGLGFBQWFWLFFBQVFhLFVBQVUsQ0FBQ0csTUFBTTtRQUNoRyxNQUFNWCxTQUFTLENBQUMsR0FBR0wsUUFBUVksTUFBTSxFQUFFRCxZQUFZWCxRQUFRYSxVQUFVLENBQUNDLE1BQU07UUFDeEUsT0FBTyxJQUFJbEIsV0FBV00sT0FBT0MsZ0JBQWdCQyxTQUFTQztJQUMxRDtJQUNBLE9BQU9ZLGdCQUFnQkMsZUFBZSxFQUFFO1FBQ3BDLElBQUlBLGdCQUFnQkMsTUFBTSxLQUFLLEdBQUc7WUFDOUIsTUFBTUMsTUFBTSxDQUFDLGlEQUFpRCxFQUFFRixnQkFBZ0JDLE1BQU0sQ0FBQyxDQUFDO1FBQzVGO1FBQ0EsTUFBTSxDQUFDakIsT0FBT0MsZ0JBQWdCQyxTQUFTQyxPQUFPLEdBQUdhO1FBQ2pELE9BQU90QixXQUFXVSxrQkFBa0IsQ0FBQztZQUFFSjtZQUFPQztZQUFnQkM7WUFBU0M7UUFBTztJQUNsRjtJQUNBOzs7O0tBSUMsR0FDRCxPQUFPZ0IsY0FBY0MsVUFBVSxFQUFFO1FBQzdCLE1BQU0sRUFBRXBCLEtBQUssRUFBRUMsY0FBYyxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRSxHQUFHaUI7UUFDbkQsTUFBTUMsY0FBYyxDQUFDLEdBQUd2QixRQUFRWSxNQUFNLEVBQUVWLE9BQU9GLFFBQVFhLFVBQVUsQ0FBQ0MsTUFBTSxNQUFNQSxPQUFPLEtBQy9FRSxPQUFPUSxLQUFLLENBQUMsS0FDYixDQUFDLEdBQUd4QixRQUFRWSxNQUFNLEVBQUVWLE9BQU9GLFFBQVFhLFVBQVUsQ0FBQ0csTUFBTTtRQUMxRCxNQUFNUyx1QkFBdUIsQ0FBQyxHQUFHekIsUUFBUVksTUFBTSxFQUFFVCxnQkFBZ0JILFFBQVFhLFVBQVUsQ0FBQ0MsTUFBTSxNQUFNQSxPQUFPLEtBQ2pHRSxPQUFPUSxLQUFLLENBQUMsS0FDYixDQUFDLEdBQUd4QixRQUFRWSxNQUFNLEVBQUVULGdCQUFnQkgsUUFBUWEsVUFBVSxDQUFDRyxNQUFNO1FBQ25FLElBQUlVO1FBQ0osSUFBSXRCLG1CQUFtQlAsVUFBVWtCLE9BQU8sRUFBRTtZQUN0Q1csZ0JBQWdCdEIsUUFBUXVCLEdBQUc7UUFDL0IsT0FDSztZQUNERCxnQkFBZ0IsQ0FBQyxHQUFHMUIsUUFBUVksTUFBTSxFQUFFUixTQUFTSixRQUFRYSxVQUFVLENBQUNHLE1BQU07UUFDMUU7UUFDQSxNQUFNWSxlQUFlLENBQUMsR0FBRzVCLFFBQVFZLE1BQU0sRUFBRVAsUUFBUUwsUUFBUWEsVUFBVSxDQUFDQyxNQUFNLE1BQU1BLE9BQU8sS0FDakZFLE9BQU9RLEtBQUssQ0FBQyxLQUNiLENBQUMsR0FBR3hCLFFBQVFZLE1BQU0sRUFBRVAsUUFBUUwsUUFBUWEsVUFBVSxDQUFDRyxNQUFNO1FBQzNELE9BQU87WUFBQ087WUFBYUU7WUFBc0JDO1lBQWVFO1NBQWE7SUFDM0U7SUFDQUMsTUFBTTtRQUNGLE9BQU9qQyxXQUFXeUIsYUFBYSxDQUFDLElBQUk7SUFDeEM7SUFDQVMsVUFBVTtRQUNOLE9BQU87WUFDSDVCLE9BQU8sSUFBSSxDQUFDQSxLQUFLO1lBQ2pCQyxnQkFBZ0IsSUFBSSxDQUFDQSxjQUFjO1lBQ25DQyxTQUFTLElBQUksQ0FBQ0EsT0FBTyxDQUFDdUIsR0FBRztZQUN6QnRCLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1FBQ3ZCO0lBQ0o7SUFDQTBCLFNBQVM7UUFDTCxPQUFPO1lBQ0g3QixPQUFPLENBQUMsR0FBR0gsUUFBUWlDLFdBQVcsRUFBRSxJQUFJLENBQUM5QixLQUFLO1lBQzFDQyxnQkFBZ0IsQ0FBQyxHQUFHSixRQUFRaUMsV0FBVyxFQUFFLElBQUksQ0FBQzdCLGNBQWM7WUFDNURDLFNBQVMsT0FBTyxJQUFJLENBQUNBLE9BQU8sQ0FBQ3VCLEdBQUcsQ0FBQ00sUUFBUSxDQUFDO1lBQzFDNUIsUUFBUSxDQUFDLEdBQUdOLFFBQVFpQyxXQUFXLEVBQUUsSUFBSSxDQUFDM0IsTUFBTTtRQUNoRDtJQUNKO0FBQ0o7QUFDQVgsa0JBQWtCLEdBQUdFLFlBQ3JCLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvQGV0aGVyZXVtanMvdXRpbC9kaXN0L3dpdGhkcmF3YWwuanM/YmYxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2l0aGRyYXdhbCA9IHZvaWQgMDtcbmNvbnN0IGFkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3NcIik7XG5jb25zdCBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIEVJUC00ODk1IHdpdGhkcmF3YWwgZGF0YVxuICovXG5jbGFzcyBXaXRoZHJhd2FsIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNvbnN0cnVjdG9yIGFzc2lnbnMgYW5kIHZhbGlkYXRlcyB0aGUgdmFsdWVzLlxuICAgICAqIFVzZSB0aGUgc3RhdGljIGZhY3RvcnkgbWV0aG9kcyB0byBhc3Npc3QgaW4gY3JlYXRpbmcgYSBXaXRoZHJhd2FsIG9iamVjdCBmcm9tIHZhcnlpbmcgZGF0YSB0eXBlcy5cbiAgICAgKiBJdHMgYW1vdW50IGlzIGluIEd3ZWkgdG8gbWF0Y2ggQ0wgcmVwcmVzZW50YXRpb24gYW5kIGZvciBldmVudHVhbCBzc3ogd2l0aGRyYXdhbHNSb290XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaW5kZXgsIHZhbGlkYXRvckluZGV4LCBhZGRyZXNzLCBcbiAgICAvKipcbiAgICAgKiB3aXRoZHJhd2FsIGFtb3VudCBpbiBHd2VpIHRvIG1hdGNoIHRoZSBDTCByZXBlc2VudGF0aW9uIGFuZCBldmVudHVhbGx5IHNzeiB3aXRoZHJhd2Fsc1Jvb3RcbiAgICAgKi9cbiAgICBhbW91bnQpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnZhbGlkYXRvckluZGV4ID0gdmFsaWRhdG9ySW5kZXg7XG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgIHRoaXMuYW1vdW50ID0gYW1vdW50O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVdpdGhkcmF3YWxEYXRhKHdpdGhkcmF3YWxEYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgaW5kZXg6IGluZGV4RGF0YSwgdmFsaWRhdG9ySW5kZXg6IHZhbGlkYXRvckluZGV4RGF0YSwgYWRkcmVzczogYWRkcmVzc0RhdGEsIGFtb3VudDogYW1vdW50RGF0YSwgfSA9IHdpdGhkcmF3YWxEYXRhO1xuICAgICAgICBjb25zdCBpbmRleCA9ICgwLCB0eXBlc18xLnRvVHlwZSkoaW5kZXhEYXRhLCB0eXBlc18xLlR5cGVPdXRwdXQuQmlnSW50KTtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9ySW5kZXggPSAoMCwgdHlwZXNfMS50b1R5cGUpKHZhbGlkYXRvckluZGV4RGF0YSwgdHlwZXNfMS5UeXBlT3V0cHV0LkJpZ0ludCk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBuZXcgYWRkcmVzc18xLkFkZHJlc3MoKDAsIHR5cGVzXzEudG9UeXBlKShhZGRyZXNzRGF0YSwgdHlwZXNfMS5UeXBlT3V0cHV0LkJ1ZmZlcikpO1xuICAgICAgICBjb25zdCBhbW91bnQgPSAoMCwgdHlwZXNfMS50b1R5cGUpKGFtb3VudERhdGEsIHR5cGVzXzEuVHlwZU91dHB1dC5CaWdJbnQpO1xuICAgICAgICByZXR1cm4gbmV3IFdpdGhkcmF3YWwoaW5kZXgsIHZhbGlkYXRvckluZGV4LCBhZGRyZXNzLCBhbW91bnQpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVZhbHVlc0FycmF5KHdpdGhkcmF3YWxBcnJheSkge1xuICAgICAgICBpZiAod2l0aGRyYXdhbEFycmF5Lmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEludmFsaWQgd2l0aGRyYXdhbEFycmF5IGxlbmd0aCBleHBlY3RlZD00IGFjdHVhbD0ke3dpdGhkcmF3YWxBcnJheS5sZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2luZGV4LCB2YWxpZGF0b3JJbmRleCwgYWRkcmVzcywgYW1vdW50XSA9IHdpdGhkcmF3YWxBcnJheTtcbiAgICAgICAgcmV0dXJuIFdpdGhkcmF3YWwuZnJvbVdpdGhkcmF3YWxEYXRhKHsgaW5kZXgsIHZhbGlkYXRvckluZGV4LCBhZGRyZXNzLCBhbW91bnQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSB3aXRoZHJhd2FsIHRvIGEgYnVmZmVyIGFycmF5XG4gICAgICogQHBhcmFtIHdpdGhkcmF3YWwgdGhlIHdpdGhkcmF3YWwgdG8gY29udmVydFxuICAgICAqIEByZXR1cm5zIGJ1ZmZlciBhcnJheSBvZiB0aGUgd2l0aGRyYXdhbFxuICAgICAqL1xuICAgIHN0YXRpYyB0b0J1ZmZlckFycmF5KHdpdGhkcmF3YWwpIHtcbiAgICAgICAgY29uc3QgeyBpbmRleCwgdmFsaWRhdG9ySW5kZXgsIGFkZHJlc3MsIGFtb3VudCB9ID0gd2l0aGRyYXdhbDtcbiAgICAgICAgY29uc3QgaW5kZXhCdWZmZXIgPSAoMCwgdHlwZXNfMS50b1R5cGUpKGluZGV4LCB0eXBlc18xLlR5cGVPdXRwdXQuQmlnSW50KSA9PT0gQmlnSW50KDApXG4gICAgICAgICAgICA/IEJ1ZmZlci5hbGxvYygwKVxuICAgICAgICAgICAgOiAoMCwgdHlwZXNfMS50b1R5cGUpKGluZGV4LCB0eXBlc18xLlR5cGVPdXRwdXQuQnVmZmVyKTtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9ySW5kZXhCdWZmZXIgPSAoMCwgdHlwZXNfMS50b1R5cGUpKHZhbGlkYXRvckluZGV4LCB0eXBlc18xLlR5cGVPdXRwdXQuQmlnSW50KSA9PT0gQmlnSW50KDApXG4gICAgICAgICAgICA/IEJ1ZmZlci5hbGxvYygwKVxuICAgICAgICAgICAgOiAoMCwgdHlwZXNfMS50b1R5cGUpKHZhbGlkYXRvckluZGV4LCB0eXBlc18xLlR5cGVPdXRwdXQuQnVmZmVyKTtcbiAgICAgICAgbGV0IGFkZHJlc3NCdWZmZXI7XG4gICAgICAgIGlmIChhZGRyZXNzIGluc3RhbmNlb2YgYWRkcmVzc18xLkFkZHJlc3MpIHtcbiAgICAgICAgICAgIGFkZHJlc3NCdWZmZXIgPSBhZGRyZXNzLmJ1ZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFkZHJlc3NCdWZmZXIgPSAoMCwgdHlwZXNfMS50b1R5cGUpKGFkZHJlc3MsIHR5cGVzXzEuVHlwZU91dHB1dC5CdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFtb3VudEJ1ZmZlciA9ICgwLCB0eXBlc18xLnRvVHlwZSkoYW1vdW50LCB0eXBlc18xLlR5cGVPdXRwdXQuQmlnSW50KSA9PT0gQmlnSW50KDApXG4gICAgICAgICAgICA/IEJ1ZmZlci5hbGxvYygwKVxuICAgICAgICAgICAgOiAoMCwgdHlwZXNfMS50b1R5cGUpKGFtb3VudCwgdHlwZXNfMS5UeXBlT3V0cHV0LkJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBbaW5kZXhCdWZmZXIsIHZhbGlkYXRvckluZGV4QnVmZmVyLCBhZGRyZXNzQnVmZmVyLCBhbW91bnRCdWZmZXJdO1xuICAgIH1cbiAgICByYXcoKSB7XG4gICAgICAgIHJldHVybiBXaXRoZHJhd2FsLnRvQnVmZmVyQXJyYXkodGhpcyk7XG4gICAgfVxuICAgIHRvVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgIHZhbGlkYXRvckluZGV4OiB0aGlzLnZhbGlkYXRvckluZGV4LFxuICAgICAgICAgICAgYWRkcmVzczogdGhpcy5hZGRyZXNzLmJ1ZixcbiAgICAgICAgICAgIGFtb3VudDogdGhpcy5hbW91bnQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluZGV4OiAoMCwgYnl0ZXNfMS5iaWdJbnRUb0hleCkodGhpcy5pbmRleCksXG4gICAgICAgICAgICB2YWxpZGF0b3JJbmRleDogKDAsIGJ5dGVzXzEuYmlnSW50VG9IZXgpKHRoaXMudmFsaWRhdG9ySW5kZXgpLFxuICAgICAgICAgICAgYWRkcmVzczogJzB4JyArIHRoaXMuYWRkcmVzcy5idWYudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgYW1vdW50OiAoMCwgYnl0ZXNfMS5iaWdJbnRUb0hleCkodGhpcy5hbW91bnQpLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuV2l0aGRyYXdhbCA9IFdpdGhkcmF3YWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aXRoZHJhd2FsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIldpdGhkcmF3YWwiLCJhZGRyZXNzXzEiLCJyZXF1aXJlIiwiYnl0ZXNfMSIsInR5cGVzXzEiLCJjb25zdHJ1Y3RvciIsImluZGV4IiwidmFsaWRhdG9ySW5kZXgiLCJhZGRyZXNzIiwiYW1vdW50IiwiZnJvbVdpdGhkcmF3YWxEYXRhIiwid2l0aGRyYXdhbERhdGEiLCJpbmRleERhdGEiLCJ2YWxpZGF0b3JJbmRleERhdGEiLCJhZGRyZXNzRGF0YSIsImFtb3VudERhdGEiLCJ0b1R5cGUiLCJUeXBlT3V0cHV0IiwiQmlnSW50IiwiQWRkcmVzcyIsIkJ1ZmZlciIsImZyb21WYWx1ZXNBcnJheSIsIndpdGhkcmF3YWxBcnJheSIsImxlbmd0aCIsIkVycm9yIiwidG9CdWZmZXJBcnJheSIsIndpdGhkcmF3YWwiLCJpbmRleEJ1ZmZlciIsImFsbG9jIiwidmFsaWRhdG9ySW5kZXhCdWZmZXIiLCJhZGRyZXNzQnVmZmVyIiwiYnVmIiwiYW1vdW50QnVmZmVyIiwicmF3IiwidG9WYWx1ZSIsInRvSlNPTiIsImJpZ0ludFRvSGV4IiwidG9TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethereumjs/util/dist/withdrawal.js\n");

/***/ })

};
;