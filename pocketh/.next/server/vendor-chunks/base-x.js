"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/base-x";
exports.ids = ["vendor-chunks/base-x"];
exports.modules = {

/***/ "(ssr)/./node_modules/base-x/src/index.js":
/*!******************************************!*\
  !*** ./node_modules/base-x/src/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = (__webpack_require__(/*! safe-buffer */ \"(ssr)/./node_modules/safe-buffer/index.js\").Buffer);\nfunction base(ALPHABET) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError(\"Alphabet too long\");\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for(var j = 0; j < BASE_MAP.length; j++){\n        BASE_MAP[j] = 255;\n    }\n    for(var i = 0; i < ALPHABET.length; i++){\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + \" is ambiguous\");\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n    ;\n    var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n    ;\n    function encode(source) {\n        if (Array.isArray(source) || source instanceof Uint8Array) {\n            source = _Buffer.from(source);\n        }\n        if (!_Buffer.isBuffer(source)) {\n            throw new TypeError(\"Expected Buffer\");\n        }\n        if (source.length === 0) {\n            return \"\";\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while(pbegin !== pend && source[pbegin] === 0){\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while(pbegin !== pend){\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){\n                carry += 256 * b58[it1] >>> 0;\n                b58[it1] = carry % BASE >>> 0;\n                carry = carry / BASE >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while(it2 !== size && b58[it2] === 0){\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for(; it2 < size; ++it2){\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    function decodeUnsafe(source) {\n        if (typeof source !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        if (source.length === 0) {\n            return _Buffer.alloc(0);\n        }\n        var psz = 0;\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while(source[psz] === LEADER){\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (source.length - psz) * FACTOR + 1 >>> 0 // log(58) / log(256), rounded up.\n        ;\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while(source[psz]){\n            // Decode character\n            var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){\n                carry += BASE * b256[it3] >>> 0;\n                b256[it3] = carry % 256 >>> 0;\n                carry = carry / 256 >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            psz++;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while(it4 !== size && b256[it4] === 0){\n            it4++;\n        }\n        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));\n        vch.fill(0x00, 0, zeroes);\n        var j = zeroes;\n        while(it4 !== size){\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(\"Non-base\" + BASE + \" character\");\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nmodule.exports = base;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFzZS14L3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLDZCQUE2QjtBQUM3Qix5Q0FBeUM7QUFDekMsbUVBQW1FO0FBQ25FLG1FQUFtRTtBQUNuRSxzRUFBc0U7QUFDdEUsYUFBYTtBQUNiLElBQUlBLFVBQVVDLDRGQUE2QjtBQUMzQyxTQUFTRSxLQUFNQyxRQUFRO0lBQ3JCLElBQUlBLFNBQVNDLE1BQU0sSUFBSSxLQUFLO1FBQUUsTUFBTSxJQUFJQyxVQUFVO0lBQXFCO0lBQ3ZFLElBQUlDLFdBQVcsSUFBSUMsV0FBVztJQUM5QixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsU0FBU0YsTUFBTSxFQUFFSSxJQUFLO1FBQ3hDRixRQUFRLENBQUNFLEVBQUUsR0FBRztJQUNoQjtJQUNBLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTixTQUFTQyxNQUFNLEVBQUVLLElBQUs7UUFDeEMsSUFBSUMsSUFBSVAsU0FBU1EsTUFBTSxDQUFDRjtRQUN4QixJQUFJRyxLQUFLRixFQUFFRyxVQUFVLENBQUM7UUFDdEIsSUFBSVAsUUFBUSxDQUFDTSxHQUFHLEtBQUssS0FBSztZQUFFLE1BQU0sSUFBSVAsVUFBVUssSUFBSTtRQUFpQjtRQUNyRUosUUFBUSxDQUFDTSxHQUFHLEdBQUdIO0lBQ2pCO0lBQ0EsSUFBSUssT0FBT1gsU0FBU0MsTUFBTTtJQUMxQixJQUFJVyxTQUFTWixTQUFTUSxNQUFNLENBQUM7SUFDN0IsSUFBSUssU0FBU0MsS0FBS0MsR0FBRyxDQUFDSixRQUFRRyxLQUFLQyxHQUFHLENBQUMsS0FBSyxtQ0FBbUM7O0lBQy9FLElBQUlDLFVBQVVGLEtBQUtDLEdBQUcsQ0FBQyxPQUFPRCxLQUFLQyxHQUFHLENBQUNKLE1BQU0sbUNBQW1DOztJQUNoRixTQUFTTSxPQUFRQyxNQUFNO1FBQ3JCLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0YsV0FBV0Esa0JBQWtCZCxZQUFZO1lBQUVjLFNBQVN0QixRQUFR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QUM1QjtZQUNBLElBQUlBLFVBQVUsR0FBRztnQkFBRSxNQUFNLElBQUlFLE1BQU07WUFBa0I7WUFDckQ3QixTQUFTSztZQUNUOEI7UUFDRjtRQUNJLCtCQUErQjtRQUNuQyxJQUFJRyxNQUFNYixPQUFPekI7UUFDakIsTUFBT3NDLFFBQVFiLFFBQVFXLElBQUksQ0FBQ0UsSUFBSSxLQUFLLEVBQUc7WUFDdENBO1FBQ0Y7UUFDQSxJQUFJQyxNQUFNNUMsUUFBUTZDLFdBQVcsQ0FBQ2xCLFNBQVVHLENBQUFBLE9BQU9hLEdBQUU7UUFDakRDLElBQUlFLElBQUksQ0FBQyxNQUFNLEdBQUduQjtRQUNsQixJQUFJbEIsSUFBSWtCO1FBQ1IsTUFBT2dCLFFBQVFiLEtBQU07WUFDbkJjLEdBQUcsQ0FBQ25DLElBQUksR0FBR2dDLElBQUksQ0FBQ0UsTUFBTTtRQUN4QjtRQUNBLE9BQU9DO0lBQ1Q7SUFDQSxTQUFTRyxPQUFRQyxNQUFNO1FBQ3JCLElBQUlDLFNBQVNYLGFBQWFVO1FBQzFCLElBQUlDLFFBQVE7WUFBRSxPQUFPQTtRQUFPO1FBQzVCLE1BQU0sSUFBSWYsTUFBTSxhQUFhbkIsT0FBTztJQUN0QztJQUNBLE9BQU87UUFDTE0sUUFBUUE7UUFDUmlCLGNBQWNBO1FBQ2RTLFFBQVFBO0lBQ1Y7QUFDRjtBQUNBRyxPQUFPQyxPQUFPLEdBQUdoRCIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvYmFzZS14L3NyYy9pbmRleC5qcz80ZjdmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuLy8gYmFzZS14IGVuY29kaW5nIC8gZGVjb2Rpbmdcbi8vIENvcHlyaWdodCAoYykgMjAxOCBiYXNlLXggY29udHJpYnV0b3JzXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxOCBUaGUgQml0Y29pbiBDb3JlIGRldmVsb3BlcnMgKGJhc2U1OC5jcHApXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIExJQ0VOU0Ugb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG4vLyBAdHMtaWdub3JlXG52YXIgX0J1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5mdW5jdGlvbiBiYXNlIChBTFBIQUJFVCkge1xuICBpZiAoQUxQSEFCRVQubGVuZ3RoID49IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHBoYWJldCB0b28gbG9uZycpIH1cbiAgdmFyIEJBU0VfTUFQID0gbmV3IFVpbnQ4QXJyYXkoMjU2KVxuICBmb3IgKHZhciBqID0gMDsgaiA8IEJBU0VfTUFQLmxlbmd0aDsgaisrKSB7XG4gICAgQkFTRV9NQVBbal0gPSAyNTVcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHggPSBBTFBIQUJFVC5jaGFyQXQoaSlcbiAgICB2YXIgeGMgPSB4LmNoYXJDb2RlQXQoMClcbiAgICBpZiAoQkFTRV9NQVBbeGNdICE9PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBhbWJpZ3VvdXMnKSB9XG4gICAgQkFTRV9NQVBbeGNdID0gaVxuICB9XG4gIHZhciBCQVNFID0gQUxQSEFCRVQubGVuZ3RoXG4gIHZhciBMRUFERVIgPSBBTFBIQUJFVC5jaGFyQXQoMClcbiAgdmFyIEZBQ1RPUiA9IE1hdGgubG9nKEJBU0UpIC8gTWF0aC5sb2coMjU2KSAvLyBsb2coQkFTRSkgLyBsb2coMjU2KSwgcm91bmRlZCB1cFxuICB2YXIgaUZBQ1RPUiA9IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhCQVNFKSAvLyBsb2coMjU2KSAvIGxvZyhCQVNFKSwgcm91bmRlZCB1cFxuICBmdW5jdGlvbiBlbmNvZGUgKHNvdXJjZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkgfHwgc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkgeyBzb3VyY2UgPSBfQnVmZmVyLmZyb20oc291cmNlKSB9XG4gICAgaWYgKCFfQnVmZmVyLmlzQnVmZmVyKHNvdXJjZSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgQnVmZmVyJykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJyB9XG4gICAgICAgIC8vIFNraXAgJiBjb3VudCBsZWFkaW5nIHplcm9lcy5cbiAgICB2YXIgemVyb2VzID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgdmFyIHBiZWdpbiA9IDBcbiAgICB2YXIgcGVuZCA9IHNvdXJjZS5sZW5ndGhcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kICYmIHNvdXJjZVtwYmVnaW5dID09PSAwKSB7XG4gICAgICBwYmVnaW4rK1xuICAgICAgemVyb2VzKytcbiAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGVub3VnaCBzcGFjZSBpbiBiaWctZW5kaWFuIGJhc2U1OCByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgocGVuZCAtIHBiZWdpbikgKiBpRkFDVE9SICsgMSkgPj4+IDBcbiAgICB2YXIgYjU4ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgYnl0ZXMuXG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCkge1xuICAgICAgdmFyIGNhcnJ5ID0gc291cmNlW3BiZWdpbl1cbiAgICAgICAgICAgIC8vIEFwcGx5IFwiYjU4ID0gYjU4ICogMjU2ICsgY2hcIi5cbiAgICAgIHZhciBpID0gMFxuICAgICAgZm9yICh2YXIgaXQxID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQxICE9PSAtMSk7IGl0MS0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKDI1NiAqIGI1OFtpdDFdKSA+Pj4gMFxuICAgICAgICBiNThbaXQxXSA9IChjYXJyeSAlIEJBU0UpID4+PiAwXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gQkFTRSkgPj4+IDBcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaVxuICAgICAgcGJlZ2luKytcbiAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYmFzZTU4IHJlc3VsdC5cbiAgICB2YXIgaXQyID0gc2l6ZSAtIGxlbmd0aFxuICAgIHdoaWxlIChpdDIgIT09IHNpemUgJiYgYjU4W2l0Ml0gPT09IDApIHtcbiAgICAgIGl0MisrXG4gICAgfVxuICAgICAgICAvLyBUcmFuc2xhdGUgdGhlIHJlc3VsdCBpbnRvIGEgc3RyaW5nLlxuICAgIHZhciBzdHIgPSBMRUFERVIucmVwZWF0KHplcm9lcylcbiAgICBmb3IgKDsgaXQyIDwgc2l6ZTsgKytpdDIpIHsgc3RyICs9IEFMUEhBQkVULmNoYXJBdChiNThbaXQyXSkgfVxuICAgIHJldHVybiBzdHJcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVVbnNhZmUgKHNvdXJjZSkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBTdHJpbmcnKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuIF9CdWZmZXIuYWxsb2MoMCkgfVxuICAgIHZhciBwc3ogPSAwXG4gICAgICAgIC8vIFNraXAgYW5kIGNvdW50IGxlYWRpbmcgJzEncy5cbiAgICB2YXIgemVyb2VzID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdID09PSBMRUFERVIpIHtcbiAgICAgIHplcm9lcysrXG4gICAgICBwc3orK1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTI1NiByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgoKHNvdXJjZS5sZW5ndGggLSBwc3opICogRkFDVE9SKSArIDEpID4+PiAwIC8vIGxvZyg1OCkgLyBsb2coMjU2KSwgcm91bmRlZCB1cC5cbiAgICB2YXIgYjI1NiA9IG5ldyBVaW50OEFycmF5KHNpemUpXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGNoYXJhY3RlcnMuXG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdKSB7XG4gICAgICAgICAgICAvLyBEZWNvZGUgY2hhcmFjdGVyXG4gICAgICB2YXIgY2FycnkgPSBCQVNFX01BUFtzb3VyY2UuY2hhckNvZGVBdChwc3opXVxuICAgICAgICAgICAgLy8gSW52YWxpZCBjaGFyYWN0ZXJcbiAgICAgIGlmIChjYXJyeSA9PT0gMjU1KSB7IHJldHVybiB9XG4gICAgICB2YXIgaSA9IDBcbiAgICAgIGZvciAodmFyIGl0MyA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MyAhPT0gLTEpOyBpdDMtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IChCQVNFICogYjI1NltpdDNdKSA+Pj4gMFxuICAgICAgICBiMjU2W2l0M10gPSAoY2FycnkgJSAyNTYpID4+PiAwXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gMjU2KSA+Pj4gMFxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpXG4gICAgICBwc3orK1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiMjU2LlxuICAgIHZhciBpdDQgPSBzaXplIC0gbGVuZ3RoXG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSAmJiBiMjU2W2l0NF0gPT09IDApIHtcbiAgICAgIGl0NCsrXG4gICAgfVxuICAgIHZhciB2Y2ggPSBfQnVmZmVyLmFsbG9jVW5zYWZlKHplcm9lcyArIChzaXplIC0gaXQ0KSlcbiAgICB2Y2guZmlsbCgweDAwLCAwLCB6ZXJvZXMpXG4gICAgdmFyIGogPSB6ZXJvZXNcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplKSB7XG4gICAgICB2Y2hbaisrXSA9IGIyNTZbaXQ0KytdXG4gICAgfVxuICAgIHJldHVybiB2Y2hcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUgKHN0cmluZykge1xuICAgIHZhciBidWZmZXIgPSBkZWNvZGVVbnNhZmUoc3RyaW5nKVxuICAgIGlmIChidWZmZXIpIHsgcmV0dXJuIGJ1ZmZlciB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24tYmFzZScgKyBCQVNFICsgJyBjaGFyYWN0ZXInKVxuICB9XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZGVjb2RlVW5zYWZlOiBkZWNvZGVVbnNhZmUsXG4gICAgZGVjb2RlOiBkZWNvZGVcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBiYXNlXG4iXSwibmFtZXMiOlsiX0J1ZmZlciIsInJlcXVpcmUiLCJCdWZmZXIiLCJiYXNlIiwiQUxQSEFCRVQiLCJsZW5ndGgiLCJUeXBlRXJyb3IiLCJCQVNFX01BUCIsIlVpbnQ4QXJyYXkiLCJqIiwiaSIsIngiLCJjaGFyQXQiLCJ4YyIsImNoYXJDb2RlQXQiLCJCQVNFIiwiTEVBREVSIiwiRkFDVE9SIiwiTWF0aCIsImxvZyIsImlGQUNUT1IiLCJlbmNvZGUiLCJzb3VyY2UiLCJBcnJheSIsImlzQXJyYXkiLCJmcm9tIiwiaXNCdWZmZXIiLCJ6ZXJvZXMiLCJwYmVnaW4iLCJwZW5kIiwic2l6ZSIsImI1OCIsImNhcnJ5IiwiaXQxIiwiRXJyb3IiLCJpdDIiLCJzdHIiLCJyZXBlYXQiLCJkZWNvZGVVbnNhZmUiLCJhbGxvYyIsInBzeiIsImIyNTYiLCJpdDMiLCJpdDQiLCJ2Y2giLCJhbGxvY1Vuc2FmZSIsImZpbGwiLCJkZWNvZGUiLCJzdHJpbmciLCJidWZmZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/base-x/src/index.js\n");

/***/ })

};
;