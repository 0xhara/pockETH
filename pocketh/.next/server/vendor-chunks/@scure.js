"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@scure";
exports.ids = ["vendor-chunks/@scure"];
exports.modules = {

/***/ "(ssr)/./node_modules/@scure/base/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@scure/base/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */ function assertNumber(n) {\n    if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);\n}\nexports.assertNumber = assertNumber;\n/**\n * @__NO_SIDE_EFFECTS__\n */ function chain(...args) {\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b)=>(c)=>a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = Array.from(args).reverse().reduce((acc, i)=>acc ? wrap(acc, i.encode) : i.encode, undefined);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.reduce((acc, i)=>acc ? wrap(acc, i.decode) : i.decode, undefined);\n    return {\n        encode,\n        decode\n    };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */ function alphabet(alphabet) {\n    return {\n        encode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"alphabet.encode input should be an array of numbers\");\n            return digits.map((i)=>{\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length) throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input)=>{\n            if (!Array.isArray(input) || input.length && typeof input[0] !== \"string\") throw new Error(\"alphabet.decode input should be array of strings\");\n            return input.map((letter)=>{\n                if (typeof letter !== \"string\") throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function join(separator = \"\") {\n    if (typeof separator !== \"string\") throw new Error(\"join separator should be string\");\n    return {\n        encode: (from)=>{\n            if (!Array.isArray(from) || from.length && typeof from[0] !== \"string\") throw new Error(\"join.encode input should be array of strings\");\n            for (let i of from)if (typeof i !== \"string\") throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to)=>{\n            if (typeof to !== \"string\") throw new Error(\"join.decode input should be string\");\n            return to.split(separator);\n        }\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */ function padding(bits, chr = \"=\") {\n    assertNumber(bits);\n    if (typeof chr !== \"string\") throw new Error(\"padding chr should be string\");\n    return {\n        encode (data) {\n            if (!Array.isArray(data) || data.length && typeof data[0] !== \"string\") throw new Error(\"padding.encode input should be array of strings\");\n            for (let i of data)if (typeof i !== \"string\") throw new Error(`padding.encode: non-string input=${i}`);\n            while(data.length * bits % 8)data.push(chr);\n            return data;\n        },\n        decode (input) {\n            if (!Array.isArray(input) || input.length && typeof input[0] !== \"string\") throw new Error(\"padding.encode input should be array of strings\");\n            for (let i of input)if (typeof i !== \"string\") throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if (end * bits % 8) throw new Error(\"Invalid padding: string should have whole number of bytes\");\n            for(; end > 0 && input[end - 1] === chr; end--){\n                if (!((end - 1) * bits % 8)) throw new Error(\"Invalid padding: string has too much padding\");\n            }\n            return input.slice(0, end);\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function normalize(fn) {\n    if (typeof fn !== \"function\") throw new Error(\"normalize fn should be function\");\n    return {\n        encode: (from)=>from,\n        decode: (to)=>fn(to)\n    };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */ function convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2) throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2) throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data)) throw new Error(\"convertRadix: data should be array\");\n    if (!data.length) return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d)=>{\n        assertNumber(d);\n        if (d < 0 || d >= from) throw new Error(`Wrong integer: ${d}`);\n    });\n    while(true){\n        let carry = 0;\n        let done = true;\n        for(let i = pos; i < digits.length; i++){\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {\n                throw new Error(\"convertRadix: carry overflow\");\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error(\"convertRadix: carry overflow\");\n            if (!done) continue;\n            else if (!rounded) pos = i;\n            else done = false;\n        }\n        res.push(carry);\n        if (done) break;\n    }\n    for(let i = 0; i < data.length - 1 && data[i] === 0; i++)res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b)=>!b ? a : gcd(b, a % b);\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to)=>from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */ function convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data)) throw new Error(\"convertRadix2: data should be array\");\n    if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data){\n        assertNumber(n);\n        if (n >= 2 ** from) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = carry << from | n;\n        if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for(; pos >= to; pos -= to)res.push((carry >> pos - to & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = carry << to - pos & mask;\n    if (!padding && pos >= from) throw new Error(\"Excess padding\");\n    if (!padding && carry) throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0) res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes)=>{\n            if (!(bytes instanceof Uint8Array)) throw new Error(\"radix.encode input should be Uint8Array\");\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"radix.decode input should be array of strings\");\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        }\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */ function radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32) throw new Error(\"radix2: bits should be in (0..32]\");\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error(\"radix2: carry overflow\");\n    return {\n        encode: (bytes)=>{\n            if (!(bytes instanceof Uint8Array)) throw new Error(\"radix2.encode input should be Uint8Array\");\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"radix2.decode input should be array of strings\");\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function unsafeWrapper(fn) {\n    if (typeof fn !== \"function\") throw new Error(\"unsafeWrapper fn should be function\");\n    return function(...args) {\n        try {\n            return fn.apply(null, args);\n        } catch (e) {}\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== \"function\") throw new Error(\"checksum fn should be function\");\n    return {\n        encode (data) {\n            if (!(data instanceof Uint8Array)) throw new Error(\"checksum.encode: input should be Uint8Array\");\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode (data) {\n            if (!(data instanceof Uint8Array)) throw new Error(\"checksum.decode: input should be Uint8Array\");\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for(let i = 0; i < len; i++)if (newChecksum[i] !== oldChecksum[i]) throw new Error(\"Invalid checksum\");\n            return payload;\n        }\n    };\n}\nexports.utils = {\n    alphabet,\n    chain,\n    checksum,\n    radix,\n    radix2,\n    join,\n    padding\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nexports.base16 = chain(radix2(4), alphabet(\"0123456789ABCDEF\"), join(\"\"));\nexports.base32 = chain(radix2(5), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), padding(5), join(\"\"));\nexports.base32hex = chain(radix2(5), alphabet(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), padding(5), join(\"\"));\nexports.base32crockford = chain(radix2(5), alphabet(\"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"), join(\"\"), normalize((s)=>s.toUpperCase().replace(/O/g, \"0\").replace(/[IL]/g, \"1\")));\nexports.base64 = chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), padding(6), join(\"\"));\nexports.base64url = chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), padding(6), join(\"\"));\nexports.base64urlnopad = chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), join(\"\"));\n// base58 code\n// -----------\nconst genBase58 = (abc)=>chain(radix(58), alphabet(abc), join(\"\"));\nexports.base58 = genBase58(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\nexports.base58flickr = genBase58(\"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\");\nexports.base58xrp = genBase58(\"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz\");\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [\n    0,\n    2,\n    3,\n    5,\n    6,\n    7,\n    9,\n    10,\n    11\n];\nexports.base58xmr = {\n    encode (data) {\n        let res = \"\";\n        for(let i = 0; i < data.length; i += 8){\n            const block = data.subarray(i, i + 8);\n            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], \"1\");\n        }\n        return res;\n    },\n    decode (str) {\n        let res = [];\n        for(let i = 0; i < str.length; i += 11){\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = exports.base58.decode(slice);\n            for(let j = 0; j < block.length - blockLen; j++){\n                if (block[j] !== 0) throw new Error(\"base58xmr: wrong padding\");\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    }\n};\nconst base58check = (sha256)=>chain(checksum(4, (data)=>sha256(sha256(data))), exports.base58);\nexports.base58check = base58check;\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet(\"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"), join(\"\"));\nconst POLYMOD_GENERATORS = [\n    0x3b6a57b2,\n    0x26508e6d,\n    0x1ea119fa,\n    0x3d4233dd,\n    0x2a1462b3\n];\n/**\n * @__NO_SIDE_EFFECTS__\n */ function bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for(let i = 0; i < POLYMOD_GENERATORS.length; i++){\n        if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for(let i = 0; i < len; i++){\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ c >> 5;\n    }\n    chk = bech32Polymod(chk);\n    for(let i = 0; i < len; i++)chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;\n    for (let v of words)chk = bech32Polymod(chk) ^ v;\n    for(let i = 0; i < 6; i++)chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([\n        chk % 2 ** 30\n    ], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function genBech32(encoding) {\n    const ENCODING_CONST = encoding === \"bech32\" ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== \"string\") throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || words.length && typeof words[0] !== \"number\") throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== \"string\") throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || limit !== false && str.length > limit) throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf(\"1\");\n        if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6) throw new Error(\"Data must be at least 6 characters long\");\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return {\n            prefix,\n            words\n        };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return {\n            prefix,\n            words,\n            bytes: fromWords(words)\n        };\n    }\n    return {\n        encode,\n        decode,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords\n    };\n}\nexports.bech32 = genBech32(\"bech32\");\nexports.bech32m = genBech32(\"bech32m\");\nexports.utf8 = {\n    encode: (data)=>new TextDecoder().decode(data),\n    decode: (str)=>new TextEncoder().encode(str)\n};\nexports.hex = chain(radix2(4), alphabet(\"0123456789abcdef\"), join(\"\"), normalize((s)=>{\n    if (typeof s !== \"string\" || s.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8: exports.utf8,\n    hex: exports.hex,\n    base16: exports.base16,\n    base32: exports.base32,\n    base64: exports.base64,\n    base64url: exports.base64url,\n    base58: exports.base58,\n    base58xmr: exports.base58xmr\n};\nconst coderTypeError = \"Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr\";\nconst bytesToString = (type, bytes)=>{\n    if (typeof type !== \"string\" || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array)) throw new TypeError(\"bytesToString() expects Uint8Array\");\n    return CODERS[type].encode(bytes);\n};\nexports.bytesToString = bytesToString;\nexports.str = exports.bytesToString; // as in python, but for bytes only\nconst stringToBytes = (type, str)=>{\n    if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (typeof str !== \"string\") throw new TypeError(\"stringToBytes() expects string\");\n    return CODERS[type].decode(str);\n};\nexports.stringToBytes = stringToBytes;\nexports.bytes = exports.stringToBytes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2Isa0VBQWtFLEdBQ2xFQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHQSxxQkFBcUIsR0FBR0EsV0FBVyxHQUFHQSxxQkFBcUIsR0FBR0EsV0FBVyxHQUFHQSxZQUFZLEdBQUdBLGVBQWUsR0FBR0EsY0FBYyxHQUFHQSxtQkFBbUIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxvQkFBb0IsR0FBR0EsY0FBYyxHQUFHQSxzQkFBc0IsR0FBR0EsaUJBQWlCLEdBQUdBLGNBQWMsR0FBR0EsdUJBQXVCLEdBQUdBLGlCQUFpQixHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsYUFBYSxHQUFHQSxvQkFBb0IsR0FBRyxLQUFLO0FBQzlhLFlBQVk7QUFDWjs7Q0FFQyxHQUNELFNBQVN1QixhQUFhQyxDQUFDO0lBQ25CLElBQUksQ0FBQ0MsT0FBT0MsYUFBYSxDQUFDRixJQUN0QixNQUFNLElBQUlHLE1BQU0sQ0FBQyxlQUFlLEVBQUVILEVBQUUsQ0FBQztBQUM3QztBQUNBeEIsb0JBQW9CLEdBQUd1QjtBQUN2Qjs7Q0FFQyxHQUNELFNBQVNLLE1BQU0sR0FBR0MsSUFBSTtJQUNsQiwrQ0FBK0M7SUFDL0MsTUFBTUMsT0FBTyxDQUFDQyxHQUFHQyxJQUFNLENBQUNDLElBQU1GLEVBQUVDLEVBQUVDO0lBQ2xDLDZEQUE2RDtJQUM3RCxNQUFNQyxTQUFTQyxNQUFNQyxJQUFJLENBQUNQLE1BQ3JCUSxPQUFPLEdBQ1BDLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxJQUFPRCxNQUFNVCxLQUFLUyxLQUFLQyxFQUFFTixNQUFNLElBQUlNLEVBQUVOLE1BQU0sRUFBR087SUFDaEUseURBQXlEO0lBQ3pELE1BQU1DLFNBQVNiLEtBQUtTLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxJQUFPRCxNQUFNVCxLQUFLUyxL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cUJBQXFCLEdBQUdHO0FBQ3hCSCxhQUFhLEdBQUdBLFFBQVFHLGFBQWEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iYXNlL2xpYi9pbmRleC5qcz8xODI0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyohIHNjdXJlLWJhc2UgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnl0ZXMgPSBleHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGV4cG9ydHMuaGV4ID0gZXhwb3J0cy51dGY4ID0gZXhwb3J0cy5iZWNoMzJtID0gZXhwb3J0cy5iZWNoMzIgPSBleHBvcnRzLmJhc2U1OGNoZWNrID0gZXhwb3J0cy5iYXNlNTh4bXIgPSBleHBvcnRzLmJhc2U1OHhycCA9IGV4cG9ydHMuYmFzZTU4ZmxpY2tyID0gZXhwb3J0cy5iYXNlNTggPSBleHBvcnRzLmJhc2U2NHVybG5vcGFkID0gZXhwb3J0cy5iYXNlNjR1cmwgPSBleHBvcnRzLmJhc2U2NCA9IGV4cG9ydHMuYmFzZTMyY3JvY2tmb3JkID0gZXhwb3J0cy5iYXNlMzJoZXggPSBleHBvcnRzLmJhc2UzMiA9IGV4cG9ydHMuYmFzZTE2ID0gZXhwb3J0cy51dGlscyA9IGV4cG9ydHMuYXNzZXJ0TnVtYmVyID0gdm9pZCAwO1xuLy8gVXRpbGl0aWVzXG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGFzc2VydE51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBpbnRlZ2VyOiAke259YCk7XG59XG5leHBvcnRzLmFzc2VydE51bWJlciA9IGFzc2VydE51bWJlcjtcbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY2hhaW4oLi4uYXJncykge1xuICAgIC8vIFdyYXAgY2FsbCBpbiBjbG9zdXJlIHNvIEpJVCBjYW4gaW5saW5lIGNhbGxzXG4gICAgY29uc3Qgd3JhcCA9IChhLCBiKSA9PiAoYykgPT4gYShiKGMpKTtcbiAgICAvLyBDb25zdHJ1Y3QgY2hhaW4gb2YgYXJnc1stMV0uZW5jb2RlKGFyZ3NbLTJdLmVuY29kZShbLi4uXSkpXG4gICAgY29uc3QgZW5jb2RlID0gQXJyYXkuZnJvbShhcmdzKVxuICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgIC5yZWR1Y2UoKGFjYywgaSkgPT4gKGFjYyA/IHdyYXAoYWNjLCBpLmVuY29kZSkgOiBpLmVuY29kZSksIHVuZGVmaW5lZCk7XG4gICAgLy8gQ29uc3RydWN0IGNoYWluIG9mIGFyZ3NbMF0uZGVjb2RlKGFyZ3NbMV0uZGVjb2RlKC4uLikpXG4gICAgY29uc3QgZGVjb2RlID0gYXJncy5yZWR1Y2UoKGFjYywgaSkgPT4gKGFjYyA/IHdyYXAoYWNjLCBpLmRlY29kZSkgOiBpLmRlY29kZSksIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUgfTtcbn1cbi8qKlxuICogRW5jb2RlcyBpbnRlZ2VyIHJhZGl4IHJlcHJlc2VudGF0aW9uIHRvIGFycmF5IG9mIHN0cmluZ3MgdXNpbmcgYWxwaGFiZXQgYW5kIGJhY2tcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGFscGhhYmV0KGFscGhhYmV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHBoYWJldC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFuIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBkaWdpdHMubWFwKChpKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0TnVtYmVyKGkpO1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMCB8fCBpID49IGFscGhhYmV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaWdpdCBpbmRleCBvdXRzaWRlIGFscGhhYmV0OiAke2l9IChhbHBoYWJldDogJHthbHBoYWJldC5sZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBhbHBoYWJldFtpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQubGVuZ3RoICYmIHR5cGVvZiBpbnB1dFswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQubWFwKChsZXR0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxldHRlciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYWxwaGFiZXQuZGVjb2RlOiBub3Qgc3RyaW5nIGVsZW1lbnQ9JHtsZXR0ZXJ9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhbHBoYWJldC5pbmRleE9mKGxldHRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxldHRlcjogXCIke2xldHRlcn1cIi4gQWxsb3dlZDogJHthbHBoYWJldH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBqb2luKHNlcGFyYXRvciA9ICcnKSB7XG4gICAgaWYgKHR5cGVvZiBzZXBhcmF0b3IgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4gc2VwYXJhdG9yIHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChmcm9tKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZnJvbSkgfHwgKGZyb20ubGVuZ3RoICYmIHR5cGVvZiBmcm9tWzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBmcm9tKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgam9pbi5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgcmV0dXJuIGZyb20uam9pbihzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6ICh0bykgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0byAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4gdG8uc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBQYWQgc3RyaW5ncyBhcnJheSBzbyBpdCBoYXMgaW50ZWdlciBudW1iZXIgb2YgYml0c1xuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcGFkZGluZyhiaXRzLCBjaHIgPSAnPScpIHtcbiAgICBhc3NlcnROdW1iZXIoYml0cyk7XG4gICAgaWYgKHR5cGVvZiBjaHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcgY2hyIHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpIHx8IChkYXRhLmxlbmd0aCAmJiB0eXBlb2YgZGF0YVswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZy5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgZGF0YSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIHdoaWxlICgoZGF0YS5sZW5ndGggKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGNocik7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpIHx8IChpbnB1dC5sZW5ndGggJiYgdHlwZW9mIGlucHV0WzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBpbnB1dClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZGVjb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoKGVuZCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFkZGluZzogc3RyaW5nIHNob3VsZCBoYXZlIHdob2xlIG51bWJlciBvZiBieXRlcycpO1xuICAgICAgICAgICAgZm9yICg7IGVuZCA+IDAgJiYgaW5wdXRbZW5kIC0gMV0gPT09IGNocjsgZW5kLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoISgoKGVuZCAtIDEpICogYml0cykgJSA4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBoYXMgdG9vIG11Y2ggcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKDAsIGVuZCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3JtYWxpemUgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIHsgZW5jb2RlOiAoZnJvbSkgPT4gZnJvbSwgZGVjb2RlOiAodG8pID0+IGZuKHRvKSB9O1xufVxuLyoqXG4gKiBTbG93OiBPKG5eMikgdGltZSBjb21wbGV4aXR5XG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgoZGF0YSwgZnJvbSwgdG8pIHtcbiAgICAvLyBiYXNlIDEgaXMgaW1wb3NzaWJsZVxuICAgIGlmIChmcm9tIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIGZyb209JHtmcm9tfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBpZiAodG8gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogd3JvbmcgdG89JHt0b30sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogZGF0YSBzaG91bGQgYmUgYXJyYXknKTtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgY29uc3QgZGlnaXRzID0gQXJyYXkuZnJvbShkYXRhKTtcbiAgICBkaWdpdHMuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICBhc3NlcnROdW1iZXIoZCk7XG4gICAgICAgIGlmIChkIDwgMCB8fCBkID49IGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGludGVnZXI6ICR7ZH1gKTtcbiAgICB9KTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgY2FycnkgPSAwO1xuICAgICAgICBsZXQgZG9uZSA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBkaWdpdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0ID0gZGlnaXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgZGlnaXRCYXNlID0gZnJvbSAqIGNhcnJ5ICsgZGlnaXQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGRpZ2l0QmFzZSkgfHxcbiAgICAgICAgICAgICAgICAoZnJvbSAqIGNhcnJ5KSAvIGZyb20gIT09IGNhcnJ5IHx8XG4gICAgICAgICAgICAgICAgZGlnaXRCYXNlIC0gZGlnaXQgIT09IGZyb20gKiBjYXJyeSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FycnkgPSBkaWdpdEJhc2UgJSB0bztcbiAgICAgICAgICAgIGNvbnN0IHJvdW5kZWQgPSBNYXRoLmZsb29yKGRpZ2l0QmFzZSAvIHRvKTtcbiAgICAgICAgICAgIGRpZ2l0c1tpXSA9IHJvdW5kZWQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHJvdW5kZWQpIHx8IHJvdW5kZWQgKiB0byArIGNhcnJ5ICE9PSBkaWdpdEJhc2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlIGlmICghcm91bmRlZClcbiAgICAgICAgICAgICAgICBwb3MgPSBpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjYXJyeSk7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxICYmIGRhdGFbaV0gPT09IDA7IGkrKylcbiAgICAgICAgcmVzLnB1c2goMCk7XG4gICAgcmV0dXJuIHJlcy5yZXZlcnNlKCk7XG59XG5jb25zdCBnY2QgPSAvKiBAX19OT19TSURFX0VGRkVDVFNfXyAqLyAoYSwgYikgPT4gKCFiID8gYSA6IGdjZChiLCBhICUgYikpO1xuY29uc3QgcmFkaXgyY2FycnkgPSAvKkBfX05PX1NJREVfRUZGRUNUU19fICovIChmcm9tLCB0bykgPT4gZnJvbSArICh0byAtIGdjZChmcm9tLCB0bykpO1xuLyoqXG4gKiBJbXBsZW1lbnRlZCB3aXRoIG51bWJlcnMsIGJlY2F1c2UgQmlnSW50IGlzIDV4IHNsb3dlclxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhZGl4MihkYXRhLCBmcm9tLCB0bywgcGFkZGluZykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXgyOiBkYXRhIHNob3VsZCBiZSBhcnJheScpO1xuICAgIGlmIChmcm9tIDw9IDAgfHwgZnJvbSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIGZyb209JHtmcm9tfWApO1xuICAgIGlmICh0byA8PSAwIHx8IHRvID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgdG89JHt0b31gKTtcbiAgICBpZiAocmFkaXgyY2FycnkoZnJvbSwgdG8pID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBmcm9tPSR7ZnJvbX0gdG89JHt0b30gY2FycnlCaXRzPSR7cmFkaXgyY2FycnkoZnJvbSwgdG8pfWApO1xuICAgIH1cbiAgICBsZXQgY2FycnkgPSAwO1xuICAgIGxldCBwb3MgPSAwOyAvLyBiaXR3aXNlIHBvc2l0aW9uIGluIGN1cnJlbnQgZWxlbWVudFxuICAgIGNvbnN0IG1hc2sgPSAyICoqIHRvIC0gMTtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgZGF0YSkge1xuICAgICAgICBhc3NlcnROdW1iZXIobik7XG4gICAgICAgIGlmIChuID49IDIgKiogZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogaW52YWxpZCBkYXRhIHdvcmQ9JHtufSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgPDwgZnJvbSkgfCBuO1xuICAgICAgICBpZiAocG9zICsgZnJvbSA+IDMyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBwb3M9JHtwb3N9IGZyb209JHtmcm9tfWApO1xuICAgICAgICBwb3MgKz0gZnJvbTtcbiAgICAgICAgZm9yICg7IHBvcyA+PSB0bzsgcG9zIC09IHRvKVxuICAgICAgICAgICAgcmVzLnB1c2goKChjYXJyeSA+PiAocG9zIC0gdG8pKSAmIG1hc2spID4+PiAwKTtcbiAgICAgICAgY2FycnkgJj0gMiAqKiBwb3MgLSAxOyAvLyBjbGVhbiBjYXJyeSwgb3RoZXJ3aXNlIGl0IHdpbGwgY2F1c2Ugb3ZlcmZsb3dcbiAgICB9XG4gICAgY2FycnkgPSAoY2FycnkgPDwgKHRvIC0gcG9zKSkgJiBtYXNrO1xuICAgIGlmICghcGFkZGluZyAmJiBwb3MgPj0gZnJvbSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGNlc3MgcGFkZGluZycpO1xuICAgIGlmICghcGFkZGluZyAmJiBjYXJyeSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24temVybyBwYWRkaW5nOiAke2NhcnJ5fWApO1xuICAgIGlmIChwYWRkaW5nICYmIHBvcyA+IDApXG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5ID4+PiAwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiByYWRpeChudW0pIHtcbiAgICBhc3NlcnROdW1iZXIobnVtKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeChBcnJheS5mcm9tKGJ5dGVzKSwgMiAqKiA4LCBudW0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgoZGlnaXRzLCBudW0sIDIgKiogOCkpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIElmIGJvdGggYmFzZXMgYXJlIHBvd2VyIG9mIHNhbWUgbnVtYmVyIChsaWtlIGAyKio4IDwtPiAyKio2NGApLFxuICogdGhlcmUgaXMgYSBsaW5lYXIgYWxnb3JpdGhtLiBGb3Igbm93IHdlIGhhdmUgaW1wbGVtZW50YXRpb24gZm9yIHBvd2VyLW9mLXR3byBiYXNlcyBvbmx5LlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcmFkaXgyKGJpdHMsIHJldlBhZGRpbmcgPSBmYWxzZSkge1xuICAgIGFzc2VydE51bWJlcihiaXRzKTtcbiAgICBpZiAoYml0cyA8PSAwIHx8IGJpdHMgPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGJpdHMgc2hvdWxkIGJlIGluICgwLi4zMl0nKTtcbiAgICBpZiAocmFkaXgyY2FycnkoOCwgYml0cykgPiAzMiB8fCByYWRpeDJjYXJyeShiaXRzLCA4KSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4Mi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgyKEFycmF5LmZyb20oYnl0ZXMpLCA4LCBiaXRzLCAhcmV2UGFkZGluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgyKGRpZ2l0cywgYml0cywgOCwgcmV2UGFkZGluZykpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHVuc2FmZVdyYXBwZXIoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc2FmZVdyYXBwZXIgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGNoZWNrc3VtKGxlbiwgZm4pIHtcbiAgICBhc3NlcnROdW1iZXIobGVuKTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5lbmNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBjaGVja3N1bSA9IGZuKGRhdGEpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCArIGxlbik7XG4gICAgICAgICAgICByZXMuc2V0KGRhdGEpO1xuICAgICAgICAgICAgcmVzLnNldChjaGVja3N1bSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmRlY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhLnNsaWNlKDAsIC1sZW4pO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hlY2tzdW0gPSBmbihwYXlsb2FkKS5zbGljZSgwLCBsZW4pO1xuICAgICAgICAgICAgY29uc3Qgb2xkQ2hlY2tzdW0gPSBkYXRhLnNsaWNlKC1sZW4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hlY2tzdW1baV0gIT09IG9sZENoZWNrc3VtW2ldKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hlY2tzdW0nKTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnRzLnV0aWxzID0geyBhbHBoYWJldCwgY2hhaW4sIGNoZWNrc3VtLCByYWRpeCwgcmFkaXgyLCBqb2luLCBwYWRkaW5nIH07XG4vLyBSRkMgNDY0OCBha2EgUkZDIDM1NDhcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXhwb3J0cy5iYXNlMTYgPSBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGJyksIGpvaW4oJycpKTtcbmV4cG9ydHMuYmFzZTMyID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnKSwgcGFkZGluZyg1KSwgam9pbignJykpO1xuZXhwb3J0cy5iYXNlMzJoZXggPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnRzLmJhc2UzMmNyb2NrZm9yZCA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSEpLTU5QUVJTVFZXWFlaJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHMudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9PL2csICcwJykucmVwbGFjZSgvW0lMXS9nLCAnMScpKSk7XG5leHBvcnRzLmJhc2U2NCA9IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuZXhwb3J0cy5iYXNlNjR1cmwgPSBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmV4cG9ydHMuYmFzZTY0dXJsbm9wYWQgPSBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyksIGpvaW4oJycpKTtcbi8vIGJhc2U1OCBjb2RlXG4vLyAtLS0tLS0tLS0tLVxuY29uc3QgZ2VuQmFzZTU4ID0gKGFiYykgPT4gY2hhaW4ocmFkaXgoNTgpLCBhbHBoYWJldChhYmMpLCBqb2luKCcnKSk7XG5leHBvcnRzLmJhc2U1OCA9IGdlbkJhc2U1OCgnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eicpO1xuZXhwb3J0cy5iYXNlNThmbGlja3IgPSBnZW5CYXNlNTgoJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonKTtcbmV4cG9ydHMuYmFzZTU4eHJwID0gZ2VuQmFzZTU4KCdycHNobmFmMzl3QlVETkVHSEpLTE00UFFSU1Q3VldYWVoyYmNkZUNnNjVqa204b0ZxaTF0dXZBeHl6Jyk7XG4vLyB4bXIgdmVyIGlzIGRvbmUgaW4gOC1ieXRlIGJsb2NrcyAod2hpY2ggZXF1YWxzIDExIGNoYXJzIGluIGRlY29kaW5nKS4gTGFzdCAobm9uLWZ1bGwpIGJsb2NrIHBhZGRlZCB3aXRoICcxJyB0byBzaXplIGluIFhNUl9CTE9DS19MRU4uXG4vLyBCbG9jayBlbmNvZGluZyBzaWduaWZpY2FudGx5IHJlZHVjZXMgcXVhZHJhdGljIGNvbXBsZXhpdHkgb2YgYmFzZTU4LlxuLy8gRGF0YSBsZW4gKGluZGV4KSAtPiBlbmNvZGVkIGJsb2NrIGxlblxuY29uc3QgWE1SX0JMT0NLX0xFTiA9IFswLCAyLCAzLCA1LCA2LCA3LCA5LCAxMCwgMTFdO1xuZXhwb3J0cy5iYXNlNTh4bXIgPSB7XG4gICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgbGV0IHJlcyA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gZGF0YS5zdWJhcnJheShpLCBpICsgOCk7XG4gICAgICAgICAgICByZXMgKz0gZXhwb3J0cy5iYXNlNTguZW5jb2RlKGJsb2NrKS5wYWRTdGFydChYTVJfQkxPQ0tfTEVOW2Jsb2NrLmxlbmd0aF0sICcxJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIGRlY29kZShzdHIpIHtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gc3RyLnNsaWNlKGksIGkgKyAxMSk7XG4gICAgICAgICAgICBjb25zdCBibG9ja0xlbiA9IFhNUl9CTE9DS19MRU4uaW5kZXhPZihzbGljZS5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBleHBvcnRzLmJhc2U1OC5kZWNvZGUoc2xpY2UpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBibG9jay5sZW5ndGggLSBibG9ja0xlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrW2pdICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jhc2U1OHhtcjogd3JvbmcgcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChBcnJheS5mcm9tKGJsb2NrLnNsaWNlKGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20ocmVzKTtcbiAgICB9LFxufTtcbmNvbnN0IGJhc2U1OGNoZWNrID0gKHNoYTI1NikgPT4gY2hhaW4oY2hlY2tzdW0oNCwgKGRhdGEpID0+IHNoYTI1NihzaGEyNTYoZGF0YSkpKSwgZXhwb3J0cy5iYXNlNTgpO1xuZXhwb3J0cy5iYXNlNThjaGVjayA9IGJhc2U1OGNoZWNrO1xuY29uc3QgQkVDSF9BTFBIQUJFVCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihhbHBoYWJldCgncXB6cnk5eDhnZjJ0dmR3MHMzam41NGtoY2U2bXVhN2wnKSwgam9pbignJykpO1xuY29uc3QgUE9MWU1PRF9HRU5FUkFUT1JTID0gWzB4M2I2YTU3YjIsIDB4MjY1MDhlNmQsIDB4MWVhMTE5ZmEsIDB4M2Q0MjMzZGQsIDB4MmExNDYyYjNdO1xuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBiZWNoMzJQb2x5bW9kKHByZSkge1xuICAgIGNvbnN0IGIgPSBwcmUgPj4gMjU7XG4gICAgbGV0IGNoayA9IChwcmUgJiAweDFmZmZmZmYpIDw8IDU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQT0xZTU9EX0dFTkVSQVRPUlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCgoYiA+PiBpKSAmIDEpID09PSAxKVxuICAgICAgICAgICAgY2hrIF49IFBPTFlNT0RfR0VORVJBVE9SU1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaztcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIGVuY29kaW5nQ29uc3QgPSAxKSB7XG4gICAgY29uc3QgbGVuID0gcHJlZml4Lmxlbmd0aDtcbiAgICBsZXQgY2hrID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByZWZpeCAoJHtwcmVmaXh9KWApO1xuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAoYyA+PiA1KTtcbiAgICB9XG4gICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChwcmVmaXguY2hhckNvZGVBdChpKSAmIDB4MWYpO1xuICAgIGZvciAobGV0IHYgb2Ygd29yZHMpXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIHY7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBjaGsgXj0gZW5jb2RpbmdDb25zdDtcbiAgICByZXR1cm4gQkVDSF9BTFBIQUJFVC5lbmNvZGUoY29udmVydFJhZGl4MihbY2hrICUgMiAqKiAzMF0sIDMwLCA1LCBmYWxzZSkpO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBnZW5CZWNoMzIoZW5jb2RpbmcpIHtcbiAgICBjb25zdCBFTkNPRElOR19DT05TVCA9IGVuY29kaW5nID09PSAnYmVjaDMyJyA/IDEgOiAweDJiYzgzMGEzO1xuICAgIGNvbnN0IF93b3JkcyA9IHJhZGl4Mig1KTtcbiAgICBjb25zdCBmcm9tV29yZHMgPSBfd29yZHMuZGVjb2RlO1xuICAgIGNvbnN0IHRvV29yZHMgPSBfd29yZHMuZW5jb2RlO1xuICAgIGNvbnN0IGZyb21Xb3Jkc1Vuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZnJvbVdvcmRzKTtcbiAgICBmdW5jdGlvbiBlbmNvZGUocHJlZml4LCB3b3JkcywgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHByZWZpeCAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgcHJlZml4IHNob3VsZCBiZSBzdHJpbmcsIG5vdCAke3R5cGVvZiBwcmVmaXh9YCk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh3b3JkcykgfHwgKHdvcmRzLmxlbmd0aCAmJiB0eXBlb2Ygd29yZHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmVuY29kZSB3b3JkcyBzaG91bGQgYmUgYXJyYXkgb2YgbnVtYmVycywgbm90ICR7dHlwZW9mIHdvcmRzfWApO1xuICAgICAgICBjb25zdCBhY3R1YWxMZW5ndGggPSBwcmVmaXgubGVuZ3RoICsgNyArIHdvcmRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxpbWl0ICE9PSBmYWxzZSAmJiBhY3R1YWxMZW5ndGggPiBsaW1pdClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYExlbmd0aCAke2FjdHVhbExlbmd0aH0gZXhjZWVkcyBsaW1pdCAke2xpbWl0fWApO1xuICAgICAgICBjb25zdCBsb3dlcmVkID0gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShsb3dlcmVkLCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpO1xuICAgICAgICByZXR1cm4gYCR7bG93ZXJlZH0xJHtCRUNIX0FMUEhBQkVULmVuY29kZSh3b3Jkcyl9JHtzdW19YDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0ciwgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHN0cn1gKTtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCA4IHx8IChsaW1pdCAhPT0gZmFsc2UgJiYgc3RyLmxlbmd0aCA+IGxpbWl0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFdyb25nIHN0cmluZyBsZW5ndGg6ICR7c3RyLmxlbmd0aH0gKCR7c3RyfSkuIEV4cGVjdGVkICg4Li4ke2xpbWl0fSlgKTtcbiAgICAgICAgLy8gZG9uJ3QgYWxsb3cgbWl4ZWQgY2FzZVxuICAgICAgICBjb25zdCBsb3dlcmVkID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzdHIgIT09IGxvd2VyZWQgJiYgc3RyICE9PSBzdHIudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyaW5nIG11c3QgYmUgbG93ZXJjYXNlIG9yIHVwcGVyY2FzZWApO1xuICAgICAgICBzdHIgPSBsb3dlcmVkO1xuICAgICAgICBjb25zdCBzZXBJbmRleCA9IHN0ci5sYXN0SW5kZXhPZignMScpO1xuICAgICAgICBpZiAoc2VwSW5kZXggPT09IDAgfHwgc2VwSW5kZXggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZXR0ZXIgXCIxXCIgbXVzdCBiZSBwcmVzZW50IGJldHdlZW4gcHJlZml4IGFuZCBkYXRhIG9ubHlgKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gc3RyLnNsaWNlKDAsIHNlcEluZGV4KTtcbiAgICAgICAgY29uc3QgX3dvcmRzID0gc3RyLnNsaWNlKHNlcEluZGV4ICsgMSk7XG4gICAgICAgIGlmIChfd29yZHMubGVuZ3RoIDwgNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBtdXN0IGJlIGF0IGxlYXN0IDYgY2hhcmFjdGVycyBsb25nJyk7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gQkVDSF9BTFBIQUJFVC5kZWNvZGUoX3dvcmRzKS5zbGljZSgwLCAtNik7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIGlmICghX3dvcmRzLmVuZHNXaXRoKHN1bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hlY2tzdW0gaW4gJHtzdHJ9OiBleHBlY3RlZCBcIiR7c3VtfVwiYCk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMgfTtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlVW5zYWZlID0gdW5zYWZlV3JhcHBlcihkZWNvZGUpO1xuICAgIGZ1bmN0aW9uIGRlY29kZVRvQnl0ZXMoc3RyKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB3b3JkcyB9ID0gZGVjb2RlKHN0ciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzLCBieXRlczogZnJvbVdvcmRzKHdvcmRzKSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBlbmNvZGUsIGRlY29kZSwgZGVjb2RlVG9CeXRlcywgZGVjb2RlVW5zYWZlLCBmcm9tV29yZHMsIGZyb21Xb3Jkc1Vuc2FmZSwgdG9Xb3JkcyB9O1xufVxuZXhwb3J0cy5iZWNoMzIgPSBnZW5CZWNoMzIoJ2JlY2gzMicpO1xuZXhwb3J0cy5iZWNoMzJtID0gZ2VuQmVjaDMyKCdiZWNoMzJtJyk7XG5leHBvcnRzLnV0ZjggPSB7XG4gICAgZW5jb2RlOiAoZGF0YSkgPT4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEpLFxuICAgIGRlY29kZTogKHN0cikgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0ciksXG59O1xuZXhwb3J0cy5oZXggPSBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5YWJjZGVmJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHtcbiAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnIHx8IHMubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaGV4LmRlY29kZTogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc30gd2l0aCBsZW5ndGggJHtzLmxlbmd0aH1gKTtcbiAgICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpO1xufSkpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBDT0RFUlMgPSB7XG4gICAgdXRmODogZXhwb3J0cy51dGY4LCBoZXg6IGV4cG9ydHMuaGV4LCBiYXNlMTY6IGV4cG9ydHMuYmFzZTE2LCBiYXNlMzI6IGV4cG9ydHMuYmFzZTMyLCBiYXNlNjQ6IGV4cG9ydHMuYmFzZTY0LCBiYXNlNjR1cmw6IGV4cG9ydHMuYmFzZTY0dXJsLCBiYXNlNTg6IGV4cG9ydHMuYmFzZTU4LCBiYXNlNTh4bXI6IGV4cG9ydHMuYmFzZTU4eG1yXG59O1xuY29uc3QgY29kZXJUeXBlRXJyb3IgPSAnSW52YWxpZCBlbmNvZGluZyB0eXBlLiBBdmFpbGFibGUgdHlwZXM6IHV0ZjgsIGhleCwgYmFzZTE2LCBiYXNlMzIsIGJhc2U2NCwgYmFzZTY0dXJsLCBiYXNlNTgsIGJhc2U1OHhtcic7XG5jb25zdCBieXRlc1RvU3RyaW5nID0gKHR5cGUsIGJ5dGVzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyB8fCAhQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAoIShieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1RvU3RyaW5nKCkgZXhwZWN0cyBVaW50OEFycmF5Jyk7XG4gICAgcmV0dXJuIENPREVSU1t0eXBlXS5lbmNvZGUoYnl0ZXMpO1xufTtcbmV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGJ5dGVzVG9TdHJpbmc7XG5leHBvcnRzLnN0ciA9IGV4cG9ydHMuYnl0ZXNUb1N0cmluZzsgLy8gYXMgaW4gcHl0aG9uLCBidXQgZm9yIGJ5dGVzIG9ubHlcbmNvbnN0IHN0cmluZ1RvQnl0ZXMgPSAodHlwZSwgc3RyKSA9PiB7XG4gICAgaWYgKCFDT0RFUlMuaGFzT3duUHJvcGVydHkodHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29kZXJUeXBlRXJyb3IpO1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RyaW5nVG9CeXRlcygpIGV4cGVjdHMgc3RyaW5nJyk7XG4gICAgcmV0dXJuIENPREVSU1t0eXBlXS5kZWNvZGUoc3RyKTtcbn07XG5leHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuZXhwb3J0cy5ieXRlcyA9IGV4cG9ydHMuc3RyaW5nVG9CeXRlcztcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImJ5dGVzIiwic3RyaW5nVG9CeXRlcyIsInN0ciIsImJ5dGVzVG9TdHJpbmciLCJoZXgiLCJ1dGY4IiwiYmVjaDMybSIsImJlY2gzMiIsImJhc2U1OGNoZWNrIiwiYmFzZTU4eG1yIiwiYmFzZTU4eHJwIiwiYmFzZTU4ZmxpY2tyIiwiYmFzZTU4IiwiYmFzZTY0dXJsbm9wYWQiLCJiYXNlNjR1cmwiLCJiYXNlNjQiLCJiYXNlMzJjcm9ja2ZvcmQiLCJiYXNlMzJoZXgiLCJiYXNlMzIiLCJiYXNlMTYiLCJ1dGlscyIsImFzc2VydE51bWJlciIsIm4iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiRXJyb3IiLCJjaGFpbiIsImFyZ3MiLCJ3cmFwIiwiYSIsImIiLCJjIiwiZW5jb2RlIiwiQXJyYXkiLCJmcm9tIiwicmV2ZXJzZSIsInJlZHVjZSIsImFjYyIsImkiLCJ1bmRlZmluZWQiLCJkZWNvZGUiLCJhbHBoYWJldCIsImRpZ2l0cyIsImlzQXJyYXkiLCJsZW5ndGgiLCJtYXAiLCJpbnB1dCIsImxldHRlciIsImluZGV4IiwiaW5kZXhPZiIsImpvaW4iLCJzZXBhcmF0b3IiLCJ0byIsInNwbGl0IiwicGFkZGluZyIsImJpdHMiLCJjaHIiLCJkYXRhIiwicHVzaCIsImVuZCIsInNsaWNlIiwibm9ybWFsaXplIiwiZm4iLCJjb252ZXJ0UmFkaXgiLCJwb3MiLCJyZXMiLCJmb3JFYWNoIiwiZCIsImNhcnJ5IiwiZG9uZSIsImRpZ2l0IiwiZGlnaXRCYXNlIiwicm91bmRlZCIsIk1hdGgiLCJmbG9vciIsImdjZCIsInJhZGl4MmNhcnJ5IiwiY29udmVydFJhZGl4MiIsIm1hc2siLCJyYWRpeCIsIm51bSIsIlVpbnQ4QXJyYXkiLCJyYWRpeDIiLCJyZXZQYWRkaW5nIiwidW5zYWZlV3JhcHBlciIsImFwcGx5IiwiZSIsImNoZWNrc3VtIiwibGVuIiwic2V0IiwicGF5bG9hZCIsIm5ld0NoZWNrc3VtIiwib2xkQ2hlY2tzdW0iLCJzIiwidG9VcHBlckNhc2UiLCJyZXBsYWNlIiwiZ2VuQmFzZTU4IiwiYWJjIiwiWE1SX0JMT0NLX0xFTiIsImJsb2NrIiwic3ViYXJyYXkiLCJwYWRTdGFydCIsImJsb2NrTGVuIiwiaiIsImNvbmNhdCIsInNoYTI1NiIsIkJFQ0hfQUxQSEFCRVQiLCJQT0xZTU9EX0dFTkVSQVRPUlMiLCJiZWNoMzJQb2x5bW9kIiwicHJlIiwiY2hrIiwiYmVjaENoZWNrc3VtIiwicHJlZml4Iiwid29yZHMiLCJlbmNvZGluZ0NvbnN0IiwiY2hhckNvZGVBdCIsInYiLCJnZW5CZWNoMzIiLCJlbmNvZGluZyIsIkVOQ09ESU5HX0NPTlNUIiwiX3dvcmRzIiwiZnJvbVdvcmRzIiwidG9Xb3JkcyIsImZyb21Xb3Jkc1Vuc2FmZSIsImxpbWl0IiwiYWN0dWFsTGVuZ3RoIiwiVHlwZUVycm9yIiwibG93ZXJlZCIsInRvTG93ZXJDYXNlIiwic3VtIiwic2VwSW5kZXgiLCJsYXN0SW5kZXhPZiIsImVuZHNXaXRoIiwiZGVjb2RlVW5zYWZlIiwiZGVjb2RlVG9CeXRlcyIsIlRleHREZWNvZGVyIiwiVGV4dEVuY29kZXIiLCJDT0RFUlMiLCJjb2RlclR5cGVFcnJvciIsInR5cGUiLCJoYXNPd25Qcm9wZXJ0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/base/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/base/lib/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@scure/base/lib/esm/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertNumber: () => (/* binding */ assertNumber),\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   base64urlnopad: () => (/* binding */ base64urlnopad),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */ function assertNumber(n) {\n    if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function chain(...args) {\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b)=>(c)=>a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = Array.from(args).reverse().reduce((acc, i)=>acc ? wrap(acc, i.encode) : i.encode, undefined);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.reduce((acc, i)=>acc ? wrap(acc, i.decode) : i.decode, undefined);\n    return {\n        encode,\n        decode\n    };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */ function alphabet(alphabet) {\n    return {\n        encode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"alphabet.encode input should be an array of numbers\");\n            return digits.map((i)=>{\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length) throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input)=>{\n            if (!Array.isArray(input) || input.length && typeof input[0] !== \"string\") throw new Error(\"alphabet.decode input should be array of strings\");\n            return input.map((letter)=>{\n                if (typeof letter !== \"string\") throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function join(separator = \"\") {\n    if (typeof separator !== \"string\") throw new Error(\"join separator should be string\");\n    return {\n        encode: (from)=>{\n            if (!Array.isArray(from) || from.length && typeof from[0] !== \"string\") throw new Error(\"join.encode input should be array of strings\");\n            for (let i of from)if (typeof i !== \"string\") throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to)=>{\n            if (typeof to !== \"string\") throw new Error(\"join.decode input should be string\");\n            return to.split(separator);\n        }\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */ function padding(bits, chr = \"=\") {\n    assertNumber(bits);\n    if (typeof chr !== \"string\") throw new Error(\"padding chr should be string\");\n    return {\n        encode (data) {\n            if (!Array.isArray(data) || data.length && typeof data[0] !== \"string\") throw new Error(\"padding.encode input should be array of strings\");\n            for (let i of data)if (typeof i !== \"string\") throw new Error(`padding.encode: non-string input=${i}`);\n            while(data.length * bits % 8)data.push(chr);\n            return data;\n        },\n        decode (input) {\n            if (!Array.isArray(input) || input.length && typeof input[0] !== \"string\") throw new Error(\"padding.encode input should be array of strings\");\n            for (let i of input)if (typeof i !== \"string\") throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if (end * bits % 8) throw new Error(\"Invalid padding: string should have whole number of bytes\");\n            for(; end > 0 && input[end - 1] === chr; end--){\n                if (!((end - 1) * bits % 8)) throw new Error(\"Invalid padding: string has too much padding\");\n            }\n            return input.slice(0, end);\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function normalize(fn) {\n    if (typeof fn !== \"function\") throw new Error(\"normalize fn should be function\");\n    return {\n        encode: (from)=>from,\n        decode: (to)=>fn(to)\n    };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */ function convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2) throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2) throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data)) throw new Error(\"convertRadix: data should be array\");\n    if (!data.length) return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d)=>{\n        assertNumber(d);\n        if (d < 0 || d >= from) throw new Error(`Wrong integer: ${d}`);\n    });\n    while(true){\n        let carry = 0;\n        let done = true;\n        for(let i = pos; i < digits.length; i++){\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {\n                throw new Error(\"convertRadix: carry overflow\");\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error(\"convertRadix: carry overflow\");\n            if (!done) continue;\n            else if (!rounded) pos = i;\n            else done = false;\n        }\n        res.push(carry);\n        if (done) break;\n    }\n    for(let i = 0; i < data.length - 1 && data[i] === 0; i++)res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b)=>!b ? a : gcd(b, a % b);\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to)=>from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */ function convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data)) throw new Error(\"convertRadix2: data should be array\");\n    if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data){\n        assertNumber(n);\n        if (n >= 2 ** from) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = carry << from | n;\n        if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for(; pos >= to; pos -= to)res.push((carry >> pos - to & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = carry << to - pos & mask;\n    if (!padding && pos >= from) throw new Error(\"Excess padding\");\n    if (!padding && carry) throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0) res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes)=>{\n            if (!(bytes instanceof Uint8Array)) throw new Error(\"radix.encode input should be Uint8Array\");\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"radix.decode input should be array of strings\");\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        }\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */ function radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32) throw new Error(\"radix2: bits should be in (0..32]\");\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error(\"radix2: carry overflow\");\n    return {\n        encode: (bytes)=>{\n            if (!(bytes instanceof Uint8Array)) throw new Error(\"radix2.encode input should be Uint8Array\");\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== \"number\") throw new Error(\"radix2.decode input should be array of strings\");\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function unsafeWrapper(fn) {\n    if (typeof fn !== \"function\") throw new Error(\"unsafeWrapper fn should be function\");\n    return function(...args) {\n        try {\n            return fn.apply(null, args);\n        } catch (e) {}\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== \"function\") throw new Error(\"checksum fn should be function\");\n    return {\n        encode (data) {\n            if (!(data instanceof Uint8Array)) throw new Error(\"checksum.encode: input should be Uint8Array\");\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode (data) {\n            if (!(data instanceof Uint8Array)) throw new Error(\"checksum.decode: input should be Uint8Array\");\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for(let i = 0; i < len; i++)if (newChecksum[i] !== oldChecksum[i]) throw new Error(\"Invalid checksum\");\n            return payload;\n        }\n    };\n}\nconst utils = {\n    alphabet,\n    chain,\n    checksum,\n    radix,\n    radix2,\n    join,\n    padding\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nconst base16 = /* @__PURE__ */ chain(radix2(4), alphabet(\"0123456789ABCDEF\"), join(\"\"));\nconst base32 = /* @__PURE__ */ chain(radix2(5), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), padding(5), join(\"\"));\nconst base32hex = /* @__PURE__ */ chain(radix2(5), alphabet(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), padding(5), join(\"\"));\nconst base32crockford = /* @__PURE__ */ chain(radix2(5), alphabet(\"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"), join(\"\"), normalize((s)=>s.toUpperCase().replace(/O/g, \"0\").replace(/[IL]/g, \"1\")));\nconst base64 = /* @__PURE__ */ chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), padding(6), join(\"\"));\nconst base64url = /* @__PURE__ */ chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), padding(6), join(\"\"));\nconst base64urlnopad = /* @__PURE__ */ chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), join(\"\"));\n// base58 code\n// -----------\nconst genBase58 = (abc)=>chain(radix(58), alphabet(abc), join(\"\"));\nconst base58 = /* @__PURE__ */ genBase58(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\nconst base58flickr = /* @__PURE__ */ genBase58(\"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\");\nconst base58xrp = /* @__PURE__ */ genBase58(\"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz\");\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [\n    0,\n    2,\n    3,\n    5,\n    6,\n    7,\n    9,\n    10,\n    11\n];\nconst base58xmr = {\n    encode (data) {\n        let res = \"\";\n        for(let i = 0; i < data.length; i += 8){\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], \"1\");\n        }\n        return res;\n    },\n    decode (str) {\n        let res = [];\n        for(let i = 0; i < str.length; i += 11){\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for(let j = 0; j < block.length - blockLen; j++){\n                if (block[j] !== 0) throw new Error(\"base58xmr: wrong padding\");\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    }\n};\nconst base58check = /* @__PURE__ */ (sha256)=>chain(checksum(4, (data)=>sha256(sha256(data))), base58);\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet(\"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"), join(\"\"));\nconst POLYMOD_GENERATORS = [\n    0x3b6a57b2,\n    0x26508e6d,\n    0x1ea119fa,\n    0x3d4233dd,\n    0x2a1462b3\n];\n/**\n * @__NO_SIDE_EFFECTS__\n */ function bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for(let i = 0; i < POLYMOD_GENERATORS.length; i++){\n        if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for(let i = 0; i < len; i++){\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ c >> 5;\n    }\n    chk = bech32Polymod(chk);\n    for(let i = 0; i < len; i++)chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;\n    for (let v of words)chk = bech32Polymod(chk) ^ v;\n    for(let i = 0; i < 6; i++)chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([\n        chk % 2 ** 30\n    ], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function genBech32(encoding) {\n    const ENCODING_CONST = encoding === \"bech32\" ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== \"string\") throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || words.length && typeof words[0] !== \"number\") throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== \"string\") throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || limit !== false && str.length > limit) throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf(\"1\");\n        if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6) throw new Error(\"Data must be at least 6 characters long\");\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return {\n            prefix,\n            words\n        };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return {\n            prefix,\n            words,\n            bytes: fromWords(words)\n        };\n    }\n    return {\n        encode,\n        decode,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords\n    };\n}\nconst bech32 = /* @__PURE__ */ genBech32(\"bech32\");\nconst bech32m = /* @__PURE__ */ genBech32(\"bech32m\");\nconst utf8 = {\n    encode: (data)=>new TextDecoder().decode(data),\n    decode: (str)=>new TextEncoder().encode(str)\n};\nconst hex = /* @__PURE__ */ chain(radix2(4), alphabet(\"0123456789abcdef\"), join(\"\"), normalize((s)=>{\n    if (typeof s !== \"string\" || s.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8,\n    hex,\n    base16,\n    base32,\n    base64,\n    base64url,\n    base58,\n    base58xmr\n};\nconst coderTypeError = \"Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr\";\nconst bytesToString = (type, bytes)=>{\n    if (typeof type !== \"string\" || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array)) throw new TypeError(\"bytesToString() expects Uint8Array\");\n    return CODERS[type].encode(bytes);\n};\nconst str = bytesToString; // as in python, but for bytes only\nconst stringToBytes = (type, str)=>{\n    if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (typeof str !== \"string\") throw new TypeError(\"stringToBytes() expects string\");\n    return CODERS[type].decode(str);\n};\nconst bytes = stringToBytes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsa0VBQWtFLEdBQ2xFLFlBQVk7QUFDWjs7Q0FFQyxHQUNNLFNBQVNBLGFBQWFDLENBQUM7SUFDMUIsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNGLElBQ3RCLE1BQU0sSUFBSUcsTUFBTSxDQUFDLGVBQWUsRUFBRUgsRUFBRSxDQUFDO0FBQzdDO0FBQ0E7O0NBRUMsR0FDRCxTQUFTSSxNQUFNLEdBQUdDLElBQUk7SUFDbEIsK0NBQStDO0lBQy9DLE1BQU1DLE9BQU8sQ0FBQ0MsR0FBR0MsSUFBTSxDQUFDQyxJQUFNRixFQUFFQyxFQUFFQztJQUNsQyw2REFBNkQ7SUFDN0QsTUFBTUMsU0FBU0MsTUFBTUMsSUFBSSxDQUFDUCxNQUNyQlEsT0FBTyxHQUNQQyxNQUFNLENBQUMsQ0FBQ0MsS0FBS0MsSUFBT0QsTUFBTVQsS0FBS1MsS0FBS0MsRUFBRU4sTUFBTSxJQUFJTSxFQUFFTixNQUFNLEVBQUdPO0lBQ2hFLHlEQUF5RDtJQUN6RCxNQUFNQyxTQUFTYixLQUFLUyxNQUFNLENBQUMsQ0FBQ0MsS0FBS0MsSUFBT0QsTUFBTVQsS0FBS1MsS0FBS0MsRUFBRUUsTUFBTSxJQUFJRixFQUFFRSxNQUFNLEVBQUdEO0lBQy9FLE9BQU87UUFBRVA7UUFBUVE7SUFBTztBQUM1QjtBQUNBOzs7Q0FHQyxHQUNELFNBQVNDLFNBQVNBLFFBQVE7SUFDdEIsT0FBTztRQUNIVCxRQUFRLENBQUNVO1lBQ0wsSUFBSSxDQUFDVCxNQUFNVSxPQUFPLENBQUNELFdBQVlBLE9BQU9FLE1BQU0sSUFBSSxPQUFPRixNQUFNLENBQUMsRUFBRSxLQUFLLFVBQ2pFLE1BQU0sSUFBSWpCLE1BQU07WUFDcEIsT0FBT2lCLE9BQU9HLEdBQUcsQ0FBQyxDQUFDUDtnQkFDZmpCLGFBQWFpQjtnQkFDYixJQUFJQSxJQUFJLEtBQUtBLEtB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VztBQUN4QixJQUFJO0FBQ0osa0JBQWtCO0FBQ2xCLE1BQU1hLFNBQVM7SUFDWEo7SUFBTUc7SUFBSzVEO0lBQVFDO0lBQVFNO0lBQVFDO0lBQVdJO0lBQVFJO0FBQzFEO0FBQ0EsTUFBTThDLGlCQUFpQjtBQUNoQixNQUFNQyxnQkFBZ0IsQ0FBQ0MsTUFBTTlFO0lBQ2hDLElBQUksT0FBTzhFLFNBQVMsWUFBWSxDQUFDSCxPQUFPSSxjQUFjLENBQUNELE9BQ25ELE1BQU0sSUFBSWxCLFVBQVVnQjtJQUN4QixJQUFJLENBQUU1RSxDQUFBQSxpQkFBaUJDLFVBQVMsR0FDNUIsTUFBTSxJQUFJMkQsVUFBVTtJQUN4QixPQUFPZSxNQUFNLENBQUNHLEtBQUssQ0FBQy9ILE1BQU0sQ0FBQ2lEO0FBQy9CLEVBQUU7QUFDSyxNQUFNa0MsTUFBTTJDLGNBQWMsQ0FBQyxtQ0FBbUM7QUFDOUQsTUFBTUcsZ0JBQWdCLENBQUNGLE1BQU01QztJQUNoQyxJQUFJLENBQUN5QyxPQUFPSSxjQUFjLENBQUNELE9BQ3ZCLE1BQU0sSUFBSWxCLFVBQVVnQjtJQUN4QixJQUFJLE9BQU8xQyxRQUFRLFVBQ2YsTUFBTSxJQUFJMEIsVUFBVTtJQUN4QixPQUFPZSxNQUFNLENBQUNHLEtBQUssQ0FBQ3ZILE1BQU0sQ0FBQzJFO0FBQy9CLEVBQUU7QUFDSyxNQUFNbEMsUUFBUWdGLGNBQWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iYXNlL2xpYi9lc20vaW5kZXguanM/ZTc5MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgc2N1cmUtYmFzZSAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gVXRpbGl0aWVzXG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROdW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW50ZWdlcjogJHtufWApO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjaGFpbiguLi5hcmdzKSB7XG4gICAgLy8gV3JhcCBjYWxsIGluIGNsb3N1cmUgc28gSklUIGNhbiBpbmxpbmUgY2FsbHNcbiAgICBjb25zdCB3cmFwID0gKGEsIGIpID0+IChjKSA9PiBhKGIoYykpO1xuICAgIC8vIENvbnN0cnVjdCBjaGFpbiBvZiBhcmdzWy0xXS5lbmNvZGUoYXJnc1stMl0uZW5jb2RlKFsuLi5dKSlcbiAgICBjb25zdCBlbmNvZGUgPSBBcnJheS5mcm9tKGFyZ3MpXG4gICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgLnJlZHVjZSgoYWNjLCBpKSA9PiAoYWNjID8gd3JhcChhY2MsIGkuZW5jb2RlKSA6IGkuZW5jb2RlKSwgdW5kZWZpbmVkKTtcbiAgICAvLyBDb25zdHJ1Y3QgY2hhaW4gb2YgYXJnc1swXS5kZWNvZGUoYXJnc1sxXS5kZWNvZGUoLi4uKSlcbiAgICBjb25zdCBkZWNvZGUgPSBhcmdzLnJlZHVjZSgoYWNjLCBpKSA9PiAoYWNjID8gd3JhcChhY2MsIGkuZGVjb2RlKSA6IGkuZGVjb2RlKSwgdW5kZWZpbmVkKTtcbiAgICByZXR1cm4geyBlbmNvZGUsIGRlY29kZSB9O1xufVxuLyoqXG4gKiBFbmNvZGVzIGludGVnZXIgcmFkaXggcmVwcmVzZW50YXRpb24gdG8gYXJyYXkgb2Ygc3RyaW5ncyB1c2luZyBhbHBoYWJldCBhbmQgYmFja1xuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYWxwaGFiZXQoYWxwaGFiZXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscGhhYmV0LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgbnVtYmVycycpO1xuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cy5tYXAoKGkpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnROdW1iZXIoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGkgPj0gYWxwaGFiZXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpZ2l0IGluZGV4IG91dHNpZGUgYWxwaGFiZXQ6ICR7aX0gKGFscGhhYmV0OiAke2FscGhhYmV0Lmxlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFscGhhYmV0W2ldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpIHx8IChpbnB1dC5sZW5ndGggJiYgdHlwZW9mIGlucHV0WzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHBoYWJldC5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5tYXAoKGxldHRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGV0dGVyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhbHBoYWJldC5kZWNvZGU6IG5vdCBzdHJpbmcgZWxlbWVudD0ke2xldHRlcn1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGFscGhhYmV0LmluZGV4T2YobGV0dGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbGV0dGVyOiBcIiR7bGV0dGVyfVwiLiBBbGxvd2VkOiAke2FscGhhYmV0fWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yID0gJycpIHtcbiAgICBpZiAodHlwZW9mIHNlcGFyYXRvciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbiBzZXBhcmF0b3Igc2hvdWxkIGJlIHN0cmluZycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGZyb20pID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShmcm9tKSB8fCAoZnJvbS5sZW5ndGggJiYgdHlwZW9mIGZyb21bMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4uZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGZyb20pXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBqb2luLmVuY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICByZXR1cm4gZnJvbS5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKHRvKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRvICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4uZGVjb2RlIGlucHV0IHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiB0by5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIFBhZCBzdHJpbmdzIGFycmF5IHNvIGl0IGhhcyBpbnRlZ2VyIG51bWJlciBvZiBiaXRzXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBwYWRkaW5nKGJpdHMsIGNociA9ICc9Jykge1xuICAgIGFzc2VydE51bWJlcihiaXRzKTtcbiAgICBpZiAodHlwZW9mIGNociAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZyBjaHIgc2hvdWxkIGJlIHN0cmluZycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkgfHwgKGRhdGEubGVuZ3RoICYmIHR5cGVvZiBkYXRhWzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBkYXRhKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFkZGluZy5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgd2hpbGUgKChkYXRhLmxlbmd0aCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goY2hyKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgKGlucHV0Lmxlbmd0aCAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGlucHV0KVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFkZGluZy5kZWNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgbGV0IGVuZCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmICgoZW5kICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYWRkaW5nOiBzdHJpbmcgc2hvdWxkIGhhdmUgd2hvbGUgbnVtYmVyIG9mIGJ5dGVzJyk7XG4gICAgICAgICAgICBmb3IgKDsgZW5kID4gMCAmJiBpbnB1dFtlbmQgLSAxXSA9PT0gY2hyOyBlbmQtLSkge1xuICAgICAgICAgICAgICAgIGlmICghKCgoZW5kIC0gMSkgKiBiaXRzKSAlIDgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFkZGluZzogc3RyaW5nIGhhcyB0b28gbXVjaCBwYWRkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQuc2xpY2UoMCwgZW5kKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBub3JtYWxpemUoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vcm1hbGl6ZSBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4geyBlbmNvZGU6IChmcm9tKSA9PiBmcm9tLCBkZWNvZGU6ICh0bykgPT4gZm4odG8pIH07XG59XG4vKipcbiAqIFNsb3c6IE8obl4yKSB0aW1lIGNvbXBsZXhpdHlcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYWRpeChkYXRhLCBmcm9tLCB0bykge1xuICAgIC8vIGJhc2UgMSBpcyBpbXBvc3NpYmxlXG4gICAgaWYgKGZyb20gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogd3JvbmcgZnJvbT0ke2Zyb219LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGlmICh0byA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiB3cm9uZyB0bz0ke3RvfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBkYXRhIHNob3VsZCBiZSBhcnJheScpO1xuICAgIGlmICghZGF0YS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBjb25zdCBkaWdpdHMgPSBBcnJheS5mcm9tKGRhdGEpO1xuICAgIGRpZ2l0cy5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgIGFzc2VydE51bWJlcihkKTtcbiAgICAgICAgaWYgKGQgPCAwIHx8IGQgPj0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW50ZWdlcjogJHtkfWApO1xuICAgIH0pO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBjYXJyeSA9IDA7XG4gICAgICAgIGxldCBkb25lID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGRpZ2l0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGlnaXQgPSBkaWdpdHNbaV07XG4gICAgICAgICAgICBjb25zdCBkaWdpdEJhc2UgPSBmcm9tICogY2FycnkgKyBkaWdpdDtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoZGlnaXRCYXNlKSB8fFxuICAgICAgICAgICAgICAgIChmcm9tICogY2FycnkpIC8gZnJvbSAhPT0gY2FycnkgfHxcbiAgICAgICAgICAgICAgICBkaWdpdEJhc2UgLSBkaWdpdCAhPT0gZnJvbSAqIGNhcnJ5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXJyeSA9IGRpZ2l0QmFzZSAlIHRvO1xuICAgICAgICAgICAgY29uc3Qgcm91bmRlZCA9IE1hdGguZmxvb3IoZGlnaXRCYXNlIC8gdG8pO1xuICAgICAgICAgICAgZGlnaXRzW2ldID0gcm91bmRlZDtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIocm91bmRlZCkgfHwgcm91bmRlZCAqIHRvICsgY2FycnkgIT09IGRpZ2l0QmFzZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFyb3VuZGVkKVxuICAgICAgICAgICAgICAgIHBvcyA9IGk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5KTtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDEgJiYgZGF0YVtpXSA9PT0gMDsgaSsrKVxuICAgICAgICByZXMucHVzaCgwKTtcbiAgICByZXR1cm4gcmVzLnJldmVyc2UoKTtcbn1cbmNvbnN0IGdjZCA9IC8qIEBfX05PX1NJREVfRUZGRUNUU19fICovIChhLCBiKSA9PiAoIWIgPyBhIDogZ2NkKGIsIGEgJSBiKSk7XG5jb25zdCByYWRpeDJjYXJyeSA9IC8qQF9fTk9fU0lERV9FRkZFQ1RTX18gKi8gKGZyb20sIHRvKSA9PiBmcm9tICsgKHRvIC0gZ2NkKGZyb20sIHRvKSk7XG4vKipcbiAqIEltcGxlbWVudGVkIHdpdGggbnVtYmVycywgYmVjYXVzZSBCaWdJbnQgaXMgNXggc2xvd2VyXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgyKGRhdGEsIGZyb20sIHRvLCBwYWRkaW5nKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDI6IGRhdGEgc2hvdWxkIGJlIGFycmF5Jyk7XG4gICAgaWYgKGZyb20gPD0gMCB8fCBmcm9tID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgZnJvbT0ke2Zyb219YCk7XG4gICAgaWYgKHRvIDw9IDAgfHwgdG8gPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyB0bz0ke3RvfWApO1xuICAgIGlmIChyYWRpeDJjYXJyeShmcm9tLCB0bykgPiAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IGZyb209JHtmcm9tfSB0bz0ke3RvfSBjYXJyeUJpdHM9JHtyYWRpeDJjYXJyeShmcm9tLCB0byl9YCk7XG4gICAgfVxuICAgIGxldCBjYXJyeSA9IDA7XG4gICAgbGV0IHBvcyA9IDA7IC8vIGJpdHdpc2UgcG9zaXRpb24gaW4gY3VycmVudCBlbGVtZW50XG4gICAgY29uc3QgbWFzayA9IDIgKiogdG8gLSAxO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgbiBvZiBkYXRhKSB7XG4gICAgICAgIGFzc2VydE51bWJlcihuKTtcbiAgICAgICAgaWYgKG4gPj0gMiAqKiBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBpbnZhbGlkIGRhdGEgd29yZD0ke259IGZyb209JHtmcm9tfWApO1xuICAgICAgICBjYXJyeSA9IChjYXJyeSA8PCBmcm9tKSB8IG47XG4gICAgICAgIGlmIChwb3MgKyBmcm9tID4gMzIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IHBvcz0ke3Bvc30gZnJvbT0ke2Zyb219YCk7XG4gICAgICAgIHBvcyArPSBmcm9tO1xuICAgICAgICBmb3IgKDsgcG9zID49IHRvOyBwb3MgLT0gdG8pXG4gICAgICAgICAgICByZXMucHVzaCgoKGNhcnJ5ID4+IChwb3MgLSB0bykpICYgbWFzaykgPj4+IDApO1xuICAgICAgICBjYXJyeSAmPSAyICoqIHBvcyAtIDE7IC8vIGNsZWFuIGNhcnJ5LCBvdGhlcndpc2UgaXQgd2lsbCBjYXVzZSBvdmVyZmxvd1xuICAgIH1cbiAgICBjYXJyeSA9IChjYXJyeSA8PCAodG8gLSBwb3MpKSAmIG1hc2s7XG4gICAgaWYgKCFwYWRkaW5nICYmIHBvcyA+PSBmcm9tKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4Y2VzcyBwYWRkaW5nJyk7XG4gICAgaWYgKCFwYWRkaW5nICYmIGNhcnJ5KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi16ZXJvIHBhZGRpbmc6ICR7Y2Fycnl9YCk7XG4gICAgaWYgKHBhZGRpbmcgJiYgcG9zID4gMClcbiAgICAgICAgcmVzLnB1c2goY2FycnkgPj4+IDApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHJhZGl4KG51bSkge1xuICAgIGFzc2VydE51bWJlcihudW0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXguZW5jb2RlIGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFJhZGl4KEFycmF5LmZyb20oYnl0ZXMpLCAyICoqIDgsIG51bSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXguZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeChkaWdpdHMsIG51bSwgMiAqKiA4KSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogSWYgYm90aCBiYXNlcyBhcmUgcG93ZXIgb2Ygc2FtZSBudW1iZXIgKGxpa2UgYDIqKjggPC0+IDIqKjY0YCksXG4gKiB0aGVyZSBpcyBhIGxpbmVhciBhbGdvcml0aG0uIEZvciBub3cgd2UgaGF2ZSBpbXBsZW1lbnRhdGlvbiBmb3IgcG93ZXItb2YtdHdvIGJhc2VzIG9ubHkuXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiByYWRpeDIoYml0cywgcmV2UGFkZGluZyA9IGZhbHNlKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGJpdHMpO1xuICAgIGlmIChiaXRzIDw9IDAgfHwgYml0cyA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogYml0cyBzaG91bGQgYmUgaW4gKDAuLjMyXScpO1xuICAgIGlmIChyYWRpeDJjYXJyeSg4LCBiaXRzKSA+IDMyIHx8IHJhZGl4MmNhcnJ5KGJpdHMsIDgpID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBjYXJyeSBvdmVyZmxvdycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeDIoQXJyYXkuZnJvbShieXRlcyksIDgsIGJpdHMsICFyZXZQYWRkaW5nKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDIuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeDIoZGlnaXRzLCBiaXRzLCA4LCByZXZQYWRkaW5nKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gdW5zYWZlV3JhcHBlcihmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zYWZlV3JhcHBlciBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY2hlY2tzdW0obGVuLCBmbikge1xuICAgIGFzc2VydE51bWJlcihsZW4pO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0gZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmVuY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtID0gZm4oZGF0YSkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgbGVuKTtcbiAgICAgICAgICAgIHJlcy5zZXQoZGF0YSk7XG4gICAgICAgICAgICByZXMuc2V0KGNoZWNrc3VtLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZGVjb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRhdGEuc2xpY2UoMCwgLWxlbik7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGVja3N1bSA9IGZuKHBheWxvYWQpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCBvbGRDaGVja3N1bSA9IGRhdGEuc2xpY2UoLWxlbik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChuZXdDaGVja3N1bVtpXSAhPT0gb2xkQ2hlY2tzdW1baV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGVja3N1bScpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCB1dGlscyA9IHsgYWxwaGFiZXQsIGNoYWluLCBjaGVja3N1bSwgcmFkaXgsIHJhZGl4Miwgam9pbiwgcGFkZGluZyB9O1xuLy8gUkZDIDQ2NDggYWthIFJGQyAzNTQ4XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydCBjb25zdCBiYXNlMTYgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDQpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRicpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3JyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlMzJoZXggPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnKSwgcGFkZGluZyg1KSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmNyb2NrZm9yZCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hKS01OUFFSU1RWV1hZWicpLCBqb2luKCcnKSwgbm9ybWFsaXplKChzKSA9PiBzLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvTy9nLCAnMCcpLnJlcGxhY2UoL1tJTF0vZywgJzEnKSkpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlNjR1cmwgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycpLCBwYWRkaW5nKDYpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTY0dXJsbm9wYWQgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycpLCBqb2luKCcnKSk7XG4vLyBiYXNlNTggY29kZVxuLy8gLS0tLS0tLS0tLS1cbmNvbnN0IGdlbkJhc2U1OCA9IChhYmMpID0+IGNoYWluKHJhZGl4KDU4KSwgYWxwaGFiZXQoYWJjKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OCA9IC8qIEBfX1BVUkVfXyAqLyBnZW5CYXNlNTgoJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonKTtcbmV4cG9ydCBjb25zdCBiYXNlNThmbGlja3IgPSAvKiBAX19QVVJFX18gKi8gZ2VuQmFzZTU4KCcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJyk7XG5leHBvcnQgY29uc3QgYmFzZTU4eHJwID0gLyogQF9fUFVSRV9fICovIGdlbkJhc2U1OCgncnBzaG5hZjM5d0JVRE5FR0hKS0xNNFBRUlNUN1ZXWFlaMmJjZGVDZzY1amttOG9GcWkxdHV2QXh5eicpO1xuLy8geG1yIHZlciBpcyBkb25lIGluIDgtYnl0ZSBibG9ja3MgKHdoaWNoIGVxdWFscyAxMSBjaGFycyBpbiBkZWNvZGluZykuIExhc3QgKG5vbi1mdWxsKSBibG9jayBwYWRkZWQgd2l0aCAnMScgdG8gc2l6ZSBpbiBYTVJfQkxPQ0tfTEVOLlxuLy8gQmxvY2sgZW5jb2Rpbmcgc2lnbmlmaWNhbnRseSByZWR1Y2VzIHF1YWRyYXRpYyBjb21wbGV4aXR5IG9mIGJhc2U1OC5cbi8vIERhdGEgbGVuIChpbmRleCkgLT4gZW5jb2RlZCBibG9jayBsZW5cbmNvbnN0IFhNUl9CTE9DS19MRU4gPSBbMCwgMiwgMywgNSwgNiwgNywgOSwgMTAsIDExXTtcbmV4cG9ydCBjb25zdCBiYXNlNTh4bXIgPSB7XG4gICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgbGV0IHJlcyA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gZGF0YS5zdWJhcnJheShpLCBpICsgOCk7XG4gICAgICAgICAgICByZXMgKz0gYmFzZTU4LmVuY29kZShibG9jaykucGFkU3RhcnQoWE1SX0JMT0NLX0xFTltibG9jay5sZW5ndGhdLCAnMScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBkZWNvZGUoc3RyKSB7XG4gICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDExKSB7XG4gICAgICAgICAgICBjb25zdCBzbGljZSA9IHN0ci5zbGljZShpLCBpICsgMTEpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tMZW4gPSBYTVJfQkxPQ0tfTEVOLmluZGV4T2Yoc2xpY2UubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gYmFzZTU4LmRlY29kZShzbGljZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tbal0gIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFzZTU4eG1yOiB3cm9uZyBwYWRkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KEFycmF5LmZyb20oYmxvY2suc2xpY2UoYmxvY2subGVuZ3RoIC0gYmxvY2tMZW4pKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShyZXMpO1xuICAgIH0sXG59O1xuZXhwb3J0IGNvbnN0IGJhc2U1OGNoZWNrID0gLyogQF9fUFVSRV9fICovIChzaGEyNTYpID0+IGNoYWluKGNoZWNrc3VtKDQsIChkYXRhKSA9PiBzaGEyNTYoc2hhMjU2KGRhdGEpKSksIGJhc2U1OCk7XG5jb25zdCBCRUNIX0FMUEhBQkVUID0gLyogQF9fUFVSRV9fICovIGNoYWluKGFscGhhYmV0KCdxcHpyeTl4OGdmMnR2ZHcwczNqbjU0a2hjZTZtdWE3bCcpLCBqb2luKCcnKSk7XG5jb25zdCBQT0xZTU9EX0dFTkVSQVRPUlMgPSBbMHgzYjZhNTdiMiwgMHgyNjUwOGU2ZCwgMHgxZWExMTlmYSwgMHgzZDQyMzNkZCwgMHgyYTE0NjJiM107XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGJlY2gzMlBvbHltb2QocHJlKSB7XG4gICAgY29uc3QgYiA9IHByZSA+PiAyNTtcbiAgICBsZXQgY2hrID0gKHByZSAmIDB4MWZmZmZmZikgPDwgNTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFBPTFlNT0RfR0VORVJBVE9SUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKChiID4+IGkpICYgMSkgPT09IDEpXG4gICAgICAgICAgICBjaGsgXj0gUE9MWU1PRF9HRU5FUkFUT1JTW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2hrO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBiZWNoQ2hlY2tzdW0ocHJlZml4LCB3b3JkcywgZW5jb2RpbmdDb25zdCA9IDEpIHtcbiAgICBjb25zdCBsZW4gPSBwcmVmaXgubGVuZ3RoO1xuICAgIGxldCBjaGsgPSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHByZWZpeC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDMzIHx8IGMgPiAxMjYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHJlZml4ICgke3ByZWZpeH0pYCk7XG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChjID4+IDUpO1xuICAgIH1cbiAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoayk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gKHByZWZpeC5jaGFyQ29kZUF0KGkpICYgMHgxZik7XG4gICAgZm9yIChsZXQgdiBvZiB3b3JkcylcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gdjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKylcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGNoayBePSBlbmNvZGluZ0NvbnN0O1xuICAgIHJldHVybiBCRUNIX0FMUEhBQkVULmVuY29kZShjb252ZXJ0UmFkaXgyKFtjaGsgJSAyICoqIDMwXSwgMzAsIDUsIGZhbHNlKSk7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGdlbkJlY2gzMihlbmNvZGluZykge1xuICAgIGNvbnN0IEVOQ09ESU5HX0NPTlNUID0gZW5jb2RpbmcgPT09ICdiZWNoMzInID8gMSA6IDB4MmJjODMwYTM7XG4gICAgY29uc3QgX3dvcmRzID0gcmFkaXgyKDUpO1xuICAgIGNvbnN0IGZyb21Xb3JkcyA9IF93b3Jkcy5kZWNvZGU7XG4gICAgY29uc3QgdG9Xb3JkcyA9IF93b3Jkcy5lbmNvZGU7XG4gICAgY29uc3QgZnJvbVdvcmRzVW5zYWZlID0gdW5zYWZlV3JhcHBlcihmcm9tV29yZHMpO1xuICAgIGZ1bmN0aW9uIGVuY29kZShwcmVmaXgsIHdvcmRzLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZml4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmVuY29kZSBwcmVmaXggc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHByZWZpeH1gKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHdvcmRzKSB8fCAod29yZHMubGVuZ3RoICYmIHR5cGVvZiB3b3Jkc1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHdvcmRzIHNob3VsZCBiZSBhcnJheSBvZiBudW1iZXJzLCBub3QgJHt0eXBlb2Ygd29yZHN9YCk7XG4gICAgICAgIGNvbnN0IGFjdHVhbExlbmd0aCA9IHByZWZpeC5sZW5ndGggKyA3ICsgd29yZHMubGVuZ3RoO1xuICAgICAgICBpZiAobGltaXQgIT09IGZhbHNlICYmIGFjdHVhbExlbmd0aCA+IGxpbWl0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTGVuZ3RoICR7YWN0dWFsTGVuZ3RofSBleGNlZWRzIGxpbWl0ICR7bGltaXR9YCk7XG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBwcmVmaXgudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3Qgc3VtID0gYmVjaENoZWNrc3VtKGxvd2VyZWQsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIHJldHVybiBgJHtsb3dlcmVkfTEke0JFQ0hfQUxQSEFCRVQuZW5jb2RlKHdvcmRzKX0ke3N1bX1gO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGUoc3RyLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgc3RyaW5nLCBub3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA8IDggfHwgKGxpbWl0ICE9PSBmYWxzZSAmJiBzdHIubGVuZ3RoID4gbGltaXQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgV3Jvbmcgc3RyaW5nIGxlbmd0aDogJHtzdHIubGVuZ3RofSAoJHtzdHJ9KS4gRXhwZWN0ZWQgKDguLiR7bGltaXR9KWApO1xuICAgICAgICAvLyBkb24ndCBhbGxvdyBtaXhlZCBjYXNlXG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHN0ciAhPT0gbG93ZXJlZCAmJiBzdHIgIT09IHN0ci50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdHJpbmcgbXVzdCBiZSBsb3dlcmNhc2Ugb3IgdXBwZXJjYXNlYCk7XG4gICAgICAgIHN0ciA9IGxvd2VyZWQ7XG4gICAgICAgIGNvbnN0IHNlcEluZGV4ID0gc3RyLmxhc3RJbmRleE9mKCcxJyk7XG4gICAgICAgIGlmIChzZXBJbmRleCA9PT0gMCB8fCBzZXBJbmRleCA9PT0gLTEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExldHRlciBcIjFcIiBtdXN0IGJlIHByZXNlbnQgYmV0d2VlbiBwcmVmaXggYW5kIGRhdGEgb25seWApO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBzdHIuc2xpY2UoMCwgc2VwSW5kZXgpO1xuICAgICAgICBjb25zdCBfd29yZHMgPSBzdHIuc2xpY2Uoc2VwSW5kZXggKyAxKTtcbiAgICAgICAgaWYgKF93b3Jkcy5sZW5ndGggPCA2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG11c3QgYmUgYXQgbGVhc3QgNiBjaGFyYWN0ZXJzIGxvbmcnKTtcbiAgICAgICAgY29uc3Qgd29yZHMgPSBCRUNIX0FMUEhBQkVULmRlY29kZShfd29yZHMpLnNsaWNlKDAsIC02KTtcbiAgICAgICAgY29uc3Qgc3VtID0gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIEVOQ09ESU5HX0NPTlNUKTtcbiAgICAgICAgaWYgKCFfd29yZHMuZW5kc1dpdGgoc3VtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGVja3N1bSBpbiAke3N0cn06IGV4cGVjdGVkIFwiJHtzdW19XCJgKTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcyB9O1xuICAgIH1cbiAgICBjb25zdCBkZWNvZGVVbnNhZmUgPSB1bnNhZmVXcmFwcGVyKGRlY29kZSk7XG4gICAgZnVuY3Rpb24gZGVjb2RlVG9CeXRlcyhzdHIpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHdvcmRzIH0gPSBkZWNvZGUoc3RyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMsIGJ5dGVzOiBmcm9tV29yZHMod29yZHMpIH07XG4gICAgfVxuICAgIHJldHVybiB7IGVuY29kZSwgZGVjb2RlLCBkZWNvZGVUb0J5dGVzLCBkZWNvZGVVbnNhZmUsIGZyb21Xb3JkcywgZnJvbVdvcmRzVW5zYWZlLCB0b1dvcmRzIH07XG59XG5leHBvcnQgY29uc3QgYmVjaDMyID0gLyogQF9fUFVSRV9fICovIGdlbkJlY2gzMignYmVjaDMyJyk7XG5leHBvcnQgY29uc3QgYmVjaDMybSA9IC8qIEBfX1BVUkVfXyAqLyBnZW5CZWNoMzIoJ2JlY2gzMm0nKTtcbmV4cG9ydCBjb25zdCB1dGY4ID0ge1xuICAgIGVuY29kZTogKGRhdGEpID0+IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkYXRhKSxcbiAgICBkZWNvZGU6IChzdHIpID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpLFxufTtcbmV4cG9ydCBjb25zdCBoZXggPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDQpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OWFiY2RlZicpLCBqb2luKCcnKSwgbm9ybWFsaXplKChzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzICE9PSAnc3RyaW5nJyB8fCBzLmxlbmd0aCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGhleC5kZWNvZGU6IGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN9IHdpdGggbGVuZ3RoICR7cy5sZW5ndGh9YCk7XG4gICAgcmV0dXJuIHMudG9Mb3dlckNhc2UoKTtcbn0pKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgQ09ERVJTID0ge1xuICAgIHV0ZjgsIGhleCwgYmFzZTE2LCBiYXNlMzIsIGJhc2U2NCwgYmFzZTY0dXJsLCBiYXNlNTgsIGJhc2U1OHhtclxufTtcbmNvbnN0IGNvZGVyVHlwZUVycm9yID0gJ0ludmFsaWQgZW5jb2RpbmcgdHlwZS4gQXZhaWxhYmxlIHR5cGVzOiB1dGY4LCBoZXgsIGJhc2UxNiwgYmFzZTMyLCBiYXNlNjQsIGJhc2U2NHVybCwgYmFzZTU4LCBiYXNlNTh4bXInO1xuZXhwb3J0IGNvbnN0IGJ5dGVzVG9TdHJpbmcgPSAodHlwZSwgYnl0ZXMpID0+IHtcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnIHx8ICFDT0RFUlMuaGFzT3duUHJvcGVydHkodHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29kZXJUeXBlRXJyb3IpO1xuICAgIGlmICghKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J5dGVzVG9TdHJpbmcoKSBleHBlY3RzIFVpbnQ4QXJyYXknKTtcbiAgICByZXR1cm4gQ09ERVJTW3R5cGVdLmVuY29kZShieXRlcyk7XG59O1xuZXhwb3J0IGNvbnN0IHN0ciA9IGJ5dGVzVG9TdHJpbmc7IC8vIGFzIGluIHB5dGhvbiwgYnV0IGZvciBieXRlcyBvbmx5XG5leHBvcnQgY29uc3Qgc3RyaW5nVG9CeXRlcyA9ICh0eXBlLCBzdHIpID0+IHtcbiAgICBpZiAoIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmdUb0J5dGVzKCkgZXhwZWN0cyBzdHJpbmcnKTtcbiAgICByZXR1cm4gQ09ERVJTW3R5cGVdLmRlY29kZShzdHIpO1xufTtcbmV4cG9ydCBjb25zdCBieXRlcyA9IHN0cmluZ1RvQnl0ZXM7XG4iXSwibmFtZXMiOlsiYXNzZXJ0TnVtYmVyIiwibiIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJFcnJvciIsImNoYWluIiwiYXJncyIsIndyYXAiLCJhIiwiYiIsImMiLCJlbmNvZGUiLCJBcnJheSIsImZyb20iLCJyZXZlcnNlIiwicmVkdWNlIiwiYWNjIiwiaSIsInVuZGVmaW5lZCIsImRlY29kZSIsImFscGhhYmV0IiwiZGlnaXRzIiwiaXNBcnJheSIsImxlbmd0aCIsIm1hcCIsImlucHV0IiwibGV0dGVyIiwiaW5kZXgiLCJpbmRleE9mIiwiam9pbiIsInNlcGFyYXRvciIsInRvIiwic3BsaXQiLCJwYWRkaW5nIiwiYml0cyIsImNociIsImRhdGEiLCJwdXNoIiwiZW5kIiwic2xpY2UiLCJub3JtYWxpemUiLCJmbiIsImNvbnZlcnRSYWRpeCIsInBvcyIsInJlcyIsImZvckVhY2giLCJkIiwiY2FycnkiLCJkb25lIiwiZGlnaXQiLCJkaWdpdEJhc2UiLCJyb3VuZGVkIiwiTWF0aCIsImZsb29yIiwiZ2NkIiwicmFkaXgyY2FycnkiLCJjb252ZXJ0UmFkaXgyIiwibWFzayIsInJhZGl4IiwibnVtIiwiYnl0ZXMiLCJVaW50OEFycmF5IiwicmFkaXgyIiwicmV2UGFkZGluZyIsInVuc2FmZVdyYXBwZXIiLCJhcHBseSIsImUiLCJjaGVja3N1bSIsImxlbiIsInNldCIsInBheWxvYWQiLCJuZXdDaGVja3N1bSIsIm9sZENoZWNrc3VtIiwidXRpbHMiLCJiYXNlMTYiLCJiYXNlMzIiLCJiYXNlMzJoZXgiLCJiYXNlMzJjcm9ja2ZvcmQiLCJzIiwidG9VcHBlckNhc2UiLCJyZXBsYWNlIiwiYmFzZTY0IiwiYmFzZTY0dXJsIiwiYmFzZTY0dXJsbm9wYWQiLCJnZW5CYXNlNTgiLCJhYmMiLCJiYXNlNTgiLCJiYXNlNThmbGlja3IiLCJiYXNlNTh4cnAiLCJYTVJfQkxPQ0tfTEVOIiwiYmFzZTU4eG1yIiwiYmxvY2siLCJzdWJhcnJheSIsInBhZFN0YXJ0Iiwic3RyIiwiYmxvY2tMZW4iLCJqIiwiY29uY2F0IiwiYmFzZTU4Y2hlY2siLCJzaGEyNTYiLCJCRUNIX0FMUEhBQkVUIiwiUE9MWU1PRF9HRU5FUkFUT1JTIiwiYmVjaDMyUG9seW1vZCIsInByZSIsImNoayIsImJlY2hDaGVja3N1bSIsInByZWZpeCIsIndvcmRzIiwiZW5jb2RpbmdDb25zdCIsImNoYXJDb2RlQXQiLCJ2IiwiZ2VuQmVjaDMyIiwiZW5jb2RpbmciLCJFTkNPRElOR19DT05TVCIsIl93b3JkcyIsImZyb21Xb3JkcyIsInRvV29yZHMiLCJmcm9tV29yZHNVbnNhZmUiLCJsaW1pdCIsImFjdHVhbExlbmd0aCIsIlR5cGVFcnJvciIsImxvd2VyZWQiLCJ0b0xvd2VyQ2FzZSIsInN1bSIsInNlcEluZGV4IiwibGFzdEluZGV4T2YiLCJlbmRzV2l0aCIsImRlY29kZVVuc2FmZSIsImRlY29kZVRvQnl0ZXMiLCJiZWNoMzIiLCJiZWNoMzJtIiwidXRmOCIsIlRleHREZWNvZGVyIiwiVGV4dEVuY29kZXIiLCJoZXgiLCJDT0RFUlMiLCJjb2RlclR5cGVFcnJvciIsImJ5dGVzVG9TdHJpbmciLCJ0eXBlIiwiaGFzT3duUHJvcGVydHkiLCJzdHJpbmdUb0J5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/base/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip39/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/@scure/bip39/esm/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   entropyToMnemonic: () => (/* binding */ entropyToMnemonic),\n/* harmony export */   generateMnemonic: () => (/* binding */ generateMnemonic),\n/* harmony export */   mnemonicToEntropy: () => (/* binding */ mnemonicToEntropy),\n/* harmony export */   mnemonicToSeed: () => (/* binding */ mnemonicToSeed),\n/* harmony export */   mnemonicToSeedSync: () => (/* binding */ mnemonicToSeedSync),\n/* harmony export */   validateMnemonic: () => (/* binding */ validateMnemonic)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/_assert */ \"(ssr)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/pbkdf2 */ \"(ssr)/./node_modules/@noble/hashes/esm/pbkdf2.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/esm/index.js\");\n\n\n\n\n\n\nconst isJapanese = (wordlist)=>wordlist[0] === \"あいこくしん\";\nfunction nfkd(str) {\n    if (typeof str !== \"string\") throw new TypeError(`Invalid mnemonic type: ${typeof str}`);\n    return str.normalize(\"NFKD\");\n}\nfunction normalize(str) {\n    const norm = nfkd(str);\n    const words = norm.split(\" \");\n    if (![\n        12,\n        15,\n        18,\n        21,\n        24\n    ].includes(words.length)) throw new Error(\"Invalid mnemonic\");\n    return {\n        nfkd: norm,\n        words\n    };\n}\nfunction assertEntropy(entropy) {\n    _noble_hashes_assert__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(entropy, 16, 20, 24, 28, 32);\n}\nfunction generateMnemonic(wordlist, strength = 128) {\n    _noble_hashes_assert__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(strength);\n    if (strength % 32 !== 0 || strength > 256) throw new TypeError(\"Invalid entropy\");\n    return entropyToMnemonic((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes)(strength / 8), wordlist);\n}\nconst calcChecksum = (entropy)=>{\n    const bitsLeft = 8 - entropy.length / 4;\n    return new Uint8Array([\n        (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(entropy)[0] >> bitsLeft << bitsLeft\n    ]);\n};\nfunction getCoder(wordlist) {\n    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== \"string\") throw new Error(\"Worlist: expected array of 2048 strings\");\n    wordlist.forEach((i)=>{\n        if (typeof i !== \"string\") throw new Error(`Wordlist: non-string element: ${i}`);\n    });\n    return _scure_base__WEBPACK_IMPORTED_MODULE_3__.utils.chain(_scure_base__WEBPACK_IMPORTED_MODULE_3__.utils.checksum(1, calcChecksum), _scure_base__WEBPACK_IMPORTED_MODULE_3__.utils.radix2(11, true), _scure_base__WEBPACK_IMPORTED_MODULE_3__.utils.alphabet(wordlist));\n}\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    const { words } = normalize(mnemonic);\n    const entropy = getCoder(wordlist).decode(words);\n    assertEntropy(entropy);\n    return entropy;\n}\nfunction entropyToMnemonic(entropy, wordlist) {\n    assertEntropy(entropy);\n    const words = getCoder(wordlist).encode(entropy);\n    return words.join(isJapanese(wordlist) ? \"　\" : \" \");\n}\nfunction validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}\nconst salt = (passphrase)=>nfkd(`mnemonic${passphrase}`);\nfunction mnemonicToSeed(mnemonic, passphrase = \"\") {\n    return (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__.pbkdf2Async)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_5__.sha512, normalize(mnemonic).nfkd, salt(passphrase), {\n        c: 2048,\n        dkLen: 64\n    });\n}\nfunction mnemonicToSeedSync(mnemonic, passphrase = \"\") {\n    return (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__.pbkdf2)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_5__.sha512, normalize(mnemonic).nfkd, salt(passphrase), {\n        c: 2048,\n        dkLen: 64\n    });\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBMkM7QUFDZ0I7QUFDYjtBQUNBO0FBQ0k7QUFDRDtBQUNqRCxNQUFNUSxhQUFhLENBQUNDLFdBQWFBLFFBQVEsQ0FBQyxFQUFFLEtBQUs7QUFDakQsU0FBU0MsS0FBS0MsR0FBRztJQUNiLElBQUksT0FBT0EsUUFBUSxVQUNmLE1BQU0sSUFBSUMsVUFBVSxDQUFDLHVCQUF1QixFQUFFLE9BQU9ELElBQUksQ0FBQztJQUM5RCxPQUFPQSxJQUFJRSxTQUFTLENBQUM7QUFDekI7QUFDQSxTQUFTQSxVQUFVRixHQUFHO0lBQ2xCLE1BQU1HLE9BQU9KLEtBQUtDO0lBQ2xCLE1BQU1JLFFBQVFELEtBQUtFLEtBQUssQ0FBQztJQUN6QixJQUFJLENBQUM7UUFBQztRQUFJO1FBQUk7UUFBSTtRQUFJO0tBQUcsQ0FBQ0MsUUFBUSxDQUFDRixNQUFNRyxNQUFNLEdBQzNDLE1BQU0sSUFBSUMsTUFBTTtJQUNwQixPQUFPO1FBQUVULE1BQU1JO1FBQU1DO0lBQU07QUFDL0I7QUFDQSxTQUFTSyxjQUFjQyxPQUFPO0lBQzFCckIsa0VBQVksQ0FBQ3FCLFNBQVMsSUFBSSxJQUFJLElBQUksSUFBSTtBQUMxQztBQUNPLFNBQVNFLGlCQUFpQmQsUUFBUSxFQUFFZSxXQUFXLEdBQUc7SUFDckR4QixtRUFBYSxDQUFDd0I7SUFDZCxJQUFJQSxXQUFXLE9BQU8sS0FBS0EsV0FBVyxLQUNsQyxNQUFNLElBQUlaLFVBQVU7SUFDeEIsT0FBT2Msa0JBQWtCckIsZ0VBQVdBLENBQUNtQixXQUFXLElBQUlmO0FBQ3hEO0FBQ0EsTUFBTWtCLGVBQWUsQ0FBQ047SUFDbEIsTUFBTU8sV0FBVyxJQUFJUCxRQUFRSCxNQUFNLEdBQUc7SUFDdEMsT0FBTyxJQUFJVyxXQUFXO1FBQUUxQiw0REFBTUEsQ0FBQ2tCLFFBQVEsQ0FBQyxFQUFFLElBQUlPLFlBQWFBO0tBQVM7QUFDeEU7QUFDQSxTQUFTRSxTQUFTckIsUUFBUTtJQUN0QixJQUFJLENBQUNzQixNQUFNQyxPQUFPLENBQUN2QixhQUFhQSxTQUFTUyxNQUFNLEtBQUssUUFBUSxPQUFPVCxRQUFRLENBQUMsRUFBRSxLQUFLLFVBQy9FLE1BQU0sSUFBSVUsTUFBTTtJQUNwQlYsU0FBU3dCLE9BQU8sQ0FBQyxDQUFDQztRQUNkLElBQUksT0FBT0EsTUFBTSxVQUNiLE1BQU0sSUFBSWYsTUFBTSxDQUFDLDhCQUE4QixFQUFFZSxFQUFFLENBQUM7SUFDNUQ7SUFDQSxPQUFPM0IsOENBQVNBLENBQUM0QixLQUFLLENBQUM1Qiw4Q0FBU0EsQ0FBQzZCLFFBQVEsQ0FBQyxHQUFHVCxlQUFlcEIsOENBQVNBLENBQUM4QixNQUFNLENBQUMsSUFBSSxPQUFPOUIsOENBQVNBLENBQUMrQixRQUFRLENBQUM3QjtBQUMvRztBQUNPLFNBQVM4QixrQkFBa0JDLFFBQVEsRUFBRS9CLFFBQVE7SUFDaEQsTUFBTSxFQUFFTSxLQUFLLEVBQUUsR0FBR0YsVUFBVTJCO0lBQzVCLE1BQU1uQixVQUFVUyxTQUFTckIsVUFBVWdDLE1BQU0sQ0FBQzFCO0lBQzFDSyxjQUFjQztJQUNkLE9BQU9BO0FBQ1g7QUFDTyxTQUFTSyxrQkFBa0JMLE9BQU8sRUFBRVosUUFBUTtJQUMvQ1csY0FBY0M7SUFDZCxNQUFNTixRQUFRZSxTQUFTckIsVUFBVWlDLE1BQU0sQ0FBQ3JCO0lBQ3hDLE9BQU9OLE1BQU00QixJQUFJLENBQUNuQyxXQUFXQyxZQUFZLE1BQVc7QUFDeEQ7QUFDTyxTQUFTbUMsaUJBQWlCSixRQUFRLEVBQUUvQixRQUFRO0lBQy9DLElBQUk7UUFDQThCLGtCQUFrQkMsVUFBVS9CO0lBQ2hDLEVBQ0EsT0FBT29DLEdBQUc7UUFDTixPQUFPO0lBQ1g7SUFDQSxPQUFPO0FBQ1g7QUFDQSxNQUFNQyxPQUFPLENBQUNDLGFBQWVyQyxLQUFLLENBQUMsUUFBUSxFQUFFcUMsV0FBVyxDQUFDO0FBQ2xELFNBQVNDLGVBQWVSLFFBQVEsRUFBRU8sYUFBYSxFQUFFO0lBQ3BELE9BQU83QyxpRUFBV0EsQ0FBQ0Usd0RBQU1BLEVBQUVTLFVBQVUyQixVQUFVOUIsSUFBSSxFQUFFb0MsS0FBS0MsYUFBYTtRQUFFRSxHQUFHO1FBQU1DLE9BQU87SUFBRztBQUNoRztBQUNPLFNBQVNDLG1CQUFtQlgsUUFBUSxFQUFFTyxhQUFhLEVBQUU7SUFDeEQsT0FBTzlDLDREQUFNQSxDQUFDRyx3REFBTUEsRUFBRVMsVUFBVTJCLFVBQVU5QixJQUFJLEVBQUVvQyxLQUFLQyxhQUFhO1FBQUVFLEdBQUc7UUFBTUMsT0FBTztJQUFHO0FBQzNGLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvZXNtL2luZGV4LmpzPzUyYTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICdAbm9ibGUvaGFzaGVzL19hc3NlcnQnO1xuaW1wb3J0IHsgcGJrZGYyLCBwYmtkZjJBc3luYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvcGJrZGYyJztcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IHNoYTUxMiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhNTEyJztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyB1dGlscyBhcyBiYXNlVXRpbHMgfSBmcm9tICdAc2N1cmUvYmFzZSc7XG5jb25zdCBpc0phcGFuZXNlID0gKHdvcmRsaXN0KSA9PiB3b3JkbGlzdFswXSA9PT0gJ1xcdTMwNDJcXHUzMDQ0XFx1MzA1M1xcdTMwNGZcXHUzMDU3XFx1MzA5Myc7XG5mdW5jdGlvbiBuZmtkKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBtbmVtb25pYyB0eXBlOiAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIHN0ci5ub3JtYWxpemUoJ05GS0QnKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZShzdHIpIHtcbiAgICBjb25zdCBub3JtID0gbmZrZChzdHIpO1xuICAgIGNvbnN0IHdvcmRzID0gbm9ybS5zcGxpdCgnICcpO1xuICAgIGlmICghWzEyLCAxNSwgMTgsIDIxLCAyNF0uaW5jbHVkZXMod29yZHMubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1uZW1vbmljJyk7XG4gICAgcmV0dXJuIHsgbmZrZDogbm9ybSwgd29yZHMgfTtcbn1cbmZ1bmN0aW9uIGFzc2VydEVudHJvcHkoZW50cm9weSkge1xuICAgIGFzc2VydC5ieXRlcyhlbnRyb3B5LCAxNiwgMjAsIDI0LCAyOCwgMzIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlTW5lbW9uaWMod29yZGxpc3QsIHN0cmVuZ3RoID0gMTI4KSB7XG4gICAgYXNzZXJ0Lm51bWJlcihzdHJlbmd0aCk7XG4gICAgaWYgKHN0cmVuZ3RoICUgMzIgIT09IDAgfHwgc3RyZW5ndGggPiAyNTYpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgZW50cm9weScpO1xuICAgIHJldHVybiBlbnRyb3B5VG9NbmVtb25pYyhyYW5kb21CeXRlcyhzdHJlbmd0aCAvIDgpLCB3b3JkbGlzdCk7XG59XG5jb25zdCBjYWxjQ2hlY2tzdW0gPSAoZW50cm9weSkgPT4ge1xuICAgIGNvbnN0IGJpdHNMZWZ0ID0gOCAtIGVudHJvcHkubGVuZ3RoIC8gNDtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWyhzaGEyNTYoZW50cm9weSlbMF0gPj4gYml0c0xlZnQpIDw8IGJpdHNMZWZ0XSk7XG59O1xuZnVuY3Rpb24gZ2V0Q29kZXIod29yZGxpc3QpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkod29yZGxpc3QpIHx8IHdvcmRsaXN0Lmxlbmd0aCAhPT0gMjA0OCB8fCB0eXBlb2Ygd29yZGxpc3RbMF0gIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmxpc3Q6IGV4cGVjdGVkIGFycmF5IG9mIDIwNDggc3RyaW5ncycpO1xuICAgIHdvcmRsaXN0LmZvckVhY2goKGkpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV29yZGxpc3Q6IG5vbi1zdHJpbmcgZWxlbWVudDogJHtpfWApO1xuICAgIH0pO1xuICAgIHJldHVybiBiYXNlVXRpbHMuY2hhaW4oYmFzZVV0aWxzLmNoZWNrc3VtKDEsIGNhbGNDaGVja3N1bSksIGJhc2VVdGlscy5yYWRpeDIoMTEsIHRydWUpLCBiYXNlVXRpbHMuYWxwaGFiZXQod29yZGxpc3QpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtbmVtb25pY1RvRW50cm9weShtbmVtb25pYywgd29yZGxpc3QpIHtcbiAgICBjb25zdCB7IHdvcmRzIH0gPSBub3JtYWxpemUobW5lbW9uaWMpO1xuICAgIGNvbnN0IGVudHJvcHkgPSBnZXRDb2Rlcih3b3JkbGlzdCkuZGVjb2RlKHdvcmRzKTtcbiAgICBhc3NlcnRFbnRyb3B5KGVudHJvcHkpO1xuICAgIHJldHVybiBlbnRyb3B5O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVudHJvcHlUb01uZW1vbmljKGVudHJvcHksIHdvcmRsaXN0KSB7XG4gICAgYXNzZXJ0RW50cm9weShlbnRyb3B5KTtcbiAgICBjb25zdCB3b3JkcyA9IGdldENvZGVyKHdvcmRsaXN0KS5lbmNvZGUoZW50cm9weSk7XG4gICAgcmV0dXJuIHdvcmRzLmpvaW4oaXNKYXBhbmVzZSh3b3JkbGlzdCkgPyAnXFx1MzAwMCcgOiAnICcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTW5lbW9uaWMobW5lbW9uaWMsIHdvcmRsaXN0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IHNhbHQgPSAocGFzc3BocmFzZSkgPT4gbmZrZChgbW5lbW9uaWMke3Bhc3NwaHJhc2V9YCk7XG5leHBvcnQgZnVuY3Rpb24gbW5lbW9uaWNUb1NlZWQobW5lbW9uaWMsIHBhc3NwaHJhc2UgPSAnJykge1xuICAgIHJldHVybiBwYmtkZjJBc3luYyhzaGE1MTIsIG5vcm1hbGl6ZShtbmVtb25pYykubmZrZCwgc2FsdChwYXNzcGhyYXNlKSwgeyBjOiAyMDQ4LCBka0xlbjogNjQgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbW5lbW9uaWNUb1NlZWRTeW5jKG1uZW1vbmljLCBwYXNzcGhyYXNlID0gJycpIHtcbiAgICByZXR1cm4gcGJrZGYyKHNoYTUxMiwgbm9ybWFsaXplKG1uZW1vbmljKS5uZmtkLCBzYWx0KHBhc3NwaHJhc2UpLCB7IGM6IDIwNDgsIGRrTGVuOiA2NCB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJhc3NlcnQiLCJwYmtkZjIiLCJwYmtkZjJBc3luYyIsInNoYTI1NiIsInNoYTUxMiIsInJhbmRvbUJ5dGVzIiwidXRpbHMiLCJiYXNlVXRpbHMiLCJpc0phcGFuZXNlIiwid29yZGxpc3QiLCJuZmtkIiwic3RyIiwiVHlwZUVycm9yIiwibm9ybWFsaXplIiwibm9ybSIsIndvcmRzIiwic3BsaXQiLCJpbmNsdWRlcyIsImxlbmd0aCIsIkVycm9yIiwiYXNzZXJ0RW50cm9weSIsImVudHJvcHkiLCJieXRlcyIsImdlbmVyYXRlTW5lbW9uaWMiLCJzdHJlbmd0aCIsIm51bWJlciIsImVudHJvcHlUb01uZW1vbmljIiwiY2FsY0NoZWNrc3VtIiwiYml0c0xlZnQiLCJVaW50OEFycmF5IiwiZ2V0Q29kZXIiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwiaSIsImNoYWluIiwiY2hlY2tzdW0iLCJyYWRpeDIiLCJhbHBoYWJldCIsIm1uZW1vbmljVG9FbnRyb3B5IiwibW5lbW9uaWMiLCJkZWNvZGUiLCJlbmNvZGUiLCJqb2luIiwidmFsaWRhdGVNbmVtb25pYyIsImUiLCJzYWx0IiwicGFzc3BocmFzZSIsIm1uZW1vbmljVG9TZWVkIiwiYyIsImRrTGVuIiwibW5lbW9uaWNUb1NlZWRTeW5jIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip39/esm/index.js\n");

/***/ })

};
;