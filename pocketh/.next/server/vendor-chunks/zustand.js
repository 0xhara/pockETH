"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/zustand";
exports.ids = ["vendor-chunks/zustand"];
exports.modules = {

/***/ "(ssr)/./node_modules/zustand/esm/index.mjs":
/*!********************************************!*\
  !*** ./node_modules/zustand/esm/index.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   createStore: () => (/* reexport safe */ zustand_vanilla__WEBPACK_IMPORTED_MODULE_0__.createStore),\n/* harmony export */   \"default\": () => (/* binding */ react),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var zustand_vanilla__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand/vanilla */ \"(ssr)/./node_modules/zustand/esm/vanilla.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/with-selector.js\");\n\n\n\n\nconst { useDebugValue } = react__WEBPACK_IMPORTED_MODULE_1__;\nconst { useSyncExternalStoreWithSelector } = use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__;\nlet didWarnAboutEqualityFn = false;\nfunction useStore(api, selector = api.getState, equalityFn) {\n    if (( false ? 0 : void 0) !== \"production\" && equalityFn && !didWarnAboutEqualityFn) {\n        console.warn(\"[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937\");\n        didWarnAboutEqualityFn = true;\n    }\n    const slice = useSyncExternalStoreWithSelector(api.subscribe, api.getState, api.getServerState || api.getState, selector, equalityFn);\n    useDebugValue(slice);\n    return slice;\n}\nconst createImpl = (createState)=>{\n    if (( false ? 0 : void 0) !== \"production\" && typeof createState !== \"function\") {\n        console.warn(\"[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.\");\n    }\n    const api = typeof createState === \"function\" ? (0,zustand_vanilla__WEBPACK_IMPORTED_MODULE_0__.createStore)(createState) : createState;\n    const useBoundStore = (selector, equalityFn)=>useStore(api, selector, equalityFn);\n    Object.assign(useBoundStore, api);\n    return useBoundStore;\n};\nconst create = (createState)=>createState ? createImpl(createState) : createImpl;\nvar react = (createState)=>{\n    if (( false ? 0 : void 0) !== \"production\") {\n        console.warn(\"[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`.\");\n    }\n    return create(createState);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvenVzdGFuZC9lc20vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBOEM7QUFDZDtBQUNDO0FBQ3VEO0FBRXhGLE1BQU0sRUFBRUcsYUFBYSxFQUFFLEdBQUdGLGtDQUFZQTtBQUN0QyxNQUFNLEVBQUVHLGdDQUFnQyxFQUFFLEdBQUdGLDBFQUEyQkE7QUFDeEUsSUFBSUcseUJBQXlCO0FBQzdCLFNBQVNDLFNBQVNDLEdBQUcsRUFBRUMsV0FBV0QsSUFBSUUsUUFBUSxFQUFFQyxVQUFVO0lBQ3hELElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sZ0JBQWdCQSxjQUFjLENBQUNMLHdCQUF3QjtRQUMvR1EsUUFBUUMsSUFBSSxDQUNWO1FBRUZULHlCQUF5QjtJQUMzQjtJQUNBLE1BQU1VLFFBQVFYLGlDQUNaRyxJQUFJUyxTQUFTLEVBQ2JULElBQUlFLFFBQVEsRUFDWkYsSUFBSVUsY0FBYyxJQUFJVixJQUFJRSxRQUFRLEVBQ2xDRCxVQUNBRTtJQUVGUCxjQUFjWTtJQUNkLE9BQU9BO0FBQ1Q7QUFDQSxNQUFNRyxhQUFhLENBQUNDO0lBQ2xCLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sZ0JBQWdCLE9BQU9BLGdCQUFnQixZQUFZO1FBQzNHTixRQUFRQyxJQUFJLENBQ1Y7SUFFSjtJQUNBLE1BQU1QLE1BQU0sT0FBT1ksZ0JBQWdCLGFBQWFuQiw0REFBV0EsQ0FBQ21CLGVBQWVBO0lBQzNFLE1BQU1DLGdCQUFnQixDQUFDWixVQUFVRSxhQUFlSixTQUFTQyxLQUFLQyxVQUFVRTtJQUN4RVcsT0FBT0MsTUFBTSxDQUFDRixlQUFlYjtJQUM3QixPQUFPYTtBQUNUO0FBQ0EsTUFBTUcsU0FBUyxDQUFDSixjQUFnQkEsY0FBY0QsV0FBV0MsZUFBZUQ7QUFDeEUsSUFBSU0sUUFBUSxDQUFDTDtJQUNYLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sY0FBYztRQUN0RU4sUUFBUUMsSUFBSSxDQUNWO0lBRUo7SUFDQSxPQUFPUyxPQUFPSjtBQUNoQjtBQUU4QyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvenVzdGFuZC9lc20vaW5kZXgubWpzPzJlNGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlU3RvcmUgfSBmcm9tICd6dXN0YW5kL3ZhbmlsbGEnO1xuZXhwb3J0ICogZnJvbSAnenVzdGFuZC92YW5pbGxhJztcbmltcG9ydCBSZWFjdEV4cG9ydHMgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZVN5bmNFeHRlcm5hbFN0b3JlRXhwb3J0cyBmcm9tICd1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL3dpdGgtc2VsZWN0b3IuanMnO1xuXG5jb25zdCB7IHVzZURlYnVnVmFsdWUgfSA9IFJlYWN0RXhwb3J0cztcbmNvbnN0IHsgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgfSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlRXhwb3J0cztcbmxldCBkaWRXYXJuQWJvdXRFcXVhbGl0eUZuID0gZmFsc2U7XG5mdW5jdGlvbiB1c2VTdG9yZShhcGksIHNlbGVjdG9yID0gYXBpLmdldFN0YXRlLCBlcXVhbGl0eUZuKSB7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiBlcXVhbGl0eUZuICYmICFkaWRXYXJuQWJvdXRFcXVhbGl0eUZuKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJbREVQUkVDQVRFRF0gVXNlIGBjcmVhdGVXaXRoRXF1YWxpdHlGbmAgaW5zdGVhZCBvZiBgY3JlYXRlYCBvciB1c2UgYHVzZVN0b3JlV2l0aEVxdWFsaXR5Rm5gIGluc3RlYWQgb2YgYHVzZVN0b3JlYC4gVGhleSBjYW4gYmUgaW1wb3J0ZWQgZnJvbSAnenVzdGFuZC90cmFkaXRpb25hbCcuIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvenVzdGFuZC9kaXNjdXNzaW9ucy8xOTM3XCJcbiAgICApO1xuICAgIGRpZFdhcm5BYm91dEVxdWFsaXR5Rm4gPSB0cnVlO1xuICB9XG4gIGNvbnN0IHNsaWNlID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgYXBpLnN1YnNjcmliZSxcbiAgICBhcGkuZ2V0U3RhdGUsXG4gICAgYXBpLmdldFNlcnZlclN0YXRlIHx8IGFwaS5nZXRTdGF0ZSxcbiAgICBzZWxlY3RvcixcbiAgICBlcXVhbGl0eUZuXG4gICk7XG4gIHVzZURlYnVnVmFsdWUoc2xpY2UpO1xuICByZXR1cm4gc2xpY2U7XG59XG5jb25zdCBjcmVhdGVJbXBsID0gKGNyZWF0ZVN0YXRlKSA9PiB7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0eXBlb2YgY3JlYXRlU3RhdGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiW0RFUFJFQ0FURURdIFBhc3NpbmcgYSB2YW5pbGxhIHN0b3JlIHdpbGwgYmUgdW5zdXBwb3J0ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gSW5zdGVhZCB1c2UgYGltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnenVzdGFuZCdgLlwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBhcGkgPSB0eXBlb2YgY3JlYXRlU3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNyZWF0ZVN0b3JlKGNyZWF0ZVN0YXRlKSA6IGNyZWF0ZVN0YXRlO1xuICBjb25zdCB1c2VCb3VuZFN0b3JlID0gKHNlbGVjdG9yLCBlcXVhbGl0eUZuKSA9PiB1c2VTdG9yZShhcGksIHNlbGVjdG9yLCBlcXVhbGl0eUZuKTtcbiAgT2JqZWN0LmFzc2lnbih1c2VCb3VuZFN0b3JlLCBhcGkpO1xuICByZXR1cm4gdXNlQm91bmRTdG9yZTtcbn07XG5jb25zdCBjcmVhdGUgPSAoY3JlYXRlU3RhdGUpID0+IGNyZWF0ZVN0YXRlID8gY3JlYXRlSW1wbChjcmVhdGVTdGF0ZSkgOiBjcmVhdGVJbXBsO1xudmFyIHJlYWN0ID0gKGNyZWF0ZVN0YXRlKSA9PiB7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiW0RFUFJFQ0FURURdIERlZmF1bHQgZXhwb3J0IGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQgdXNlIGBpbXBvcnQgeyBjcmVhdGUgfSBmcm9tICd6dXN0YW5kJ2AuXCJcbiAgICApO1xuICB9XG4gIHJldHVybiBjcmVhdGUoY3JlYXRlU3RhdGUpO1xufTtcblxuZXhwb3J0IHsgY3JlYXRlLCByZWFjdCBhcyBkZWZhdWx0LCB1c2VTdG9yZSB9O1xuIl0sIm5hbWVzIjpbImNyZWF0ZVN0b3JlIiwiUmVhY3RFeHBvcnRzIiwidXNlU3luY0V4dGVybmFsU3RvcmVFeHBvcnRzIiwidXNlRGVidWdWYWx1ZSIsInVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIiwiZGlkV2FybkFib3V0RXF1YWxpdHlGbiIsInVzZVN0b3JlIiwiYXBpIiwic2VsZWN0b3IiLCJnZXRTdGF0ZSIsImVxdWFsaXR5Rm4iLCJlbnYiLCJNT0RFIiwiY29uc29sZSIsIndhcm4iLCJzbGljZSIsInN1YnNjcmliZSIsImdldFNlcnZlclN0YXRlIiwiY3JlYXRlSW1wbCIsImNyZWF0ZVN0YXRlIiwidXNlQm91bmRTdG9yZSIsIk9iamVjdCIsImFzc2lnbiIsImNyZWF0ZSIsInJlYWN0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/zustand/esm/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/zustand/esm/middleware.mjs":
/*!*************************************************!*\
  !*** ./node_modules/zustand/esm/middleware.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   combine: () => (/* binding */ combine),\n/* harmony export */   createJSONStorage: () => (/* binding */ createJSONStorage),\n/* harmony export */   devtools: () => (/* binding */ devtools),\n/* harmony export */   persist: () => (/* binding */ persist),\n/* harmony export */   redux: () => (/* binding */ redux),\n/* harmony export */   subscribeWithSelector: () => (/* binding */ subscribeWithSelector)\n/* harmony export */ });\nconst reduxImpl = (reducer, initial)=>(set, _get, api)=>{\n        api.dispatch = (action)=>{\n            set((state)=>reducer(state, action), false, action);\n            return action;\n        };\n        api.dispatchFromDevtools = true;\n        return {\n            dispatch: (...a)=>api.dispatch(...a),\n            ...initial\n        };\n    };\nconst redux = reduxImpl;\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name)=>{\n    const api = trackedConnections.get(name);\n    if (!api) return {};\n    return Object.fromEntries(Object.entries(api.stores).map(([key, api2])=>[\n            key,\n            api2.getState()\n        ]));\n};\nconst extractConnectionInformation = (store, extensionConnector, options)=>{\n    if (store === void 0) {\n        return {\n            type: \"untracked\",\n            connection: extensionConnector.connect(options)\n        };\n    }\n    const existingConnection = trackedConnections.get(options.name);\n    if (existingConnection) {\n        return {\n            type: \"tracked\",\n            store,\n            ...existingConnection\n        };\n    }\n    const newConnection = {\n        connection: extensionConnector.connect(options),\n        stores: {}\n    };\n    trackedConnections.set(options.name, newConnection);\n    return {\n        type: \"tracked\",\n        store,\n        ...newConnection\n    };\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {})=>(set, get, api)=>{\n        const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n        let extensionConnector;\n        try {\n            extensionConnector = (enabled != null ? enabled : ( false ? 0 : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n        } catch (e) {}\n        if (!extensionConnector) {\n            if (( false ? 0 : void 0) !== \"production\" && enabled) {\n                console.warn(\"[zustand devtools middleware] Please install/enable Redux devtools extension\");\n            }\n            return fn(set, get, api);\n        }\n        const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n        let isRecording = true;\n        api.setState = (state, replace, nameOrAction)=>{\n            const r = set(state, replace);\n            if (!isRecording) return r;\n            const action = nameOrAction === void 0 ? {\n                type: anonymousActionType || \"anonymous\"\n            } : typeof nameOrAction === \"string\" ? {\n                type: nameOrAction\n            } : nameOrAction;\n            if (store === void 0) {\n                connection == null ? void 0 : connection.send(action, get());\n                return r;\n            }\n            connection == null ? void 0 : connection.send({\n                ...action,\n                type: `${store}/${action.type}`\n            }, {\n                ...getTrackedConnectionState(options.name),\n                [store]: api.getState()\n            });\n            return r;\n        };\n        const setStateFromDevtools = (...a)=>{\n            const originalIsRecording = isRecording;\n            isRecording = false;\n            set(...a);\n            isRecording = originalIsRecording;\n        };\n        const initialState = fn(api.setState, get, api);\n        if (connectionInformation.type === \"untracked\") {\n            connection == null ? void 0 : connection.init(initialState);\n        } else {\n            connectionInformation.stores[connectionInformation.store] = api;\n            connection == null ? void 0 : connection.init(Object.fromEntries(Object.entries(connectionInformation.stores).map(([key, store2])=>[\n                    key,\n                    key === connectionInformation.store ? initialState : store2.getState()\n                ])));\n        }\n        if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n            let didWarnAboutReservedActionType = false;\n            const originalDispatch = api.dispatch;\n            api.dispatch = (...a)=>{\n                if (( false ? 0 : void 0) !== \"production\" && a[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n                    console.warn('[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.');\n                    didWarnAboutReservedActionType = true;\n                }\n                originalDispatch(...a);\n            };\n        }\n        connection.subscribe((message)=>{\n            var _a;\n            switch(message.type){\n                case \"ACTION\":\n                    if (typeof message.payload !== \"string\") {\n                        console.error(\"[zustand devtools middleware] Unsupported action format\");\n                        return;\n                    }\n                    return parseJsonThen(message.payload, (action)=>{\n                        if (action.type === \"__setState\") {\n                            if (store === void 0) {\n                                setStateFromDevtools(action.state);\n                                return;\n                            }\n                            if (Object.keys(action.state).length !== 1) {\n                                console.error(`\n                    [zustand devtools middleware] Unsupported __setState action format. \n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `);\n                            }\n                            const stateFromDevtools = action.state[store];\n                            if (stateFromDevtools === void 0 || stateFromDevtools === null) {\n                                return;\n                            }\n                            if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                                setStateFromDevtools(stateFromDevtools);\n                            }\n                            return;\n                        }\n                        if (!api.dispatchFromDevtools) return;\n                        if (typeof api.dispatch !== \"function\") return;\n                        api.dispatch(action);\n                    });\n                case \"DISPATCH\":\n                    switch(message.payload.type){\n                        case \"RESET\":\n                            setStateFromDevtools(initialState);\n                            if (store === void 0) {\n                                return connection == null ? void 0 : connection.init(api.getState());\n                            }\n                            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n                        case \"COMMIT\":\n                            if (store === void 0) {\n                                connection == null ? void 0 : connection.init(api.getState());\n                                return;\n                            }\n                            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n                        case \"ROLLBACK\":\n                            return parseJsonThen(message.state, (state)=>{\n                                if (store === void 0) {\n                                    setStateFromDevtools(state);\n                                    connection == null ? void 0 : connection.init(api.getState());\n                                    return;\n                                }\n                                setStateFromDevtools(state[store]);\n                                connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n                            });\n                        case \"JUMP_TO_STATE\":\n                        case \"JUMP_TO_ACTION\":\n                            return parseJsonThen(message.state, (state)=>{\n                                if (store === void 0) {\n                                    setStateFromDevtools(state);\n                                    return;\n                                }\n                                if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                                    setStateFromDevtools(state[store]);\n                                }\n                            });\n                        case \"IMPORT_STATE\":\n                            {\n                                const { nextLiftedState } = message.payload;\n                                const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;\n                                if (!lastComputedState) return;\n                                if (store === void 0) {\n                                    setStateFromDevtools(lastComputedState);\n                                } else {\n                                    setStateFromDevtools(lastComputedState[store]);\n                                }\n                                connection == null ? void 0 : connection.send(null, // FIXME no-any\n                                nextLiftedState);\n                                return;\n                            }\n                        case \"PAUSE_RECORDING\":\n                            return isRecording = !isRecording;\n                    }\n                    return;\n            }\n        });\n        return initialState;\n    };\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, f)=>{\n    let parsed;\n    try {\n        parsed = JSON.parse(stringified);\n    } catch (e) {\n        console.error(\"[zustand devtools middleware] Could not parse the received json\", e);\n    }\n    if (parsed !== void 0) f(parsed);\n};\nconst subscribeWithSelectorImpl = (fn)=>(set, get, api)=>{\n        const origSubscribe = api.subscribe;\n        api.subscribe = (selector, optListener, options)=>{\n            let listener = selector;\n            if (optListener) {\n                const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;\n                let currentSlice = selector(api.getState());\n                listener = (state)=>{\n                    const nextSlice = selector(state);\n                    if (!equalityFn(currentSlice, nextSlice)) {\n                        const previousSlice = currentSlice;\n                        optListener(currentSlice = nextSlice, previousSlice);\n                    }\n                };\n                if (options == null ? void 0 : options.fireImmediately) {\n                    optListener(currentSlice, currentSlice);\n                }\n            }\n            return origSubscribe(listener);\n        };\n        const initialState = fn(set, get, api);\n        return initialState;\n    };\nconst subscribeWithSelector = subscribeWithSelectorImpl;\nconst combine = (initialState, create)=>(...a)=>Object.assign({}, initialState, create(...a));\nfunction createJSONStorage(getStorage, options) {\n    let storage;\n    try {\n        storage = getStorage();\n    } catch (e) {\n        return;\n    }\n    const persistStorage = {\n        getItem: (name)=>{\n            var _a;\n            const parse = (str2)=>{\n                if (str2 === null) {\n                    return null;\n                }\n                return JSON.parse(str2, options == null ? void 0 : options.reviver);\n            };\n            const str = (_a = storage.getItem(name)) != null ? _a : null;\n            if (str instanceof Promise) {\n                return str.then(parse);\n            }\n            return parse(str);\n        },\n        setItem: (name, newValue)=>storage.setItem(name, JSON.stringify(newValue, options == null ? void 0 : options.replacer)),\n        removeItem: (name)=>storage.removeItem(name)\n    };\n    return persistStorage;\n}\nconst toThenable = (fn)=>(input)=>{\n        try {\n            const result = fn(input);\n            if (result instanceof Promise) {\n                return result;\n            }\n            return {\n                then (onFulfilled) {\n                    return toThenable(onFulfilled)(result);\n                },\n                catch (_onRejected) {\n                    return this;\n                }\n            };\n        } catch (e) {\n            return {\n                then (_onFulfilled) {\n                    return this;\n                },\n                catch (onRejected) {\n                    return toThenable(onRejected)(e);\n                }\n            };\n        }\n    };\nconst oldImpl = (config, baseOptions)=>(set, get, api)=>{\n        let options = {\n            getStorage: ()=>localStorage,\n            serialize: JSON.stringify,\n            deserialize: JSON.parse,\n            partialize: (state)=>state,\n            version: 0,\n            merge: (persistedState, currentState)=>({\n                    ...currentState,\n                    ...persistedState\n                }),\n            ...baseOptions\n        };\n        let hasHydrated = false;\n        const hydrationListeners = /* @__PURE__ */ new Set();\n        const finishHydrationListeners = /* @__PURE__ */ new Set();\n        let storage;\n        try {\n            storage = options.getStorage();\n        } catch (e) {}\n        if (!storage) {\n            return config((...args)=>{\n                console.warn(`[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`);\n                set(...args);\n            }, get, api);\n        }\n        const thenableSerialize = toThenable(options.serialize);\n        const setItem = ()=>{\n            const state = options.partialize({\n                ...get()\n            });\n            let errorInSync;\n            const thenable = thenableSerialize({\n                state,\n                version: options.version\n            }).then((serializedValue)=>storage.setItem(options.name, serializedValue)).catch((e)=>{\n                errorInSync = e;\n            });\n            if (errorInSync) {\n                throw errorInSync;\n            }\n            return thenable;\n        };\n        const savedSetState = api.setState;\n        api.setState = (state, replace)=>{\n            savedSetState(state, replace);\n            void setItem();\n        };\n        const configResult = config((...args)=>{\n            set(...args);\n            void setItem();\n        }, get, api);\n        let stateFromStorage;\n        const hydrate = ()=>{\n            var _a;\n            if (!storage) return;\n            hasHydrated = false;\n            hydrationListeners.forEach((cb)=>cb(get()));\n            const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;\n            return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue)=>{\n                if (storageValue) {\n                    return options.deserialize(storageValue);\n                }\n            }).then((deserializedStorageValue)=>{\n                if (deserializedStorageValue) {\n                    if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n                        if (options.migrate) {\n                            return options.migrate(deserializedStorageValue.state, deserializedStorageValue.version);\n                        }\n                        console.error(`State loaded from storage couldn't be migrated since no migrate function was provided`);\n                    } else {\n                        return deserializedStorageValue.state;\n                    }\n                }\n            }).then((migratedState)=>{\n                var _a2;\n                stateFromStorage = options.merge(migratedState, (_a2 = get()) != null ? _a2 : configResult);\n                set(stateFromStorage, true);\n                return setItem();\n            }).then(()=>{\n                postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n                hasHydrated = true;\n                finishHydrationListeners.forEach((cb)=>cb(stateFromStorage));\n            }).catch((e)=>{\n                postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n            });\n        };\n        api.persist = {\n            setOptions: (newOptions)=>{\n                options = {\n                    ...options,\n                    ...newOptions\n                };\n                if (newOptions.getStorage) {\n                    storage = newOptions.getStorage();\n                }\n            },\n            clearStorage: ()=>{\n                storage == null ? void 0 : storage.removeItem(options.name);\n            },\n            getOptions: ()=>options,\n            rehydrate: ()=>hydrate(),\n            hasHydrated: ()=>hasHydrated,\n            onHydrate: (cb)=>{\n                hydrationListeners.add(cb);\n                return ()=>{\n                    hydrationListeners.delete(cb);\n                };\n            },\n            onFinishHydration: (cb)=>{\n                finishHydrationListeners.add(cb);\n                return ()=>{\n                    finishHydrationListeners.delete(cb);\n                };\n            }\n        };\n        hydrate();\n        return stateFromStorage || configResult;\n    };\nconst newImpl = (config, baseOptions)=>(set, get, api)=>{\n        let options = {\n            storage: createJSONStorage(()=>localStorage),\n            partialize: (state)=>state,\n            version: 0,\n            merge: (persistedState, currentState)=>({\n                    ...currentState,\n                    ...persistedState\n                }),\n            ...baseOptions\n        };\n        let hasHydrated = false;\n        const hydrationListeners = /* @__PURE__ */ new Set();\n        const finishHydrationListeners = /* @__PURE__ */ new Set();\n        let storage = options.storage;\n        if (!storage) {\n            return config((...args)=>{\n                console.warn(`[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`);\n                set(...args);\n            }, get, api);\n        }\n        const setItem = ()=>{\n            const state = options.partialize({\n                ...get()\n            });\n            return storage.setItem(options.name, {\n                state,\n                version: options.version\n            });\n        };\n        const savedSetState = api.setState;\n        api.setState = (state, replace)=>{\n            savedSetState(state, replace);\n            void setItem();\n        };\n        const configResult = config((...args)=>{\n            set(...args);\n            void setItem();\n        }, get, api);\n        let stateFromStorage;\n        const hydrate = ()=>{\n            var _a, _b;\n            if (!storage) return;\n            hasHydrated = false;\n            hydrationListeners.forEach((cb)=>{\n                var _a2;\n                return cb((_a2 = get()) != null ? _a2 : configResult);\n            });\n            const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;\n            return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue)=>{\n                if (deserializedStorageValue) {\n                    if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n                        if (options.migrate) {\n                            return options.migrate(deserializedStorageValue.state, deserializedStorageValue.version);\n                        }\n                        console.error(`State loaded from storage couldn't be migrated since no migrate function was provided`);\n                    } else {\n                        return deserializedStorageValue.state;\n                    }\n                }\n            }).then((migratedState)=>{\n                var _a2;\n                stateFromStorage = options.merge(migratedState, (_a2 = get()) != null ? _a2 : configResult);\n                set(stateFromStorage, true);\n                return setItem();\n            }).then(()=>{\n                postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n                stateFromStorage = get();\n                hasHydrated = true;\n                finishHydrationListeners.forEach((cb)=>cb(stateFromStorage));\n            }).catch((e)=>{\n                postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n            });\n        };\n        api.persist = {\n            setOptions: (newOptions)=>{\n                options = {\n                    ...options,\n                    ...newOptions\n                };\n                if (newOptions.storage) {\n                    storage = newOptions.storage;\n                }\n            },\n            clearStorage: ()=>{\n                storage == null ? void 0 : storage.removeItem(options.name);\n            },\n            getOptions: ()=>options,\n            rehydrate: ()=>hydrate(),\n            hasHydrated: ()=>hasHydrated,\n            onHydrate: (cb)=>{\n                hydrationListeners.add(cb);\n                return ()=>{\n                    hydrationListeners.delete(cb);\n                };\n            },\n            onFinishHydration: (cb)=>{\n                finishHydrationListeners.add(cb);\n                return ()=>{\n                    finishHydrationListeners.delete(cb);\n                };\n            }\n        };\n        if (!options.skipHydration) {\n            hydrate();\n        }\n        return stateFromStorage || configResult;\n    };\nconst persistImpl = (config, baseOptions)=>{\n    if (\"getStorage\" in baseOptions || \"serialize\" in baseOptions || \"deserialize\" in baseOptions) {\n        if (( false ? 0 : void 0) !== \"production\") {\n            console.warn(\"[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead.\");\n        }\n        return oldImpl(config, baseOptions);\n    }\n    return newImpl(config, baseOptions);\n};\nconst persist = persistImpl;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvenVzdGFuZC9lc20vbWlkZGxld2FyZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsTUFBTUEsWUFBWSxDQUFDQyxTQUFTQyxVQUFZLENBQUNDLEtBQUtDLE1BQU1DO1FBQ2xEQSxJQUFJQyxRQUFRLEdBQUcsQ0FBQ0M7WUFDZEosSUFBSSxDQUFDSyxRQUFVUCxRQUFRTyxPQUFPRCxTQUFTLE9BQU9BO1lBQzlDLE9BQU9BO1FBQ1Q7UUFDQUYsSUFBSUksb0JBQW9CLEdBQUc7UUFDM0IsT0FBTztZQUFFSCxVQUFVLENBQUMsR0FBR0ksSUFBTUwsSUFBSUMsUUFBUSxJQUFJSTtZQUFJLEdBQUdSLE9BQU87UUFBQztJQUM5RDtBQUNBLE1BQU1TLFFBQVFYO0FBRWQsTUFBTVkscUJBQXFCLGFBQWEsR0FBRyxJQUFJQztBQUMvQyxNQUFNQyw0QkFBNEIsQ0FBQ0M7SUFDakMsTUFBTVYsTUFBTU8sbUJBQW1CSSxHQUFHLENBQUNEO0lBQ25DLElBQUksQ0FBQ1YsS0FDSCxPQUFPLENBQUM7SUFDVixPQUFPWSxPQUFPQyxXQUFXLENBQ3ZCRCxPQUFPRSxPQUFPLENBQUNkLElBQUllLE1BQU0sRUFBRUMsR0FBRyxDQUFDLENBQUMsQ0FBQ0MsS0FBS0MsS0FBSyxHQUFLO1lBQUNEO1lBQUtDLEtBQUtDLFFBQVE7U0FBRztBQUUxRTtBQUNBLE1BQU1DLCtCQUErQixDQUFDQyxPQUFPQyxvQkFBb0JDO0lBQy9ELElBQUlGLFVBQVUsS0FBSyxHQUFHO1FBQ3BCLE9BQU87WUFDTEcsTUFBTTtZQUNOQyxZQUFZSCxtQkFBbUJJLE9BQU8sQ0FBQ0g7UUFDekM7SUFDRjtJQUNBLE1BQU1JLHFCQUFxQnBCLG1CQUFtQkksR0FBRyxDQUFDWSxRQUFRYixJQUFJO0lBQzlELElBQUlpQixvQkFBb0I7UUFDdEIsT0FBTztZQUFFSCxNQUFNO1lBQVdIO1lBQU8sR0FBR00sa0JBQWtCO1FBQUM7SUFDekQ7SUFDQSxNQUFNQyxnQkFBZ0I7UUFDcEJI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ZXRoLy4vbm9kZV9tb2R1bGVzL3p1c3RhbmQvZXNtL21pZGRsZXdhcmUubWpzPzNjZmEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcmVkdXhJbXBsID0gKHJlZHVjZXIsIGluaXRpYWwpID0+IChzZXQsIF9nZXQsIGFwaSkgPT4ge1xuICBhcGkuZGlzcGF0Y2ggPSAoYWN0aW9uKSA9PiB7XG4gICAgc2V0KChzdGF0ZSkgPT4gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKSwgZmFsc2UsIGFjdGlvbik7XG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfTtcbiAgYXBpLmRpc3BhdGNoRnJvbURldnRvb2xzID0gdHJ1ZTtcbiAgcmV0dXJuIHsgZGlzcGF0Y2g6ICguLi5hKSA9PiBhcGkuZGlzcGF0Y2goLi4uYSksIC4uLmluaXRpYWwgfTtcbn07XG5jb25zdCByZWR1eCA9IHJlZHV4SW1wbDtcblxuY29uc3QgdHJhY2tlZENvbm5lY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmNvbnN0IGdldFRyYWNrZWRDb25uZWN0aW9uU3RhdGUgPSAobmFtZSkgPT4ge1xuICBjb25zdCBhcGkgPSB0cmFja2VkQ29ubmVjdGlvbnMuZ2V0KG5hbWUpO1xuICBpZiAoIWFwaSlcbiAgICByZXR1cm4ge307XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMoYXBpLnN0b3JlcykubWFwKChba2V5LCBhcGkyXSkgPT4gW2tleSwgYXBpMi5nZXRTdGF0ZSgpXSlcbiAgKTtcbn07XG5jb25zdCBleHRyYWN0Q29ubmVjdGlvbkluZm9ybWF0aW9uID0gKHN0b3JlLCBleHRlbnNpb25Db25uZWN0b3IsIG9wdGlvbnMpID0+IHtcbiAgaWYgKHN0b3JlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ1bnRyYWNrZWRcIixcbiAgICAgIGNvbm5lY3Rpb246IGV4dGVuc2lvbkNvbm5lY3Rvci5jb25uZWN0KG9wdGlvbnMpXG4gICAgfTtcbiAgfVxuICBjb25zdCBleGlzdGluZ0Nvbm5lY3Rpb24gPSB0cmFja2VkQ29ubmVjdGlvbnMuZ2V0KG9wdGlvbnMubmFtZSk7XG4gIGlmIChleGlzdGluZ0Nvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4geyB0eXBlOiBcInRyYWNrZWRcIiwgc3RvcmUsIC4uLmV4aXN0aW5nQ29ubmVjdGlvbiB9O1xuICB9XG4gIGNvbnN0IG5ld0Nvbm5lY3Rpb24gPSB7XG4gICAgY29ubmVjdGlvbjogZXh0ZW5zaW9uQ29ubmVjdG9yLmNvbm5lY3Qob3B0aW9ucyksXG4gICAgc3RvcmVzOiB7fVxuICB9O1xuICB0cmFja2VkQ29ubmVjdGlvbnMuc2V0KG9wdGlvbnMubmFtZSwgbmV3Q29ubmVjdGlvbik7XG4gIHJldHVybiB7IHR5cGU6IFwidHJhY2tlZFwiLCBzdG9yZSwgLi4ubmV3Q29ubmVjdGlvbiB9O1xufTtcbmNvbnN0IGRldnRvb2xzSW1wbCA9IChmbiwgZGV2dG9vbHNPcHRpb25zID0ge30pID0+IChzZXQsIGdldCwgYXBpKSA9PiB7XG4gIGNvbnN0IHsgZW5hYmxlZCwgYW5vbnltb3VzQWN0aW9uVHlwZSwgc3RvcmUsIC4uLm9wdGlvbnMgfSA9IGRldnRvb2xzT3B0aW9ucztcbiAgbGV0IGV4dGVuc2lvbkNvbm5lY3RvcjtcbiAgdHJ5IHtcbiAgICBleHRlbnNpb25Db25uZWN0b3IgPSAoZW5hYmxlZCAhPSBudWxsID8gZW5hYmxlZCA6IChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXztcbiAgfSBjYXRjaCAoZSkge1xuICB9XG4gIGlmICghZXh0ZW5zaW9uQ29ubmVjdG9yKSB7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmIGVuYWJsZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJbenVzdGFuZCBkZXZ0b29scyBtaWRkbGV3YXJlXSBQbGVhc2UgaW5zdGFsbC9lbmFibGUgUmVkdXggZGV2dG9vbHMgZXh0ZW5zaW9uXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBmbihzZXQsIGdldCwgYXBpKTtcbiAgfVxuICBjb25zdCB7IGNvbm5lY3Rpb24sIC4uLmNvbm5lY3Rpb25JbmZvcm1hdGlvbiB9ID0gZXh0cmFjdENvbm5lY3Rpb25JbmZvcm1hdGlvbihzdG9yZSwgZXh0ZW5zaW9uQ29ubmVjdG9yLCBvcHRpb25zKTtcbiAgbGV0IGlzUmVjb3JkaW5nID0gdHJ1ZTtcbiAgYXBpLnNldFN0YXRlID0gKHN0YXRlLCByZXBsYWNlLCBuYW1lT3JBY3Rpb24pID0+IHtcbiAgICBjb25zdCByID0gc2V0KHN0YXRlLCByZXBsYWNlKTtcbiAgICBpZiAoIWlzUmVjb3JkaW5nKVxuICAgICAgcmV0dXJuIHI7XG4gICAgY29uc3QgYWN0aW9uID0gbmFtZU9yQWN0aW9uID09PSB2b2lkIDAgPyB7IHR5cGU6IGFub255bW91c0FjdGlvblR5cGUgfHwgXCJhbm9ueW1vdXNcIiB9IDogdHlwZW9mIG5hbWVPckFjdGlvbiA9PT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogbmFtZU9yQWN0aW9uIH0gOiBuYW1lT3JBY3Rpb247XG4gICAgaWYgKHN0b3JlID09PSB2b2lkIDApIHtcbiAgICAgIGNvbm5lY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24uc2VuZChhY3Rpb24sIGdldCgpKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBjb25uZWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBjb25uZWN0aW9uLnNlbmQoXG4gICAgICB7XG4gICAgICAgIC4uLmFjdGlvbixcbiAgICAgICAgdHlwZTogYCR7c3RvcmV9LyR7YWN0aW9uLnR5cGV9YFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLi4uZ2V0VHJhY2tlZENvbm5lY3Rpb25TdGF0ZShvcHRpb25zLm5hbWUpLFxuICAgICAgICBbc3RvcmVdOiBhcGkuZ2V0U3RhdGUoKVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHI7XG4gIH07XG4gIGNvbnN0IHNldFN0YXRlRnJvbURldnRvb2xzID0gKC4uLmEpID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbElzUmVjb3JkaW5nID0gaXNSZWNvcmRpbmc7XG4gICAgaXNSZWNvcmRpbmcgPSBmYWxzZTtcbiAgICBzZXQoLi4uYSk7XG4gICAgaXNSZWNvcmRpbmcgPSBvcmlnaW5hbElzUmVjb3JkaW5nO1xuICB9O1xuICBjb25zdCBpbml0aWFsU3RhdGUgPSBmbihhcGkuc2V0U3RhdGUsIGdldCwgYXBpKTtcbiAgaWYgKGNvbm5lY3Rpb25JbmZvcm1hdGlvbi50eXBlID09PSBcInVudHJhY2tlZFwiKSB7XG4gICAgY29ubmVjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogY29ubmVjdGlvbi5pbml0KGluaXRpYWxTdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgY29ubmVjdGlvbkluZm9ybWF0aW9uLnN0b3Jlc1tjb25uZWN0aW9uSW5mb3JtYXRpb24uc3RvcmVdID0gYXBpO1xuICAgIGNvbm5lY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24uaW5pdChcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoY29ubmVjdGlvbkluZm9ybWF0aW9uLnN0b3JlcykubWFwKChba2V5LCBzdG9yZTJdKSA9PiBbXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGtleSA9PT0gY29ubmVjdGlvbkluZm9ybWF0aW9uLnN0b3JlID8gaW5pdGlhbFN0YXRlIDogc3RvcmUyLmdldFN0YXRlKClcbiAgICAgICAgXSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGlmIChhcGkuZGlzcGF0Y2hGcm9tRGV2dG9vbHMgJiYgdHlwZW9mIGFwaS5kaXNwYXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgbGV0IGRpZFdhcm5BYm91dFJlc2VydmVkQWN0aW9uVHlwZSA9IGZhbHNlO1xuICAgIGNvbnN0IG9yaWdpbmFsRGlzcGF0Y2ggPSBhcGkuZGlzcGF0Y2g7XG4gICAgYXBpLmRpc3BhdGNoID0gKC4uLmEpID0+IHtcbiAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiBhWzBdLnR5cGUgPT09IFwiX19zZXRTdGF0ZVwiICYmICFkaWRXYXJuQWJvdXRSZXNlcnZlZEFjdGlvblR5cGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdbenVzdGFuZCBkZXZ0b29scyBtaWRkbGV3YXJlXSBcIl9fc2V0U3RhdGVcIiBhY3Rpb24gdHlwZSBpcyByZXNlcnZlZCB0byBzZXQgc3RhdGUgZnJvbSB0aGUgZGV2dG9vbHMuIEF2b2lkIHVzaW5nIGl0LidcbiAgICAgICAgKTtcbiAgICAgICAgZGlkV2FybkFib3V0UmVzZXJ2ZWRBY3Rpb25UeXBlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG9yaWdpbmFsRGlzcGF0Y2goLi4uYSk7XG4gICAgfTtcbiAgfVxuICBjb25uZWN0aW9uLnN1YnNjcmliZSgobWVzc2FnZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgY2FzZSBcIkFDVElPTlwiOlxuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UucGF5bG9hZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlt6dXN0YW5kIGRldnRvb2xzIG1pZGRsZXdhcmVdIFVuc3VwcG9ydGVkIGFjdGlvbiBmb3JtYXRcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUpzb25UaGVuKFxuICAgICAgICAgIG1lc3NhZ2UucGF5bG9hZCxcbiAgICAgICAgICAoYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09IFwiX19zZXRTdGF0ZVwiKSB7XG4gICAgICAgICAgICAgIGlmIChzdG9yZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgc2V0U3RhdGVGcm9tRGV2dG9vbHMoYWN0aW9uLnN0YXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGFjdGlvbi5zdGF0ZSkubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICAgICAgW3p1c3RhbmQgZGV2dG9vbHMgbWlkZGxld2FyZV0gVW5zdXBwb3J0ZWQgX19zZXRTdGF0ZSBhY3Rpb24gZm9ybWF0LiBcbiAgICAgICAgICAgICAgICAgICAgV2hlbiB1c2luZyAnc3RvcmUnIG9wdGlvbiBpbiBkZXZ0b29scygpLCB0aGUgJ3N0YXRlJyBzaG91bGQgaGF2ZSBvbmx5IG9uZSBrZXksIHdoaWNoIGlzIGEgdmFsdWUgb2YgJ3N0b3JlJyB0aGF0IHdhcyBwYXNzZWQgaW4gZGV2dG9vbHMoKSxcbiAgICAgICAgICAgICAgICAgICAgYW5kIHZhbHVlIG9mIHRoaXMgb25seSBrZXkgc2hvdWxkIGJlIGEgc3RhdGUgb2JqZWN0LiBFeGFtcGxlOiB7IFwidHlwZVwiOiBcIl9fc2V0U3RhdGVcIiwgXCJzdGF0ZVwiOiB7IFwiYWJjMTIzU3RvcmVcIjogeyBcImZvb1wiOiBcImJhclwiIH0gfSB9XG4gICAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHN0YXRlRnJvbURldnRvb2xzID0gYWN0aW9uLnN0YXRlW3N0b3JlXTtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlRnJvbURldnRvb2xzID09PSB2b2lkIDAgfHwgc3RhdGVGcm9tRGV2dG9vbHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KGFwaS5nZXRTdGF0ZSgpKSAhPT0gSlNPTi5zdHJpbmdpZnkoc3RhdGVGcm9tRGV2dG9vbHMpKSB7XG4gICAgICAgICAgICAgICAgc2V0U3RhdGVGcm9tRGV2dG9vbHMoc3RhdGVGcm9tRGV2dG9vbHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXBpLmRpc3BhdGNoRnJvbURldnRvb2xzKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFwaS5kaXNwYXRjaCAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBhcGkuZGlzcGF0Y2goYWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICBjYXNlIFwiRElTUEFUQ0hcIjpcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLnBheWxvYWQudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJSRVNFVFwiOlxuICAgICAgICAgICAgc2V0U3RhdGVGcm9tRGV2dG9vbHMoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgICAgIGlmIChzdG9yZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBjb25uZWN0aW9uLmluaXQoYXBpLmdldFN0YXRlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24uaW5pdChnZXRUcmFja2VkQ29ubmVjdGlvblN0YXRlKG9wdGlvbnMubmFtZSkpO1xuICAgICAgICAgIGNhc2UgXCJDT01NSVRcIjpcbiAgICAgICAgICAgIGlmIChzdG9yZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGNvbm5lY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24uaW5pdChhcGkuZ2V0U3RhdGUoKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBjb25uZWN0aW9uLmluaXQoZ2V0VHJhY2tlZENvbm5lY3Rpb25TdGF0ZShvcHRpb25zLm5hbWUpKTtcbiAgICAgICAgICBjYXNlIFwiUk9MTEJBQ0tcIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUpzb25UaGVuKG1lc3NhZ2Uuc3RhdGUsIChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoc3RvcmUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHNldFN0YXRlRnJvbURldnRvb2xzKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBjb25uZWN0aW9uLmluaXQoYXBpLmdldFN0YXRlKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZXRTdGF0ZUZyb21EZXZ0b29scyhzdGF0ZVtzdG9yZV0pO1xuICAgICAgICAgICAgICBjb25uZWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBjb25uZWN0aW9uLmluaXQoZ2V0VHJhY2tlZENvbm5lY3Rpb25TdGF0ZShvcHRpb25zLm5hbWUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgXCJKVU1QX1RPX1NUQVRFXCI6XG4gICAgICAgICAgY2FzZSBcIkpVTVBfVE9fQUNUSU9OXCI6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VKc29uVGhlbihtZXNzYWdlLnN0YXRlLCAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHN0b3JlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZUZyb21EZXZ0b29scyhzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChKU09OLnN0cmluZ2lmeShhcGkuZ2V0U3RhdGUoKSkgIT09IEpTT04uc3RyaW5naWZ5KHN0YXRlW3N0b3JlXSkpIHtcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZUZyb21EZXZ0b29scyhzdGF0ZVtzdG9yZV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBjYXNlIFwiSU1QT1JUX1NUQVRFXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmV4dExpZnRlZFN0YXRlIH0gPSBtZXNzYWdlLnBheWxvYWQ7XG4gICAgICAgICAgICBjb25zdCBsYXN0Q29tcHV0ZWRTdGF0ZSA9IChfYSA9IG5leHRMaWZ0ZWRTdGF0ZS5jb21wdXRlZFN0YXRlcy5zbGljZSgtMSlbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5zdGF0ZTtcbiAgICAgICAgICAgIGlmICghbGFzdENvbXB1dGVkU3RhdGUpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChzdG9yZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHNldFN0YXRlRnJvbURldnRvb2xzKGxhc3RDb21wdXRlZFN0YXRlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNldFN0YXRlRnJvbURldnRvb2xzKGxhc3RDb21wdXRlZFN0YXRlW3N0b3JlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25uZWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBjb25uZWN0aW9uLnNlbmQoXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIC8vIEZJWE1FIG5vLWFueVxuICAgICAgICAgICAgICBuZXh0TGlmdGVkU3RhdGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJQQVVTRV9SRUNPUkRJTkdcIjpcbiAgICAgICAgICAgIHJldHVybiBpc1JlY29yZGluZyA9ICFpc1JlY29yZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGluaXRpYWxTdGF0ZTtcbn07XG5jb25zdCBkZXZ0b29scyA9IGRldnRvb2xzSW1wbDtcbmNvbnN0IHBhcnNlSnNvblRoZW4gPSAoc3RyaW5naWZpZWQsIGYpID0+IHtcbiAgbGV0IHBhcnNlZDtcbiAgdHJ5IHtcbiAgICBwYXJzZWQgPSBKU09OLnBhcnNlKHN0cmluZ2lmaWVkKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIlt6dXN0YW5kIGRldnRvb2xzIG1pZGRsZXdhcmVdIENvdWxkIG5vdCBwYXJzZSB0aGUgcmVjZWl2ZWQganNvblwiLFxuICAgICAgZVxuICAgICk7XG4gIH1cbiAgaWYgKHBhcnNlZCAhPT0gdm9pZCAwKVxuICAgIGYocGFyc2VkKTtcbn07XG5cbmNvbnN0IHN1YnNjcmliZVdpdGhTZWxlY3RvckltcGwgPSAoZm4pID0+IChzZXQsIGdldCwgYXBpKSA9PiB7XG4gIGNvbnN0IG9yaWdTdWJzY3JpYmUgPSBhcGkuc3Vic2NyaWJlO1xuICBhcGkuc3Vic2NyaWJlID0gKHNlbGVjdG9yLCBvcHRMaXN0ZW5lciwgb3B0aW9ucykgPT4ge1xuICAgIGxldCBsaXN0ZW5lciA9IHNlbGVjdG9yO1xuICAgIGlmIChvcHRMaXN0ZW5lcikge1xuICAgICAgY29uc3QgZXF1YWxpdHlGbiA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmVxdWFsaXR5Rm4pIHx8IE9iamVjdC5pcztcbiAgICAgIGxldCBjdXJyZW50U2xpY2UgPSBzZWxlY3RvcihhcGkuZ2V0U3RhdGUoKSk7XG4gICAgICBsaXN0ZW5lciA9IChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBuZXh0U2xpY2UgPSBzZWxlY3RvcihzdGF0ZSk7XG4gICAgICAgIGlmICghZXF1YWxpdHlGbihjdXJyZW50U2xpY2UsIG5leHRTbGljZSkpIHtcbiAgICAgICAgICBjb25zdCBwcmV2aW91c1NsaWNlID0gY3VycmVudFNsaWNlO1xuICAgICAgICAgIG9wdExpc3RlbmVyKGN1cnJlbnRTbGljZSA9IG5leHRTbGljZSwgcHJldmlvdXNTbGljZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5maXJlSW1tZWRpYXRlbHkpIHtcbiAgICAgICAgb3B0TGlzdGVuZXIoY3VycmVudFNsaWNlLCBjdXJyZW50U2xpY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3JpZ1N1YnNjcmliZShsaXN0ZW5lcik7XG4gIH07XG4gIGNvbnN0IGluaXRpYWxTdGF0ZSA9IGZuKHNldCwgZ2V0LCBhcGkpO1xuICByZXR1cm4gaW5pdGlhbFN0YXRlO1xufTtcbmNvbnN0IHN1YnNjcmliZVdpdGhTZWxlY3RvciA9IHN1YnNjcmliZVdpdGhTZWxlY3RvckltcGw7XG5cbmNvbnN0IGNvbWJpbmUgPSAoaW5pdGlhbFN0YXRlLCBjcmVhdGUpID0+ICguLi5hKSA9PiBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU3RhdGUsIGNyZWF0ZSguLi5hKSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUpTT05TdG9yYWdlKGdldFN0b3JhZ2UsIG9wdGlvbnMpIHtcbiAgbGV0IHN0b3JhZ2U7XG4gIHRyeSB7XG4gICAgc3RvcmFnZSA9IGdldFN0b3JhZ2UoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwZXJzaXN0U3RvcmFnZSA9IHtcbiAgICBnZXRJdGVtOiAobmFtZSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgcGFyc2UgPSAoc3RyMikgPT4ge1xuICAgICAgICBpZiAoc3RyMiA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHN0cjIsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucmV2aXZlcik7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc3RyID0gKF9hID0gc3RvcmFnZS5nZXRJdGVtKG5hbWUpKSAhPSBudWxsID8gX2EgOiBudWxsO1xuICAgICAgaWYgKHN0ciBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHN0ci50aGVuKHBhcnNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZShzdHIpO1xuICAgIH0sXG4gICAgc2V0SXRlbTogKG5hbWUsIG5ld1ZhbHVlKSA9PiBzdG9yYWdlLnNldEl0ZW0oXG4gICAgICBuYW1lLFxuICAgICAgSlNPTi5zdHJpbmdpZnkobmV3VmFsdWUsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucmVwbGFjZXIpXG4gICAgKSxcbiAgICByZW1vdmVJdGVtOiAobmFtZSkgPT4gc3RvcmFnZS5yZW1vdmVJdGVtKG5hbWUpXG4gIH07XG4gIHJldHVybiBwZXJzaXN0U3RvcmFnZTtcbn1cbmNvbnN0IHRvVGhlbmFibGUgPSAoZm4pID0+IChpbnB1dCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGZuKGlucHV0KTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRoZW4ob25GdWxmaWxsZWQpIHtcbiAgICAgICAgcmV0dXJuIHRvVGhlbmFibGUob25GdWxmaWxsZWQpKHJlc3VsdCk7XG4gICAgICB9LFxuICAgICAgY2F0Y2goX29uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7XG4gICAgICB0aGVuKF9vbkZ1bGZpbGxlZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBjYXRjaChvblJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0b1RoZW5hYmxlKG9uUmVqZWN0ZWQpKGUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5jb25zdCBvbGRJbXBsID0gKGNvbmZpZywgYmFzZU9wdGlvbnMpID0+IChzZXQsIGdldCwgYXBpKSA9PiB7XG4gIGxldCBvcHRpb25zID0ge1xuICAgIGdldFN0b3JhZ2U6ICgpID0+IGxvY2FsU3RvcmFnZSxcbiAgICBzZXJpYWxpemU6IEpTT04uc3RyaW5naWZ5LFxuICAgIGRlc2VyaWFsaXplOiBKU09OLnBhcnNlLFxuICAgIHBhcnRpYWxpemU6IChzdGF0ZSkgPT4gc3RhdGUsXG4gICAgdmVyc2lvbjogMCxcbiAgICBtZXJnZTogKHBlcnNpc3RlZFN0YXRlLCBjdXJyZW50U3RhdGUpID0+ICh7XG4gICAgICAuLi5jdXJyZW50U3RhdGUsXG4gICAgICAuLi5wZXJzaXN0ZWRTdGF0ZVxuICAgIH0pLFxuICAgIC4uLmJhc2VPcHRpb25zXG4gIH07XG4gIGxldCBoYXNIeWRyYXRlZCA9IGZhbHNlO1xuICBjb25zdCBoeWRyYXRpb25MaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBmaW5pc2hIeWRyYXRpb25MaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgc3RvcmFnZTtcbiAgdHJ5IHtcbiAgICBzdG9yYWdlID0gb3B0aW9ucy5nZXRTdG9yYWdlKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICBpZiAoIXN0b3JhZ2UpIHtcbiAgICByZXR1cm4gY29uZmlnKFxuICAgICAgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBbenVzdGFuZCBwZXJzaXN0IG1pZGRsZXdhcmVdIFVuYWJsZSB0byB1cGRhdGUgaXRlbSAnJHtvcHRpb25zLm5hbWV9JywgdGhlIGdpdmVuIHN0b3JhZ2UgaXMgY3VycmVudGx5IHVuYXZhaWxhYmxlLmBcbiAgICAgICAgKTtcbiAgICAgICAgc2V0KC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGdldCxcbiAgICAgIGFwaVxuICAgICk7XG4gIH1cbiAgY29uc3QgdGhlbmFibGVTZXJpYWxpemUgPSB0b1RoZW5hYmxlKG9wdGlvbnMuc2VyaWFsaXplKTtcbiAgY29uc3Qgc2V0SXRlbSA9ICgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IG9wdGlvbnMucGFydGlhbGl6ZSh7IC4uLmdldCgpIH0pO1xuICAgIGxldCBlcnJvckluU3luYztcbiAgICBjb25zdCB0aGVuYWJsZSA9IHRoZW5hYmxlU2VyaWFsaXplKHsgc3RhdGUsIHZlcnNpb246IG9wdGlvbnMudmVyc2lvbiB9KS50aGVuKFxuICAgICAgKHNlcmlhbGl6ZWRWYWx1ZSkgPT4gc3RvcmFnZS5zZXRJdGVtKG9wdGlvbnMubmFtZSwgc2VyaWFsaXplZFZhbHVlKVxuICAgICkuY2F0Y2goKGUpID0+IHtcbiAgICAgIGVycm9ySW5TeW5jID0gZTtcbiAgICB9KTtcbiAgICBpZiAoZXJyb3JJblN5bmMpIHtcbiAgICAgIHRocm93IGVycm9ySW5TeW5jO1xuICAgIH1cbiAgICByZXR1cm4gdGhlbmFibGU7XG4gIH07XG4gIGNvbnN0IHNhdmVkU2V0U3RhdGUgPSBhcGkuc2V0U3RhdGU7XG4gIGFwaS5zZXRTdGF0ZSA9IChzdGF0ZSwgcmVwbGFjZSkgPT4ge1xuICAgIHNhdmVkU2V0U3RhdGUoc3RhdGUsIHJlcGxhY2UpO1xuICAgIHZvaWQgc2V0SXRlbSgpO1xuICB9O1xuICBjb25zdCBjb25maWdSZXN1bHQgPSBjb25maWcoXG4gICAgKC4uLmFyZ3MpID0+IHtcbiAgICAgIHNldCguLi5hcmdzKTtcbiAgICAgIHZvaWQgc2V0SXRlbSgpO1xuICAgIH0sXG4gICAgZ2V0LFxuICAgIGFwaVxuICApO1xuICBsZXQgc3RhdGVGcm9tU3RvcmFnZTtcbiAgY29uc3QgaHlkcmF0ZSA9ICgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFzdG9yYWdlKVxuICAgICAgcmV0dXJuO1xuICAgIGhhc0h5ZHJhdGVkID0gZmFsc2U7XG4gICAgaHlkcmF0aW9uTGlzdGVuZXJzLmZvckVhY2goKGNiKSA9PiBjYihnZXQoKSkpO1xuICAgIGNvbnN0IHBvc3RSZWh5ZHJhdGlvbkNhbGxiYWNrID0gKChfYSA9IG9wdGlvbnMub25SZWh5ZHJhdGVTdG9yYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCBnZXQoKSkpIHx8IHZvaWQgMDtcbiAgICByZXR1cm4gdG9UaGVuYWJsZShzdG9yYWdlLmdldEl0ZW0uYmluZChzdG9yYWdlKSkob3B0aW9ucy5uYW1lKS50aGVuKChzdG9yYWdlVmFsdWUpID0+IHtcbiAgICAgIGlmIChzdG9yYWdlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGVzZXJpYWxpemUoc3RvcmFnZVZhbHVlKTtcbiAgICAgIH1cbiAgICB9KS50aGVuKChkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUpID0+IHtcbiAgICAgIGlmIChkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUudmVyc2lvbiA9PT0gXCJudW1iZXJcIiAmJiBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUudmVyc2lvbiAhPT0gb3B0aW9ucy52ZXJzaW9uKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMubWlncmF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMubWlncmF0ZShcbiAgICAgICAgICAgICAgZGVzZXJpYWxpemVkU3RvcmFnZVZhbHVlLnN0YXRlLFxuICAgICAgICAgICAgICBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUudmVyc2lvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIGBTdGF0ZSBsb2FkZWQgZnJvbSBzdG9yYWdlIGNvdWxkbid0IGJlIG1pZ3JhdGVkIHNpbmNlIG5vIG1pZ3JhdGUgZnVuY3Rpb24gd2FzIHByb3ZpZGVkYFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplZFN0b3JhZ2VWYWx1ZS5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLnRoZW4oKG1pZ3JhdGVkU3RhdGUpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBzdGF0ZUZyb21TdG9yYWdlID0gb3B0aW9ucy5tZXJnZShcbiAgICAgICAgbWlncmF0ZWRTdGF0ZSxcbiAgICAgICAgKF9hMiA9IGdldCgpKSAhPSBudWxsID8gX2EyIDogY29uZmlnUmVzdWx0XG4gICAgICApO1xuICAgICAgc2V0KHN0YXRlRnJvbVN0b3JhZ2UsIHRydWUpO1xuICAgICAgcmV0dXJuIHNldEl0ZW0oKTtcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIHBvc3RSZWh5ZHJhdGlvbkNhbGxiYWNrID09IG51bGwgPyB2b2lkIDAgOiBwb3N0UmVoeWRyYXRpb25DYWxsYmFjayhzdGF0ZUZyb21TdG9yYWdlLCB2b2lkIDApO1xuICAgICAgaGFzSHlkcmF0ZWQgPSB0cnVlO1xuICAgICAgZmluaXNoSHlkcmF0aW9uTGlzdGVuZXJzLmZvckVhY2goKGNiKSA9PiBjYihzdGF0ZUZyb21TdG9yYWdlKSk7XG4gICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgIHBvc3RSZWh5ZHJhdGlvbkNhbGxiYWNrID09IG51bGwgPyB2b2lkIDAgOiBwb3N0UmVoeWRyYXRpb25DYWxsYmFjayh2b2lkIDAsIGUpO1xuICAgIH0pO1xuICB9O1xuICBhcGkucGVyc2lzdCA9IHtcbiAgICBzZXRPcHRpb25zOiAobmV3T3B0aW9ucykgPT4ge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLi4ubmV3T3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGlmIChuZXdPcHRpb25zLmdldFN0b3JhZ2UpIHtcbiAgICAgICAgc3RvcmFnZSA9IG5ld09wdGlvbnMuZ2V0U3RvcmFnZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xlYXJTdG9yYWdlOiAoKSA9PiB7XG4gICAgICBzdG9yYWdlID09IG51bGwgPyB2b2lkIDAgOiBzdG9yYWdlLnJlbW92ZUl0ZW0ob3B0aW9ucy5uYW1lKTtcbiAgICB9LFxuICAgIGdldE9wdGlvbnM6ICgpID0+IG9wdGlvbnMsXG4gICAgcmVoeWRyYXRlOiAoKSA9PiBoeWRyYXRlKCksXG4gICAgaGFzSHlkcmF0ZWQ6ICgpID0+IGhhc0h5ZHJhdGVkLFxuICAgIG9uSHlkcmF0ZTogKGNiKSA9PiB7XG4gICAgICBoeWRyYXRpb25MaXN0ZW5lcnMuYWRkKGNiKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGh5ZHJhdGlvbkxpc3RlbmVycy5kZWxldGUoY2IpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIG9uRmluaXNoSHlkcmF0aW9uOiAoY2IpID0+IHtcbiAgICAgIGZpbmlzaEh5ZHJhdGlvbkxpc3RlbmVycy5hZGQoY2IpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZmluaXNoSHlkcmF0aW9uTGlzdGVuZXJzLmRlbGV0ZShjYik7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgaHlkcmF0ZSgpO1xuICByZXR1cm4gc3RhdGVGcm9tU3RvcmFnZSB8fCBjb25maWdSZXN1bHQ7XG59O1xuY29uc3QgbmV3SW1wbCA9IChjb25maWcsIGJhc2VPcHRpb25zKSA9PiAoc2V0LCBnZXQsIGFwaSkgPT4ge1xuICBsZXQgb3B0aW9ucyA9IHtcbiAgICBzdG9yYWdlOiBjcmVhdGVKU09OU3RvcmFnZSgoKSA9PiBsb2NhbFN0b3JhZ2UpLFxuICAgIHBhcnRpYWxpemU6IChzdGF0ZSkgPT4gc3RhdGUsXG4gICAgdmVyc2lvbjogMCxcbiAgICBtZXJnZTogKHBlcnNpc3RlZFN0YXRlLCBjdXJyZW50U3RhdGUpID0+ICh7XG4gICAgICAuLi5jdXJyZW50U3RhdGUsXG4gICAgICAuLi5wZXJzaXN0ZWRTdGF0ZVxuICAgIH0pLFxuICAgIC4uLmJhc2VPcHRpb25zXG4gIH07XG4gIGxldCBoYXNIeWRyYXRlZCA9IGZhbHNlO1xuICBjb25zdCBoeWRyYXRpb25MaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBmaW5pc2hIeWRyYXRpb25MaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgc3RvcmFnZSA9IG9wdGlvbnMuc3RvcmFnZTtcbiAgaWYgKCFzdG9yYWdlKSB7XG4gICAgcmV0dXJuIGNvbmZpZyhcbiAgICAgICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgW3p1c3RhbmQgcGVyc2lzdCBtaWRkbGV3YXJlXSBVbmFibGUgdG8gdXBkYXRlIGl0ZW0gJyR7b3B0aW9ucy5uYW1lfScsIHRoZSBnaXZlbiBzdG9yYWdlIGlzIGN1cnJlbnRseSB1bmF2YWlsYWJsZS5gXG4gICAgICAgICk7XG4gICAgICAgIHNldCguLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBnZXQsXG4gICAgICBhcGlcbiAgICApO1xuICB9XG4gIGNvbnN0IHNldEl0ZW0gPSAoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBvcHRpb25zLnBhcnRpYWxpemUoeyAuLi5nZXQoKSB9KTtcbiAgICByZXR1cm4gc3RvcmFnZS5zZXRJdGVtKG9wdGlvbnMubmFtZSwge1xuICAgICAgc3RhdGUsXG4gICAgICB2ZXJzaW9uOiBvcHRpb25zLnZlcnNpb25cbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgc2F2ZWRTZXRTdGF0ZSA9IGFwaS5zZXRTdGF0ZTtcbiAgYXBpLnNldFN0YXRlID0gKHN0YXRlLCByZXBsYWNlKSA9PiB7XG4gICAgc2F2ZWRTZXRTdGF0ZShzdGF0ZSwgcmVwbGFjZSk7XG4gICAgdm9pZCBzZXRJdGVtKCk7XG4gIH07XG4gIGNvbnN0IGNvbmZpZ1Jlc3VsdCA9IGNvbmZpZyhcbiAgICAoLi4uYXJncykgPT4ge1xuICAgICAgc2V0KC4uLmFyZ3MpO1xuICAgICAgdm9pZCBzZXRJdGVtKCk7XG4gICAgfSxcbiAgICBnZXQsXG4gICAgYXBpXG4gICk7XG4gIGxldCBzdGF0ZUZyb21TdG9yYWdlO1xuICBjb25zdCBoeWRyYXRlID0gKCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCFzdG9yYWdlKVxuICAgICAgcmV0dXJuO1xuICAgIGhhc0h5ZHJhdGVkID0gZmFsc2U7XG4gICAgaHlkcmF0aW9uTGlzdGVuZXJzLmZvckVhY2goKGNiKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgcmV0dXJuIGNiKChfYTIgPSBnZXQoKSkgIT0gbnVsbCA/IF9hMiA6IGNvbmZpZ1Jlc3VsdCk7XG4gICAgfSk7XG4gICAgY29uc3QgcG9zdFJlaHlkcmF0aW9uQ2FsbGJhY2sgPSAoKF9iID0gb3B0aW9ucy5vblJlaHlkcmF0ZVN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKG9wdGlvbnMsIChfYSA9IGdldCgpKSAhPSBudWxsID8gX2EgOiBjb25maWdSZXN1bHQpKSB8fCB2b2lkIDA7XG4gICAgcmV0dXJuIHRvVGhlbmFibGUoc3RvcmFnZS5nZXRJdGVtLmJpbmQoc3RvcmFnZSkpKG9wdGlvbnMubmFtZSkudGhlbigoZGVzZXJpYWxpemVkU3RvcmFnZVZhbHVlKSA9PiB7XG4gICAgICBpZiAoZGVzZXJpYWxpemVkU3RvcmFnZVZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVzZXJpYWxpemVkU3RvcmFnZVZhbHVlLnZlcnNpb24gPT09IFwibnVtYmVyXCIgJiYgZGVzZXJpYWxpemVkU3RvcmFnZVZhbHVlLnZlcnNpb24gIT09IG9wdGlvbnMudmVyc2lvbikge1xuICAgICAgICAgIGlmIChvcHRpb25zLm1pZ3JhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLm1pZ3JhdGUoXG4gICAgICAgICAgICAgIGRlc2VyaWFsaXplZFN0b3JhZ2VWYWx1ZS5zdGF0ZSxcbiAgICAgICAgICAgICAgZGVzZXJpYWxpemVkU3RvcmFnZVZhbHVlLnZlcnNpb25cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBgU3RhdGUgbG9hZGVkIGZyb20gc3RvcmFnZSBjb3VsZG4ndCBiZSBtaWdyYXRlZCBzaW5jZSBubyBtaWdyYXRlIGZ1bmN0aW9uIHdhcyBwcm92aWRlZGBcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUuc3RhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KS50aGVuKChtaWdyYXRlZFN0YXRlKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgc3RhdGVGcm9tU3RvcmFnZSA9IG9wdGlvbnMubWVyZ2UoXG4gICAgICAgIG1pZ3JhdGVkU3RhdGUsXG4gICAgICAgIChfYTIgPSBnZXQoKSkgIT0gbnVsbCA/IF9hMiA6IGNvbmZpZ1Jlc3VsdFxuICAgICAgKTtcbiAgICAgIHNldChzdGF0ZUZyb21TdG9yYWdlLCB0cnVlKTtcbiAgICAgIHJldHVybiBzZXRJdGVtKCk7XG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICBwb3N0UmVoeWRyYXRpb25DYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogcG9zdFJlaHlkcmF0aW9uQ2FsbGJhY2soc3RhdGVGcm9tU3RvcmFnZSwgdm9pZCAwKTtcbiAgICAgIHN0YXRlRnJvbVN0b3JhZ2UgPSBnZXQoKTtcbiAgICAgIGhhc0h5ZHJhdGVkID0gdHJ1ZTtcbiAgICAgIGZpbmlzaEh5ZHJhdGlvbkxpc3RlbmVycy5mb3JFYWNoKChjYikgPT4gY2Ioc3RhdGVGcm9tU3RvcmFnZSkpO1xuICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICBwb3N0UmVoeWRyYXRpb25DYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogcG9zdFJlaHlkcmF0aW9uQ2FsbGJhY2sodm9pZCAwLCBlKTtcbiAgICB9KTtcbiAgfTtcbiAgYXBpLnBlcnNpc3QgPSB7XG4gICAgc2V0T3B0aW9uczogKG5ld09wdGlvbnMpID0+IHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIC4uLm5ld09wdGlvbnNcbiAgICAgIH07XG4gICAgICBpZiAobmV3T3B0aW9ucy5zdG9yYWdlKSB7XG4gICAgICAgIHN0b3JhZ2UgPSBuZXdPcHRpb25zLnN0b3JhZ2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGVhclN0b3JhZ2U6ICgpID0+IHtcbiAgICAgIHN0b3JhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHN0b3JhZ2UucmVtb3ZlSXRlbShvcHRpb25zLm5hbWUpO1xuICAgIH0sXG4gICAgZ2V0T3B0aW9uczogKCkgPT4gb3B0aW9ucyxcbiAgICByZWh5ZHJhdGU6ICgpID0+IGh5ZHJhdGUoKSxcbiAgICBoYXNIeWRyYXRlZDogKCkgPT4gaGFzSHlkcmF0ZWQsXG4gICAgb25IeWRyYXRlOiAoY2IpID0+IHtcbiAgICAgIGh5ZHJhdGlvbkxpc3RlbmVycy5hZGQoY2IpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaHlkcmF0aW9uTGlzdGVuZXJzLmRlbGV0ZShjYik7XG4gICAgICB9O1xuICAgIH0sXG4gICAgb25GaW5pc2hIeWRyYXRpb246IChjYikgPT4ge1xuICAgICAgZmluaXNoSHlkcmF0aW9uTGlzdGVuZXJzLmFkZChjYik7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBmaW5pc2hIeWRyYXRpb25MaXN0ZW5lcnMuZGVsZXRlKGNiKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBpZiAoIW9wdGlvbnMuc2tpcEh5ZHJhdGlvbikge1xuICAgIGh5ZHJhdGUoKTtcbiAgfVxuICByZXR1cm4gc3RhdGVGcm9tU3RvcmFnZSB8fCBjb25maWdSZXN1bHQ7XG59O1xuY29uc3QgcGVyc2lzdEltcGwgPSAoY29uZmlnLCBiYXNlT3B0aW9ucykgPT4ge1xuICBpZiAoXCJnZXRTdG9yYWdlXCIgaW4gYmFzZU9wdGlvbnMgfHwgXCJzZXJpYWxpemVcIiBpbiBiYXNlT3B0aW9ucyB8fCBcImRlc2VyaWFsaXplXCIgaW4gYmFzZU9wdGlvbnMpIHtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJbREVQUkVDQVRFRF0gYGdldFN0b3JhZ2VgLCBgc2VyaWFsaXplYCBhbmQgYGRlc2VyaWFsaXplYCBvcHRpb25zIGFyZSBkZXByZWNhdGVkLiBVc2UgYHN0b3JhZ2VgIG9wdGlvbiBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gb2xkSW1wbChjb25maWcsIGJhc2VPcHRpb25zKTtcbiAgfVxuICByZXR1cm4gbmV3SW1wbChjb25maWcsIGJhc2VPcHRpb25zKTtcbn07XG5jb25zdCBwZXJzaXN0ID0gcGVyc2lzdEltcGw7XG5cbmV4cG9ydCB7IGNvbWJpbmUsIGNyZWF0ZUpTT05TdG9yYWdlLCBkZXZ0b29scywgcGVyc2lzdCwgcmVkdXgsIHN1YnNjcmliZVdpdGhTZWxlY3RvciB9O1xuIl0sIm5hbWVzIjpbInJlZHV4SW1wbCIsInJlZHVjZXIiLCJpbml0aWFsIiwic2V0IiwiX2dldCIsImFwaSIsImRpc3BhdGNoIiwiYWN0aW9uIiwic3RhdGUiLCJkaXNwYXRjaEZyb21EZXZ0b29scyIsImEiLCJyZWR1eCIsInRyYWNrZWRDb25uZWN0aW9ucyIsIk1hcCIsImdldFRyYWNrZWRDb25uZWN0aW9uU3RhdGUiLCJuYW1lIiwiZ2V0IiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwic3RvcmVzIiwibWFwIiwia2V5IiwiYXBpMiIsImdldFN0YXRlIiwiZXh0cmFjdENvbm5lY3Rpb25JbmZvcm1hdGlvbiIsInN0b3JlIiwiZXh0ZW5zaW9uQ29ubmVjdG9yIiwib3B0aW9ucyIsInR5cGUiLCJjb25uZWN0aW9uIiwiY29ubmVjdCIsImV4aXN0aW5nQ29ubmVjdGlvbiIsIm5ld0Nvbm5lY3Rpb24iLCJkZXZ0b29sc0ltcGwiLCJmbiIsImRldnRvb2xzT3B0aW9ucyIsImVuYWJsZWQiLCJhbm9ueW1vdXNBY3Rpb25UeXBlIiwiZW52IiwiTU9ERSIsIndpbmRvdyIsIl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18iLCJlIiwiY29uc29sZSIsIndhcm4iLCJjb25uZWN0aW9uSW5mb3JtYXRpb24iLCJpc1JlY29yZGluZyIsInNldFN0YXRlIiwicmVwbGFjZSIsIm5hbWVPckFjdGlvbiIsInIiLCJzZW5kIiwic2V0U3RhdGVGcm9tRGV2dG9vbHMiLCJvcmlnaW5hbElzUmVjb3JkaW5nIiwiaW5pdGlhbFN0YXRlIiwiaW5pdCIsInN0b3JlMiIsImRpZFdhcm5BYm91dFJlc2VydmVkQWN0aW9uVHlwZSIsIm9yaWdpbmFsRGlzcGF0Y2giLCJzdWJzY3JpYmUiLCJtZXNzYWdlIiwiX2EiLCJwYXlsb2FkIiwiZXJyb3IiLCJwYXJzZUpzb25UaGVuIiwia2V5cyIsImxlbmd0aCIsInN0YXRlRnJvbURldnRvb2xzIiwiSlNPTiIsInN0cmluZ2lmeSIsIm5leHRMaWZ0ZWRTdGF0ZSIsImxhc3RDb21wdXRlZFN0YXRlIiwiY29tcHV0ZWRTdGF0ZXMiLCJzbGljZSIsImRldnRvb2xzIiwic3RyaW5naWZpZWQiLCJmIiwicGFyc2VkIiwicGFyc2UiLCJzdWJzY3JpYmVXaXRoU2VsZWN0b3JJbXBsIiwib3JpZ1N1YnNjcmliZSIsInNlbGVjdG9yIiwib3B0TGlzdGVuZXIiLCJsaXN0ZW5lciIsImVxdWFsaXR5Rm4iLCJpcyIsImN1cnJlbnRTbGljZSIsIm5leHRTbGljZSIsInByZXZpb3VzU2xpY2UiLCJmaXJlSW1tZWRpYXRlbHkiLCJzdWJzY3JpYmVXaXRoU2VsZWN0b3IiLCJjb21iaW5lIiwiY3JlYXRlIiwiYXNzaWduIiwiY3JlYXRlSlNPTlN0b3JhZ2UiLCJnZXRTdG9yYWdlIiwic3RvcmFnZSIsInBlcnNpc3RTdG9yYWdlIiwiZ2V0SXRlbSIsInN0cjIiLCJyZXZpdmVyIiwic3RyIiwiUHJvbWlzZSIsInRoZW4iLCJzZXRJdGVtIiwibmV3VmFsdWUiLCJyZXBsYWNlciIsInJlbW92ZUl0ZW0iLCJ0b1RoZW5hYmxlIiwiaW5wdXQiLCJyZXN1bHQiLCJvbkZ1bGZpbGxlZCIsImNhdGNoIiwiX29uUmVqZWN0ZWQiLCJfb25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwib2xkSW1wbCIsImNvbmZpZyIsImJhc2VPcHRpb25zIiwibG9jYWxTdG9yYWdlIiwic2VyaWFsaXplIiwiZGVzZXJpYWxpemUiLCJwYXJ0aWFsaXplIiwidmVyc2lvbiIsIm1lcmdlIiwicGVyc2lzdGVkU3RhdGUiLCJjdXJyZW50U3RhdGUiLCJoYXNIeWRyYXRlZCIsImh5ZHJhdGlvbkxpc3RlbmVycyIsIlNldCIsImZpbmlzaEh5ZHJhdGlvbkxpc3RlbmVycyIsImFyZ3MiLCJ0aGVuYWJsZVNlcmlhbGl6ZSIsImVycm9ySW5TeW5jIiwidGhlbmFibGUiLCJzZXJpYWxpemVkVmFsdWUiLCJzYXZlZFNldFN0YXRlIiwiY29uZmlnUmVzdWx0Iiwic3RhdGVGcm9tU3RvcmFnZSIsImh5ZHJhdGUiLCJmb3JFYWNoIiwiY2IiLCJwb3N0UmVoeWRyYXRpb25DYWxsYmFjayIsIm9uUmVoeWRyYXRlU3RvcmFnZSIsImNhbGwiLCJiaW5kIiwic3RvcmFnZVZhbHVlIiwiZGVzZXJpYWxpemVkU3RvcmFnZVZhbHVlIiwibWlncmF0ZSIsIm1pZ3JhdGVkU3RhdGUiLCJfYTIiLCJwZXJzaXN0Iiwic2V0T3B0aW9ucyIsIm5ld09wdGlvbnMiLCJjbGVhclN0b3JhZ2UiLCJnZXRPcHRpb25zIiwicmVoeWRyYXRlIiwib25IeWRyYXRlIiwiYWRkIiwiZGVsZXRlIiwib25GaW5pc2hIeWRyYXRpb24iLCJuZXdJbXBsIiwiX2IiLCJza2lwSHlkcmF0aW9uIiwicGVyc2lzdEltcGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/zustand/esm/middleware.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/zustand/esm/vanilla.mjs":
/*!**********************************************!*\
  !*** ./node_modules/zustand/esm/vanilla.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   \"default\": () => (/* binding */ vanilla)\n/* harmony export */ });\nconst createStoreImpl = (createState)=>{\n    let state;\n    const listeners = /* @__PURE__ */ new Set();\n    const setState = (partial, replace)=>{\n        const nextState = typeof partial === \"function\" ? partial(state) : partial;\n        if (!Object.is(nextState, state)) {\n            const previousState = state;\n            state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n            listeners.forEach((listener)=>listener(state, previousState));\n        }\n    };\n    const getState = ()=>state;\n    const subscribe = (listener)=>{\n        listeners.add(listener);\n        return ()=>listeners.delete(listener);\n    };\n    const destroy = ()=>{\n        if (( false ? 0 : void 0) !== \"production\") {\n            console.warn(\"[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.\");\n        }\n        listeners.clear();\n    };\n    const api = {\n        setState,\n        getState,\n        subscribe,\n        destroy\n    };\n    state = createState(setState, getState, api);\n    return api;\n};\nconst createStore = (createState)=>createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState)=>{\n    if (( false ? 0 : void 0) !== \"production\") {\n        console.warn(\"[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.\");\n    }\n    return createStore(createState);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvenVzdGFuZC9lc20vdmFuaWxsYS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxNQUFNQSxrQkFBa0IsQ0FBQ0M7SUFDdkIsSUFBSUM7SUFDSixNQUFNQyxZQUFZLGFBQWEsR0FBRyxJQUFJQztJQUN0QyxNQUFNQyxXQUFXLENBQUNDLFNBQVNDO1FBQ3pCLE1BQU1DLFlBQVksT0FBT0YsWUFBWSxhQUFhQSxRQUFRSixTQUFTSTtRQUNuRSxJQUFJLENBQUNHLE9BQU9DLEVBQUUsQ0FBQ0YsV0FBV04sUUFBUTtZQUNoQyxNQUFNUyxnQkFBZ0JUO1lBQ3RCQSxRQUFRLENBQUNLLFdBQVcsT0FBT0EsVUFBVSxPQUFPQyxjQUFjLFlBQVlBLGNBQWMsSUFBRyxJQUFLQSxZQUFZQyxPQUFPRyxNQUFNLENBQUMsQ0FBQyxHQUFHVixPQUFPTTtZQUNqSUwsVUFBVVUsT0FBTyxDQUFDLENBQUNDLFdBQWFBLFNBQVNaLE9BQU9TO1FBQ2xEO0lBQ0Y7SUFDQSxNQUFNSSxXQUFXLElBQU1iO0lBQ3ZCLE1BQU1jLFlBQVksQ0FBQ0Y7UUFDakJYLFVBQVVjLEdBQUcsQ0FBQ0g7UUFDZCxPQUFPLElBQU1YLFVBQVVlLE1BQU0sQ0FBQ0o7SUFDaEM7SUFDQSxNQUFNSyxVQUFVO1FBQ2QsSUFBSSxDQUFDLE1BQWUsR0FBRyxDQUFvQixHQUFHLEtBQUssT0FBTyxjQUFjO1lBQ3RFRyxRQUFRQyxJQUFJLENBQ1Y7UUFFSjtRQUNBcEIsVUFBVXFCLEtBQUs7SUFDakI7SUFDQSxNQUFNQyxNQUFNO1FBQUVwQjtRQUFVVTtRQUFVQztRQUFXRztJQUFRO0lBQ3JEakIsUUFBUUQsWUFBWUksVUFBVVUsVUFBVVU7SUFDeEMsT0FBT0E7QUFDVDtBQUNBLE1BQU1DLGNBQWMsQ0FBQ3pCLGNBQWdCQSxjQUFjRCxnQkFBZ0JDLGVBQWVEO0FBQ2xGLElBQUkyQixVQUFVLENBQUMxQjtJQUNiLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sY0FBYztRQUN0RXFCLFFBQVFDLElBQUksQ0FDVjtJQUVKO0lBQ0EsT0FBT0csWUFBWXpCO0FBQ3JCO0FBRTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS92YW5pbGxhLm1qcz85ZDllIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNyZWF0ZVN0b3JlSW1wbCA9IChjcmVhdGVTdGF0ZSkgPT4ge1xuICBsZXQgc3RhdGU7XG4gIGNvbnN0IGxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHNldFN0YXRlID0gKHBhcnRpYWwsIHJlcGxhY2UpID0+IHtcbiAgICBjb25zdCBuZXh0U3RhdGUgPSB0eXBlb2YgcGFydGlhbCA9PT0gXCJmdW5jdGlvblwiID8gcGFydGlhbChzdGF0ZSkgOiBwYXJ0aWFsO1xuICAgIGlmICghT2JqZWN0LmlzKG5leHRTdGF0ZSwgc3RhdGUpKSB7XG4gICAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gc3RhdGU7XG4gICAgICBzdGF0ZSA9IChyZXBsYWNlICE9IG51bGwgPyByZXBsYWNlIDogdHlwZW9mIG5leHRTdGF0ZSAhPT0gXCJvYmplY3RcIiB8fCBuZXh0U3RhdGUgPT09IG51bGwpID8gbmV4dFN0YXRlIDogT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKHN0YXRlLCBwcmV2aW91c1N0YXRlKSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBnZXRTdGF0ZSA9ICgpID0+IHN0YXRlO1xuICBjb25zdCBzdWJzY3JpYmUgPSAobGlzdGVuZXIpID0+IHtcbiAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gIH07XG4gIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiW0RFUFJFQ0FURURdIFRoZSBgZGVzdHJveWAgbWV0aG9kIHdpbGwgYmUgdW5zdXBwb3J0ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gSW5zdGVhZCB1c2UgdW5zdWJzY3JpYmUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgc3Vic2NyaWJlLiBFdmVyeXRoaW5nIHdpbGwgYmUgZ2FyYmFnZS1jb2xsZWN0ZWQgaWYgc3RvcmUgaXMgZ2FyYmFnZS1jb2xsZWN0ZWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGxpc3RlbmVycy5jbGVhcigpO1xuICB9O1xuICBjb25zdCBhcGkgPSB7IHNldFN0YXRlLCBnZXRTdGF0ZSwgc3Vic2NyaWJlLCBkZXN0cm95IH07XG4gIHN0YXRlID0gY3JlYXRlU3RhdGUoc2V0U3RhdGUsIGdldFN0YXRlLCBhcGkpO1xuICByZXR1cm4gYXBpO1xufTtcbmNvbnN0IGNyZWF0ZVN0b3JlID0gKGNyZWF0ZVN0YXRlKSA9PiBjcmVhdGVTdGF0ZSA/IGNyZWF0ZVN0b3JlSW1wbChjcmVhdGVTdGF0ZSkgOiBjcmVhdGVTdG9yZUltcGw7XG52YXIgdmFuaWxsYSA9IChjcmVhdGVTdGF0ZSkgPT4ge1xuICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIltERVBSRUNBVEVEXSBEZWZhdWx0IGV4cG9ydCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHVzZSBpbXBvcnQgeyBjcmVhdGVTdG9yZSB9IGZyb20gJ3p1c3RhbmQvdmFuaWxsYScuXCJcbiAgICApO1xuICB9XG4gIHJldHVybiBjcmVhdGVTdG9yZShjcmVhdGVTdGF0ZSk7XG59O1xuXG5leHBvcnQgeyBjcmVhdGVTdG9yZSwgdmFuaWxsYSBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOlsiY3JlYXRlU3RvcmVJbXBsIiwiY3JlYXRlU3RhdGUiLCJzdGF0ZSIsImxpc3RlbmVycyIsIlNldCIsInNldFN0YXRlIiwicGFydGlhbCIsInJlcGxhY2UiLCJuZXh0U3RhdGUiLCJPYmplY3QiLCJpcyIsInByZXZpb3VzU3RhdGUiLCJhc3NpZ24iLCJmb3JFYWNoIiwibGlzdGVuZXIiLCJnZXRTdGF0ZSIsInN1YnNjcmliZSIsImFkZCIsImRlbGV0ZSIsImRlc3Ryb3kiLCJlbnYiLCJNT0RFIiwiY29uc29sZSIsIndhcm4iLCJjbGVhciIsImFwaSIsImNyZWF0ZVN0b3JlIiwidmFuaWxsYSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/zustand/esm/vanilla.mjs\n");

/***/ })

};
;