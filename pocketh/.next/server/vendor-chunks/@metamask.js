"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@metamask";
exports.ids = ["vendor-chunks/@metamask"];
exports.modules = {

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/abi.js":
/*!******************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/abi.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// ESLint gets confused by the nested list and tables in the docs, so we disable\n// the rule for this file.\n/* eslint-disable jsdoc/check-indentation, jsdoc/match-description */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.decodeSingle = exports.decode = exports.encodePacked = exports.encodeSingle = exports.encode = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/utils/dist/index.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\");\nconst packer_1 = __webpack_require__(/*! ./packer */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/packer.js\");\n/**\n * Encode the data with the provided types. The types must be valid Solidity\n * ABI types.\n *\n * This will attempt to parse the values into the correct types. For example,\n * if you pass in a hex string for a `uint256`, it will be parsed into a\n * `bigint`. Regular strings are interpreted as UTF-8 strings. If you want to\n * pass in a hex string, you must pass it in as a `Uint8Array`, or use the\n * \"0x\"-prefix.\n *\n * It will also attempt to infer the types of the values. For example, if you\n * pass in a string for a `uint256`, it will result in a TypeScript compile-time\n * error. This does not work for all types, however. For example, if you use\n * nested arrays or tuples, the type will be inferred as `unknown`.\n *\n * The following types are supported:\n *\n * - `address`: A 20-byte Ethereum address.\n *   - As a 40-character-long hexadecimal string, starting with \"0x\".\n *   - As a 20-byte-long byte array, i.e., `Uint8Array`.\n * - `bool`: A boolean value.\n *   - As a boolean literal, i.e., `true` or `false`.\n *   - As the strings \"true\" or \"false\".\n * - `bytes(n)`: A dynamic byte array.\n *   - As a hexadecimal string, starting with \"0x\".\n *   - As a byte array, i.e., `Uint8Array`.\n *   - As a regular string, which will be interpreted as UTF-8.\n * - `function`: A Solidity function.\n *   - As a 48-character-long hexadecimal string, starting with \"0x\".\n *   - As a 24-byte-long byte array, i.e., `Uint8Array`.\n *   - As a {@link SolidityFunction} object.\n * - `int(n)`: A signed integer.\n *   - As a number.\n *   - As a `bigint`.\n *   - As a hexadecimal string, starting with \"0x\".\n * - `string`: A dynamic UTF-8 string.\n *   - As a regular string.\n *   - As a hexadecimal string, starting with \"0x\".\n *   - As a byte array, i.e., `Uint8Array`.\n * - `tuple`: A tuple of values.\n *   - As an array of values.\n * - `uint(n)`: An unsigned integer.\n *   - As a number.\n *   - As a `bigint`.\n *   - As a hexadecimal string, starting with \"0x\".\n *\n * @example\n * ```typescript\n * import { encode, decode } from '@metamask/abi-utils';\n *\n * const types = ['uint256', 'string'];\n * const encoded = encode(types, [42, 'Hello, world!']);\n * const decoded = decode(types, encoded);\n *\n * console.log(decoded); // [42n, 'Hello, world!']\n * ```\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html\n * @param types - The types to encode.\n * @param values - The values to encode. This array must have the same length as\n * the types array.\n * @param packed - Whether to use the non-standard packed mode. Defaults to\n * `false`.\n * @param tight - Whether to pack the values tightly. When enabled, the values\n * will be packed without any padding. This matches the behaviour of\n * `ethereumjs-abi`. Defaults to `false`.\n * @returns The ABI encoded bytes.\n */ const encode = (types, values, packed, tight)=>{\n    try {\n        return (0, packer_1.pack)({\n            types,\n            values,\n            packed,\n            tight\n        });\n    } catch (error) {\n        if (error instanceof errors_1.ParserError) {\n            throw new errors_1.ParserError(`Unable to encode value: ${error.message}`, error);\n        }\n        throw new errors_1.ParserError(`An unexpected error occurred: ${(0, errors_1.getErrorMessage)(error)}`, error);\n    }\n};\nexports.encode = encode;\n/**\n * Encode the data with the provided type. The type must be a valid Solidity\n * ABI type.\n *\n * See {@link encode} for more information on how values are parsed.\n *\n * @example\n * ```typescript\n * import { encodeSingle, decodeSingle } from '@metamask/abi-utils';\n *\n * const encoded = encodeSingle('uint256', 42);\n * const decoded = decodeSingle('uint256', encoded);\n *\n * console.log(decoded); // 42n\n * ```\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#types\n * @param type - The type to encode.\n * @param value - The value to encode.\n * @returns The ABI encoded bytes.\n */ const encodeSingle = (type, value)=>{\n    return (0, exports.encode)([\n        type\n    ], [\n        value\n    ]);\n};\nexports.encodeSingle = encodeSingle;\n/**\n * Encode the data with the provided types. The types must be valid Solidity\n * ABI types. This is similar to {@link encode}, but the values are encoded in\n * the non-standard packed mode. This differs from the standard encoding in the\n * following ways:\n *\n * - Most values are packed tightly, without alignment padding.\n *   - The exception is array values, which are padded to 32 bytes.\n * - Values are still padded to their full size, i.e., `uint16` values are still\n *  padded to 2 bytes, regardless of the length of the value.\n * - The encoding of dynamic types (`bytes`, `string`) is different. The length\n * of the dynamic type is not included in the encoding, and the dynamic type is\n * not padded to a multiple of 32 bytes.\n * - All values are encoded in-place, without any offsets.\n *\n * The encoding of this is ambiguous as soon as there is more than one dynamic\n * type. That means that these values cannot be decoded with {@link decode} or\n * Solidity's `abi.decode` function.\n *\n * See {@link encode} for more information on how values are parsed.\n *\n * @example\n * ```typescript\n * import { encodePacked } from '@metamask/abi-utils';\n *\n * const encoded = encodePacked(['uint8'], [42]);\n *\n * console.log(encoded); // `Uint8Array [ 42 ]`\n * ```\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#types\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#non-standard-packed-mode\n * @param types - The types to encode.\n * @param values - The values to encode.\n * @param tight - Whether to pack the values tightly. When enabled, `bytesN`\n * values in arrays will be packed without any padding. This matches the\n * behaviour of `ethereumjs-abi`. Defaults to `false`.\n * @returns The ABI encoded bytes.\n */ const encodePacked = (types, values, tight)=>{\n    return (0, exports.encode)(types, values, true, tight);\n};\nexports.encodePacked = encodePacked;\n/**\n * Decode an ABI encoded buffer with the specified types. The types must be\n * valid Solidity ABI types.\n *\n * This will attempt to infer the output types from the input types. For\n * example, if you use `uint256` as an input type, the output type will be\n * `bigint`. This does not work for all types, however. For example, if you use\n * nested array types or tuple types, the output type will be `unknown`.\n *\n * The resulting types of the values will be as follows:\n *\n * | Contract ABI Type | Resulting JavaScript Type |\n * | ----------------- | ------------------------- |\n * | `address`         | `string`                  |\n * | `bool`            | `boolean`                 |\n * | `bytes(n)`        | `Uint8Array`              |\n * | `function`        | {@link SolidityFunction}  |\n * | `int(n)`          | `bigint`                  |\n * | `string`          | `string`                  |\n * | `tuple`           | `Array`                   |\n * | `array`           | `Array`                   |\n * | `uint(n)`         | `bigint`                  |\n *\n * @example\n * ```typescript\n * import { encode, decode } from '@metamask/abi-utils';\n *\n * const types = ['uint256', 'string'];\n * const encoded = encode(types, [42, 'Hello, world!']);\n * const decoded = decode(types, encoded);\n *\n * console.log(decoded); // [42n, 'Hello, world!']\n * ```\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#types\n * @param types - The types to decode the bytes with.\n * @param value - The bytes-like value to decode.\n * @returns The decoded values as array.\n */ const decode = (types, value)=>{\n    const bytes = (0, utils_1.createBytes)(value);\n    try {\n        return (0, packer_1.unpack)(types, bytes);\n    } catch (error) {\n        if (error instanceof errors_1.ParserError) {\n            throw new errors_1.ParserError(`Unable to decode value: ${error.message}`, error);\n        }\n        throw new errors_1.ParserError(`An unexpected error occurred: ${(0, errors_1.getErrorMessage)(error)}`, error);\n    }\n};\nexports.decode = decode;\n/**\n * Decode the data with the provided type. The type must be a valid Solidity\n * ABI type.\n *\n * See {@link decode} for more information on how values are parsed.\n *\n * @example\n * ```typescript\n * import { encodeSingle, decodeSingle } from '@metamask/abi-utils';\n *\n * const encoded = encodeSingle('uint256', 42);\n * const decoded = decodeSingle('uint256', encoded);\n *\n * console.log(decoded); // 42n\n * ```\n * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#types\n * @param type - The type to decode.\n * @param value - The bytes-like value to decode.\n * @returns The decoded value.\n */ const decodeSingle = (type, value)=>{\n    const result = (0, exports.decode)([\n        type\n    ], value);\n    (0, utils_1.assert)(result.length === 1, new errors_1.ParserError(\"Decoded value array has unexpected length.\"));\n    return result[0];\n};\nexports.decodeSingle = decodeSingle; //# sourceMappingURL=abi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L2FiaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGdGQUFnRjtBQUNoRiwwQkFBMEI7QUFDMUIsbUVBQW1FLEdBQ25FQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsb0JBQW9CLEdBQUdBLGNBQWMsR0FBR0Esb0JBQW9CLEdBQUdBLG9CQUFvQixHQUFHQSxjQUFjLEdBQUcsS0FBSztBQUM1RyxNQUFNTyxVQUFVQyxtQkFBT0EsQ0FBQywyRUFBaUI7QUFDekMsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMseUVBQVU7QUFDbkMsTUFBTUUsV0FBV0YsbUJBQU9BLENBQUMseUVBQVU7QUFDbkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtFQyxHQUNELE1BQU1GLFNBQVMsQ0FBQ0ssT0FBT0MsUUFBUUMsUUFBUUM7SUFDbkMsSUFBSTtRQUNBLE9BQU8sQ0FBQyxHQUFHSixTQUFTSyxJQUFJLEVBQUU7WUFBRUo7WUFBT0M7WUFBUUM7WUFBUUM7UUFBTTtJQUM3RCxFQUNBLE9BQU9FLE9BQU87UUFDVixJQUFJQSxpQkFBaUJQLFNBQVNRLFdBQVcsRUFBRTtZQUN2QyxNQUFNLElBQUlSLFNBQVNRLFdBQVcsQ0FBQyxDQUFDLHdCQUF3QixFQUFFRCxNQUFNRSxPQUFPLENBQUMsQ0FBQyxFQUFFRjtRQUMvRTtRQUNBLE1BQU0sSUFBSVAsU0FBU1EsV0FBVyxDQUFDLENBQUMsOEJBQThCLEVBQUUsQ0FBQyxHQUFHUixTQUFTVSxlQUFlLEVBQUVILE9BQU8sQ0FBQyxFQUFFQTtJQUM1RztBQUNKO0FBQ0FoQixjQUFjLEdBQUdNO0FBQ2pCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQ0QsTUFBTUQsZUFBZSxDQUFDZSxNQUFNbkI7SUFDeEIsT0FBTyxDQUFDLEdBQUdELFFBQVFNLE1BQU0sRUFBRTtRQUFDYztLQUFLLEVBQUU7UUFBQ25CO0tBQU07QUFDOUM7QUFDQUQsb0JBQW9CLEdBQUdLO0FBQ3ZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUNDLEdBQ0QsTUFBTUQsZUFBZSxDQUFDTyxPQUFPQyxRQUFRRTtJQUNqQyxPQUFPLENBQUMsR0FBR2QsUUFBUU0sTUFBTSxFQUFFSyxPQUFPQyxRQUFRLE1BQU1FO0FBQ3BEO0FBQ0FkLG9CQUFvQixHQUFHSTtBQUN2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFDQyxHQUNELE1BQU1ELFNBQVMsQ0FBQ1EsT0FBT1Y7SUFDbkIsTUFBTW9CLFFBQVEsQ0FBQyxHQUFHZCxRQUFRZSxXQUFXLEVBQUVyQjtJQUN2QyxJQUFJO1FBQ0EsT0FBTyxDQUFDLEdBQUdTLFNBQVNhLE1BQU0sRUFBRVosT0FBT1U7SUFDdkMsRUFDQSxPQUFPTCxPQUFPO1FBQ1YsSUFBSUEsaUJBQWlCUCxTQUFTUSxXQUFXLEVBQUU7WUFDdkMsTUFBTSxJQUFJUixTQUFTUSxXQUFXLENBQUMsQ0FBQyx3QkFBd0IsRUFBRUQsTUFBTUUsT0FBTyxDQUFDLENBQUMsRUFBRUY7UUFDL0U7UUFDQSxNQUFNLElBQUlQLFNBQVNRLFdBQVcsQ0FBQyxDQUFDLDhCQUE4QixFQUFFLENBQUMsR0FBR1IsU0FBU1UsZUFBZSxFQUFFSCxPQUFPLENBQUMsRUFBRUE7SUFDNUc7QUFDSjtBQUNBaEIsY0FBYyxHQUFHRztBQUNqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNELE1BQU1ELGVBQWUsQ0FBQ2tCLE1BQU1uQjtJQUN4QixNQUFNdUIsU0FBUyxDQUFDLEdBQUd4QixRQUFRRyxNQUFNLEVBQUU7UUFBQ2lCO0tBQUssRUFBRW5CO0lBQzFDLElBQUdNLFFBQVFrQixNQUFNLEVBQUVELE9BQU9FLE1BQU0sS0FBSyxHQUFHLElBQUlqQixTQUFTUSxXQUFXLENBQUM7SUFDbEUsT0FBT08sTUFBTSxDQUFDLEVBQUU7QUFDcEI7QUFDQXhCLG9CQUFvQixHQUFHRSxjQUN2QiwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9hYmkuanM/NTBkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIEVTTGludCBnZXRzIGNvbmZ1c2VkIGJ5IHRoZSBuZXN0ZWQgbGlzdCBhbmQgdGFibGVzIGluIHRoZSBkb2NzLCBzbyB3ZSBkaXNhYmxlXG4vLyB0aGUgcnVsZSBmb3IgdGhpcyBmaWxlLlxuLyogZXNsaW50LWRpc2FibGUganNkb2MvY2hlY2staW5kZW50YXRpb24sIGpzZG9jL21hdGNoLWRlc2NyaXB0aW9uICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZVNpbmdsZSA9IGV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5lbmNvZGVQYWNrZWQgPSBleHBvcnRzLmVuY29kZVNpbmdsZSA9IGV4cG9ydHMuZW5jb2RlID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IHBhY2tlcl8xID0gcmVxdWlyZShcIi4vcGFja2VyXCIpO1xuLyoqXG4gKiBFbmNvZGUgdGhlIGRhdGEgd2l0aCB0aGUgcHJvdmlkZWQgdHlwZXMuIFRoZSB0eXBlcyBtdXN0IGJlIHZhbGlkIFNvbGlkaXR5XG4gKiBBQkkgdHlwZXMuXG4gKlxuICogVGhpcyB3aWxsIGF0dGVtcHQgdG8gcGFyc2UgdGhlIHZhbHVlcyBpbnRvIHRoZSBjb3JyZWN0IHR5cGVzLiBGb3IgZXhhbXBsZSxcbiAqIGlmIHlvdSBwYXNzIGluIGEgaGV4IHN0cmluZyBmb3IgYSBgdWludDI1NmAsIGl0IHdpbGwgYmUgcGFyc2VkIGludG8gYVxuICogYGJpZ2ludGAuIFJlZ3VsYXIgc3RyaW5ncyBhcmUgaW50ZXJwcmV0ZWQgYXMgVVRGLTggc3RyaW5ncy4gSWYgeW91IHdhbnQgdG9cbiAqIHBhc3MgaW4gYSBoZXggc3RyaW5nLCB5b3UgbXVzdCBwYXNzIGl0IGluIGFzIGEgYFVpbnQ4QXJyYXlgLCBvciB1c2UgdGhlXG4gKiBcIjB4XCItcHJlZml4LlxuICpcbiAqIEl0IHdpbGwgYWxzbyBhdHRlbXB0IHRvIGluZmVyIHRoZSB0eXBlcyBvZiB0aGUgdmFsdWVzLiBGb3IgZXhhbXBsZSwgaWYgeW91XG4gKiBwYXNzIGluIGEgc3RyaW5nIGZvciBhIGB1aW50MjU2YCwgaXQgd2lsbCByZXN1bHQgaW4gYSBUeXBlU2NyaXB0IGNvbXBpbGUtdGltZVxuICogZXJyb3IuIFRoaXMgZG9lcyBub3Qgd29yayBmb3IgYWxsIHR5cGVzLCBob3dldmVyLiBGb3IgZXhhbXBsZSwgaWYgeW91IHVzZVxuICogbmVzdGVkIGFycmF5cyBvciB0dXBsZXMsIHRoZSB0eXBlIHdpbGwgYmUgaW5mZXJyZWQgYXMgYHVua25vd25gLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgdHlwZXMgYXJlIHN1cHBvcnRlZDpcbiAqXG4gKiAtIGBhZGRyZXNzYDogQSAyMC1ieXRlIEV0aGVyZXVtIGFkZHJlc3MuXG4gKiAgIC0gQXMgYSA0MC1jaGFyYWN0ZXItbG9uZyBoZXhhZGVjaW1hbCBzdHJpbmcsIHN0YXJ0aW5nIHdpdGggXCIweFwiLlxuICogICAtIEFzIGEgMjAtYnl0ZS1sb25nIGJ5dGUgYXJyYXksIGkuZS4sIGBVaW50OEFycmF5YC5cbiAqIC0gYGJvb2xgOiBBIGJvb2xlYW4gdmFsdWUuXG4gKiAgIC0gQXMgYSBib29sZWFuIGxpdGVyYWwsIGkuZS4sIGB0cnVlYCBvciBgZmFsc2VgLlxuICogICAtIEFzIHRoZSBzdHJpbmdzIFwidHJ1ZVwiIG9yIFwiZmFsc2VcIi5cbiAqIC0gYGJ5dGVzKG4pYDogQSBkeW5hbWljIGJ5dGUgYXJyYXkuXG4gKiAgIC0gQXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcsIHN0YXJ0aW5nIHdpdGggXCIweFwiLlxuICogICAtIEFzIGEgYnl0ZSBhcnJheSwgaS5lLiwgYFVpbnQ4QXJyYXlgLlxuICogICAtIEFzIGEgcmVndWxhciBzdHJpbmcsIHdoaWNoIHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXMgVVRGLTguXG4gKiAtIGBmdW5jdGlvbmA6IEEgU29saWRpdHkgZnVuY3Rpb24uXG4gKiAgIC0gQXMgYSA0OC1jaGFyYWN0ZXItbG9uZyBoZXhhZGVjaW1hbCBzdHJpbmcsIHN0YXJ0aW5nIHdpdGggXCIweFwiLlxuICogICAtIEFzIGEgMjQtYnl0ZS1sb25nIGJ5dGUgYXJyYXksIGkuZS4sIGBVaW50OEFycmF5YC5cbiAqICAgLSBBcyBhIHtAbGluayBTb2xpZGl0eUZ1bmN0aW9ufSBvYmplY3QuXG4gKiAtIGBpbnQobilgOiBBIHNpZ25lZCBpbnRlZ2VyLlxuICogICAtIEFzIGEgbnVtYmVyLlxuICogICAtIEFzIGEgYGJpZ2ludGAuXG4gKiAgIC0gQXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcsIHN0YXJ0aW5nIHdpdGggXCIweFwiLlxuICogLSBgc3RyaW5nYDogQSBkeW5hbWljIFVURi04IHN0cmluZy5cbiAqICAgLSBBcyBhIHJlZ3VsYXIgc3RyaW5nLlxuICogICAtIEFzIGEgaGV4YWRlY2ltYWwgc3RyaW5nLCBzdGFydGluZyB3aXRoIFwiMHhcIi5cbiAqICAgLSBBcyBhIGJ5dGUgYXJyYXksIGkuZS4sIGBVaW50OEFycmF5YC5cbiAqIC0gYHR1cGxlYDogQSB0dXBsZSBvZiB2YWx1ZXMuXG4gKiAgIC0gQXMgYW4gYXJyYXkgb2YgdmFsdWVzLlxuICogLSBgdWludChuKWA6IEFuIHVuc2lnbmVkIGludGVnZXIuXG4gKiAgIC0gQXMgYSBudW1iZXIuXG4gKiAgIC0gQXMgYSBgYmlnaW50YC5cbiAqICAgLSBBcyBhIGhleGFkZWNpbWFsIHN0cmluZywgc3RhcnRpbmcgd2l0aCBcIjB4XCIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IGVuY29kZSwgZGVjb2RlIH0gZnJvbSAnQG1ldGFtYXNrL2FiaS11dGlscyc7XG4gKlxuICogY29uc3QgdHlwZXMgPSBbJ3VpbnQyNTYnLCAnc3RyaW5nJ107XG4gKiBjb25zdCBlbmNvZGVkID0gZW5jb2RlKHR5cGVzLCBbNDIsICdIZWxsbywgd29ybGQhJ10pO1xuICogY29uc3QgZGVjb2RlZCA9IGRlY29kZSh0eXBlcywgZW5jb2RlZCk7XG4gKlxuICogY29uc29sZS5sb2coZGVjb2RlZCk7IC8vIFs0Mm4sICdIZWxsbywgd29ybGQhJ11cbiAqIGBgYFxuICogQHNlZSBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi92MC44LjE3L2FiaS1zcGVjLmh0bWxcbiAqIEBwYXJhbSB0eXBlcyAtIFRoZSB0eXBlcyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byBlbmNvZGUuIFRoaXMgYXJyYXkgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhc1xuICogdGhlIHR5cGVzIGFycmF5LlxuICogQHBhcmFtIHBhY2tlZCAtIFdoZXRoZXIgdG8gdXNlIHRoZSBub24tc3RhbmRhcmQgcGFja2VkIG1vZGUuIERlZmF1bHRzIHRvXG4gKiBgZmFsc2VgLlxuICogQHBhcmFtIHRpZ2h0IC0gV2hldGhlciB0byBwYWNrIHRoZSB2YWx1ZXMgdGlnaHRseS4gV2hlbiBlbmFibGVkLCB0aGUgdmFsdWVzXG4gKiB3aWxsIGJlIHBhY2tlZCB3aXRob3V0IGFueSBwYWRkaW5nLiBUaGlzIG1hdGNoZXMgdGhlIGJlaGF2aW91ciBvZlxuICogYGV0aGVyZXVtanMtYWJpYC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqIEByZXR1cm5zIFRoZSBBQkkgZW5jb2RlZCBieXRlcy5cbiAqL1xuY29uc3QgZW5jb2RlID0gKHR5cGVzLCB2YWx1ZXMsIHBhY2tlZCwgdGlnaHQpID0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIHBhY2tlcl8xLnBhY2spKHsgdHlwZXMsIHZhbHVlcywgcGFja2VkLCB0aWdodCB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGVycm9yc18xLlBhcnNlckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYFVuYWJsZSB0byBlbmNvZGUgdmFsdWU6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkOiAkeygwLCBlcnJvcnNfMS5nZXRFcnJvck1lc3NhZ2UpKGVycm9yKX1gLCBlcnJvcik7XG4gICAgfVxufTtcbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuLyoqXG4gKiBFbmNvZGUgdGhlIGRhdGEgd2l0aCB0aGUgcHJvdmlkZWQgdHlwZS4gVGhlIHR5cGUgbXVzdCBiZSBhIHZhbGlkIFNvbGlkaXR5XG4gKiBBQkkgdHlwZS5cbiAqXG4gKiBTZWUge0BsaW5rIGVuY29kZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHZhbHVlcyBhcmUgcGFyc2VkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBlbmNvZGVTaW5nbGUsIGRlY29kZVNpbmdsZSB9IGZyb20gJ0BtZXRhbWFzay9hYmktdXRpbHMnO1xuICpcbiAqIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVTaW5nbGUoJ3VpbnQyNTYnLCA0Mik7XG4gKiBjb25zdCBkZWNvZGVkID0gZGVjb2RlU2luZ2xlKCd1aW50MjU2JywgZW5jb2RlZCk7XG4gKlxuICogY29uc29sZS5sb2coZGVjb2RlZCk7IC8vIDQyblxuICogYGBgXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL3YwLjguMTcvYWJpLXNwZWMuaHRtbCN0eXBlc1xuICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZW5jb2RlLlxuICogQHJldHVybnMgVGhlIEFCSSBlbmNvZGVkIGJ5dGVzLlxuICovXG5jb25zdCBlbmNvZGVTaW5nbGUgPSAodHlwZSwgdmFsdWUpID0+IHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuZW5jb2RlKShbdHlwZV0sIFt2YWx1ZV0pO1xufTtcbmV4cG9ydHMuZW5jb2RlU2luZ2xlID0gZW5jb2RlU2luZ2xlO1xuLyoqXG4gKiBFbmNvZGUgdGhlIGRhdGEgd2l0aCB0aGUgcHJvdmlkZWQgdHlwZXMuIFRoZSB0eXBlcyBtdXN0IGJlIHZhbGlkIFNvbGlkaXR5XG4gKiBBQkkgdHlwZXMuIFRoaXMgaXMgc2ltaWxhciB0byB7QGxpbmsgZW5jb2RlfSwgYnV0IHRoZSB2YWx1ZXMgYXJlIGVuY29kZWQgaW5cbiAqIHRoZSBub24tc3RhbmRhcmQgcGFja2VkIG1vZGUuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSBzdGFuZGFyZCBlbmNvZGluZyBpbiB0aGVcbiAqIGZvbGxvd2luZyB3YXlzOlxuICpcbiAqIC0gTW9zdCB2YWx1ZXMgYXJlIHBhY2tlZCB0aWdodGx5LCB3aXRob3V0IGFsaWdubWVudCBwYWRkaW5nLlxuICogICAtIFRoZSBleGNlcHRpb24gaXMgYXJyYXkgdmFsdWVzLCB3aGljaCBhcmUgcGFkZGVkIHRvIDMyIGJ5dGVzLlxuICogLSBWYWx1ZXMgYXJlIHN0aWxsIHBhZGRlZCB0byB0aGVpciBmdWxsIHNpemUsIGkuZS4sIGB1aW50MTZgIHZhbHVlcyBhcmUgc3RpbGxcbiAqICBwYWRkZWQgdG8gMiBieXRlcywgcmVnYXJkbGVzcyBvZiB0aGUgbGVuZ3RoIG9mIHRoZSB2YWx1ZS5cbiAqIC0gVGhlIGVuY29kaW5nIG9mIGR5bmFtaWMgdHlwZXMgKGBieXRlc2AsIGBzdHJpbmdgKSBpcyBkaWZmZXJlbnQuIFRoZSBsZW5ndGhcbiAqIG9mIHRoZSBkeW5hbWljIHR5cGUgaXMgbm90IGluY2x1ZGVkIGluIHRoZSBlbmNvZGluZywgYW5kIHRoZSBkeW5hbWljIHR5cGUgaXNcbiAqIG5vdCBwYWRkZWQgdG8gYSBtdWx0aXBsZSBvZiAzMiBieXRlcy5cbiAqIC0gQWxsIHZhbHVlcyBhcmUgZW5jb2RlZCBpbi1wbGFjZSwgd2l0aG91dCBhbnkgb2Zmc2V0cy5cbiAqXG4gKiBUaGUgZW5jb2Rpbmcgb2YgdGhpcyBpcyBhbWJpZ3VvdXMgYXMgc29vbiBhcyB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGR5bmFtaWNcbiAqIHR5cGUuIFRoYXQgbWVhbnMgdGhhdCB0aGVzZSB2YWx1ZXMgY2Fubm90IGJlIGRlY29kZWQgd2l0aCB7QGxpbmsgZGVjb2RlfSBvclxuICogU29saWRpdHkncyBgYWJpLmRlY29kZWAgZnVuY3Rpb24uXG4gKlxuICogU2VlIHtAbGluayBlbmNvZGV9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGhvdyB2YWx1ZXMgYXJlIHBhcnNlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgZW5jb2RlUGFja2VkIH0gZnJvbSAnQG1ldGFtYXNrL2FiaS11dGlscyc7XG4gKlxuICogY29uc3QgZW5jb2RlZCA9IGVuY29kZVBhY2tlZChbJ3VpbnQ4J10sIFs0Ml0pO1xuICpcbiAqIGNvbnNvbGUubG9nKGVuY29kZWQpOyAvLyBgVWludDhBcnJheSBbIDQyIF1gXG4gKiBgYGBcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vdjAuOC4xNy9hYmktc3BlYy5odG1sI3R5cGVzXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL3YwLjguMTcvYWJpLXNwZWMuaHRtbCNub24tc3RhbmRhcmQtcGFja2VkLW1vZGVcbiAqIEBwYXJhbSB0eXBlcyAtIFRoZSB0eXBlcyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdGlnaHQgLSBXaGV0aGVyIHRvIHBhY2sgdGhlIHZhbHVlcyB0aWdodGx5LiBXaGVuIGVuYWJsZWQsIGBieXRlc05gXG4gKiB2YWx1ZXMgaW4gYXJyYXlzIHdpbGwgYmUgcGFja2VkIHdpdGhvdXQgYW55IHBhZGRpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAqIGJlaGF2aW91ciBvZiBgZXRoZXJldW1qcy1hYmlgLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICogQHJldHVybnMgVGhlIEFCSSBlbmNvZGVkIGJ5dGVzLlxuICovXG5jb25zdCBlbmNvZGVQYWNrZWQgPSAodHlwZXMsIHZhbHVlcywgdGlnaHQpID0+IHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuZW5jb2RlKSh0eXBlcywgdmFsdWVzLCB0cnVlLCB0aWdodCk7XG59O1xuZXhwb3J0cy5lbmNvZGVQYWNrZWQgPSBlbmNvZGVQYWNrZWQ7XG4vKipcbiAqIERlY29kZSBhbiBBQkkgZW5jb2RlZCBidWZmZXIgd2l0aCB0aGUgc3BlY2lmaWVkIHR5cGVzLiBUaGUgdHlwZXMgbXVzdCBiZVxuICogdmFsaWQgU29saWRpdHkgQUJJIHR5cGVzLlxuICpcbiAqIFRoaXMgd2lsbCBhdHRlbXB0IHRvIGluZmVyIHRoZSBvdXRwdXQgdHlwZXMgZnJvbSB0aGUgaW5wdXQgdHlwZXMuIEZvclxuICogZXhhbXBsZSwgaWYgeW91IHVzZSBgdWludDI1NmAgYXMgYW4gaW5wdXQgdHlwZSwgdGhlIG91dHB1dCB0eXBlIHdpbGwgYmVcbiAqIGBiaWdpbnRgLiBUaGlzIGRvZXMgbm90IHdvcmsgZm9yIGFsbCB0eXBlcywgaG93ZXZlci4gRm9yIGV4YW1wbGUsIGlmIHlvdSB1c2VcbiAqIG5lc3RlZCBhcnJheSB0eXBlcyBvciB0dXBsZSB0eXBlcywgdGhlIG91dHB1dCB0eXBlIHdpbGwgYmUgYHVua25vd25gLlxuICpcbiAqIFRoZSByZXN1bHRpbmcgdHlwZXMgb2YgdGhlIHZhbHVlcyB3aWxsIGJlIGFzIGZvbGxvd3M6XG4gKlxuICogfCBDb250cmFjdCBBQkkgVHlwZSB8IFJlc3VsdGluZyBKYXZhU2NyaXB0IFR5cGUgfFxuICogfCAtLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxuICogfCBgYWRkcmVzc2AgICAgICAgICB8IGBzdHJpbmdgICAgICAgICAgICAgICAgICAgfFxuICogfCBgYm9vbGAgICAgICAgICAgICB8IGBib29sZWFuYCAgICAgICAgICAgICAgICAgfFxuICogfCBgYnl0ZXMobilgICAgICAgICB8IGBVaW50OEFycmF5YCAgICAgICAgICAgICAgfFxuICogfCBgZnVuY3Rpb25gICAgICAgICB8IHtAbGluayBTb2xpZGl0eUZ1bmN0aW9ufSAgfFxuICogfCBgaW50KG4pYCAgICAgICAgICB8IGBiaWdpbnRgICAgICAgICAgICAgICAgICAgfFxuICogfCBgc3RyaW5nYCAgICAgICAgICB8IGBzdHJpbmdgICAgICAgICAgICAgICAgICAgfFxuICogfCBgdHVwbGVgICAgICAgICAgICB8IGBBcnJheWAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgYXJyYXlgICAgICAgICAgICB8IGBBcnJheWAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgdWludChuKWAgICAgICAgICB8IGBiaWdpbnRgICAgICAgICAgICAgICAgICAgfFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBlbmNvZGUsIGRlY29kZSB9IGZyb20gJ0BtZXRhbWFzay9hYmktdXRpbHMnO1xuICpcbiAqIGNvbnN0IHR5cGVzID0gWyd1aW50MjU2JywgJ3N0cmluZyddO1xuICogY29uc3QgZW5jb2RlZCA9IGVuY29kZSh0eXBlcywgWzQyLCAnSGVsbG8sIHdvcmxkISddKTtcbiAqIGNvbnN0IGRlY29kZWQgPSBkZWNvZGUodHlwZXMsIGVuY29kZWQpO1xuICpcbiAqIGNvbnNvbGUubG9nKGRlY29kZWQpOyAvLyBbNDJuLCAnSGVsbG8sIHdvcmxkISddXG4gKiBgYGBcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vdjAuOC4xNy9hYmktc3BlYy5odG1sI3R5cGVzXG4gKiBAcGFyYW0gdHlwZXMgLSBUaGUgdHlwZXMgdG8gZGVjb2RlIHRoZSBieXRlcyB3aXRoLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGJ5dGVzLWxpa2UgdmFsdWUgdG8gZGVjb2RlLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgdmFsdWVzIGFzIGFycmF5LlxuICovXG5jb25zdCBkZWNvZGUgPSAodHlwZXMsIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgYnl0ZXMgPSAoMCwgdXRpbHNfMS5jcmVhdGVCeXRlcykodmFsdWUpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoMCwgcGFja2VyXzEudW5wYWNrKSh0eXBlcywgYnl0ZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgZXJyb3JzXzEuUGFyc2VyRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgVW5hYmxlIHRvIGRlY29kZSB2YWx1ZTogJHtlcnJvci5tZXNzYWdlfWAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYEFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQ6ICR7KDAsIGVycm9yc18xLmdldEVycm9yTWVzc2FnZSkoZXJyb3IpfWAsIGVycm9yKTtcbiAgICB9XG59O1xuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4vKipcbiAqIERlY29kZSB0aGUgZGF0YSB3aXRoIHRoZSBwcm92aWRlZCB0eXBlLiBUaGUgdHlwZSBtdXN0IGJlIGEgdmFsaWQgU29saWRpdHlcbiAqIEFCSSB0eXBlLlxuICpcbiAqIFNlZSB7QGxpbmsgZGVjb2RlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBob3cgdmFsdWVzIGFyZSBwYXJzZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IGVuY29kZVNpbmdsZSwgZGVjb2RlU2luZ2xlIH0gZnJvbSAnQG1ldGFtYXNrL2FiaS11dGlscyc7XG4gKlxuICogY29uc3QgZW5jb2RlZCA9IGVuY29kZVNpbmdsZSgndWludDI1NicsIDQyKTtcbiAqIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVTaW5nbGUoJ3VpbnQyNTYnLCBlbmNvZGVkKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhkZWNvZGVkKTsgLy8gNDJuXG4gKiBgYGBcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vdjAuOC4xNy9hYmktc3BlYy5odG1sI3R5cGVzXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBieXRlcy1saWtlIHZhbHVlIHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHZhbHVlLlxuICovXG5jb25zdCBkZWNvZGVTaW5nbGUgPSAodHlwZSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSAoMCwgZXhwb3J0cy5kZWNvZGUpKFt0eXBlXSwgdmFsdWUpO1xuICAgICgwLCB1dGlsc18xLmFzc2VydCkocmVzdWx0Lmxlbmd0aCA9PT0gMSwgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKCdEZWNvZGVkIHZhbHVlIGFycmF5IGhhcyB1bmV4cGVjdGVkIGxlbmd0aC4nKSk7XG4gICAgcmV0dXJuIHJlc3VsdFswXTtcbn07XG5leHBvcnRzLmRlY29kZVNpbmdsZSA9IGRlY29kZVNpbmdsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFiaS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWNvZGVTaW5nbGUiLCJkZWNvZGUiLCJlbmNvZGVQYWNrZWQiLCJlbmNvZGVTaW5nbGUiLCJlbmNvZGUiLCJ1dGlsc18xIiwicmVxdWlyZSIsImVycm9yc18xIiwicGFja2VyXzEiLCJ0eXBlcyIsInZhbHVlcyIsInBhY2tlZCIsInRpZ2h0IiwicGFjayIsImVycm9yIiwiUGFyc2VyRXJyb3IiLCJtZXNzYWdlIiwiZ2V0RXJyb3JNZXNzYWdlIiwidHlwZSIsImJ5dGVzIiwiY3JlYXRlQnl0ZXMiLCJ1bnBhY2siLCJyZXN1bHQiLCJhc3NlcnQiLCJsZW5ndGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/abi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js":
/*!*********************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/errors.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ParserError = exports.getErrorStack = exports.getErrorMessage = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/utils/dist/index.js\");\n/**\n * Attempt to get an error message from a value.\n *\n * - If the value is an error, the error's message is returned.\n * - If the value is an object with a `message` property, the value of that\n * property is returned.\n * - If the value is a string, the value is returned.\n * - Otherwise, \"Unknown error.\" is returned.\n *\n * @param error - The value to get an error message from.\n * @returns The error message.\n * @internal\n */ const getErrorMessage = (error)=>{\n    if (typeof error === \"string\") {\n        return error;\n    }\n    if (error instanceof Error) {\n        return error.message;\n    }\n    if ((0, utils_1.isObject)(error) && (0, utils_1.hasProperty)(error, \"message\") && typeof error.message === \"string\") {\n        return error.message;\n    }\n    return \"Unknown error.\";\n};\nexports.getErrorMessage = getErrorMessage;\n/**\n * Get the error stack from a value. If the value is an error, the error's stack\n * is returned. Otherwise, it returns `undefined`.\n *\n * @param error - The value to get an error stack from.\n * @returns The error stack, or `undefined` if the value is not an error.\n * @internal\n */ const getErrorStack = (error)=>{\n    if (error instanceof Error) {\n        return error.stack;\n    }\n    return undefined;\n};\nexports.getErrorStack = getErrorStack;\n/**\n * An error that is thrown when the ABI encoder or decoder encounters an\n * issue.\n */ class ParserError extends Error {\n    constructor(message, originalError){\n        super(message);\n        this.name = \"ParserError\";\n        const originalStack = (0, exports.getErrorStack)(originalError);\n        if (originalStack) {\n            this.stack = originalStack;\n        }\n    }\n}\nexports.ParserError = ParserError; //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLHFCQUFxQixHQUFHQSx1QkFBdUIsR0FBRyxLQUFLO0FBQzdFLE1BQU1LLFVBQVVDLG1CQUFPQSxDQUFDLDJFQUFpQjtBQUN6Qzs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRCxNQUFNRixrQkFBa0IsQ0FBQ0c7SUFDckIsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDM0IsT0FBT0E7SUFDWDtJQUNBLElBQUlBLGlCQUFpQkMsT0FBTztRQUN4QixPQUFPRCxNQUFNRSxPQUFPO0lBQ3hCO0lBQ0EsSUFBSSxDQUFDLEdBQUdKLFFBQVFLLFFBQVEsRUFBRUgsVUFDdEIsQ0FBQyxHQUFHRixRQUFRTSxXQUFXLEVBQUVKLE9BQU8sY0FDaEMsT0FBT0EsTUFBTUUsT0FBTyxLQUFLLFVBQVU7UUFDbkMsT0FBT0YsTUFBTUUsT0FBTztJQUN4QjtJQUNBLE9BQU87QUFDWDtBQUNBVCx1QkFBdUIsR0FBR0k7QUFDMUI7Ozs7Ozs7Q0FPQyxHQUNELE1BQU1ELGdCQUFnQixDQUFDSTtJQUNuQixJQUFJQSxpQkFBaUJDLE9BQU87UUFDeEIsT0FBT0QsTUFBTUssS0FBSztJQUN0QjtJQUNBLE9BQU9DO0FBQ1g7QUFDQWIscUJBQXFCLEdBQUdHO0FBQ3hCOzs7Q0FHQyxHQUNELE1BQU1ELG9CQUFvQk07SUFDdEJNLFlBQVlMLE9BQU8sRUFBRU0sYUFBYSxDQUFFO1FBQ2hDLEtBQUssQ0FBQ047UUFDTixJQUFJLENBQUNPLElBQUksR0FBRztRQUNaLE1BQU1DLGdCQUFnQixDQUFDLEdBQUdqQixRQUFRRyxhQUFhLEVBQUVZO1FBQ2pELElBQUlFLGVBQWU7WUFDZixJQUFJLENBQUNMLEtBQUssR0FBR0s7UUFDakI7SUFDSjtBQUNKO0FBQ0FqQixtQkFBbUIsR0FBR0UsYUFDdEIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvZXJyb3JzLmpzP2Q2MmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhcnNlckVycm9yID0gZXhwb3J0cy5nZXRFcnJvclN0YWNrID0gZXhwb3J0cy5nZXRFcnJvck1lc3NhZ2UgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbi8qKlxuICogQXR0ZW1wdCB0byBnZXQgYW4gZXJyb3IgbWVzc2FnZSBmcm9tIGEgdmFsdWUuXG4gKlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYW4gZXJyb3IsIHRoZSBlcnJvcidzIG1lc3NhZ2UgaXMgcmV0dXJuZWQuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhIGBtZXNzYWdlYCBwcm9wZXJ0eSwgdGhlIHZhbHVlIG9mIHRoYXRcbiAqIHByb3BlcnR5IGlzIHJldHVybmVkLlxuICogLSBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIHRoZSB2YWx1ZSBpcyByZXR1cm5lZC5cbiAqIC0gT3RoZXJ3aXNlLCBcIlVua25vd24gZXJyb3IuXCIgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIHZhbHVlIHRvIGdldCBhbiBlcnJvciBtZXNzYWdlIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBnZXRFcnJvck1lc3NhZ2UgPSAoZXJyb3IpID0+IHtcbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICAgIH1cbiAgICBpZiAoKDAsIHV0aWxzXzEuaXNPYmplY3QpKGVycm9yKSAmJlxuICAgICAgICAoMCwgdXRpbHNfMS5oYXNQcm9wZXJ0eSkoZXJyb3IsICdtZXNzYWdlJykgJiZcbiAgICAgICAgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gJ1Vua25vd24gZXJyb3IuJztcbn07XG5leHBvcnRzLmdldEVycm9yTWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZTtcbi8qKlxuICogR2V0IHRoZSBlcnJvciBzdGFjayBmcm9tIGEgdmFsdWUuIElmIHRoZSB2YWx1ZSBpcyBhbiBlcnJvciwgdGhlIGVycm9yJ3Mgc3RhY2tcbiAqIGlzIHJldHVybmVkLiBPdGhlcndpc2UsIGl0IHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIHZhbHVlIHRvIGdldCBhbiBlcnJvciBzdGFjayBmcm9tLlxuICogQHJldHVybnMgVGhlIGVycm9yIHN0YWNrLCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgdmFsdWUgaXMgbm90IGFuIGVycm9yLlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IGdldEVycm9yU3RhY2sgPSAoZXJyb3IpID0+IHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3Iuc3RhY2s7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuZXhwb3J0cy5nZXRFcnJvclN0YWNrID0gZ2V0RXJyb3JTdGFjaztcbi8qKlxuICogQW4gZXJyb3IgdGhhdCBpcyB0aHJvd24gd2hlbiB0aGUgQUJJIGVuY29kZXIgb3IgZGVjb2RlciBlbmNvdW50ZXJzIGFuXG4gKiBpc3N1ZS5cbiAqL1xuY2xhc3MgUGFyc2VyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgb3JpZ2luYWxFcnJvcikge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1BhcnNlckVycm9yJztcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTdGFjayA9ICgwLCBleHBvcnRzLmdldEVycm9yU3RhY2spKG9yaWdpbmFsRXJyb3IpO1xuICAgICAgICBpZiAob3JpZ2luYWxTdGFjaykge1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IG9yaWdpbmFsU3RhY2s7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlBhcnNlckVycm9yID0gUGFyc2VyRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUGFyc2VyRXJyb3IiLCJnZXRFcnJvclN0YWNrIiwiZ2V0RXJyb3JNZXNzYWdlIiwidXRpbHNfMSIsInJlcXVpcmUiLCJlcnJvciIsIkVycm9yIiwibWVzc2FnZSIsImlzT2JqZWN0IiwiaGFzUHJvcGVydHkiLCJzdGFjayIsInVuZGVmaW5lZCIsImNvbnN0cnVjdG9yIiwib3JpZ2luYWxFcnJvciIsIm5hbWUiLCJvcmlnaW5hbFN0YWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n__exportStar(__webpack_require__(/*! ./abi */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/abi.js\"), exports);\n__exportStar(__webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/types/index.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLGVBQWUsSUFBSyxJQUFJLElBQUksQ0FBQ0EsWUFBWSxJQUFLLFNBQVNaLENBQUMsRUFBRWEsUUFBTztJQUNqRSxJQUFLLElBQUlDLEtBQUtkLEVBQUcsSUFBSWMsTUFBTSxhQUFhLENBQUNqQixPQUFPa0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osVUFBU0MsSUFBSWxCLGdCQUFnQmlCLFVBQVNiLEdBQUdjO0FBQzNIO0FBQ0FqQiw4Q0FBNkM7SUFBRXFCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0ROLGFBQWFPLG1CQUFPQSxDQUFDLG1FQUFPLEdBQUdOO0FBQy9CRCxhQUFhTyxtQkFBT0EsQ0FBQyx5RUFBVSxHQUFHTjtBQUNsQ0QsYUFBYU8sbUJBQU9BLENBQUMsNkVBQVMsR0FBR04sVUFDakMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvaW5kZXguanM/N2RmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FiaVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXJyb3JzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19leHBvcnRTdGFyIiwiZXhwb3J0cyIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ2YWx1ZSIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/iterator.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.iterate = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/utils/dist/index.js\");\n/**\n * Iterate over a buffer with the specified size. This will yield a part of the\n * buffer starting at an increment of the specified size, until the end of the\n * buffer is reached.\n *\n * Calling the `skip` function will make it skip the specified number of bytes.\n *\n * @param buffer - The buffer to iterate over.\n * @param size - The number of bytes to iterate with.\n * @returns An iterator that yields the parts of the byte array.\n * @yields The parts of the byte array.\n */ const iterate = function*(buffer, size = 32) {\n    for(let pointer = 0; pointer < buffer.length; pointer += size){\n        const skip = (length)=>{\n            (0, utils_1.assert)(length >= 0, \"Cannot skip a negative number of bytes.\");\n            (0, utils_1.assert)(length % size === 0, \"Length must be a multiple of the size.\");\n            pointer += length;\n        };\n        const value = buffer.subarray(pointer);\n        yield {\n            skip,\n            value\n        };\n    }\n    return {\n        skip: ()=>undefined,\n        value: new Uint8Array()\n    };\n};\nexports.iterate = iterate; //# sourceMappingURL=iterator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L2l0ZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxlQUFlLEdBQUcsS0FBSztBQUN2QixNQUFNRyxVQUFVQyxtQkFBT0EsQ0FBQywyRUFBaUI7QUFDekM7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxNQUFNRixVQUFVLFVBQVdHLE1BQU0sRUFBRUMsT0FBTyxFQUFFO0lBQ3hDLElBQUssSUFBSUMsVUFBVSxHQUFHQSxVQUFVRixPQUFPRyxNQUFNLEVBQUVELFdBQVdELEtBQU07UUFDNUQsTUFBTUcsT0FBTyxDQUFDRDtZQUNULElBQUdMLFFBQVFPLE1BQU0sRUFBRUYsVUFBVSxHQUFHO1lBQ2hDLElBQUdMLFFBQVFPLE1BQU0sRUFBRUYsU0FBU0YsU0FBUyxHQUFHO1lBQ3pDQyxXQUFXQztRQUNmO1FBQ0EsTUFBTVAsUUFBUUksT0FBT00sUUFBUSxDQUFDSjtRQUM5QixNQUFNO1lBQUVFO1lBQU1SO1FBQU07SUFDeEI7SUFDQSxPQUFPO1FBQ0hRLE1BQU0sSUFBTUc7UUFDWlgsT0FBTyxJQUFJWTtJQUNmO0FBQ0o7QUFDQWIsZUFBZSxHQUFHRSxTQUNsQixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9pdGVyYXRvci5qcz8xYmNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pdGVyYXRlID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhIGJ1ZmZlciB3aXRoIHRoZSBzcGVjaWZpZWQgc2l6ZS4gVGhpcyB3aWxsIHlpZWxkIGEgcGFydCBvZiB0aGVcbiAqIGJ1ZmZlciBzdGFydGluZyBhdCBhbiBpbmNyZW1lbnQgb2YgdGhlIHNwZWNpZmllZCBzaXplLCB1bnRpbCB0aGUgZW5kIG9mIHRoZVxuICogYnVmZmVyIGlzIHJlYWNoZWQuXG4gKlxuICogQ2FsbGluZyB0aGUgYHNraXBgIGZ1bmN0aW9uIHdpbGwgbWFrZSBpdCBza2lwIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBidWZmZXIgLSBUaGUgYnVmZmVyIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSBzaXplIC0gVGhlIG51bWJlciBvZiBieXRlcyB0byBpdGVyYXRlIHdpdGguXG4gKiBAcmV0dXJucyBBbiBpdGVyYXRvciB0aGF0IHlpZWxkcyB0aGUgcGFydHMgb2YgdGhlIGJ5dGUgYXJyYXkuXG4gKiBAeWllbGRzIFRoZSBwYXJ0cyBvZiB0aGUgYnl0ZSBhcnJheS5cbiAqL1xuY29uc3QgaXRlcmF0ZSA9IGZ1bmN0aW9uKiAoYnVmZmVyLCBzaXplID0gMzIpIHtcbiAgICBmb3IgKGxldCBwb2ludGVyID0gMDsgcG9pbnRlciA8IGJ1ZmZlci5sZW5ndGg7IHBvaW50ZXIgKz0gc2l6ZSkge1xuICAgICAgICBjb25zdCBza2lwID0gKGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgKDAsIHV0aWxzXzEuYXNzZXJ0KShsZW5ndGggPj0gMCwgJ0Nhbm5vdCBza2lwIGEgbmVnYXRpdmUgbnVtYmVyIG9mIGJ5dGVzLicpO1xuICAgICAgICAgICAgKDAsIHV0aWxzXzEuYXNzZXJ0KShsZW5ndGggJSBzaXplID09PSAwLCAnTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiB0aGUgc2l6ZS4nKTtcbiAgICAgICAgICAgIHBvaW50ZXIgKz0gbGVuZ3RoO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGJ1ZmZlci5zdWJhcnJheShwb2ludGVyKTtcbiAgICAgICAgeWllbGQgeyBza2lwLCB2YWx1ZSB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBza2lwOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgICAgIHZhbHVlOiBuZXcgVWludDhBcnJheSgpLFxuICAgIH07XG59O1xuZXhwb3J0cy5pdGVyYXRlID0gaXRlcmF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZXJhdG9yLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIml0ZXJhdGUiLCJ1dGlsc18xIiwicmVxdWlyZSIsImJ1ZmZlciIsInNpemUiLCJwb2ludGVyIiwibGVuZ3RoIiwic2tpcCIsImFzc2VydCIsInN1YmFycmF5IiwidW5kZWZpbmVkIiwiVWludDhBcnJheSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/iterator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/packer.js":
/*!*********************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/packer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.unpack = exports.pack = exports.isDynamicParser = exports.getParser = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/utils/dist/index.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\");\nconst iterator_1 = __webpack_require__(/*! ./iterator */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/iterator.js\");\nconst parsers_1 = __webpack_require__(/*! ./parsers */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/index.js\");\nconst utils_2 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/utils/index.js\");\n/**\n * Get the parser for the specified type.\n *\n * @param type - The type to get a parser for.\n * @returns The parser.\n * @throws If there is no parser for the specified type.\n */ const getParser = (type)=>{\n    const parsers = {\n        address: parsers_1.address,\n        array: parsers_1.array,\n        bool: parsers_1.bool,\n        bytes: parsers_1.bytes,\n        fixedBytes: parsers_1.fixedBytes,\n        function: parsers_1.fn,\n        number: parsers_1.number,\n        string: parsers_1.string,\n        tuple: parsers_1.tuple\n    };\n    const staticParser = parsers[type];\n    if (staticParser) {\n        return staticParser;\n    }\n    const parser = Object.values(parsers).find((value)=>value.isType(type));\n    if (parser) {\n        return parser;\n    }\n    throw new errors_1.ParserError(`The type \"${type}\" is not supported.`);\n};\nexports.getParser = getParser;\n/**\n * Check if the specified parser is dynamic, for the provided types. This is\n * primarily used for parsing tuples, where a tuple can be dynamic based on the\n * types. For other parsers, it will simply use the set `isDynamic` value.\n *\n * @param parser - The parser to check.\n * @param type - The type to check the parser with.\n * @returns Whether the parser is dynamic.\n */ const isDynamicParser = (parser, type)=>{\n    const { isDynamic } = parser;\n    if (typeof isDynamic === \"function\") {\n        return isDynamic(type);\n    }\n    return isDynamic;\n};\nexports.isDynamicParser = isDynamicParser;\n/**\n * Pack the provided values in a buffer, encoded with the specified types. If a\n * buffer is specified, the resulting value will be concatenated with the\n * buffer.\n *\n * @param args - The arguments object.\n * @param args.types - The types of the values to pack.\n * @param args.values - The values to pack.\n * @param args.packed - Whether to use the non-standard packed mode. Defaults to\n * `false`.\n * @param args.arrayPacked - Whether to use the non-standard packed mode for\n * arrays. Defaults to `false`.\n * @param args.byteArray - The byte array to encode the values into. Defaults to\n * an empty array.\n * @param args.tight - Whether to use tight packing mode. Only applicable when\n * `packed` is true. When true, the packed mode will not add any padding bytes.\n * This matches the packing behaviour of `ethereumjs-abi`, but is not standard.\n * @returns The resulting encoded buffer.\n */ const pack = ({ types, values, packed = false, tight = false, arrayPacked = false, byteArray = new Uint8Array() })=>{\n    (0, utils_1.assert)(types.length === values.length, new errors_1.ParserError(`The number of types (${types.length}) does not match the number of values (${values.length}).`));\n    const { staticBuffer, dynamicBuffer, pointers } = types.reduce(// eslint-disable-next-line @typescript-eslint/no-shadow\n    ({ staticBuffer, dynamicBuffer, pointers }, type, index)=>{\n        const parser = (0, exports.getParser)(type);\n        const value = values[index];\n        // If packed mode is enabled, we can skip the dynamic check, as all\n        // values are encoded in the static buffer.\n        if (packed || arrayPacked || !(0, exports.isDynamicParser)(parser, type)) {\n            return {\n                staticBuffer: parser.encode({\n                    buffer: staticBuffer,\n                    value,\n                    type,\n                    packed,\n                    tight\n                }),\n                dynamicBuffer,\n                pointers\n            };\n        }\n        const newStaticBuffer = (0, utils_1.concatBytes)([\n            staticBuffer,\n            new Uint8Array(32)\n        ]);\n        const newDynamicBuffer = parser.encode({\n            buffer: dynamicBuffer,\n            value,\n            type,\n            packed,\n            tight\n        });\n        return {\n            staticBuffer: newStaticBuffer,\n            dynamicBuffer: newDynamicBuffer,\n            pointers: [\n                ...pointers,\n                {\n                    position: staticBuffer.length,\n                    pointer: dynamicBuffer.length\n                }\n            ]\n        };\n    }, {\n        staticBuffer: new Uint8Array(),\n        dynamicBuffer: new Uint8Array(),\n        pointers: []\n    });\n    // If packed mode is enabled, there shouldn't be any dynamic values.\n    (0, utils_1.assert)(!packed && !arrayPacked || dynamicBuffer.length === 0, new errors_1.ParserError(\"Invalid pack state.\"));\n    const dynamicStart = staticBuffer.length;\n    const updatedBuffer = pointers.reduce((target, { pointer, position })=>{\n        const offset = (0, utils_2.padStart)((0, utils_1.numberToBytes)(dynamicStart + pointer));\n        return (0, utils_2.set)(target, offset, position);\n    }, staticBuffer);\n    return (0, utils_1.concatBytes)([\n        byteArray,\n        updatedBuffer,\n        dynamicBuffer\n    ]);\n};\nexports.pack = pack;\nconst unpack = (types, buffer)=>{\n    const iterator = (0, iterator_1.iterate)(buffer);\n    return types.map((type)=>{\n        const { value: { value, skip }, done } = iterator.next();\n        (0, utils_1.assert)(!done, new errors_1.ParserError(`The encoded value is invalid for the provided types. Reached end of buffer while attempting to parse \"${type}\".`));\n        const parser = (0, exports.getParser)(type);\n        const isDynamic = (0, exports.isDynamicParser)(parser, type);\n        if (isDynamic) {\n            const pointer = (0, utils_1.bytesToNumber)(value.subarray(0, 32));\n            const target = buffer.subarray(pointer);\n            return parser.decode({\n                type,\n                value: target,\n                skip\n            });\n        }\n        return parser.decode({\n            type,\n            value,\n            skip\n        });\n    });\n};\nexports.unpack = unpack; //# sourceMappingURL=packer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhY2tlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHQSxZQUFZLEdBQUdBLHVCQUF1QixHQUFHQSxpQkFBaUIsR0FBRyxLQUFLO0FBQ25GLE1BQU1NLFVBQVVDLG1CQUFPQSxDQUFDLDJFQUFpQjtBQUN6QyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyx5RUFBVTtBQUNuQyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyw2RUFBWTtBQUN2QyxNQUFNRyxZQUFZSCxtQkFBT0EsQ0FBQyxpRkFBVztBQUNyQyxNQUFNSSxVQUFVSixtQkFBT0EsQ0FBQyw2RUFBUztBQUNqQzs7Ozs7O0NBTUMsR0FDRCxNQUFNRixZQUFZLENBQUNPO0lBQ2YsTUFBTUMsVUFBVTtRQUNaQyxTQUFTSixVQUFVSSxPQUFPO1FBQzFCQyxPQUFPTCxVQUFVSyxLQUFLO1FBQ3RCQyxNQUFNTixVQUFVTSxJQUFJO1FBQ3BCQyxPQUFPUCxVQUFVTyxLQUFLO1FBQ3RCQyxZQUFZUixVQUFVUSxVQUFVO1FBQ2hDQyxVQUFVVCxVQUFVVSxFQUFFO1FBQ3RCQyxRQUFRWCxVQUFVVyxNQUFNO1FBQ3hCQyxRQUFRWixVQUFVWSxNQUFNO1FBQ3hCQyxPQUFPYixVQUFVYSxLQUFLO0lBQzFCO0lBQ0EsTUFBTUMsZUFBZVgsT0FBTyxDQUFDRCxLQUFLO0lBQ2xDLElBQUlZLGNBQWM7UUFDZCxPQUFPQTtJQUNYO0lBQ0EsTUFBTUMsU0FBUzNCLE9BQU80QixNQUFNLENBQUNiLFNBQVNjLElBQUksQ0FBQyxDQUFDMUIsUUFBVUEsTUFBTTJCLE1BQU0sQ0FBQ2hCO0lBQ25FLElBQUlhLFFBQVE7UUFDUixPQUFPQTtJQUNYO0lBQ0EsTUFBTSxJQUFJakIsU0FBU3FCLFdBQVcsQ0FBQyxDQUFDLFVBQVUsRUFBRWpCLEtBQUssbUJBQW1CLENBQUM7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a0QsT0FBTyxFQUFFZDtJQUN6QyxPQUFPZCxNQUFNNkIsR0FBRyxDQUFDLENBQUNoRDtRQUNkLE1BQU0sRUFBRVgsT0FBTyxFQUFFQSxLQUFLLEVBQUU0RCxJQUFJLEVBQUUsRUFBRUMsSUFBSSxFQUFHLEdBQUdKLFNBQVNLLElBQUk7UUFDdEQsSUFBR3pELFFBQVErQixNQUFNLEVBQUUsQ0FBQ3lCLE1BQU0sSUFBSXRELFNBQVNxQixXQUFXLENBQUMsQ0FBQyxzR0FBc0csRUFBRWpCLEtBQUssRUFBRSxDQUFDO1FBQ3JLLE1BQU1hLFNBQVMsQ0FBQyxHQUFHekIsUUFBUUssU0FBUyxFQUFFTztRQUN0QyxNQUFNa0IsWUFBWSxDQUFDLEdBQUc5QixRQUFRSSxlQUFlLEVBQUVxQixRQUFRYjtRQUN2RCxJQUFJa0IsV0FBVztZQUNYLE1BQU1vQixVQUFVLENBQUMsR0FBRzVDLFFBQVEwRCxhQUFhLEVBQUUvRCxNQUFNZ0UsUUFBUSxDQUFDLEdBQUc7WUFDN0QsTUFBTVosU0FBU1IsT0FBT29CLFFBQVEsQ0FBQ2Y7WUFDL0IsT0FBT3pCLE9BQU95QyxNQUFNLENBQUM7Z0JBQUV0RDtnQkFBTVgsT0FBT29EO2dCQUFRUTtZQUFLO1FBQ3JEO1FBQ0EsT0FBT3BDLE9BQU95QyxNQUFNLENBQUM7WUFBRXREO1lBQU1YO1lBQU80RDtRQUFLO0lBQzdDO0FBQ0o7QUFDQTdELGNBQWMsR0FBR0UsUUFDakIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvcGFja2VyLmpzPzA0NjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVucGFjayA9IGV4cG9ydHMucGFjayA9IGV4cG9ydHMuaXNEeW5hbWljUGFyc2VyID0gZXhwb3J0cy5nZXRQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgaXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL2l0ZXJhdG9yXCIpO1xuY29uc3QgcGFyc2Vyc18xID0gcmVxdWlyZShcIi4vcGFyc2Vyc1wiKTtcbmNvbnN0IHV0aWxzXzIgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogR2V0IHRoZSBwYXJzZXIgZm9yIHRoZSBzcGVjaWZpZWQgdHlwZS5cbiAqXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGdldCBhIHBhcnNlciBmb3IuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VyLlxuICogQHRocm93cyBJZiB0aGVyZSBpcyBubyBwYXJzZXIgZm9yIHRoZSBzcGVjaWZpZWQgdHlwZS5cbiAqL1xuY29uc3QgZ2V0UGFyc2VyID0gKHR5cGUpID0+IHtcbiAgICBjb25zdCBwYXJzZXJzID0ge1xuICAgICAgICBhZGRyZXNzOiBwYXJzZXJzXzEuYWRkcmVzcyxcbiAgICAgICAgYXJyYXk6IHBhcnNlcnNfMS5hcnJheSxcbiAgICAgICAgYm9vbDogcGFyc2Vyc18xLmJvb2wsXG4gICAgICAgIGJ5dGVzOiBwYXJzZXJzXzEuYnl0ZXMsXG4gICAgICAgIGZpeGVkQnl0ZXM6IHBhcnNlcnNfMS5maXhlZEJ5dGVzLFxuICAgICAgICBmdW5jdGlvbjogcGFyc2Vyc18xLmZuLFxuICAgICAgICBudW1iZXI6IHBhcnNlcnNfMS5udW1iZXIsXG4gICAgICAgIHN0cmluZzogcGFyc2Vyc18xLnN0cmluZyxcbiAgICAgICAgdHVwbGU6IHBhcnNlcnNfMS50dXBsZSxcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY1BhcnNlciA9IHBhcnNlcnNbdHlwZV07XG4gICAgaWYgKHN0YXRpY1BhcnNlcikge1xuICAgICAgICByZXR1cm4gc3RhdGljUGFyc2VyO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZXIgPSBPYmplY3QudmFsdWVzKHBhcnNlcnMpLmZpbmQoKHZhbHVlKSA9PiB2YWx1ZS5pc1R5cGUodHlwZSkpO1xuICAgIGlmIChwYXJzZXIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBUaGUgdHlwZSBcIiR7dHlwZX1cIiBpcyBub3Qgc3VwcG9ydGVkLmApO1xufTtcbmV4cG9ydHMuZ2V0UGFyc2VyID0gZ2V0UGFyc2VyO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgc3BlY2lmaWVkIHBhcnNlciBpcyBkeW5hbWljLCBmb3IgdGhlIHByb3ZpZGVkIHR5cGVzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZCBmb3IgcGFyc2luZyB0dXBsZXMsIHdoZXJlIGEgdHVwbGUgY2FuIGJlIGR5bmFtaWMgYmFzZWQgb24gdGhlXG4gKiB0eXBlcy4gRm9yIG90aGVyIHBhcnNlcnMsIGl0IHdpbGwgc2ltcGx5IHVzZSB0aGUgc2V0IGBpc0R5bmFtaWNgIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBwYXJzZXIgLSBUaGUgcGFyc2VyIHRvIGNoZWNrLlxuICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSB0byBjaGVjayB0aGUgcGFyc2VyIHdpdGguXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBwYXJzZXIgaXMgZHluYW1pYy5cbiAqL1xuY29uc3QgaXNEeW5hbWljUGFyc2VyID0gKHBhcnNlciwgdHlwZSkgPT4ge1xuICAgIGNvbnN0IHsgaXNEeW5hbWljIH0gPSBwYXJzZXI7XG4gICAgaWYgKHR5cGVvZiBpc0R5bmFtaWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGlzRHluYW1pYyh0eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRHluYW1pYztcbn07XG5leHBvcnRzLmlzRHluYW1pY1BhcnNlciA9IGlzRHluYW1pY1BhcnNlcjtcbi8qKlxuICogUGFjayB0aGUgcHJvdmlkZWQgdmFsdWVzIGluIGEgYnVmZmVyLCBlbmNvZGVkIHdpdGggdGhlIHNwZWNpZmllZCB0eXBlcy4gSWYgYVxuICogYnVmZmVyIGlzIHNwZWNpZmllZCwgdGhlIHJlc3VsdGluZyB2YWx1ZSB3aWxsIGJlIGNvbmNhdGVuYXRlZCB3aXRoIHRoZVxuICogYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBvYmplY3QuXG4gKiBAcGFyYW0gYXJncy50eXBlcyAtIFRoZSB0eXBlcyBvZiB0aGUgdmFsdWVzIHRvIHBhY2suXG4gKiBAcGFyYW0gYXJncy52YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIHBhY2suXG4gKiBAcGFyYW0gYXJncy5wYWNrZWQgLSBXaGV0aGVyIHRvIHVzZSB0aGUgbm9uLXN0YW5kYXJkIHBhY2tlZCBtb2RlLiBEZWZhdWx0cyB0b1xuICogYGZhbHNlYC5cbiAqIEBwYXJhbSBhcmdzLmFycmF5UGFja2VkIC0gV2hldGhlciB0byB1c2UgdGhlIG5vbi1zdGFuZGFyZCBwYWNrZWQgbW9kZSBmb3JcbiAqIGFycmF5cy4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqIEBwYXJhbSBhcmdzLmJ5dGVBcnJheSAtIFRoZSBieXRlIGFycmF5IHRvIGVuY29kZSB0aGUgdmFsdWVzIGludG8uIERlZmF1bHRzIHRvXG4gKiBhbiBlbXB0eSBhcnJheS5cbiAqIEBwYXJhbSBhcmdzLnRpZ2h0IC0gV2hldGhlciB0byB1c2UgdGlnaHQgcGFja2luZyBtb2RlLiBPbmx5IGFwcGxpY2FibGUgd2hlblxuICogYHBhY2tlZGAgaXMgdHJ1ZS4gV2hlbiB0cnVlLCB0aGUgcGFja2VkIG1vZGUgd2lsbCBub3QgYWRkIGFueSBwYWRkaW5nIGJ5dGVzLlxuICogVGhpcyBtYXRjaGVzIHRoZSBwYWNraW5nIGJlaGF2aW91ciBvZiBgZXRoZXJldW1qcy1hYmlgLCBidXQgaXMgbm90IHN0YW5kYXJkLlxuICogQHJldHVybnMgVGhlIHJlc3VsdGluZyBlbmNvZGVkIGJ1ZmZlci5cbiAqL1xuY29uc3QgcGFjayA9ICh7IHR5cGVzLCB2YWx1ZXMsIHBhY2tlZCA9IGZhbHNlLCB0aWdodCA9IGZhbHNlLCBhcnJheVBhY2tlZCA9IGZhbHNlLCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheSgpLCB9KSA9PiB7XG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KSh0eXBlcy5sZW5ndGggPT09IHZhbHVlcy5sZW5ndGgsIG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgVGhlIG51bWJlciBvZiB0eXBlcyAoJHt0eXBlcy5sZW5ndGh9KSBkb2VzIG5vdCBtYXRjaCB0aGUgbnVtYmVyIG9mIHZhbHVlcyAoJHt2YWx1ZXMubGVuZ3RofSkuYCkpO1xuICAgIGNvbnN0IHsgc3RhdGljQnVmZmVyLCBkeW5hbWljQnVmZmVyLCBwb2ludGVycyB9ID0gdHlwZXMucmVkdWNlKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG4gICAgKHsgc3RhdGljQnVmZmVyLCBkeW5hbWljQnVmZmVyLCBwb2ludGVycyB9LCB0eXBlLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJzZXIgPSAoMCwgZXhwb3J0cy5nZXRQYXJzZXIpKHR5cGUpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIC8vIElmIHBhY2tlZCBtb2RlIGlzIGVuYWJsZWQsIHdlIGNhbiBza2lwIHRoZSBkeW5hbWljIGNoZWNrLCBhcyBhbGxcbiAgICAgICAgLy8gdmFsdWVzIGFyZSBlbmNvZGVkIGluIHRoZSBzdGF0aWMgYnVmZmVyLlxuICAgICAgICBpZiAocGFja2VkIHx8IGFycmF5UGFja2VkIHx8ICEoMCwgZXhwb3J0cy5pc0R5bmFtaWNQYXJzZXIpKHBhcnNlciwgdHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdGljQnVmZmVyOiBwYXJzZXIuZW5jb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiBzdGF0aWNCdWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICBwYWNrZWQsXG4gICAgICAgICAgICAgICAgICAgIHRpZ2h0LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNCdWZmZXIsXG4gICAgICAgICAgICAgICAgcG9pbnRlcnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1N0YXRpY0J1ZmZlciA9ICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbc3RhdGljQnVmZmVyLCBuZXcgVWludDhBcnJheSgzMildKTtcbiAgICAgICAgY29uc3QgbmV3RHluYW1pY0J1ZmZlciA9IHBhcnNlci5lbmNvZGUoe1xuICAgICAgICAgICAgYnVmZmVyOiBkeW5hbWljQnVmZmVyLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcGFja2VkLFxuICAgICAgICAgICAgdGlnaHQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdGljQnVmZmVyOiBuZXdTdGF0aWNCdWZmZXIsXG4gICAgICAgICAgICBkeW5hbWljQnVmZmVyOiBuZXdEeW5hbWljQnVmZmVyLFxuICAgICAgICAgICAgcG9pbnRlcnM6IFtcbiAgICAgICAgICAgICAgICAuLi5wb2ludGVycyxcbiAgICAgICAgICAgICAgICB7IHBvc2l0aW9uOiBzdGF0aWNCdWZmZXIubGVuZ3RoLCBwb2ludGVyOiBkeW5hbWljQnVmZmVyLmxlbmd0aCB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9LCB7XG4gICAgICAgIHN0YXRpY0J1ZmZlcjogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgZHluYW1pY0J1ZmZlcjogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgcG9pbnRlcnM6IFtdLFxuICAgIH0pO1xuICAgIC8vIElmIHBhY2tlZCBtb2RlIGlzIGVuYWJsZWQsIHRoZXJlIHNob3VsZG4ndCBiZSBhbnkgZHluYW1pYyB2YWx1ZXMuXG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KSgoIXBhY2tlZCAmJiAhYXJyYXlQYWNrZWQpIHx8IGR5bmFtaWNCdWZmZXIubGVuZ3RoID09PSAwLCBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoJ0ludmFsaWQgcGFjayBzdGF0ZS4nKSk7XG4gICAgY29uc3QgZHluYW1pY1N0YXJ0ID0gc3RhdGljQnVmZmVyLmxlbmd0aDtcbiAgICBjb25zdCB1cGRhdGVkQnVmZmVyID0gcG9pbnRlcnMucmVkdWNlKCh0YXJnZXQsIHsgcG9pbnRlciwgcG9zaXRpb24gfSkgPT4ge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAoMCwgdXRpbHNfMi5wYWRTdGFydCkoKDAsIHV0aWxzXzEubnVtYmVyVG9CeXRlcykoZHluYW1pY1N0YXJ0ICsgcG9pbnRlcikpO1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzIuc2V0KSh0YXJnZXQsIG9mZnNldCwgcG9zaXRpb24pO1xuICAgIH0sIHN0YXRpY0J1ZmZlcik7XG4gICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbYnl0ZUFycmF5LCB1cGRhdGVkQnVmZmVyLCBkeW5hbWljQnVmZmVyXSk7XG59O1xuZXhwb3J0cy5wYWNrID0gcGFjaztcbmNvbnN0IHVucGFjayA9ICh0eXBlcywgYnVmZmVyKSA9PiB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSAoMCwgaXRlcmF0b3JfMS5pdGVyYXRlKShidWZmZXIpO1xuICAgIHJldHVybiB0eXBlcy5tYXAoKHR5cGUpID0+IHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZTogeyB2YWx1ZSwgc2tpcCB9LCBkb25lLCB9ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKCFkb25lLCBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYFRoZSBlbmNvZGVkIHZhbHVlIGlzIGludmFsaWQgZm9yIHRoZSBwcm92aWRlZCB0eXBlcy4gUmVhY2hlZCBlbmQgb2YgYnVmZmVyIHdoaWxlIGF0dGVtcHRpbmcgdG8gcGFyc2UgXCIke3R5cGV9XCIuYCkpO1xuICAgICAgICBjb25zdCBwYXJzZXIgPSAoMCwgZXhwb3J0cy5nZXRQYXJzZXIpKHR5cGUpO1xuICAgICAgICBjb25zdCBpc0R5bmFtaWMgPSAoMCwgZXhwb3J0cy5pc0R5bmFtaWNQYXJzZXIpKHBhcnNlciwgdHlwZSk7XG4gICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXIgPSAoMCwgdXRpbHNfMS5ieXRlc1RvTnVtYmVyKSh2YWx1ZS5zdWJhcnJheSgwLCAzMikpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gYnVmZmVyLnN1YmFycmF5KHBvaW50ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5kZWNvZGUoeyB0eXBlLCB2YWx1ZTogdGFyZ2V0LCBza2lwIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZXIuZGVjb2RlKHsgdHlwZSwgdmFsdWUsIHNraXAgfSk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy51bnBhY2sgPSB1bnBhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWNrZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidW5wYWNrIiwicGFjayIsImlzRHluYW1pY1BhcnNlciIsImdldFBhcnNlciIsInV0aWxzXzEiLCJyZXF1aXJlIiwiZXJyb3JzXzEiLCJpdGVyYXRvcl8xIiwicGFyc2Vyc18xIiwidXRpbHNfMiIsInR5cGUiLCJwYXJzZXJzIiwiYWRkcmVzcyIsImFycmF5IiwiYm9vbCIsImJ5dGVzIiwiZml4ZWRCeXRlcyIsImZ1bmN0aW9uIiwiZm4iLCJudW1iZXIiLCJzdHJpbmciLCJ0dXBsZSIsInN0YXRpY1BhcnNlciIsInBhcnNlciIsInZhbHVlcyIsImZpbmQiLCJpc1R5cGUiLCJQYXJzZXJFcnJvciIsImlzRHluYW1pYyIsInR5cGVzIiwicGFja2VkIiwidGlnaHQiLCJhcnJheVBhY2tlZCIsImJ5dGVBcnJheSIsIlVpbnQ4QXJyYXkiLCJhc3NlcnQiLCJsZW5ndGgiLCJzdGF0aWNCdWZmZXIiLCJkeW5hbWljQnVmZmVyIiwicG9pbnRlcnMiLCJyZWR1Y2UiLCJpbmRleCIsImVuY29kZSIsImJ1ZmZlciIsIm5ld1N0YXRpY0J1ZmZlciIsImNvbmNhdEJ5dGVzIiwibmV3RHluYW1pY0J1ZmZlciIsInBvc2l0aW9uIiwicG9pbnRlciIsImR5bmFtaWNTdGFydCIsInVwZGF0ZWRCdWZmZXIiLCJ0YXJnZXQiLCJvZmZzZXQiLCJwYWRTdGFydCIsIm51bWJlclRvQnl0ZXMiLCJzZXQiLCJpdGVyYXRvciIsIml0ZXJhdGUiLCJtYXAiLCJza2lwIiwiZG9uZSIsIm5leHQiLCJieXRlc1RvTnVtYmVyIiwic3ViYXJyYXkiLCJkZWNvZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/packer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/address.js":
/*!******************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/address.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.address = exports.getAddress = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/utils/dist/index.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\");\nconst utils_2 = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/utils/index.js\");\n/**\n * Normalize an address value. This accepts the address as:\n *\n * - A hex string starting with the `0x` prefix.\n * - A byte array (`Uint8Array` or `Buffer`).\n *\n * It checks that the address is 20 bytes long.\n *\n * @param value - The value to normalize.\n * @returns The normalized address as `Uint8Array`.\n */ const getAddress = (value)=>{\n    const bytesValue = (0, utils_1.createBytes)(value);\n    (0, utils_1.assert)(bytesValue.length <= 20, new errors_1.ParserError(`Invalid address value. Expected address to be 20 bytes long, but received ${bytesValue.length} bytes.`));\n    return (0, utils_2.padStart)(bytesValue, 20);\n};\nexports.getAddress = getAddress;\nexports.address = {\n    isDynamic: false,\n    /**\n     * Get if the given value is a valid address type. Since `address` is a simple\n     * type, this is just a check that the value is \"address\".\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a valid address type.\n     */ isType: (type)=>type === \"address\",\n    /**\n     * Get the byte length of an encoded address. Since `address` is a simple\n     * type, this always returns 32.\n     *\n     * Note that actual addresses are only 20 bytes long, but the encoding of\n     * the `address` type is always 32 bytes long.\n     *\n     * @returns The byte length of an encoded address.\n     */ getByteLength () {\n        return 32;\n    },\n    /**\n     * Encode the given address to a 32-byte-long byte array.\n     *\n     * @param args - The encoding arguments.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The address to encode.\n     * @param args.packed - Whether to use packed encoding.\n     * @returns The bytes with the encoded address added to it.\n     */ encode ({ buffer, value, packed }) {\n        const addressValue = (0, exports.getAddress)(value);\n        // If we're using packed encoding, we can just add the address bytes to the\n        // byte array, without adding any padding.\n        if (packed) {\n            return (0, utils_1.concatBytes)([\n                buffer,\n                addressValue\n            ]);\n        }\n        const addressBuffer = (0, utils_2.padStart)(addressValue);\n        return (0, utils_1.concatBytes)([\n            buffer,\n            addressBuffer\n        ]);\n    },\n    /**\n     * Decode the given byte array to an address.\n     *\n     * @param args - The decoding arguments.\n     * @param args.value - The byte array to decode.\n     * @returns The decoded address as a hexadecimal string, starting with the\n     * \"0x\"-prefix.\n     */ decode ({ value }) {\n        return (0, utils_1.add0x)((0, utils_1.bytesToHex)(value.slice(12, 32)));\n    }\n}; //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvYWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZUFBZSxHQUFHQSxrQkFBa0IsR0FBRyxLQUFLO0FBQzVDLE1BQU1JLFVBQVVDLG1CQUFPQSxDQUFDLDJFQUFpQjtBQUN6QyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQywwRUFBVztBQUNwQyxNQUFNRSxVQUFVRixtQkFBT0EsQ0FBQyw4RUFBVTtBQUNsQzs7Ozs7Ozs7OztDQVVDLEdBQ0QsTUFBTUYsYUFBYSxDQUFDRjtJQUNoQixNQUFNTyxhQUFhLENBQUMsR0FBR0osUUFBUUssV0FBVyxFQUFFUjtJQUMzQyxJQUFHRyxRQUFRTSxNQUFNLEVBQUVGLFdBQVdHLE1BQU0sSUFBSSxJQUFJLElBQUlMLFNBQVNNLFdBQVcsQ0FBQyxDQUFDLDBFQUEwRSxFQUFFSixXQUFXRyxNQUFNLENBQUMsT0FBTyxDQUFDO0lBQzdLLE9BQU8sQ0FBQyxHQUFHSixRQUFRTSxRQUFRLEVBQUVMLFlBQVk7QUFDN0M7QUFDQVIsa0JBQWtCLEdBQUdHO0FBQ3JCSCxlQUFlLEdBQUc7SUFDZGMsV0FBVztJQUNYOzs7Ozs7S0FNQyxHQUNEQyxRQUFRLENBQUNDLE9BQVNBLFNBQVM7SUFDM0I7Ozs7Ozs7O0tBUUMsR0FDREM7UUFDSSxPQUFPO0lBQ1g7SUFDQTs7Ozs7Ozs7S0FRQyxHQUNEQyxRQUFPLEVBQUVDLE1BQU0sRUFBRWxCLEtBQUssRUFBRW1CLE1BQU0sRUFBRTtRQUM1QixNQUFNQyxlQUFlLENBQUMsR0FBR3JCLFFBQVFHLFVBQVUsRUFBRUY7UUFDN0MsMkVBQTJFO1FBQzNFLDBDQUEwQztRQUMxQyxJQUFJbUIsUUFBUTtZQUNSLE9BQU8sQ0FBQyxHQUFHaEIsUUFBUWtCLFdBQVcsRUFBRTtnQkFBQ0g7Z0JBQVFFO2FBQWE7UUFDMUQ7UUFDQSxNQUFNRSxnQkFBZ0IsQ0FBQyxHQUFHaEIsUUFBUU0sUUFBUSxFQUFFUTtRQUM1QyxPQUFPLENBQUMsR0FBR2pCLFFBQVFrQixXQUFXLEVBQUU7WUFBQ0g7WUFBUUk7U0FBYztJQUMzRDtJQUNBOzs7Ozs7O0tBT0MsR0FDREMsUUFBTyxFQUFFdkIsS0FBSyxFQUFFO1FBQ1osT0FBTyxDQUFDLEdBQUdHLFFBQVFxQixLQUFLLEVBQUUsQ0FBQyxHQUFHckIsUUFBUXNCLFVBQVUsRUFBRXpCLE1BQU0wQixLQUFLLENBQUMsSUFBSTtJQUN0RTtBQUNKLEdBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvcGFyc2Vycy9hZGRyZXNzLmpzP2RjZWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZHJlc3MgPSBleHBvcnRzLmdldEFkZHJlc3MgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IHV0aWxzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG4vKipcbiAqIE5vcm1hbGl6ZSBhbiBhZGRyZXNzIHZhbHVlLiBUaGlzIGFjY2VwdHMgdGhlIGFkZHJlc3MgYXM6XG4gKlxuICogLSBBIGhleCBzdHJpbmcgc3RhcnRpbmcgd2l0aCB0aGUgYDB4YCBwcmVmaXguXG4gKiAtIEEgYnl0ZSBhcnJheSAoYFVpbnQ4QXJyYXlgIG9yIGBCdWZmZXJgKS5cbiAqXG4gKiBJdCBjaGVja3MgdGhhdCB0aGUgYWRkcmVzcyBpcyAyMCBieXRlcyBsb25nLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBub3JtYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCBhZGRyZXNzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuY29uc3QgZ2V0QWRkcmVzcyA9ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGJ5dGVzVmFsdWUgPSAoMCwgdXRpbHNfMS5jcmVhdGVCeXRlcykodmFsdWUpO1xuICAgICgwLCB1dGlsc18xLmFzc2VydCkoYnl0ZXNWYWx1ZS5sZW5ndGggPD0gMjAsIG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgSW52YWxpZCBhZGRyZXNzIHZhbHVlLiBFeHBlY3RlZCBhZGRyZXNzIHRvIGJlIDIwIGJ5dGVzIGxvbmcsIGJ1dCByZWNlaXZlZCAke2J5dGVzVmFsdWUubGVuZ3RofSBieXRlcy5gKSk7XG4gICAgcmV0dXJuICgwLCB1dGlsc18yLnBhZFN0YXJ0KShieXRlc1ZhbHVlLCAyMCk7XG59O1xuZXhwb3J0cy5nZXRBZGRyZXNzID0gZ2V0QWRkcmVzcztcbmV4cG9ydHMuYWRkcmVzcyA9IHtcbiAgICBpc0R5bmFtaWM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEdldCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCBhZGRyZXNzIHR5cGUuIFNpbmNlIGBhZGRyZXNzYCBpcyBhIHNpbXBsZVxuICAgICAqIHR5cGUsIHRoaXMgaXMganVzdCBhIGNoZWNrIHRoYXQgdGhlIHZhbHVlIGlzIFwiYWRkcmVzc1wiLlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB0eXBlIGlzIGEgdmFsaWQgYWRkcmVzcyB0eXBlLlxuICAgICAqL1xuICAgIGlzVHlwZTogKHR5cGUpID0+IHR5cGUgPT09ICdhZGRyZXNzJyxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGUgbGVuZ3RoIG9mIGFuIGVuY29kZWQgYWRkcmVzcy4gU2luY2UgYGFkZHJlc3NgIGlzIGEgc2ltcGxlXG4gICAgICogdHlwZSwgdGhpcyBhbHdheXMgcmV0dXJucyAzMi5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBhY3R1YWwgYWRkcmVzc2VzIGFyZSBvbmx5IDIwIGJ5dGVzIGxvbmcsIGJ1dCB0aGUgZW5jb2Rpbmcgb2ZcbiAgICAgKiB0aGUgYGFkZHJlc3NgIHR5cGUgaXMgYWx3YXlzIDMyIGJ5dGVzIGxvbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYnl0ZSBsZW5ndGggb2YgYW4gZW5jb2RlZCBhZGRyZXNzLlxuICAgICAqL1xuICAgIGdldEJ5dGVMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiAzMjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuY29kZSB0aGUgZ2l2ZW4gYWRkcmVzcyB0byBhIDMyLWJ5dGUtbG9uZyBieXRlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZW5jb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBhcmdzLmJ1ZmZlciAtIFRoZSBieXRlIGFycmF5IHRvIGFkZCB0by5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSBhZGRyZXNzIHRvIGVuY29kZS5cbiAgICAgKiBAcGFyYW0gYXJncy5wYWNrZWQgLSBXaGV0aGVyIHRvIHVzZSBwYWNrZWQgZW5jb2RpbmcuXG4gICAgICogQHJldHVybnMgVGhlIGJ5dGVzIHdpdGggdGhlIGVuY29kZWQgYWRkcmVzcyBhZGRlZCB0byBpdC5cbiAgICAgKi9cbiAgICBlbmNvZGUoeyBidWZmZXIsIHZhbHVlLCBwYWNrZWQgfSkge1xuICAgICAgICBjb25zdCBhZGRyZXNzVmFsdWUgPSAoMCwgZXhwb3J0cy5nZXRBZGRyZXNzKSh2YWx1ZSk7XG4gICAgICAgIC8vIElmIHdlJ3JlIHVzaW5nIHBhY2tlZCBlbmNvZGluZywgd2UgY2FuIGp1c3QgYWRkIHRoZSBhZGRyZXNzIGJ5dGVzIHRvIHRoZVxuICAgICAgICAvLyBieXRlIGFycmF5LCB3aXRob3V0IGFkZGluZyBhbnkgcGFkZGluZy5cbiAgICAgICAgaWYgKHBhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbYnVmZmVyLCBhZGRyZXNzVmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzQnVmZmVyID0gKDAsIHV0aWxzXzIucGFkU3RhcnQpKGFkZHJlc3NWYWx1ZSk7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoW2J1ZmZlciwgYWRkcmVzc0J1ZmZlcl0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGVjb2RlIHRoZSBnaXZlbiBieXRlIGFycmF5IHRvIGFuIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBkZWNvZGluZyBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIGFyZ3MudmFsdWUgLSBUaGUgYnl0ZSBhcnJheSB0byBkZWNvZGUuXG4gICAgICogQHJldHVybnMgVGhlIGRlY29kZWQgYWRkcmVzcyBhcyBhIGhleGFkZWNpbWFsIHN0cmluZywgc3RhcnRpbmcgd2l0aCB0aGVcbiAgICAgKiBcIjB4XCItcHJlZml4LlxuICAgICAqL1xuICAgIGRlY29kZSh7IHZhbHVlIH0pIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmFkZDB4KSgoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KSh2YWx1ZS5zbGljZSgxMiwgMzIpKSk7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFkZHJlc3MiLCJnZXRBZGRyZXNzIiwidXRpbHNfMSIsInJlcXVpcmUiLCJlcnJvcnNfMSIsInV0aWxzXzIiLCJieXRlc1ZhbHVlIiwiY3JlYXRlQnl0ZXMiLCJhc3NlcnQiLCJsZW5ndGgiLCJQYXJzZXJFcnJvciIsInBhZFN0YXJ0IiwiaXNEeW5hbWljIiwiaXNUeXBlIiwidHlwZSIsImdldEJ5dGVMZW5ndGgiLCJlbmNvZGUiLCJidWZmZXIiLCJwYWNrZWQiLCJhZGRyZXNzVmFsdWUiLCJjb25jYXRCeXRlcyIsImFkZHJlc3NCdWZmZXIiLCJkZWNvZGUiLCJhZGQweCIsImJ5dGVzVG9IZXgiLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/array.js":
/*!****************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/array.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.array = exports.getTupleType = exports.getArrayType = exports.isArrayType = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/utils/dist/index.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\");\nconst packer_1 = __webpack_require__(/*! ../packer */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/packer.js\");\nconst utils_2 = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/utils/index.js\");\nconst fixed_bytes_1 = __webpack_require__(/*! ./fixed-bytes */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js\");\nconst tuple_1 = __webpack_require__(/*! ./tuple */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/tuple.js\");\nconst ARRAY_REGEX = /^(?<type>.*)\\[(?<length>\\d*?)\\]$/u;\nconst isArrayType = (type)=>ARRAY_REGEX.test(type);\nexports.isArrayType = isArrayType;\n/**\n * Get the type of the array.\n *\n * @param type - The type to get the array type for.\n * @returns The array type.\n */ const getArrayType = (type)=>{\n    const match = type.match(ARRAY_REGEX);\n    (0, utils_1.assert)(match?.groups?.type, new errors_1.ParserError(`Invalid array type. Expected an array type, but received \"${type}\".`));\n    return [\n        match.groups.type,\n        match.groups.length ? parseInt(match.groups.length, 10) : undefined\n    ];\n};\nexports.getArrayType = getArrayType;\n/**\n * Get the type of the array as a tuple type. This is used for encoding fixed\n * length arrays, which are encoded as tuples.\n *\n * @param innerType - The type of the array.\n * @param length - The length of the array.\n * @returns The tuple type.\n */ const getTupleType = (innerType, length)=>{\n    return `(${new Array(length).fill(innerType).join(\",\")})`;\n};\nexports.getTupleType = getTupleType;\nexports.array = {\n    /**\n     * Check if the array is dynamic. Arrays are dynamic if the array does not\n     * have a fixed length, or if the array type is dynamic.\n     *\n     * @param type - The type to check.\n     * @returns Whether the array is dynamic.\n     */ isDynamic (type) {\n        const [innerType, length] = (0, exports.getArrayType)(type);\n        return(// `T[]` is dynamic for any `T`. `T[k]` is dynamic for any dynamic `T` and\n        // any `k >= 0`.\n        length === undefined || (0, packer_1.isDynamicParser)((0, packer_1.getParser)(innerType), innerType));\n    },\n    /**\n     * Check if a type is an array type.\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is an array type.\n     */ isType (type) {\n        return (0, exports.isArrayType)(type);\n    },\n    /**\n     * Get the byte length of an encoded array. If the array is dynamic, this\n     * returns 32, i.e., the length of the pointer to the array. If the array is\n     * static, this returns the byte length of the resulting tuple type.\n     *\n     * @param type - The type to get the byte length for.\n     * @returns The byte length of an encoded array.\n     */ getByteLength (type) {\n        (0, utils_1.assert)((0, exports.isArrayType)(type), new errors_1.ParserError(`Expected an array type, but received \"${type}\".`));\n        const [innerType, length] = (0, exports.getArrayType)(type);\n        if (!(0, packer_1.isDynamicParser)(this, type) && length !== undefined) {\n            return tuple_1.tuple.getByteLength((0, exports.getTupleType)(innerType, length));\n        }\n        return 32;\n    },\n    /**\n     * Encode the given array to a byte array. If the array is static, this uses\n     * the tuple encoder.\n     *\n     * @param args - The encoding arguments.\n     * @param args.type - The type of the array.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The array to encode.\n     * @param args.packed - Whether to use non-standard packed encoding.\n     * @param args.tight - Whether to use non-standard tight encoding.\n     * @returns The bytes with the encoded array added to it.\n     */ encode ({ type, buffer, value, packed, tight }) {\n        const [arrayType, fixedLength] = (0, exports.getArrayType)(type);\n        // Packed encoding does not support nested arrays.\n        (0, utils_1.assert)(!packed || !(0, exports.isArrayType)(arrayType), new errors_1.ParserError(`Cannot pack nested arrays.`));\n        // Tightly pack `T[]` where `T` is a dynamic type. This is not supported in\n        // Solidity, but is commonly used in the Ethereum ecosystem.\n        if (packed && (0, packer_1.isDynamicParser)((0, packer_1.getParser)(arrayType), arrayType)) {\n            return (0, packer_1.pack)({\n                types: new Array(value.length).fill(arrayType),\n                values: value,\n                byteArray: buffer,\n                packed,\n                arrayPacked: true,\n                tight\n            });\n        }\n        if (fixedLength) {\n            (0, utils_1.assert)(fixedLength === value.length, new errors_1.ParserError(`Array length does not match type length. Expected a length of ${fixedLength}, but received ${value.length}.`));\n            // `T[k]` for any `T` and `k` is encoded as `(T[0], ..., T[k - 1])`.\n            return tuple_1.tuple.encode({\n                type: (0, exports.getTupleType)(arrayType, fixedLength),\n                buffer,\n                value,\n                // In \"tight\" mode, we don't pad the values to 32 bytes if the value is\n                // of type `bytesN`. This is an edge case in `ethereumjs-abi` that we\n                // support to provide compatibility with it.\n                packed: fixed_bytes_1.fixedBytes.isType(arrayType) && tight,\n                tight\n            });\n        }\n        // For packed encoding, we don't need to encode the length of the array,\n        // so we can just encode the values.\n        if (packed) {\n            return (0, packer_1.pack)({\n                types: new Array(value.length).fill(arrayType),\n                values: value,\n                byteArray: buffer,\n                // In \"tight\" mode, we don't pad the values to 32 bytes if the value is\n                // of type `bytesN`. This is an edge case in `ethereumjs-abi` that we\n                // support to provide compatibility with it.\n                packed: fixed_bytes_1.fixedBytes.isType(arrayType) && tight,\n                arrayPacked: true,\n                tight\n            });\n        }\n        // `T[]` with `k` elements is encoded as `k (T[0], ..., T[k - 1])`. That\n        // means that we just need to encode the length of the array, and then the\n        // array itself. The pointer is encoded by the {@link pack} function.\n        const arrayLength = (0, utils_2.padStart)((0, utils_1.numberToBytes)(value.length));\n        return (0, packer_1.pack)({\n            types: new Array(value.length).fill(arrayType),\n            values: value,\n            byteArray: (0, utils_1.concatBytes)([\n                buffer,\n                arrayLength\n            ]),\n            packed,\n            tight\n        });\n    },\n    /**\n     * Decode an array from the given byte array.\n     *\n     * @param args - The decoding arguments.\n     * @param args.type - The type of the array.\n     * @param args.value - The byte array to decode.\n     * @returns The decoded array.\n     */ decode ({ type, value, ...rest }) {\n        const [arrayType, fixedLength] = (0, exports.getArrayType)(type);\n        if (fixedLength) {\n            const result = tuple_1.tuple.decode({\n                type: (0, exports.getTupleType)(arrayType, fixedLength),\n                value,\n                ...rest\n            });\n            (0, utils_1.assert)(result.length === fixedLength, new errors_1.ParserError(`Array length does not match type length. Expected a length of ${fixedLength}, but received ${result.length}.`));\n            return result;\n        }\n        const arrayLength = (0, utils_1.bytesToNumber)(value.subarray(0, 32));\n        return (0, packer_1.unpack)(new Array(arrayLength).fill(arrayType), value.subarray(32));\n    }\n}; //# sourceMappingURL=array.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvYXJyYXkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGFBQWEsR0FBR0Esb0JBQW9CLEdBQUdBLG9CQUFvQixHQUFHQSxtQkFBbUIsR0FBRyxLQUFLO0FBQ3pGLE1BQU1NLFVBQVVDLG1CQUFPQSxDQUFDLDJFQUFpQjtBQUN6QyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQywwRUFBVztBQUNwQyxNQUFNRSxXQUFXRixtQkFBT0EsQ0FBQywwRUFBVztBQUNwQyxNQUFNRyxVQUFVSCxtQkFBT0EsQ0FBQyw4RUFBVTtBQUNsQyxNQUFNSSxnQkFBZ0JKLG1CQUFPQSxDQUFDLDJGQUFlO0FBQzdDLE1BQU1LLFVBQVVMLG1CQUFPQSxDQUFDLCtFQUFTO0FBQ2pDLE1BQU1NLGNBQWM7QUFDcEIsTUFBTVIsY0FBYyxDQUFDUyxPQUFTRCxZQUFZRSxJQUFJLENBQUNEO0FBQy9DZCxtQkFBbUIsR0FBR0s7QUFDdEI7Ozs7O0NBS0MsR0FDRCxNQUFNRCxlQUFlLENBQUNVO0lBQ2xCLE1BQU1FLFFBQVFGLEtBQUtFLEtBQUssQ0FBQ0g7SUFDeEIsSUFBR1AsUUFBUVcsTUFBTSxFQUFFRCxPQUFPRSxRQUFRSixNQUFNLElBQUlOLFNBQVNXLFdBQVcsQ0FBQyxDQUFDLDBEQUEwRCxFQUFFTCxLQUFLLEVBQUUsQ0FBQztJQUN2SSxPQUFPO1FBQ0hFLE1BQU1FLE1BQU0sQ0FBQ0osSUFBSTtRQUNqQkUsTUFBTUUsTUFBTSxDQUFDRSxNQUFNLEdBQUdDLFNBQVNMLE1BQU1FLE1BQU0sQ0FBQ0UsTUFBTSxFQUFFLE1BQU1FO0tBQzdEO0FBQ0w7QUFDQXRCLG9CQUFvQixHQUFHSTtBQUN2Qjs7Ozs7OztDQU9DLEdBQ0QsTUFBTUQsZUFBZSxDQUFDb0IsV0FBV0g7SUFDN0IsT0FBTyxDQUFDLENBQUMsRUFBRSxJQUFJSSxN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QWUsRUFBRWEsT0FBTy9CLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFDMUwsT0FBTytCO1FBQ1g7UUFDQSxNQUFNTixjQUFjLENBQUMsR0FBR3ZDLFFBQVE4QyxhQUFhLEVBQUVuRCxNQUFNb0QsUUFBUSxDQUFDLEdBQUc7UUFDakUsT0FBTyxDQUFDLEdBQUc1QyxTQUFTNkMsTUFBTSxFQUFFLElBQUk5QixNQUFNcUIsYUFBYXBCLElBQUksQ0FBQ1ksWUFBWXBDLE1BQU1vRCxRQUFRLENBQUM7SUFDdkY7QUFDSixHQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvYXJyYXkuanM/YjVmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXJyYXkgPSBleHBvcnRzLmdldFR1cGxlVHlwZSA9IGV4cG9ydHMuZ2V0QXJyYXlUeXBlID0gZXhwb3J0cy5pc0FycmF5VHlwZSA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgcGFja2VyXzEgPSByZXF1aXJlKFwiLi4vcGFja2VyXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IGZpeGVkX2J5dGVzXzEgPSByZXF1aXJlKFwiLi9maXhlZC1ieXRlc1wiKTtcbmNvbnN0IHR1cGxlXzEgPSByZXF1aXJlKFwiLi90dXBsZVwiKTtcbmNvbnN0IEFSUkFZX1JFR0VYID0gL14oPzx0eXBlPi4qKVxcWyg/PGxlbmd0aD5cXGQqPylcXF0kL3U7XG5jb25zdCBpc0FycmF5VHlwZSA9ICh0eXBlKSA9PiBBUlJBWV9SRUdFWC50ZXN0KHR5cGUpO1xuZXhwb3J0cy5pc0FycmF5VHlwZSA9IGlzQXJyYXlUeXBlO1xuLyoqXG4gKiBHZXQgdGhlIHR5cGUgb2YgdGhlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgdG8gZ2V0IHRoZSBhcnJheSB0eXBlIGZvci5cbiAqIEByZXR1cm5zIFRoZSBhcnJheSB0eXBlLlxuICovXG5jb25zdCBnZXRBcnJheVR5cGUgPSAodHlwZSkgPT4ge1xuICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaChBUlJBWV9SRUdFWCk7XG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KShtYXRjaD8uZ3JvdXBzPy50eXBlLCBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYEludmFsaWQgYXJyYXkgdHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgdHlwZSwgYnV0IHJlY2VpdmVkIFwiJHt0eXBlfVwiLmApKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBtYXRjaC5ncm91cHMudHlwZSxcbiAgICAgICAgbWF0Y2guZ3JvdXBzLmxlbmd0aCA/IHBhcnNlSW50KG1hdGNoLmdyb3Vwcy5sZW5ndGgsIDEwKSA6IHVuZGVmaW5lZCxcbiAgICBdO1xufTtcbmV4cG9ydHMuZ2V0QXJyYXlUeXBlID0gZ2V0QXJyYXlUeXBlO1xuLyoqXG4gKiBHZXQgdGhlIHR5cGUgb2YgdGhlIGFycmF5IGFzIGEgdHVwbGUgdHlwZS4gVGhpcyBpcyB1c2VkIGZvciBlbmNvZGluZyBmaXhlZFxuICogbGVuZ3RoIGFycmF5cywgd2hpY2ggYXJlIGVuY29kZWQgYXMgdHVwbGVzLlxuICpcbiAqIEBwYXJhbSBpbm5lclR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgYXJyYXkuXG4gKiBAcGFyYW0gbGVuZ3RoIC0gVGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKiBAcmV0dXJucyBUaGUgdHVwbGUgdHlwZS5cbiAqL1xuY29uc3QgZ2V0VHVwbGVUeXBlID0gKGlubmVyVHlwZSwgbGVuZ3RoKSA9PiB7XG4gICAgcmV0dXJuIGAoJHtuZXcgQXJyYXkobGVuZ3RoKS5maWxsKGlubmVyVHlwZSkuam9pbignLCcpfSlgO1xufTtcbmV4cG9ydHMuZ2V0VHVwbGVUeXBlID0gZ2V0VHVwbGVUeXBlO1xuZXhwb3J0cy5hcnJheSA9IHtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgYXJyYXkgaXMgZHluYW1pYy4gQXJyYXlzIGFyZSBkeW5hbWljIGlmIHRoZSBhcnJheSBkb2VzIG5vdFxuICAgICAqIGhhdmUgYSBmaXhlZCBsZW5ndGgsIG9yIGlmIHRoZSBhcnJheSB0eXBlIGlzIGR5bmFtaWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGFycmF5IGlzIGR5bmFtaWMuXG4gICAgICovXG4gICAgaXNEeW5hbWljKHR5cGUpIHtcbiAgICAgICAgY29uc3QgW2lubmVyVHlwZSwgbGVuZ3RoXSA9ICgwLCBleHBvcnRzLmdldEFycmF5VHlwZSkodHlwZSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgIC8vIGBUW11gIGlzIGR5bmFtaWMgZm9yIGFueSBgVGAuIGBUW2tdYCBpcyBkeW5hbWljIGZvciBhbnkgZHluYW1pYyBgVGAgYW5kXG4gICAgICAgIC8vIGFueSBgayA+PSAwYC5cbiAgICAgICAgbGVuZ3RoID09PSB1bmRlZmluZWQgfHwgKDAsIHBhY2tlcl8xLmlzRHluYW1pY1BhcnNlcikoKDAsIHBhY2tlcl8xLmdldFBhcnNlcikoaW5uZXJUeXBlKSwgaW5uZXJUeXBlKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHR5cGUgaXMgYW4gYXJyYXkgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgdHlwZSBpcyBhbiBhcnJheSB0eXBlLlxuICAgICAqL1xuICAgIGlzVHlwZSh0eXBlKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5pc0FycmF5VHlwZSkodHlwZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGUgbGVuZ3RoIG9mIGFuIGVuY29kZWQgYXJyYXkuIElmIHRoZSBhcnJheSBpcyBkeW5hbWljLCB0aGlzXG4gICAgICogcmV0dXJucyAzMiwgaS5lLiwgdGhlIGxlbmd0aCBvZiB0aGUgcG9pbnRlciB0byB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBpc1xuICAgICAqIHN0YXRpYywgdGhpcyByZXR1cm5zIHRoZSBieXRlIGxlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHR1cGxlIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGdldCB0aGUgYnl0ZSBsZW5ndGggZm9yLlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlIGxlbmd0aCBvZiBhbiBlbmNvZGVkIGFycmF5LlxuICAgICAqL1xuICAgIGdldEJ5dGVMZW5ndGgodHlwZSkge1xuICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKCgwLCBleHBvcnRzLmlzQXJyYXlUeXBlKSh0eXBlKSwgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBFeHBlY3RlZCBhbiBhcnJheSB0eXBlLCBidXQgcmVjZWl2ZWQgXCIke3R5cGV9XCIuYCkpO1xuICAgICAgICBjb25zdCBbaW5uZXJUeXBlLCBsZW5ndGhdID0gKDAsIGV4cG9ydHMuZ2V0QXJyYXlUeXBlKSh0eXBlKTtcbiAgICAgICAgaWYgKCEoMCwgcGFja2VyXzEuaXNEeW5hbWljUGFyc2VyKSh0aGlzLCB0eXBlKSAmJiBsZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHR1cGxlXzEudHVwbGUuZ2V0Qnl0ZUxlbmd0aCgoMCwgZXhwb3J0cy5nZXRUdXBsZVR5cGUpKGlubmVyVHlwZSwgbGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDMyO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRW5jb2RlIHRoZSBnaXZlbiBhcnJheSB0byBhIGJ5dGUgYXJyYXkuIElmIHRoZSBhcnJheSBpcyBzdGF0aWMsIHRoaXMgdXNlc1xuICAgICAqIHRoZSB0dXBsZSBlbmNvZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZW5jb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBhcmdzLnR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgYXJyYXkuXG4gICAgICogQHBhcmFtIGFyZ3MuYnVmZmVyIC0gVGhlIGJ5dGUgYXJyYXkgdG8gYWRkIHRvLlxuICAgICAqIEBwYXJhbSBhcmdzLnZhbHVlIC0gVGhlIGFycmF5IHRvIGVuY29kZS5cbiAgICAgKiBAcGFyYW0gYXJncy5wYWNrZWQgLSBXaGV0aGVyIHRvIHVzZSBub24tc3RhbmRhcmQgcGFja2VkIGVuY29kaW5nLlxuICAgICAqIEBwYXJhbSBhcmdzLnRpZ2h0IC0gV2hldGhlciB0byB1c2Ugbm9uLXN0YW5kYXJkIHRpZ2h0IGVuY29kaW5nLlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlcyB3aXRoIHRoZSBlbmNvZGVkIGFycmF5IGFkZGVkIHRvIGl0LlxuICAgICAqL1xuICAgIGVuY29kZSh7IHR5cGUsIGJ1ZmZlciwgdmFsdWUsIHBhY2tlZCwgdGlnaHQgfSkge1xuICAgICAgICBjb25zdCBbYXJyYXlUeXBlLCBmaXhlZExlbmd0aF0gPSAoMCwgZXhwb3J0cy5nZXRBcnJheVR5cGUpKHR5cGUpO1xuICAgICAgICAvLyBQYWNrZWQgZW5jb2RpbmcgZG9lcyBub3Qgc3VwcG9ydCBuZXN0ZWQgYXJyYXlzLlxuICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKCFwYWNrZWQgfHwgISgwLCBleHBvcnRzLmlzQXJyYXlUeXBlKShhcnJheVR5cGUpLCBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYENhbm5vdCBwYWNrIG5lc3RlZCBhcnJheXMuYCkpO1xuICAgICAgICAvLyBUaWdodGx5IHBhY2sgYFRbXWAgd2hlcmUgYFRgIGlzIGEgZHluYW1pYyB0eXBlLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgaW5cbiAgICAgICAgLy8gU29saWRpdHksIGJ1dCBpcyBjb21tb25seSB1c2VkIGluIHRoZSBFdGhlcmV1bSBlY29zeXN0ZW0uXG4gICAgICAgIGlmIChwYWNrZWQgJiYgKDAsIHBhY2tlcl8xLmlzRHluYW1pY1BhcnNlcikoKDAsIHBhY2tlcl8xLmdldFBhcnNlcikoYXJyYXlUeXBlKSwgYXJyYXlUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBwYWNrZXJfMS5wYWNrKSh7XG4gICAgICAgICAgICAgICAgdHlwZXM6IG5ldyBBcnJheSh2YWx1ZS5sZW5ndGgpLmZpbGwoYXJyYXlUeXBlKSxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGJ5dGVBcnJheTogYnVmZmVyLFxuICAgICAgICAgICAgICAgIHBhY2tlZCxcbiAgICAgICAgICAgICAgICBhcnJheVBhY2tlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0aWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXhlZExlbmd0aCkge1xuICAgICAgICAgICAgKDAsIHV0aWxzXzEuYXNzZXJ0KShmaXhlZExlbmd0aCA9PT0gdmFsdWUubGVuZ3RoLCBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYEFycmF5IGxlbmd0aCBkb2VzIG5vdCBtYXRjaCB0eXBlIGxlbmd0aC4gRXhwZWN0ZWQgYSBsZW5ndGggb2YgJHtmaXhlZExlbmd0aH0sIGJ1dCByZWNlaXZlZCAke3ZhbHVlLmxlbmd0aH0uYCkpO1xuICAgICAgICAgICAgLy8gYFRba11gIGZvciBhbnkgYFRgIGFuZCBga2AgaXMgZW5jb2RlZCBhcyBgKFRbMF0sIC4uLiwgVFtrIC0gMV0pYC5cbiAgICAgICAgICAgIHJldHVybiB0dXBsZV8xLnR1cGxlLmVuY29kZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogKDAsIGV4cG9ydHMuZ2V0VHVwbGVUeXBlKShhcnJheVR5cGUsIGZpeGVkTGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgLy8gSW4gXCJ0aWdodFwiIG1vZGUsIHdlIGRvbid0IHBhZCB0aGUgdmFsdWVzIHRvIDMyIGJ5dGVzIGlmIHRoZSB2YWx1ZSBpc1xuICAgICAgICAgICAgICAgIC8vIG9mIHR5cGUgYGJ5dGVzTmAuIFRoaXMgaXMgYW4gZWRnZSBjYXNlIGluIGBldGhlcmV1bWpzLWFiaWAgdGhhdCB3ZVxuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgdG8gcHJvdmlkZSBjb21wYXRpYmlsaXR5IHdpdGggaXQuXG4gICAgICAgICAgICAgICAgcGFja2VkOiBmaXhlZF9ieXRlc18xLmZpeGVkQnl0ZXMuaXNUeXBlKGFycmF5VHlwZSkgJiYgdGlnaHQsXG4gICAgICAgICAgICAgICAgdGlnaHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgcGFja2VkIGVuY29kaW5nLCB3ZSBkb24ndCBuZWVkIHRvIGVuY29kZSB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSxcbiAgICAgICAgLy8gc28gd2UgY2FuIGp1c3QgZW5jb2RlIHRoZSB2YWx1ZXMuXG4gICAgICAgIGlmIChwYWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgcGFja2VyXzEucGFjaykoe1xuICAgICAgICAgICAgICAgIHR5cGVzOiBuZXcgQXJyYXkodmFsdWUubGVuZ3RoKS5maWxsKGFycmF5VHlwZSksXG4gICAgICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBieXRlQXJyYXk6IGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAvLyBJbiBcInRpZ2h0XCIgbW9kZSwgd2UgZG9uJ3QgcGFkIHRoZSB2YWx1ZXMgdG8gMzIgYnl0ZXMgaWYgdGhlIHZhbHVlIGlzXG4gICAgICAgICAgICAgICAgLy8gb2YgdHlwZSBgYnl0ZXNOYC4gVGhpcyBpcyBhbiBlZGdlIGNhc2UgaW4gYGV0aGVyZXVtanMtYWJpYCB0aGF0IHdlXG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydCB0byBwcm92aWRlIGNvbXBhdGliaWxpdHkgd2l0aCBpdC5cbiAgICAgICAgICAgICAgICBwYWNrZWQ6IGZpeGVkX2J5dGVzXzEuZml4ZWRCeXRlcy5pc1R5cGUoYXJyYXlUeXBlKSAmJiB0aWdodCxcbiAgICAgICAgICAgICAgICBhcnJheVBhY2tlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0aWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGBUW11gIHdpdGggYGtgIGVsZW1lbnRzIGlzIGVuY29kZWQgYXMgYGsgKFRbMF0sIC4uLiwgVFtrIC0gMV0pYC4gVGhhdFxuICAgICAgICAvLyBtZWFucyB0aGF0IHdlIGp1c3QgbmVlZCB0byBlbmNvZGUgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXksIGFuZCB0aGVuIHRoZVxuICAgICAgICAvLyBhcnJheSBpdHNlbGYuIFRoZSBwb2ludGVyIGlzIGVuY29kZWQgYnkgdGhlIHtAbGluayBwYWNrfSBmdW5jdGlvbi5cbiAgICAgICAgY29uc3QgYXJyYXlMZW5ndGggPSAoMCwgdXRpbHNfMi5wYWRTdGFydCkoKDAsIHV0aWxzXzEubnVtYmVyVG9CeXRlcykodmFsdWUubGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiAoMCwgcGFja2VyXzEucGFjaykoe1xuICAgICAgICAgICAgdHlwZXM6IG5ldyBBcnJheSh2YWx1ZS5sZW5ndGgpLmZpbGwoYXJyYXlUeXBlKSxcbiAgICAgICAgICAgIHZhbHVlczogdmFsdWUsXG4gICAgICAgICAgICBieXRlQXJyYXk6ICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbYnVmZmVyLCBhcnJheUxlbmd0aF0pLFxuICAgICAgICAgICAgcGFja2VkLFxuICAgICAgICAgICAgdGlnaHQsXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGVjb2RlIGFuIGFycmF5IGZyb20gdGhlIGdpdmVuIGJ5dGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBkZWNvZGluZyBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIGFyZ3MudHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBhcnJheS5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSBieXRlIGFycmF5IHRvIGRlY29kZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBhcnJheS5cbiAgICAgKi9cbiAgICBkZWNvZGUoeyB0eXBlLCB2YWx1ZSwgLi4ucmVzdCB9KSB7XG4gICAgICAgIGNvbnN0IFthcnJheVR5cGUsIGZpeGVkTGVuZ3RoXSA9ICgwLCBleHBvcnRzLmdldEFycmF5VHlwZSkodHlwZSk7XG4gICAgICAgIGlmIChmaXhlZExlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdHVwbGVfMS50dXBsZS5kZWNvZGUoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICgwLCBleHBvcnRzLmdldFR1cGxlVHlwZSkoYXJyYXlUeXBlLCBmaXhlZExlbmd0aCksXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKDAsIHV0aWxzXzEuYXNzZXJ0KShyZXN1bHQubGVuZ3RoID09PSBmaXhlZExlbmd0aCwgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBBcnJheSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggdHlwZSBsZW5ndGguIEV4cGVjdGVkIGEgbGVuZ3RoIG9mICR7Zml4ZWRMZW5ndGh9LCBidXQgcmVjZWl2ZWQgJHtyZXN1bHQubGVuZ3RofS5gKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFycmF5TGVuZ3RoID0gKDAsIHV0aWxzXzEuYnl0ZXNUb051bWJlcikodmFsdWUuc3ViYXJyYXkoMCwgMzIpKTtcbiAgICAgICAgcmV0dXJuICgwLCBwYWNrZXJfMS51bnBhY2spKG5ldyBBcnJheShhcnJheUxlbmd0aCkuZmlsbChhcnJheVR5cGUpLCB2YWx1ZS5zdWJhcnJheSgzMikpO1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXkuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYXJyYXkiLCJnZXRUdXBsZVR5cGUiLCJnZXRBcnJheVR5cGUiLCJpc0FycmF5VHlwZSIsInV0aWxzXzEiLCJyZXF1aXJlIiwiZXJyb3JzXzEiLCJwYWNrZXJfMSIsInV0aWxzXzIiLCJmaXhlZF9ieXRlc18xIiwidHVwbGVfMSIsIkFSUkFZX1JFR0VYIiwidHlwZSIsInRlc3QiLCJtYXRjaCIsImFzc2VydCIsImdyb3VwcyIsIlBhcnNlckVycm9yIiwibGVuZ3RoIiwicGFyc2VJbnQiLCJ1bmRlZmluZWQiLCJpbm5lclR5cGUiLCJBcnJheSIsImZpbGwiLCJqb2luIiwiaXNEeW5hbWljIiwiaXNEeW5hbWljUGFyc2VyIiwiZ2V0UGFyc2VyIiwiaXNUeXBlIiwiZ2V0Qnl0ZUxlbmd0aCIsInR1cGxlIiwiZW5jb2RlIiwiYnVmZmVyIiwicGFja2VkIiwidGlnaHQiLCJhcnJheVR5cGUiLCJmaXhlZExlbmd0aCIsInBhY2siLCJ0eXBlcyIsInZhbHVlcyIsImJ5dGVBcnJheSIsImFycmF5UGFja2VkIiwiZml4ZWRCeXRlcyIsImFycmF5TGVuZ3RoIiwicGFkU3RhcnQiLCJudW1iZXJUb0J5dGVzIiwiY29uY2F0Qnl0ZXMiLCJkZWNvZGUiLCJyZXN0IiwicmVzdWx0IiwiYnl0ZXNUb051bWJlciIsInN1YmFycmF5IiwidW5wYWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/array.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/bool.js":
/*!***************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/bool.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.bool = exports.getBooleanValue = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/utils/dist/index.js\");\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\");\nconst number_1 = __webpack_require__(/*! ./number */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/number.js\");\nconst BooleanCoercer = (0, superstruct_1.coerce)((0, superstruct_1.boolean)(), (0, superstruct_1.union)([\n    (0, superstruct_1.literal)(\"true\"),\n    (0, superstruct_1.literal)(\"false\")\n]), (value)=>value === \"true\");\n/**\n * Normalize a boolean value. This accepts the boolean as:\n *\n * - A boolean literal.\n * - The string \"true\" or \"false\".\n *\n * @param value - The value to get a boolean for.\n * @returns The parsed boolean value. This is `BigInt(1)` for truthy values, or\n * `BigInt(0)` for falsy values.\n */ const getBooleanValue = (value)=>{\n    try {\n        const booleanValue = (0, superstruct_1.create)(value, BooleanCoercer);\n        if (booleanValue) {\n            return BigInt(1);\n        }\n        return BigInt(0);\n    } catch  {\n        throw new errors_1.ParserError(`Invalid boolean value. Expected a boolean literal, or the string \"true\" or \"false\", but received \"${value}\".`);\n    }\n};\nexports.getBooleanValue = getBooleanValue;\nexports.bool = {\n    isDynamic: false,\n    /**\n     * Get if the given value is a valid boolean type. Since `bool` is a simple\n     * type, this is just a check that the value is \"bool\".\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a valid boolean type.\n     */ isType: (type)=>type === \"bool\",\n    /**\n     * Get the byte length of an encoded boolean. Since `bool` is a simple\n     * type, this always returns 32.\n     *\n     * Note that actual booleans are only 1 byte long, but the encoding of\n     * the `bool` type is always 32 bytes long.\n     *\n     * @returns The byte length of an encoded boolean.\n     */ getByteLength () {\n        return 32;\n    },\n    /**\n     * Encode the given boolean to a byte array.\n     *\n     * @param args - The encoding arguments.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The boolean to encode.\n     * @param args.packed - Whether the value is packed.\n     * @param args.tight - Whether to use non-standard tight encoding.\n     * @returns The bytes with the encoded boolean added to it.\n     */ encode ({ buffer, value, packed, tight }) {\n        const booleanValue = (0, exports.getBooleanValue)(value);\n        // For packed encoding, we add a single byte (`0x00` or `0x01`) to the byte\n        // array.\n        if (packed) {\n            return (0, utils_1.concatBytes)([\n                buffer,\n                (0, utils_1.bigIntToBytes)(booleanValue)\n            ]);\n        }\n        // Booleans are encoded as 32-byte integers, so we use the number parser\n        // to encode the boolean value.\n        return number_1.number.encode({\n            type: \"uint256\",\n            buffer,\n            value: booleanValue,\n            packed,\n            tight\n        });\n    },\n    /**\n     * Decode the given byte array to a boolean.\n     *\n     * @param args - The decoding arguments.\n     * @returns The decoded boolean.\n     */ decode (args) {\n        // Booleans are encoded as 32-byte integers, so we use the number parser\n        // to decode the boolean value.\n        return number_1.number.decode({\n            ...args,\n            type: \"uint256\"\n        }) === BigInt(1);\n    }\n}; //# sourceMappingURL=bool.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvYm9vbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsWUFBWSxHQUFHQSx1QkFBdUIsR0FBRyxLQUFLO0FBQzlDLE1BQU1JLFVBQVVDLG1CQUFPQSxDQUFDLDJFQUFpQjtBQUN6QyxNQUFNQyxnQkFBZ0JELG1CQUFPQSxDQUFDLG9FQUFhO0FBQzNDLE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ3BDLE1BQU1HLFdBQVdILG1CQUFPQSxDQUFDLGlGQUFVO0FBQ25DLE1BQU1JLGlCQUFpQixDQUFDLEdBQUdILGNBQWNJLE1BQU0sRUFBRSxDQUFDLEdBQUdKLGNBQWNLLE9BQU8sS0FBSyxDQUFDLEdBQUdMLGNBQWNNLEtBQUssRUFBRTtJQUFFLElBQUdOLGNBQWNPLE9BQU8sRUFBRTtJQUFVLElBQUdQLGNBQWNPLE9BQU8sRUFBRTtDQUFTLEdBQUcsQ0FBQ1osUUFBVUEsVUFBVTtBQUN6TTs7Ozs7Ozs7O0NBU0MsR0FDRCxNQUFNRSxrQkFBa0IsQ0FBQ0Y7SUFDckIsSUFBSTtRQUNBLE1BQU1hLGVBQWUsQ0FBQyxHQUFHUixjQUFjUyxNQUFNLEVBQUVkLE9BQU9RO1FBQ3RELElBQUlLLGNBQWM7WUFDZCxPQUFPRSxPQUFPO1FBQ2xCO1FBQ0EsT0FBT0EsT0FBTztJQUNsQixFQUNBLE9BQU07UUFDRixNQUFNLElBQUlULFNBQVNVLFdBQVcsQ0FBQyxDQUFDLGtHQUFrRyxFQUFFaEIsTUFBTSxFQUFFLENBQUM7SUFDako7QUFDSjtBQUNBRCx1QkFBdUIsR0FBR0c7QUFDMUJILFlBQVksR0FBRztJQUNYa0IsV0FBVztJQUNYOzs7Ozs7S0FNQyxHQUNEQyxRQUFRLENBQUNDLE9BQVNBLFNBQVM7SUFDM0I7Ozs7Ozs7O0tBUUMsR0FDREM7UUFDSSxPQUFPO0lBQ1g7SUFDQTs7Ozs7Ozs7O0tBU0MsR0FDREMsUUFBTyxFQUFFQyxNQUFNLEVBQUV0QixLQUFLLEVBQUV1QixNQUFNLEVBQUVDLEtBQUssRUFBRTtRQUNuQyxNQUFNWCxlQUFlLENBQUMsR0FBR2QsUUFBUUcsZUFBZSxFQUFFRjtRQUNsRCwyRUFBMkU7UUFDM0UsU0FBUztRQUNULElBQUl1QixRQUFRO1lBQ1IsT0FBTyxDQUFDLEdBQUdwQixRQUFRc0IsV0FBVyxFQUFFO2dCQUFDSDtnQkFBUyxJQUFHbkIsUUFBUXVCLGFBQWEsRUFBRWI7YUFBYztRQUN0RjtRQUNBLHdFQUF3RTtRQUN4RSwrQkFBK0I7UUFDL0IsT0FBT04sU0FBU29CLE1BQU0sQ0FBQ04sTUFBTSxDQUFDO1lBQzFCRixNQUFNO1lBQ05HO1lBQ0F0QixPQUFPYTtZQUNQVTtZQUNBQztRQUNKO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNESSxRQUFPQyxJQUFJO1FBQ1Asd0VBQXdFO1FBQ3hFLCtCQUErQjtRQUMvQixPQUFPdEIsU0FBU29CLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDO1lBQUUsR0FBR0MsSUFBSTtZQUFFVixNQUFNO1FBQVUsT0FBT0osT0FBTztJQUMzRTtBQUNKLEdBQ0EsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvcGFyc2Vycy9ib29sLmpzP2Y1ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJvb2wgPSBleHBvcnRzLmdldEJvb2xlYW5WYWx1ZSA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IG51bWJlcl8xID0gcmVxdWlyZShcIi4vbnVtYmVyXCIpO1xuY29uc3QgQm9vbGVhbkNvZXJjZXIgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5jb2VyY2UpKCgwLCBzdXBlcnN0cnVjdF8xLmJvb2xlYW4pKCksICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbKDAsIHN1cGVyc3RydWN0XzEubGl0ZXJhbCkoJ3RydWUnKSwgKDAsIHN1cGVyc3RydWN0XzEubGl0ZXJhbCkoJ2ZhbHNlJyldKSwgKHZhbHVlKSA9PiB2YWx1ZSA9PT0gJ3RydWUnKTtcbi8qKlxuICogTm9ybWFsaXplIGEgYm9vbGVhbiB2YWx1ZS4gVGhpcyBhY2NlcHRzIHRoZSBib29sZWFuIGFzOlxuICpcbiAqIC0gQSBib29sZWFuIGxpdGVyYWwuXG4gKiAtIFRoZSBzdHJpbmcgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBnZXQgYSBib29sZWFuIGZvci5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgYm9vbGVhbiB2YWx1ZS4gVGhpcyBpcyBgQmlnSW50KDEpYCBmb3IgdHJ1dGh5IHZhbHVlcywgb3JcbiAqIGBCaWdJbnQoMClgIGZvciBmYWxzeSB2YWx1ZXMuXG4gKi9cbmNvbnN0IGdldEJvb2xlYW5WYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJvb2xlYW5WYWx1ZSA9ICgwLCBzdXBlcnN0cnVjdF8xLmNyZWF0ZSkodmFsdWUsIEJvb2xlYW5Db2VyY2VyKTtcbiAgICAgICAgaWYgKGJvb2xlYW5WYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnSW50KDApO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgSW52YWxpZCBib29sZWFuIHZhbHVlLiBFeHBlY3RlZCBhIGJvb2xlYW4gbGl0ZXJhbCwgb3IgdGhlIHN0cmluZyBcInRydWVcIiBvciBcImZhbHNlXCIsIGJ1dCByZWNlaXZlZCBcIiR7dmFsdWV9XCIuYCk7XG4gICAgfVxufTtcbmV4cG9ydHMuZ2V0Qm9vbGVhblZhbHVlID0gZ2V0Qm9vbGVhblZhbHVlO1xuZXhwb3J0cy5ib29sID0ge1xuICAgIGlzRHluYW1pYzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogR2V0IGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIGJvb2xlYW4gdHlwZS4gU2luY2UgYGJvb2xgIGlzIGEgc2ltcGxlXG4gICAgICogdHlwZSwgdGhpcyBpcyBqdXN0IGEgY2hlY2sgdGhhdCB0aGUgdmFsdWUgaXMgXCJib29sXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHR5cGUgaXMgYSB2YWxpZCBib29sZWFuIHR5cGUuXG4gICAgICovXG4gICAgaXNUeXBlOiAodHlwZSkgPT4gdHlwZSA9PT0gJ2Jvb2wnLFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnl0ZSBsZW5ndGggb2YgYW4gZW5jb2RlZCBib29sZWFuLiBTaW5jZSBgYm9vbGAgaXMgYSBzaW1wbGVcbiAgICAgKiB0eXBlLCB0aGlzIGFsd2F5cyByZXR1cm5zIDMyLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGFjdHVhbCBib29sZWFucyBhcmUgb25seSAxIGJ5dGUgbG9uZywgYnV0IHRoZSBlbmNvZGluZyBvZlxuICAgICAqIHRoZSBgYm9vbGAgdHlwZSBpcyBhbHdheXMgMzIgYnl0ZXMgbG9uZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlIGxlbmd0aCBvZiBhbiBlbmNvZGVkIGJvb2xlYW4uXG4gICAgICovXG4gICAgZ2V0Qnl0ZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIDMyO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRW5jb2RlIHRoZSBnaXZlbiBib29sZWFuIHRvIGEgYnl0ZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGVuY29kaW5nIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0gYXJncy5idWZmZXIgLSBUaGUgYnl0ZSBhcnJheSB0byBhZGQgdG8uXG4gICAgICogQHBhcmFtIGFyZ3MudmFsdWUgLSBUaGUgYm9vbGVhbiB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIGFyZ3MucGFja2VkIC0gV2hldGhlciB0aGUgdmFsdWUgaXMgcGFja2VkLlxuICAgICAqIEBwYXJhbSBhcmdzLnRpZ2h0IC0gV2hldGhlciB0byB1c2Ugbm9uLXN0YW5kYXJkIHRpZ2h0IGVuY29kaW5nLlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlcyB3aXRoIHRoZSBlbmNvZGVkIGJvb2xlYW4gYWRkZWQgdG8gaXQuXG4gICAgICovXG4gICAgZW5jb2RlKHsgYnVmZmVyLCB2YWx1ZSwgcGFja2VkLCB0aWdodCB9KSB7XG4gICAgICAgIGNvbnN0IGJvb2xlYW5WYWx1ZSA9ICgwLCBleHBvcnRzLmdldEJvb2xlYW5WYWx1ZSkodmFsdWUpO1xuICAgICAgICAvLyBGb3IgcGFja2VkIGVuY29kaW5nLCB3ZSBhZGQgYSBzaW5nbGUgYnl0ZSAoYDB4MDBgIG9yIGAweDAxYCkgdG8gdGhlIGJ5dGVcbiAgICAgICAgLy8gYXJyYXkuXG4gICAgICAgIGlmIChwYWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoW2J1ZmZlciwgKDAsIHV0aWxzXzEuYmlnSW50VG9CeXRlcykoYm9vbGVhblZhbHVlKV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJvb2xlYW5zIGFyZSBlbmNvZGVkIGFzIDMyLWJ5dGUgaW50ZWdlcnMsIHNvIHdlIHVzZSB0aGUgbnVtYmVyIHBhcnNlclxuICAgICAgICAvLyB0byBlbmNvZGUgdGhlIGJvb2xlYW4gdmFsdWUuXG4gICAgICAgIHJldHVybiBudW1iZXJfMS5udW1iZXIuZW5jb2RlKHtcbiAgICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgIHZhbHVlOiBib29sZWFuVmFsdWUsXG4gICAgICAgICAgICBwYWNrZWQsXG4gICAgICAgICAgICB0aWdodCxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZWNvZGUgdGhlIGdpdmVuIGJ5dGUgYXJyYXkgdG8gYSBib29sZWFuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZGVjb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIGJvb2xlYW4uXG4gICAgICovXG4gICAgZGVjb2RlKGFyZ3MpIHtcbiAgICAgICAgLy8gQm9vbGVhbnMgYXJlIGVuY29kZWQgYXMgMzItYnl0ZSBpbnRlZ2Vycywgc28gd2UgdXNlIHRoZSBudW1iZXIgcGFyc2VyXG4gICAgICAgIC8vIHRvIGRlY29kZSB0aGUgYm9vbGVhbiB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIG51bWJlcl8xLm51bWJlci5kZWNvZGUoeyAuLi5hcmdzLCB0eXBlOiAndWludDI1NicgfSkgPT09IEJpZ0ludCgxKTtcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb2wuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYm9vbCIsImdldEJvb2xlYW5WYWx1ZSIsInV0aWxzXzEiLCJyZXF1aXJlIiwic3VwZXJzdHJ1Y3RfMSIsImVycm9yc18xIiwibnVtYmVyXzEiLCJCb29sZWFuQ29lcmNlciIsImNvZXJjZSIsImJvb2xlYW4iLCJ1bmlvbiIsImxpdGVyYWwiLCJib29sZWFuVmFsdWUiLCJjcmVhdGUiLCJCaWdJbnQiLCJQYXJzZXJFcnJvciIsImlzRHluYW1pYyIsImlzVHlwZSIsInR5cGUiLCJnZXRCeXRlTGVuZ3RoIiwiZW5jb2RlIiwiYnVmZmVyIiwicGFja2VkIiwidGlnaHQiLCJjb25jYXRCeXRlcyIsImJpZ0ludFRvQnl0ZXMiLCJudW1iZXIiLCJkZWNvZGUiLCJhcmdzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/bool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/bytes.js":
/*!****************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/bytes.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.bytes = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/utils/dist/index.js\");\nconst utils_2 = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/utils/index.js\");\nexports.bytes = {\n    isDynamic: true,\n    /**\n     * Check if a type is a bytes type. Since `bytes` is a simple type, this is\n     * just a check that the type is \"bytes\".\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a bytes type.\n     */ isType: (type)=>type === \"bytes\",\n    /**\n     * Get the byte length of an encoded bytes value. Since `bytes` is a simple\n     * type, this always returns 32.\n     *\n     * Note that actual length of a bytes value is variable, but the encoded\n     * static value (pointer) is always 32 bytes long.\n     *\n     * @returns The byte length of an encoded bytes value.\n     */ getByteLength () {\n        return 32;\n    },\n    /**\n     * Encode the given bytes value to a byte array.\n     *\n     * @param args - The encoding arguments.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The bytes value to encode.\n     * @param args.packed - Whether to use packed encoding.\n     * @returns The bytes with the encoded bytes value added to it.\n     */ encode ({ buffer, value, packed }) {\n        const bufferValue = (0, utils_1.createBytes)(value);\n        // For packed encoding, we can just add the bytes value to the byte array,\n        // without adding any padding or alignment. There is also no need to\n        // encode the length of the bytes.\n        if (packed) {\n            return (0, utils_1.concatBytes)([\n                buffer,\n                bufferValue\n            ]);\n        }\n        const paddedSize = Math.ceil(bufferValue.byteLength / 32) * 32;\n        // Bytes of length `k` are encoded as `k pad_right(bytes)`.\n        return (0, utils_1.concatBytes)([\n            buffer,\n            (0, utils_2.padStart)((0, utils_1.numberToBytes)(bufferValue.byteLength)),\n            (0, utils_2.padEnd)(bufferValue, paddedSize)\n        ]);\n    },\n    /**\n     * Decode the given byte array to a bytes value.\n     *\n     * @param args - The decoding arguments.\n     * @param args.value - The byte array to decode.\n     * @returns The decoded bytes value as a `Uint8Array`.\n     */ decode ({ value }) {\n        const bytesValue = value.subarray(0, 32);\n        const length = (0, utils_1.bytesToNumber)(bytesValue);\n        // Since we're returning a `Uint8Array`, we use `slice` to copy the bytes\n        // into a new array.\n        return value.slice(32, 32 + length);\n    }\n}; //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvYnl0ZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGFBQWEsR0FBRyxLQUFLO0FBQ3JCLE1BQU1HLFVBQVVDLG1CQUFPQSxDQUFDLDJFQUFpQjtBQUN6QyxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQyw4RUFBVTtBQUNsQ0osYUFBYSxHQUFHO0lBQ1pNLFdBQVc7SUFDWDs7Ozs7O0tBTUMsR0FDREMsUUFBUSxDQUFDQyxPQUFTQSxTQUFTO0lBQzNCOzs7Ozs7OztLQVFDLEdBQ0RDO1FBQ0ksT0FBTztJQUNYO0lBQ0E7Ozs7Ozs7O0tBUUMsR0FDREMsUUFBTyxFQUFFQyxNQUFNLEVBQUVWLEtBQUssRUFBRVcsTUFBTSxFQUFFO1FBQzVCLE1BQU1DLGNBQWMsQ0FBQyxHQUFHVixRQUFRVyxXQUFXLEVBQUViO1FBQzdDLDBFQUEwRTtRQUMxRSxvRUFBb0U7UUFDcEUsa0NBQWtDO1FBQ2xDLElBQUlXLFFBQVE7WUFDUixPQUFPLENBQUMsR0FBR1QsUUFBUVksV0FBVyxFQUFFO2dCQUFDSjtnQkFBUUU7YUFBWTtRQUN6RDtRQUNBLE1BQU1HLGFBQWFDLEtBQUtDLElBQUksQ0FBQ0wsWUFBWU0sVUFBVSxHQUFHLE1BQU07UUFDNUQsMkRBQTJEO1FBQzNELE9BQU8sQ0FBQyxHQUFHaEIsUUFBUVksV0FBVyxFQUFFO1lBQzVCSjtZQUNDLElBQUdOLFFBQVFlLFFBQVEsRUFBRSxDQUFDLEdBQUdqQixRQUFRa0IsYUFBYSxFQUFFUixZQUFZTSxVQUFVO1lBQ3RFLElBQUdkLFFBQVFpQixNQUFNLEVBQUVULGFBQWFHO1NBQ3BDO0lBQ0w7SUFDQTs7Ozs7O0tBTUMsR0FDRE8sUUFBTyxFQUFFdEIsS0FBSyxFQUFFO1FBQ1osTUFBTXVCLGFBQWF2QixNQUFNd0IsUUFBUSxDQUFDLEdBQUc7UUFDckMsTUFBTUMsU0FBUyxDQUFDLEdBQUd2QixRQUFRd0IsYUFBYSxFQUFFSDtRQUMxQyx5RUFBeUU7UUFDekUsb0JBQW9CO1FBQ3BCLE9BQU92QixNQUFNMkIsS0FBSyxDQUFDLElBQUksS0FBS0Y7SUFDaEM7QUFDSixHQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvYnl0ZXMuanM/YzM3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnl0ZXMgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbmNvbnN0IHV0aWxzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5leHBvcnRzLmJ5dGVzID0ge1xuICAgIGlzRHluYW1pYzogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHR5cGUgaXMgYSBieXRlcyB0eXBlLiBTaW5jZSBgYnl0ZXNgIGlzIGEgc2ltcGxlIHR5cGUsIHRoaXMgaXNcbiAgICAgKiBqdXN0IGEgY2hlY2sgdGhhdCB0aGUgdHlwZSBpcyBcImJ5dGVzXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHR5cGUgaXMgYSBieXRlcyB0eXBlLlxuICAgICAqL1xuICAgIGlzVHlwZTogKHR5cGUpID0+IHR5cGUgPT09ICdieXRlcycsXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBieXRlIGxlbmd0aCBvZiBhbiBlbmNvZGVkIGJ5dGVzIHZhbHVlLiBTaW5jZSBgYnl0ZXNgIGlzIGEgc2ltcGxlXG4gICAgICogdHlwZSwgdGhpcyBhbHdheXMgcmV0dXJucyAzMi5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBhY3R1YWwgbGVuZ3RoIG9mIGEgYnl0ZXMgdmFsdWUgaXMgdmFyaWFibGUsIGJ1dCB0aGUgZW5jb2RlZFxuICAgICAqIHN0YXRpYyB2YWx1ZSAocG9pbnRlcikgaXMgYWx3YXlzIDMyIGJ5dGVzIGxvbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYnl0ZSBsZW5ndGggb2YgYW4gZW5jb2RlZCBieXRlcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRCeXRlTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gMzI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmNvZGUgdGhlIGdpdmVuIGJ5dGVzIHZhbHVlIHRvIGEgYnl0ZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGVuY29kaW5nIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0gYXJncy5idWZmZXIgLSBUaGUgYnl0ZSBhcnJheSB0byBhZGQgdG8uXG4gICAgICogQHBhcmFtIGFyZ3MudmFsdWUgLSBUaGUgYnl0ZXMgdmFsdWUgdG8gZW5jb2RlLlxuICAgICAqIEBwYXJhbSBhcmdzLnBhY2tlZCAtIFdoZXRoZXIgdG8gdXNlIHBhY2tlZCBlbmNvZGluZy5cbiAgICAgKiBAcmV0dXJucyBUaGUgYnl0ZXMgd2l0aCB0aGUgZW5jb2RlZCBieXRlcyB2YWx1ZSBhZGRlZCB0byBpdC5cbiAgICAgKi9cbiAgICBlbmNvZGUoeyBidWZmZXIsIHZhbHVlLCBwYWNrZWQgfSkge1xuICAgICAgICBjb25zdCBidWZmZXJWYWx1ZSA9ICgwLCB1dGlsc18xLmNyZWF0ZUJ5dGVzKSh2YWx1ZSk7XG4gICAgICAgIC8vIEZvciBwYWNrZWQgZW5jb2RpbmcsIHdlIGNhbiBqdXN0IGFkZCB0aGUgYnl0ZXMgdmFsdWUgdG8gdGhlIGJ5dGUgYXJyYXksXG4gICAgICAgIC8vIHdpdGhvdXQgYWRkaW5nIGFueSBwYWRkaW5nIG9yIGFsaWdubWVudC4gVGhlcmUgaXMgYWxzbyBubyBuZWVkIHRvXG4gICAgICAgIC8vIGVuY29kZSB0aGUgbGVuZ3RoIG9mIHRoZSBieXRlcy5cbiAgICAgICAgaWYgKHBhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbYnVmZmVyLCBidWZmZXJWYWx1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhZGRlZFNpemUgPSBNYXRoLmNlaWwoYnVmZmVyVmFsdWUuYnl0ZUxlbmd0aCAvIDMyKSAqIDMyO1xuICAgICAgICAvLyBCeXRlcyBvZiBsZW5ndGggYGtgIGFyZSBlbmNvZGVkIGFzIGBrIHBhZF9yaWdodChieXRlcylgLlxuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKFtcbiAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgICgwLCB1dGlsc18yLnBhZFN0YXJ0KSgoMCwgdXRpbHNfMS5udW1iZXJUb0J5dGVzKShidWZmZXJWYWx1ZS5ieXRlTGVuZ3RoKSksXG4gICAgICAgICAgICAoMCwgdXRpbHNfMi5wYWRFbmQpKGJ1ZmZlclZhbHVlLCBwYWRkZWRTaXplKSxcbiAgICAgICAgXSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZWNvZGUgdGhlIGdpdmVuIGJ5dGUgYXJyYXkgdG8gYSBieXRlcyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGRlY29kaW5nIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSBieXRlIGFycmF5IHRvIGRlY29kZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBieXRlcyB2YWx1ZSBhcyBhIGBVaW50OEFycmF5YC5cbiAgICAgKi9cbiAgICBkZWNvZGUoeyB2YWx1ZSB9KSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzVmFsdWUgPSB2YWx1ZS5zdWJhcnJheSgwLCAzMik7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9ICgwLCB1dGlsc18xLmJ5dGVzVG9OdW1iZXIpKGJ5dGVzVmFsdWUpO1xuICAgICAgICAvLyBTaW5jZSB3ZSdyZSByZXR1cm5pbmcgYSBgVWludDhBcnJheWAsIHdlIHVzZSBgc2xpY2VgIHRvIGNvcHkgdGhlIGJ5dGVzXG4gICAgICAgIC8vIGludG8gYSBuZXcgYXJyYXkuXG4gICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgzMiwgMzIgKyBsZW5ndGgpO1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYnl0ZXMiLCJ1dGlsc18xIiwicmVxdWlyZSIsInV0aWxzXzIiLCJpc0R5bmFtaWMiLCJpc1R5cGUiLCJ0eXBlIiwiZ2V0Qnl0ZUxlbmd0aCIsImVuY29kZSIsImJ1ZmZlciIsInBhY2tlZCIsImJ1ZmZlclZhbHVlIiwiY3JlYXRlQnl0ZXMiLCJjb25jYXRCeXRlcyIsInBhZGRlZFNpemUiLCJNYXRoIiwiY2VpbCIsImJ5dGVMZW5ndGgiLCJwYWRTdGFydCIsIm51bWJlclRvQnl0ZXMiLCJwYWRFbmQiLCJkZWNvZGUiLCJieXRlc1ZhbHVlIiwic3ViYXJyYXkiLCJsZW5ndGgiLCJieXRlc1RvTnVtYmVyIiwic2xpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.fixedBytes = exports.getByteLength = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/utils/dist/index.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\");\nconst utils_2 = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/utils/index.js\");\nconst BYTES_REGEX = /^bytes([0-9]{1,2})$/u;\n/**\n * Get the length of the specified type. If a length is not specified, or if the\n * length is out of range (0 < n <= 32), this will throw an error.\n *\n * @param type - The type to get the length for.\n * @returns The byte length of the type.\n */ const getByteLength = (type)=>{\n    const bytes = type.match(BYTES_REGEX)?.[1];\n    (0, utils_1.assert)(bytes, `Invalid byte length. Expected a number between 1 and 32, but received \"${type}\".`);\n    const length = Number(bytes);\n    (0, utils_1.assert)(length > 0 && length <= 32, new errors_1.ParserError(`Invalid byte length. Expected a number between 1 and 32, but received \"${type}\".`));\n    return length;\n};\nexports.getByteLength = getByteLength;\nexports.fixedBytes = {\n    isDynamic: false,\n    /**\n     * Check if a type is a fixed bytes type.\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a fixed bytes type.\n     */ isType (type) {\n        return BYTES_REGEX.test(type);\n    },\n    /**\n     * Get the byte length of an encoded fixed bytes type.\n     *\n     * @returns The byte length of the type.\n     */ getByteLength () {\n        return 32;\n    },\n    /**\n     * Encode a fixed bytes value.\n     *\n     * @param args - The arguments to encode.\n     * @param args.type - The type of the value.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The value to encode.\n     * @param args.packed - Whether to use packed encoding.\n     * @returns The bytes with the encoded value added to it.\n     */ encode ({ type, buffer, value, packed }) {\n        const length = (0, exports.getByteLength)(type);\n        const bufferValue = (0, utils_1.createBytes)(value);\n        (0, utils_1.assert)(bufferValue.length <= length, new errors_1.ParserError(`Expected a value of length ${length}, but received a value of length ${bufferValue.length}.`));\n        // For packed encoding, the value is padded to the length of the type, and\n        // then added to the byte array.\n        if (packed) {\n            return (0, utils_1.concatBytes)([\n                buffer,\n                (0, utils_2.padEnd)(bufferValue, length)\n            ]);\n        }\n        return (0, utils_1.concatBytes)([\n            buffer,\n            (0, utils_2.padEnd)(bufferValue)\n        ]);\n    },\n    /**\n     * Decode a fixed bytes value.\n     *\n     * @param args - The arguments to decode.\n     * @param args.type - The type of the value.\n     * @param args.value - The value to decode.\n     * @returns The decoded value as a `Uint8Array`.\n     */ decode ({ type, value }) {\n        const length = (0, exports.getByteLength)(type);\n        // Since we're returning a `Uint8Array`, we use `slice` to copy the bytes\n        // into a new array.\n        return value.slice(0, length);\n    }\n}; //# sourceMappingURL=fixed-bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvZml4ZWQtYnl0ZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtCQUFrQixHQUFHQSxxQkFBcUIsR0FBRyxLQUFLO0FBQ2xELE1BQU1JLFVBQVVDLG1CQUFPQSxDQUFDLDJFQUFpQjtBQUN6QyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQywwRUFBVztBQUNwQyxNQUFNRSxVQUFVRixtQkFBT0EsQ0FBQyw4RUFBVTtBQUNsQyxNQUFNRyxjQUFjO0FBQ3BCOzs7Ozs7Q0FNQyxHQUNELE1BQU1MLGdCQUFnQixDQUFDTTtJQUNuQixNQUFNQyxRQUFRRCxLQUFLRSxLQUFLLENBQUNILGNBQWMsQ0FBQyxFQUFFO0lBQ3pDLElBQUdKLFFBQVFRLE1BQU0sRUFBRUYsT0FBTyxDQUFDLHVFQUF1RSxFQUFFRCxLQUFLLEVBQUUsQ0FBQztJQUM3RyxNQUFNSSxTQUFTQyxPQUFPSjtJQUNyQixJQUFHTixRQUFRUSxNQUFNLEVBQUVDLFNBQVMsS0FBS0EsVUFBVSxJQUFJLElBQUlQLFNBQVNTLFdBQVcsQ0FBQyxDQUFDLHVFQUF1RSxFQUFFTixLQUFLLEVBQUUsQ0FBQztJQUMzSixPQUFPSTtBQUNYO0FBQ0FiLHFCQUFxQixHQUFHRztBQUN4Qkgsa0JBQWtCLEdBQUc7SUFDakJnQixXQUFXO0lBQ1g7Ozs7O0tBS0MsR0FDREMsUUFBT1IsSUFBSTtRQUNQLE9BQU9ELFlBQVlVLElBQUksQ0FBQ1Q7SUFDNUI7SUFDQTs7OztLQUlDLEdBQ0ROO1FBQ0ksT0FBTztJQUNYO0lBQ0E7Ozs7Ozs7OztLQVNDLEdBQ0RnQixRQUFPLEVBQUVWLElBQUksRUFBRVcsTUFBTSxFQUFFbkIsS0FBSyxFQUFFb0IsTUFBTSxFQUFFO1FBQ2xDLE1BQU1SLFNBQVMsQ0FBQyxHQUFHYixRQUFRRyxhQUFhLEVBQUVNO1FBQzFDLE1BQU1hLGNBQWMsQ0FBQyxHQUFHbEIsUUFBUW1CLFdBQVcsRUFBRXRCO1FBQzVDLElBQUdHLFFBQVFRLE1BQU0sRUFBRVUsWUFBWVQsTUFBTSxJQUFJQSxRQUFRLElBQUlQLFNBQVNTLFdBQVcsQ0FBQyxDQUFDLDJCQUEyQixFQUFFRixPQUFPLGlDQUFpQyxFQUFFUyxZQUFZVCxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ3hLLDBFQUEwRTtRQUMxRSxnQ0FBZ0M7UUFDaEMsSUFBSVEsUUFBUTtZQUNSLE9BQU8sQ0FBQyxHQUFHakIsUUFBUW9CLFdBQVcsRUFBRTtnQkFBQ0o7Z0JBQVMsSUFBR2IsUUFBUWtCLE1BQU0sRUFBRUgsYUFBYVQ7YUFBUTtRQUN0RjtRQUNBLE9BQU8sQ0FBQyxHQUFHVCxRQUFRb0IsV0FBVyxFQUFFO1lBQUNKO1lBQVMsSUFBR2IsUUFBUWtCLE1BQU0sRUFBRUg7U0FBYTtJQUM5RTtJQUNBOzs7Ozs7O0tBT0MsR0FDREksUUFBTyxFQUFFakIsSUFBSSxFQUFFUixLQUFLLEVBQUU7UUFDbEIsTUFBTVksU0FBUyxDQUFDLEdBQUdiLFFBQVFHLGFBQWEsRUFBRU07UUFDMUMseUVBQXlFO1FBQ3pFLG9CQUFvQjtRQUNwQixPQUFPUixNQUFNMEIsS0FBSyxDQUFDLEdBQUdkO0lBQzFCO0FBQ0osR0FDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC9wYXJzZXJzL2ZpeGVkLWJ5dGVzLmpzPzIyZjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZpeGVkQnl0ZXMgPSBleHBvcnRzLmdldEJ5dGVMZW5ndGggPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IHV0aWxzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBCWVRFU19SRUdFWCA9IC9eYnl0ZXMoWzAtOV17MSwyfSkkL3U7XG4vKipcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIHRoZSBzcGVjaWZpZWQgdHlwZS4gSWYgYSBsZW5ndGggaXMgbm90IHNwZWNpZmllZCwgb3IgaWYgdGhlXG4gKiBsZW5ndGggaXMgb3V0IG9mIHJhbmdlICgwIDwgbiA8PSAzMiksIHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGdldCB0aGUgbGVuZ3RoIGZvci5cbiAqIEByZXR1cm5zIFRoZSBieXRlIGxlbmd0aCBvZiB0aGUgdHlwZS5cbiAqL1xuY29uc3QgZ2V0Qnl0ZUxlbmd0aCA9ICh0eXBlKSA9PiB7XG4gICAgY29uc3QgYnl0ZXMgPSB0eXBlLm1hdGNoKEJZVEVTX1JFR0VYKT8uWzFdO1xuICAgICgwLCB1dGlsc18xLmFzc2VydCkoYnl0ZXMsIGBJbnZhbGlkIGJ5dGUgbGVuZ3RoLiBFeHBlY3RlZCBhIG51bWJlciBiZXR3ZWVuIDEgYW5kIDMyLCBidXQgcmVjZWl2ZWQgXCIke3R5cGV9XCIuYCk7XG4gICAgY29uc3QgbGVuZ3RoID0gTnVtYmVyKGJ5dGVzKTtcbiAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKGxlbmd0aCA+IDAgJiYgbGVuZ3RoIDw9IDMyLCBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYEludmFsaWQgYnl0ZSBsZW5ndGguIEV4cGVjdGVkIGEgbnVtYmVyIGJldHdlZW4gMSBhbmQgMzIsIGJ1dCByZWNlaXZlZCBcIiR7dHlwZX1cIi5gKSk7XG4gICAgcmV0dXJuIGxlbmd0aDtcbn07XG5leHBvcnRzLmdldEJ5dGVMZW5ndGggPSBnZXRCeXRlTGVuZ3RoO1xuZXhwb3J0cy5maXhlZEJ5dGVzID0ge1xuICAgIGlzRHluYW1pYzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB0eXBlIGlzIGEgZml4ZWQgYnl0ZXMgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgdHlwZSBpcyBhIGZpeGVkIGJ5dGVzIHR5cGUuXG4gICAgICovXG4gICAgaXNUeXBlKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIEJZVEVTX1JFR0VYLnRlc3QodHlwZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGUgbGVuZ3RoIG9mIGFuIGVuY29kZWQgZml4ZWQgYnl0ZXMgdHlwZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlIGxlbmd0aCBvZiB0aGUgdHlwZS5cbiAgICAgKi9cbiAgICBnZXRCeXRlTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gMzI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmNvZGUgYSBmaXhlZCBieXRlcyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIGFyZ3MudHlwZSAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gYXJncy5idWZmZXIgLSBUaGUgYnl0ZSBhcnJheSB0byBhZGQgdG8uXG4gICAgICogQHBhcmFtIGFyZ3MudmFsdWUgLSBUaGUgdmFsdWUgdG8gZW5jb2RlLlxuICAgICAqIEBwYXJhbSBhcmdzLnBhY2tlZCAtIFdoZXRoZXIgdG8gdXNlIHBhY2tlZCBlbmNvZGluZy5cbiAgICAgKiBAcmV0dXJucyBUaGUgYnl0ZXMgd2l0aCB0aGUgZW5jb2RlZCB2YWx1ZSBhZGRlZCB0byBpdC5cbiAgICAgKi9cbiAgICBlbmNvZGUoeyB0eXBlLCBidWZmZXIsIHZhbHVlLCBwYWNrZWQgfSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSAoMCwgZXhwb3J0cy5nZXRCeXRlTGVuZ3RoKSh0eXBlKTtcbiAgICAgICAgY29uc3QgYnVmZmVyVmFsdWUgPSAoMCwgdXRpbHNfMS5jcmVhdGVCeXRlcykodmFsdWUpO1xuICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKGJ1ZmZlclZhbHVlLmxlbmd0aCA8PSBsZW5ndGgsIG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgRXhwZWN0ZWQgYSB2YWx1ZSBvZiBsZW5ndGggJHtsZW5ndGh9LCBidXQgcmVjZWl2ZWQgYSB2YWx1ZSBvZiBsZW5ndGggJHtidWZmZXJWYWx1ZS5sZW5ndGh9LmApKTtcbiAgICAgICAgLy8gRm9yIHBhY2tlZCBlbmNvZGluZywgdGhlIHZhbHVlIGlzIHBhZGRlZCB0byB0aGUgbGVuZ3RoIG9mIHRoZSB0eXBlLCBhbmRcbiAgICAgICAgLy8gdGhlbiBhZGRlZCB0byB0aGUgYnl0ZSBhcnJheS5cbiAgICAgICAgaWYgKHBhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbYnVmZmVyLCAoMCwgdXRpbHNfMi5wYWRFbmQpKGJ1ZmZlclZhbHVlLCBsZW5ndGgpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbYnVmZmVyLCAoMCwgdXRpbHNfMi5wYWRFbmQpKGJ1ZmZlclZhbHVlKV0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGVjb2RlIGEgZml4ZWQgYnl0ZXMgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gZGVjb2RlLlxuICAgICAqIEBwYXJhbSBhcmdzLnR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUuXG4gICAgICogQHBhcmFtIGFyZ3MudmFsdWUgLSBUaGUgdmFsdWUgdG8gZGVjb2RlLlxuICAgICAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHZhbHVlIGFzIGEgYFVpbnQ4QXJyYXlgLlxuICAgICAqL1xuICAgIGRlY29kZSh7IHR5cGUsIHZhbHVlIH0pIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gKDAsIGV4cG9ydHMuZ2V0Qnl0ZUxlbmd0aCkodHlwZSk7XG4gICAgICAgIC8vIFNpbmNlIHdlJ3JlIHJldHVybmluZyBhIGBVaW50OEFycmF5YCwgd2UgdXNlIGBzbGljZWAgdG8gY29weSB0aGUgYnl0ZXNcbiAgICAgICAgLy8gaW50byBhIG5ldyBhcnJheS5cbiAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXhlZC1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJmaXhlZEJ5dGVzIiwiZ2V0Qnl0ZUxlbmd0aCIsInV0aWxzXzEiLCJyZXF1aXJlIiwiZXJyb3JzXzEiLCJ1dGlsc18yIiwiQllURVNfUkVHRVgiLCJ0eXBlIiwiYnl0ZXMiLCJtYXRjaCIsImFzc2VydCIsImxlbmd0aCIsIk51bWJlciIsIlBhcnNlckVycm9yIiwiaXNEeW5hbWljIiwiaXNUeXBlIiwidGVzdCIsImVuY29kZSIsImJ1ZmZlciIsInBhY2tlZCIsImJ1ZmZlclZhbHVlIiwiY3JlYXRlQnl0ZXMiLCJjb25jYXRCeXRlcyIsInBhZEVuZCIsImRlY29kZSIsInNsaWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/function.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/function.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.fn = exports.getFunction = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/utils/dist/index.js\");\nconst superstruct_1 = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\");\nconst fixed_bytes_1 = __webpack_require__(/*! ./fixed-bytes */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js\");\n/**\n * A struct that represents a Solidity function. The value must be a hex string\n * or a byte array. The created value will always be an object with an `address`\n * and `selector` property.\n */ const FunctionStruct = (0, superstruct_1.coerce)((0, superstruct_1.object)({\n    address: utils_1.StrictHexStruct,\n    selector: utils_1.StrictHexStruct\n}), (0, superstruct_1.union)([\n    utils_1.StrictHexStruct,\n    (0, superstruct_1.instance)(Uint8Array)\n]), (value)=>{\n    const bytes = (0, utils_1.createBytes)(value);\n    (0, utils_1.assert)(bytes.length === 24, new errors_1.ParserError(`Invalid Solidity function. Expected function to be 24 bytes long, but received ${bytes.length} bytes.`));\n    return {\n        address: (0, utils_1.bytesToHex)(bytes.subarray(0, 20)),\n        selector: (0, utils_1.bytesToHex)(bytes.subarray(20, 24))\n    };\n});\n/**\n * Normalize a function. This accepts the function as:\n *\n * - A {@link SolidityFunction} object.\n * - A hexadecimal string.\n * - A byte array.\n *\n * @param input - The function-like input.\n * @returns The function as buffer.\n */ const getFunction = (input)=>{\n    const value = (0, superstruct_1.create)(input, FunctionStruct);\n    return (0, utils_1.concatBytes)([\n        (0, utils_1.hexToBytes)(value.address),\n        (0, utils_1.hexToBytes)(value.selector)\n    ]);\n};\nexports.getFunction = getFunction;\nexports.fn = {\n    isDynamic: false,\n    /**\n     * Check if a type is a function type. Since `function` is a simple type, this\n     * is just a check that the type is \"function\".\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a function type.\n     */ isType: (type)=>type === \"function\",\n    /**\n     * Get the byte length of an encoded function. Since `function` is a simple\n     * type, this always returns 32.\n     *\n     * Note that actual functions are only 24 bytes long, but the encoding of\n     * the `function` type is always 32 bytes long.\n     *\n     * @returns The byte length of an encoded function.\n     */ getByteLength () {\n        return 32;\n    },\n    /**\n     * Encode the given function to a byte array.\n     *\n     * @param args - The encoding arguments.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The function to encode.\n     * @param args.packed - Whether to use packed encoding.\n     * @param args.tight - Whether to use non-standard tight encoding.\n     * @returns The bytes with the encoded function added to it.\n     */ encode ({ buffer, value, packed, tight }) {\n        const fnValue = (0, exports.getFunction)(value);\n        // Functions are encoded as `bytes24`, so we use the fixedBytes parser to\n        // encode the function.\n        return fixed_bytes_1.fixedBytes.encode({\n            type: \"bytes24\",\n            buffer,\n            value: fnValue,\n            packed,\n            tight\n        });\n    },\n    /**\n     * Decode the given byte array to a function.\n     *\n     * @param args - The decoding arguments.\n     * @param args.value - The byte array to decode.\n     * @returns The decoded function as a {@link SolidityFunction} object.\n     */ decode ({ value }) {\n        return {\n            address: (0, utils_1.bytesToHex)(value.slice(0, 20)),\n            selector: (0, utils_1.bytesToHex)(value.slice(20, 24))\n        };\n    }\n}; //# sourceMappingURL=function.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvZnVuY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELFVBQVUsR0FBR0EsbUJBQW1CLEdBQUcsS0FBSztBQUN4QyxNQUFNSSxVQUFVQyxtQkFBT0EsQ0FBQywyRUFBaUI7QUFDekMsTUFBTUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQyxvRUFBYTtBQUMzQyxNQUFNRSxXQUFXRixtQkFBT0EsQ0FBQywwRUFBVztBQUNwQyxNQUFNRyxnQkFBZ0JILG1CQUFPQSxDQUFDLDJGQUFlO0FBQzdDOzs7O0NBSUMsR0FDRCxNQUFNSSxpQkFBaUIsQ0FBQyxHQUFHSCxjQUFjSSxNQUFNLEVBQUUsQ0FBQyxHQUFHSixjQUFjSyxNQUFNLEVBQUU7SUFDdkVDLFNBQVNSLFFBQVFTLGVBQWU7SUFDaENDLFVBQVVWLFFBQVFTLGVBQWU7QUFDckMsSUFBSSxDQUFDLEdBQUdQLGNBQWNTLEtBQUssRUFBRTtJQUFDWCxRQUFRUyxlQUFlO0lBQUcsSUFBR1AsY0FBY1UsUUFBUSxFQUFFQztDQUFZLEdBQUcsQ0FBQ2hCO0lBQy9GLE1BQU1pQixRQUFRLENBQUMsR0FBR2QsUUFBUWUsV0FBVyxFQUFFbEI7SUFDdEMsSUFBR0csUUFBUWdCLE1BQU0sRUFBRUYsTUFBTUcsTUFBTSxLQUFLLElBQUksSUFBSWQsU0FBU2UsV0FBVyxDQUFDLENBQUMsK0VBQStFLEVBQUVKLE1BQU1HLE1BQU0sQ0FBQyxPQUFPLENBQUM7SUFDekssT0FBTztRQUNIVCxTQUFTLENBQUMsR0FBR1IsUUFBUW1CLFVBQVUsRUFBRUwsTUFBTU0sUUFBUSxDQUFDLEdBQUc7UUFDbkRWLFVBQVUsQ0FBQyxHQUFHVixRQUFRbUIsVUFBVSxFQUFFTCxNQUFNTSxRQUFRLENBQUMsSUFBSTtJQUN6RDtBQUNKO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ0QsTUFBTXJCLGNBQWMsQ0FBQ3NCO0lBQ2pCLE1BQU14QixRQUFRLENBQUMsR0FBR0ssY0FBY29CLE1BQU0sRUFBRUQsT0FBT2hCO0lBQy9DLE9BQU8sQ0FBQyxHQUFHTCxRQUFRdUIsV0FBVyxFQUFFO1FBQUUsSUFBR3ZCLFFBQVF3QixVQUFVLEVBQUUzQixNQUFNVyxPQUFPO1FBQUksSUFBR1IsUUFBUXdCLFVBQVUsRUFBRTNCLE1BQU1hLFFBQVE7S0FBRTtBQUNySDtBQUNBZCxtQkFBbUIsR0FBR0c7QUFDdEJILFVBQVUsR0FBRztJQUNUNkIsV0FBVztJQUNYOzs7Ozs7S0FNQyxHQUNEQyxRQUFRLENBQUNDLE9BQVNBLFNBQVM7SUFDM0I7Ozs7Ozs7O0tBUUMsR0FDREM7UUFDSSxPQUFPO0lBQ1g7SUFDQTs7Ozs7Ozs7O0tBU0MsR0FDREMsUUFBTyxFQUFFQyxNQUFNLEVBQUVqQyxLQUFLLEVBQUVrQyxNQUFNLEVBQUVDLEtBQUssRUFBRTtRQUNuQyxNQUFNQyxVQUFVLENBQUMsR0FBR3JDLFFBQVFHLFdBQVcsRUFBRUY7UUFDekMseUVBQXlFO1FBQ3pFLHVCQUF1QjtRQUN2QixPQUFPTyxjQUFjOEIsVUFBVSxDQUFDTCxNQUFNLENBQUM7WUFDbkNGLE1BQU07WUFDTkc7WUFDQWpDLE9BQU9vQztZQUNQRjtZQUNBQztRQUNKO0lBQ0o7SUFDQTs7Ozs7O0tBTUMsR0FDREcsUUFBTyxFQUFFdEMsS0FBSyxFQUFFO1FBQ1osT0FBTztZQUNIVyxTQUFTLENBQUMsR0FBR1IsUUFBUW1CLFVBQVUsRUFBRXRCLE1BQU11QyxLQUFLLENBQUMsR0FBRztZQUNoRDFCLFVBQVUsQ0FBQyxHQUFHVixRQUFRbUIsVUFBVSxFQUFFdEIsTUFBTXVDLEtBQUssQ0FBQyxJQUFJO1FBQ3REO0lBQ0o7QUFDSixHQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvZnVuY3Rpb24uanM/MDUwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZm4gPSBleHBvcnRzLmdldEZ1bmN0aW9uID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgZml4ZWRfYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2ZpeGVkLWJ5dGVzXCIpO1xuLyoqXG4gKiBBIHN0cnVjdCB0aGF0IHJlcHJlc2VudHMgYSBTb2xpZGl0eSBmdW5jdGlvbi4gVGhlIHZhbHVlIG11c3QgYmUgYSBoZXggc3RyaW5nXG4gKiBvciBhIGJ5dGUgYXJyYXkuIFRoZSBjcmVhdGVkIHZhbHVlIHdpbGwgYWx3YXlzIGJlIGFuIG9iamVjdCB3aXRoIGFuIGBhZGRyZXNzYFxuICogYW5kIGBzZWxlY3RvcmAgcHJvcGVydHkuXG4gKi9cbmNvbnN0IEZ1bmN0aW9uU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEuY29lcmNlKSgoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBhZGRyZXNzOiB1dGlsc18xLlN0cmljdEhleFN0cnVjdCxcbiAgICBzZWxlY3RvcjogdXRpbHNfMS5TdHJpY3RIZXhTdHJ1Y3QsXG59KSwgKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFt1dGlsc18xLlN0cmljdEhleFN0cnVjdCwgKDAsIHN1cGVyc3RydWN0XzEuaW5zdGFuY2UpKFVpbnQ4QXJyYXkpXSksICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGJ5dGVzID0gKDAsIHV0aWxzXzEuY3JlYXRlQnl0ZXMpKHZhbHVlKTtcbiAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKGJ5dGVzLmxlbmd0aCA9PT0gMjQsIG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgSW52YWxpZCBTb2xpZGl0eSBmdW5jdGlvbi4gRXhwZWN0ZWQgZnVuY3Rpb24gdG8gYmUgMjQgYnl0ZXMgbG9uZywgYnV0IHJlY2VpdmVkICR7Ynl0ZXMubGVuZ3RofSBieXRlcy5gKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogKDAsIHV0aWxzXzEuYnl0ZXNUb0hleCkoYnl0ZXMuc3ViYXJyYXkoMCwgMjApKSxcbiAgICAgICAgc2VsZWN0b3I6ICgwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKGJ5dGVzLnN1YmFycmF5KDIwLCAyNCkpLFxuICAgIH07XG59KTtcbi8qKlxuICogTm9ybWFsaXplIGEgZnVuY3Rpb24uIFRoaXMgYWNjZXB0cyB0aGUgZnVuY3Rpb24gYXM6XG4gKlxuICogLSBBIHtAbGluayBTb2xpZGl0eUZ1bmN0aW9ufSBvYmplY3QuXG4gKiAtIEEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogLSBBIGJ5dGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIGZ1bmN0aW9uLWxpa2UgaW5wdXQuXG4gKiBAcmV0dXJucyBUaGUgZnVuY3Rpb24gYXMgYnVmZmVyLlxuICovXG5jb25zdCBnZXRGdW5jdGlvbiA9IChpbnB1dCkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gKDAsIHN1cGVyc3RydWN0XzEuY3JlYXRlKShpbnB1dCwgRnVuY3Rpb25TdHJ1Y3QpO1xuICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoWygwLCB1dGlsc18xLmhleFRvQnl0ZXMpKHZhbHVlLmFkZHJlc3MpLCAoMCwgdXRpbHNfMS5oZXhUb0J5dGVzKSh2YWx1ZS5zZWxlY3RvcildKTtcbn07XG5leHBvcnRzLmdldEZ1bmN0aW9uID0gZ2V0RnVuY3Rpb247XG5leHBvcnRzLmZuID0ge1xuICAgIGlzRHluYW1pYzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB0eXBlIGlzIGEgZnVuY3Rpb24gdHlwZS4gU2luY2UgYGZ1bmN0aW9uYCBpcyBhIHNpbXBsZSB0eXBlLCB0aGlzXG4gICAgICogaXMganVzdCBhIGNoZWNrIHRoYXQgdGhlIHR5cGUgaXMgXCJmdW5jdGlvblwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB0eXBlIGlzIGEgZnVuY3Rpb24gdHlwZS5cbiAgICAgKi9cbiAgICBpc1R5cGU6ICh0eXBlKSA9PiB0eXBlID09PSAnZnVuY3Rpb24nLFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnl0ZSBsZW5ndGggb2YgYW4gZW5jb2RlZCBmdW5jdGlvbi4gU2luY2UgYGZ1bmN0aW9uYCBpcyBhIHNpbXBsZVxuICAgICAqIHR5cGUsIHRoaXMgYWx3YXlzIHJldHVybnMgMzIuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgYWN0dWFsIGZ1bmN0aW9ucyBhcmUgb25seSAyNCBieXRlcyBsb25nLCBidXQgdGhlIGVuY29kaW5nIG9mXG4gICAgICogdGhlIGBmdW5jdGlvbmAgdHlwZSBpcyBhbHdheXMgMzIgYnl0ZXMgbG9uZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlIGxlbmd0aCBvZiBhbiBlbmNvZGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGdldEJ5dGVMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiAzMjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuY29kZSB0aGUgZ2l2ZW4gZnVuY3Rpb24gdG8gYSBieXRlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZW5jb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBhcmdzLmJ1ZmZlciAtIFRoZSBieXRlIGFycmF5IHRvIGFkZCB0by5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSBmdW5jdGlvbiB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIGFyZ3MucGFja2VkIC0gV2hldGhlciB0byB1c2UgcGFja2VkIGVuY29kaW5nLlxuICAgICAqIEBwYXJhbSBhcmdzLnRpZ2h0IC0gV2hldGhlciB0byB1c2Ugbm9uLXN0YW5kYXJkIHRpZ2h0IGVuY29kaW5nLlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlcyB3aXRoIHRoZSBlbmNvZGVkIGZ1bmN0aW9uIGFkZGVkIHRvIGl0LlxuICAgICAqL1xuICAgIGVuY29kZSh7IGJ1ZmZlciwgdmFsdWUsIHBhY2tlZCwgdGlnaHQgfSkge1xuICAgICAgICBjb25zdCBmblZhbHVlID0gKDAsIGV4cG9ydHMuZ2V0RnVuY3Rpb24pKHZhbHVlKTtcbiAgICAgICAgLy8gRnVuY3Rpb25zIGFyZSBlbmNvZGVkIGFzIGBieXRlczI0YCwgc28gd2UgdXNlIHRoZSBmaXhlZEJ5dGVzIHBhcnNlciB0b1xuICAgICAgICAvLyBlbmNvZGUgdGhlIGZ1bmN0aW9uLlxuICAgICAgICByZXR1cm4gZml4ZWRfYnl0ZXNfMS5maXhlZEJ5dGVzLmVuY29kZSh7XG4gICAgICAgICAgICB0eXBlOiAnYnl0ZXMyNCcsXG4gICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgICB2YWx1ZTogZm5WYWx1ZSxcbiAgICAgICAgICAgIHBhY2tlZCxcbiAgICAgICAgICAgIHRpZ2h0LFxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERlY29kZSB0aGUgZ2l2ZW4gYnl0ZSBhcnJheSB0byBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgZGVjb2RpbmcgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBhcmdzLnZhbHVlIC0gVGhlIGJ5dGUgYXJyYXkgdG8gZGVjb2RlLlxuICAgICAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIGZ1bmN0aW9uIGFzIGEge0BsaW5rIFNvbGlkaXR5RnVuY3Rpb259IG9iamVjdC5cbiAgICAgKi9cbiAgICBkZWNvZGUoeyB2YWx1ZSB9KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzOiAoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KSh2YWx1ZS5zbGljZSgwLCAyMCkpLFxuICAgICAgICAgICAgc2VsZWN0b3I6ICgwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKHZhbHVlLnNsaWNlKDIwLCAyNCkpLFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVuY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZm4iLCJnZXRGdW5jdGlvbiIsInV0aWxzXzEiLCJyZXF1aXJlIiwic3VwZXJzdHJ1Y3RfMSIsImVycm9yc18xIiwiZml4ZWRfYnl0ZXNfMSIsIkZ1bmN0aW9uU3RydWN0IiwiY29lcmNlIiwib2JqZWN0IiwiYWRkcmVzcyIsIlN0cmljdEhleFN0cnVjdCIsInNlbGVjdG9yIiwidW5pb24iLCJpbnN0YW5jZSIsIlVpbnQ4QXJyYXkiLCJieXRlcyIsImNyZWF0ZUJ5dGVzIiwiYXNzZXJ0IiwibGVuZ3RoIiwiUGFyc2VyRXJyb3IiLCJieXRlc1RvSGV4Iiwic3ViYXJyYXkiLCJpbnB1dCIsImNyZWF0ZSIsImNvbmNhdEJ5dGVzIiwiaGV4VG9CeXRlcyIsImlzRHluYW1pYyIsImlzVHlwZSIsInR5cGUiLCJnZXRCeXRlTGVuZ3RoIiwiZW5jb2RlIiwiYnVmZmVyIiwicGFja2VkIiwidGlnaHQiLCJmblZhbHVlIiwiZml4ZWRCeXRlcyIsImRlY29kZSIsInNsaWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/function.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n__exportStar(__webpack_require__(/*! ./address */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/address.js\"), exports);\n__exportStar(__webpack_require__(/*! ./array */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/array.js\"), exports);\n__exportStar(__webpack_require__(/*! ./bool */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/bool.js\"), exports);\n__exportStar(__webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/bytes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./fixed-bytes */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./function */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/function.js\"), exports);\n__exportStar(__webpack_require__(/*! ./number */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/number.js\"), exports);\n__exportStar(__webpack_require__(/*! ./parser */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/parser.js\"), exports);\n__exportStar(__webpack_require__(/*! ./string */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/string.js\"), exports);\n__exportStar(__webpack_require__(/*! ./tuple */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/tuple.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsSUFBSyxJQUFJLElBQUksQ0FBQ0EsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPUCxPQUFPUSx3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBSixPQUFPYyxjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0wsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSVcsZUFBZSxJQUFLLElBQUksSUFBSSxDQUFDQSxZQUFZLElBQUssU0FBU1osQ0FBQyxFQUFFYSxRQUFPO0lBQ2pFLElBQUssSUFBSUMsS0FBS2QsRUFBRyxJQUFJYyxNQUFNLGFBQWEsQ0FBQ2pCLE9BQU9rQixTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixVQUFTQyxJQUFJbEIsZ0JBQWdCaUIsVUFBU2IsR0FBR2M7QUFDM0g7QUFDQWpCLDhDQUE2QztJQUFFcUIsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RE4sYUFBYU8sbUJBQU9BLENBQUMsbUZBQVcsR0FBR047QUFDbkNELGFBQWFPLG1CQUFPQSxDQUFDLCtFQUFTLEdBQUdOO0FBQ2pDRCxhQUFhTyxtQkFBT0EsQ0FBQyw2RUFBUSxHQUFHTjtBQUNoQ0QsYUFBYU8sbUJBQU9BLENBQUMsK0VBQVMsR0FBR047QUFDakNELGFBQWFPLG1CQUFPQSxDQUFDLDJGQUFlLEdBQUdOO0FBQ3ZDRCxhQUFhTyxtQkFBT0EsQ0FBQyxxRkFBWSxHQUFHTjtBQUNwQ0QsYUFBYU8sbUJBQU9BLENBQUMsaUZBQVUsR0FBR047QUFDbENELGFBQWFPLG1CQUFPQSxDQUFDLGlGQUFVLEdBQUdOO0FBQ2xDRCxhQUFhTyxtQkFBT0EsQ0FBQyxpRkFBVSxHQUFHTjtBQUNsQ0QsYUFBYU8sbUJBQU9BLENBQUMsK0VBQVMsR0FBR04sVUFDakMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvcGFyc2Vycy9pbmRleC5qcz83ZTY1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYWRkcmVzc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXJyYXlcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jvb2xcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2J5dGVzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9maXhlZC1ieXRlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZnVuY3Rpb25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL251bWJlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcGFyc2VyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdHJpbmdcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R1cGxlXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2V4cG9ydFN0YXIiLCJleHBvcnRzIiwicCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInZhbHVlIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/number.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/number.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.number = exports.getBigInt = exports.assertNumberLength = exports.getLength = exports.isSigned = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/utils/dist/index.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\");\nconst utils_2 = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/utils/index.js\");\nconst NUMBER_REGEX = /^u?int(?<length>[0-9]*)?$/u;\n/**\n * Check if a number type is signed.\n *\n * @param type - The type to check.\n * @returns Whether the type is signed.\n */ const isSigned = (type)=>{\n    return !type.startsWith(\"u\");\n};\nexports.isSigned = isSigned;\n/**\n * Get the length of the specified type. If a length is not specified, if the\n * length is out of range (8 <= n <= 256), or if the length is not a multiple of\n * 8, this will throw an error.\n *\n * @param type - The type to get the length for.\n * @returns The bit length of the type.\n */ const getLength = (type)=>{\n    if (type === \"int\" || type === \"uint\") {\n        return 256;\n    }\n    const match = type.match(NUMBER_REGEX);\n    (0, utils_1.assert)(match?.groups?.length, new errors_1.ParserError(`Invalid number type. Expected a number type, but received \"${type}\".`));\n    const length = parseInt(match.groups.length, 10);\n    (0, utils_1.assert)(length >= 8 && length <= 256, new errors_1.ParserError(`Invalid number length. Expected a number between 8 and 256, but received \"${type}\".`));\n    (0, utils_1.assert)(length % 8 === 0, new errors_1.ParserError(`Invalid number length. Expected a multiple of 8, but received \"${type}\".`));\n    return length;\n};\nexports.getLength = getLength;\n/**\n * Assert that the byte length of the given value is in range for the given\n * number type.\n *\n * @param value - The value to check.\n * @param type - The type of the value.\n * @throws If the value is out of range for the type.\n */ const assertNumberLength = (value, type)=>{\n    const length = (0, exports.getLength)(type);\n    const maxValue = BigInt(2) ** BigInt(length - ((0, exports.isSigned)(type) ? 1 : 0)) - BigInt(1);\n    if ((0, exports.isSigned)(type)) {\n        // Signed types must be in the range of `-(2^(length - 1))` to\n        // `2^(length - 1) - 1`.\n        (0, utils_1.assert)(value >= -(maxValue + BigInt(1)) && value <= maxValue, new errors_1.ParserError(`Number \"${value}\" is out of range for type \"${type}\".`));\n        return;\n    }\n    // Unsigned types must be in the range of `0` to `2^length - 1`.\n    (0, utils_1.assert)(value <= maxValue, new errors_1.ParserError(`Number \"${value}\" is out of range for type \"${type}\".`));\n};\nexports.assertNumberLength = assertNumberLength;\n/**\n * Normalize a `bigint` value. This accepts the value as:\n *\n * - A `bigint`.\n * - A `number`.\n * - A decimal string, i.e., a string that does not start with \"0x\".\n * - A hexadecimal string, i.e., a string that starts with \"0x\".\n *\n * @param value - The number-like value to parse.\n * @returns The value parsed as bigint.\n */ const getBigInt = (value)=>{\n    try {\n        return (0, utils_1.createBigInt)(value);\n    } catch  {\n        throw new errors_1.ParserError(`Invalid number. Expected a valid number value, but received \"${value}\".`);\n    }\n};\nexports.getBigInt = getBigInt;\nexports.number = {\n    isDynamic: false,\n    /**\n     * Check if a type is a number type.\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a number type.\n     */ isType (type) {\n        return NUMBER_REGEX.test(type);\n    },\n    /**\n     * Get the byte length of an encoded number type. Since `int` and `uint` are\n     * simple types, this will always return 32.\n     *\n     * @returns The byte length of the type.\n     */ getByteLength () {\n        return 32;\n    },\n    /**\n     * Encode a number value.\n     *\n     * @param args - The arguments to encode.\n     * @param args.type - The type of the value.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The value to encode.\n     * @param args.packed - Whether to use packed encoding.\n     * @returns The bytes with the encoded value added to it.\n     */ encode ({ type, buffer, value, packed }) {\n        const bigIntValue = (0, exports.getBigInt)(value);\n        (0, exports.assertNumberLength)(bigIntValue, type);\n        if ((0, exports.isSigned)(type)) {\n            // For packed encoding, the value is padded to the length of the type, and\n            // then added to the byte array.\n            if (packed) {\n                const length = (0, exports.getLength)(type) / 8;\n                return (0, utils_1.concatBytes)([\n                    buffer,\n                    (0, utils_1.signedBigIntToBytes)(bigIntValue, length)\n                ]);\n            }\n            return (0, utils_1.concatBytes)([\n                buffer,\n                (0, utils_2.padStart)((0, utils_1.signedBigIntToBytes)(bigIntValue, 32))\n            ]);\n        }\n        // For packed encoding, the value is padded to the length of the type, and\n        // then added to the byte array.\n        if (packed) {\n            const length = (0, exports.getLength)(type) / 8;\n            return (0, utils_1.concatBytes)([\n                buffer,\n                (0, utils_2.padStart)((0, utils_1.bigIntToBytes)(bigIntValue), length)\n            ]);\n        }\n        return (0, utils_1.concatBytes)([\n            buffer,\n            (0, utils_2.padStart)((0, utils_1.bigIntToBytes)(bigIntValue))\n        ]);\n    },\n    /**\n     * Decode a number value.\n     *\n     * @param args - The decoding arguments.\n     * @param args.type - The type of the value.\n     * @param args.value - The value to decode.\n     * @returns The decoded value.\n     */ decode ({ type, value }) {\n        const buffer = value.subarray(0, 32);\n        if ((0, exports.isSigned)(type)) {\n            const numberValue = (0, utils_1.bytesToSignedBigInt)(buffer);\n            (0, exports.assertNumberLength)(numberValue, type);\n            return numberValue;\n        }\n        const numberValue = (0, utils_1.bytesToBigInt)(buffer);\n        (0, exports.assertNumberLength)(numberValue, type);\n        return numberValue;\n    }\n}; //# sourceMappingURL=number.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvbnVtYmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUdBLGlCQUFpQixHQUFHQSwwQkFBMEIsR0FBR0EsaUJBQWlCLEdBQUdBLGdCQUFnQixHQUFHLEtBQUs7QUFDOUcsTUFBTU8sVUFBVUMsbUJBQU9BLENBQUMsMkVBQWlCO0FBQ3pDLE1BQU1DLFdBQVdELG1CQUFPQSxDQUFDLDBFQUFXO0FBQ3BDLE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLDhFQUFVO0FBQ2xDLE1BQU1HLGVBQWU7QUFDckI7Ozs7O0NBS0MsR0FDRCxNQUFNTCxXQUFXLENBQUNNO0lBQ2QsT0FBTyxDQUFDQSxLQUFLQyxVQUFVLENBQUM7QUFDNUI7QUFDQWIsZ0JBQWdCLEdBQUdNO0FBQ25COzs7Ozs7O0NBT0MsR0FDRCxNQUFNRCxZQUFZLENBQUNPO0lBQ2YsSUFBSUEsU0FBUyxTQUFTQSxTQUFTLFFBQVE7UUFDbkMsT0FBTztJQUNYO0lBQ0EsTUFBTUUsUUFBUUYsS0FBS0UsS0FBSyxDQUFDSDtJQUN4QixJQUFHSixRQUFRUSxNQUFNLEVBQUVELE9BQU9FLFFBQVFDLFFBQVEsSUFBSVIsU0FBU1MsV0FBVyxDQUFDLENBQUMsMkRBQTJELEVBQUVOLEtBQUssRUFBRSxDQUFDO0lBQzFJLE1BQU1LLFNBQVNFLFNBQVNMLE1BQU1FLE1BQU0sQ0FBQ0MsTUFBTSxFQUFFO0lBQzVDLElBQUdWLFFBQVFRLE1BQU0sRUFBRUUsVUFBVSxLQUFLQSxVQUFVLEtBQUssSUFBSVIsU0FBU1MsV0FBVyxDQUFDLENBQUMsMEVBQTBFLEVBQUVOLEtBQUssRUFBRSxDQUFDO0lBQy9KLElBQUdMLFFBQVFRLE1BQU0sRUFBRUUsU0FBUyxNQUFNLEdBQUcsSUFBSVIsU0FBU1MsV0FBVyxDQUFDLENBQUMsK0RBQStELEVBQUVOLEtB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YztJQUM1RztJQUNBOzs7Ozs7O0tBT0MsR0FDREssUUFBTyxFQUFFdkIsSUFBSSxFQUFFWCxLQUFLLEVBQUU7UUFDbEIsTUFBTTJCLFNBQVMzQixNQUFNbUMsUUFBUSxDQUFDLEdBQUc7UUFDakMsSUFBSSxDQUFDLEdBQUdwQyxRQUFRTSxRQUFRLEVBQUVNLE9BQU87WUFDN0IsTUFBTXlCLGNBQWMsQ0FBQyxHQUFHOUIsUUFBUStCLG1CQUFtQixFQUFFVjtZQUNwRCxJQUFHNUIsUUFBUUksa0JBQWtCLEVBQUVpQyxhQUFhekI7WUFDN0MsT0FBT3lCO1FBQ1g7UUFDQSxNQUFNQSxjQUFjLENBQUMsR0FBRzlCLFFBQVFnQyxhQUFhLEVBQUVYO1FBQzlDLElBQUc1QixRQUFRSSxrQkFBa0IsRUFBRWlDLGFBQWF6QjtRQUM3QyxPQUFPeUI7SUFDWDtBQUNKLEdBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvcGFyc2Vycy9udW1iZXIuanM/NDE5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubnVtYmVyID0gZXhwb3J0cy5nZXRCaWdJbnQgPSBleHBvcnRzLmFzc2VydE51bWJlckxlbmd0aCA9IGV4cG9ydHMuZ2V0TGVuZ3RoID0gZXhwb3J0cy5pc1NpZ25lZCA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IE5VTUJFUl9SRUdFWCA9IC9edT9pbnQoPzxsZW5ndGg+WzAtOV0qKT8kL3U7XG4vKipcbiAqIENoZWNrIGlmIGEgbnVtYmVyIHR5cGUgaXMgc2lnbmVkLlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB0eXBlIGlzIHNpZ25lZC5cbiAqL1xuY29uc3QgaXNTaWduZWQgPSAodHlwZSkgPT4ge1xuICAgIHJldHVybiAhdHlwZS5zdGFydHNXaXRoKCd1Jyk7XG59O1xuZXhwb3J0cy5pc1NpZ25lZCA9IGlzU2lnbmVkO1xuLyoqXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuIElmIGEgbGVuZ3RoIGlzIG5vdCBzcGVjaWZpZWQsIGlmIHRoZVxuICogbGVuZ3RoIGlzIG91dCBvZiByYW5nZSAoOCA8PSBuIDw9IDI1NiksIG9yIGlmIHRoZSBsZW5ndGggaXMgbm90IGEgbXVsdGlwbGUgb2ZcbiAqIDgsIHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGdldCB0aGUgbGVuZ3RoIGZvci5cbiAqIEByZXR1cm5zIFRoZSBiaXQgbGVuZ3RoIG9mIHRoZSB0eXBlLlxuICovXG5jb25zdCBnZXRMZW5ndGggPSAodHlwZSkgPT4ge1xuICAgIGlmICh0eXBlID09PSAnaW50JyB8fCB0eXBlID09PSAndWludCcpIHtcbiAgICAgICAgcmV0dXJuIDI1NjtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKE5VTUJFUl9SRUdFWCk7XG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KShtYXRjaD8uZ3JvdXBzPy5sZW5ndGgsIG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgSW52YWxpZCBudW1iZXIgdHlwZS4gRXhwZWN0ZWQgYSBudW1iZXIgdHlwZSwgYnV0IHJlY2VpdmVkIFwiJHt0eXBlfVwiLmApKTtcbiAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChtYXRjaC5ncm91cHMubGVuZ3RoLCAxMCk7XG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KShsZW5ndGggPj0gOCAmJiBsZW5ndGggPD0gMjU2LCBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYEludmFsaWQgbnVtYmVyIGxlbmd0aC4gRXhwZWN0ZWQgYSBudW1iZXIgYmV0d2VlbiA4IGFuZCAyNTYsIGJ1dCByZWNlaXZlZCBcIiR7dHlwZX1cIi5gKSk7XG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KShsZW5ndGggJSA4ID09PSAwLCBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYEludmFsaWQgbnVtYmVyIGxlbmd0aC4gRXhwZWN0ZWQgYSBtdWx0aXBsZSBvZiA4LCBidXQgcmVjZWl2ZWQgXCIke3R5cGV9XCIuYCkpO1xuICAgIHJldHVybiBsZW5ndGg7XG59O1xuZXhwb3J0cy5nZXRMZW5ndGggPSBnZXRMZW5ndGg7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBieXRlIGxlbmd0aCBvZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgaW4gcmFuZ2UgZm9yIHRoZSBnaXZlblxuICogbnVtYmVyIHR5cGUuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBvdXQgb2YgcmFuZ2UgZm9yIHRoZSB0eXBlLlxuICovXG5jb25zdCBhc3NlcnROdW1iZXJMZW5ndGggPSAodmFsdWUsIHR5cGUpID0+IHtcbiAgICBjb25zdCBsZW5ndGggPSAoMCwgZXhwb3J0cy5nZXRMZW5ndGgpKHR5cGUpO1xuICAgIGNvbnN0IG1heFZhbHVlID0gQmlnSW50KDIpICoqIEJpZ0ludChsZW5ndGggLSAoKDAsIGV4cG9ydHMuaXNTaWduZWQpKHR5cGUpID8gMSA6IDApKSAtIEJpZ0ludCgxKTtcbiAgICBpZiAoKDAsIGV4cG9ydHMuaXNTaWduZWQpKHR5cGUpKSB7XG4gICAgICAgIC8vIFNpZ25lZCB0eXBlcyBtdXN0IGJlIGluIHRoZSByYW5nZSBvZiBgLSgyXihsZW5ndGggLSAxKSlgIHRvXG4gICAgICAgIC8vIGAyXihsZW5ndGggLSAxKSAtIDFgLlxuICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKHZhbHVlID49IC0obWF4VmFsdWUgKyBCaWdJbnQoMSkpICYmIHZhbHVlIDw9IG1heFZhbHVlLCBuZXcgZXJyb3JzXzEuUGFyc2VyRXJyb3IoYE51bWJlciBcIiR7dmFsdWV9XCIgaXMgb3V0IG9mIHJhbmdlIGZvciB0eXBlIFwiJHt0eXBlfVwiLmApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBVbnNpZ25lZCB0eXBlcyBtdXN0IGJlIGluIHRoZSByYW5nZSBvZiBgMGAgdG8gYDJebGVuZ3RoIC0gMWAuXG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KSh2YWx1ZSA8PSBtYXhWYWx1ZSwgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBOdW1iZXIgXCIke3ZhbHVlfVwiIGlzIG91dCBvZiByYW5nZSBmb3IgdHlwZSBcIiR7dHlwZX1cIi5gKSk7XG59O1xuZXhwb3J0cy5hc3NlcnROdW1iZXJMZW5ndGggPSBhc3NlcnROdW1iZXJMZW5ndGg7XG4vKipcbiAqIE5vcm1hbGl6ZSBhIGBiaWdpbnRgIHZhbHVlLiBUaGlzIGFjY2VwdHMgdGhlIHZhbHVlIGFzOlxuICpcbiAqIC0gQSBgYmlnaW50YC5cbiAqIC0gQSBgbnVtYmVyYC5cbiAqIC0gQSBkZWNpbWFsIHN0cmluZywgaS5lLiwgYSBzdHJpbmcgdGhhdCBkb2VzIG5vdCBzdGFydCB3aXRoIFwiMHhcIi5cbiAqIC0gQSBoZXhhZGVjaW1hbCBzdHJpbmcsIGkuZS4sIGEgc3RyaW5nIHRoYXQgc3RhcnRzIHdpdGggXCIweFwiLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXItbGlrZSB2YWx1ZSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBwYXJzZWQgYXMgYmlnaW50LlxuICovXG5jb25zdCBnZXRCaWdJbnQgPSAodmFsdWUpID0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuY3JlYXRlQmlnSW50KSh2YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlBhcnNlckVycm9yKGBJbnZhbGlkIG51bWJlci4gRXhwZWN0ZWQgYSB2YWxpZCBudW1iZXIgdmFsdWUsIGJ1dCByZWNlaXZlZCBcIiR7dmFsdWV9XCIuYCk7XG4gICAgfVxufTtcbmV4cG9ydHMuZ2V0QmlnSW50ID0gZ2V0QmlnSW50O1xuZXhwb3J0cy5udW1iZXIgPSB7XG4gICAgaXNEeW5hbWljOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHR5cGUgaXMgYSBudW1iZXIgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgdHlwZSBpcyBhIG51bWJlciB0eXBlLlxuICAgICAqL1xuICAgIGlzVHlwZSh0eXBlKSB7XG4gICAgICAgIHJldHVybiBOVU1CRVJfUkVHRVgudGVzdCh0eXBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnl0ZSBsZW5ndGggb2YgYW4gZW5jb2RlZCBudW1iZXIgdHlwZS4gU2luY2UgYGludGAgYW5kIGB1aW50YCBhcmVcbiAgICAgKiBzaW1wbGUgdHlwZXMsIHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIDMyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGJ5dGUgbGVuZ3RoIG9mIHRoZSB0eXBlLlxuICAgICAqL1xuICAgIGdldEJ5dGVMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiAzMjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuY29kZSBhIG51bWJlciB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIGFyZ3MudHlwZSAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gYXJncy5idWZmZXIgLSBUaGUgYnl0ZSBhcnJheSB0byBhZGQgdG8uXG4gICAgICogQHBhcmFtIGFyZ3MudmFsdWUgLSBUaGUgdmFsdWUgdG8gZW5jb2RlLlxuICAgICAqIEBwYXJhbSBhcmdzLnBhY2tlZCAtIFdoZXRoZXIgdG8gdXNlIHBhY2tlZCBlbmNvZGluZy5cbiAgICAgKiBAcmV0dXJucyBUaGUgYnl0ZXMgd2l0aCB0aGUgZW5jb2RlZCB2YWx1ZSBhZGRlZCB0byBpdC5cbiAgICAgKi9cbiAgICBlbmNvZGUoeyB0eXBlLCBidWZmZXIsIHZhbHVlLCBwYWNrZWQgfSkge1xuICAgICAgICBjb25zdCBiaWdJbnRWYWx1ZSA9ICgwLCBleHBvcnRzLmdldEJpZ0ludCkodmFsdWUpO1xuICAgICAgICAoMCwgZXhwb3J0cy5hc3NlcnROdW1iZXJMZW5ndGgpKGJpZ0ludFZhbHVlLCB0eXBlKTtcbiAgICAgICAgaWYgKCgwLCBleHBvcnRzLmlzU2lnbmVkKSh0eXBlKSkge1xuICAgICAgICAgICAgLy8gRm9yIHBhY2tlZCBlbmNvZGluZywgdGhlIHZhbHVlIGlzIHBhZGRlZCB0byB0aGUgbGVuZ3RoIG9mIHRoZSB0eXBlLCBhbmRcbiAgICAgICAgICAgIC8vIHRoZW4gYWRkZWQgdG8gdGhlIGJ5dGUgYXJyYXkuXG4gICAgICAgICAgICBpZiAocGFja2VkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gKDAsIGV4cG9ydHMuZ2V0TGVuZ3RoKSh0eXBlKSAvIDg7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbYnVmZmVyLCAoMCwgdXRpbHNfMS5zaWduZWRCaWdJbnRUb0J5dGVzKShiaWdJbnRWYWx1ZSwgbGVuZ3RoKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbXG4gICAgICAgICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgICAgICAgICgwLCB1dGlsc18yLnBhZFN0YXJ0KSgoMCwgdXRpbHNfMS5zaWduZWRCaWdJbnRUb0J5dGVzKShiaWdJbnRWYWx1ZSwgMzIpKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBwYWNrZWQgZW5jb2RpbmcsIHRoZSB2YWx1ZSBpcyBwYWRkZWQgdG8gdGhlIGxlbmd0aCBvZiB0aGUgdHlwZSwgYW5kXG4gICAgICAgIC8vIHRoZW4gYWRkZWQgdG8gdGhlIGJ5dGUgYXJyYXkuXG4gICAgICAgIGlmIChwYWNrZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9ICgwLCBleHBvcnRzLmdldExlbmd0aCkodHlwZSkgLyA4O1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbXG4gICAgICAgICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgICAgICAgICgwLCB1dGlsc18yLnBhZFN0YXJ0KSgoMCwgdXRpbHNfMS5iaWdJbnRUb0J5dGVzKShiaWdJbnRWYWx1ZSksIGxlbmd0aCksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKFtidWZmZXIsICgwLCB1dGlsc18yLnBhZFN0YXJ0KSgoMCwgdXRpbHNfMS5iaWdJbnRUb0J5dGVzKShiaWdJbnRWYWx1ZSkpXSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYSBudW1iZXIgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBkZWNvZGluZyBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIGFyZ3MudHlwZSAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSB2YWx1ZSB0byBkZWNvZGUuXG4gICAgICogQHJldHVybnMgVGhlIGRlY29kZWQgdmFsdWUuXG4gICAgICovXG4gICAgZGVjb2RlKHsgdHlwZSwgdmFsdWUgfSkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB2YWx1ZS5zdWJhcnJheSgwLCAzMik7XG4gICAgICAgIGlmICgoMCwgZXhwb3J0cy5pc1NpZ25lZCkodHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bWJlclZhbHVlID0gKDAsIHV0aWxzXzEuYnl0ZXNUb1NpZ25lZEJpZ0ludCkoYnVmZmVyKTtcbiAgICAgICAgICAgICgwLCBleHBvcnRzLmFzc2VydE51bWJlckxlbmd0aCkobnVtYmVyVmFsdWUsIHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlclZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG51bWJlclZhbHVlID0gKDAsIHV0aWxzXzEuYnl0ZXNUb0JpZ0ludCkoYnVmZmVyKTtcbiAgICAgICAgKDAsIGV4cG9ydHMuYXNzZXJ0TnVtYmVyTGVuZ3RoKShudW1iZXJWYWx1ZSwgdHlwZSk7XG4gICAgICAgIHJldHVybiBudW1iZXJWYWx1ZTtcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJudW1iZXIiLCJnZXRCaWdJbnQiLCJhc3NlcnROdW1iZXJMZW5ndGgiLCJnZXRMZW5ndGgiLCJpc1NpZ25lZCIsInV0aWxzXzEiLCJyZXF1aXJlIiwiZXJyb3JzXzEiLCJ1dGlsc18yIiwiTlVNQkVSX1JFR0VYIiwidHlwZSIsInN0YXJ0c1dpdGgiLCJtYXRjaCIsImFzc2VydCIsImdyb3VwcyIsImxlbmd0aCIsIlBhcnNlckVycm9yIiwicGFyc2VJbnQiLCJtYXhWYWx1ZSIsIkJpZ0ludCIsImNyZWF0ZUJpZ0ludCIsImlzRHluYW1pYyIsImlzVHlwZSIsInRlc3QiLCJnZXRCeXRlTGVuZ3RoIiwiZW5jb2RlIiwiYnVmZmVyIiwicGFja2VkIiwiYmlnSW50VmFsdWUiLCJjb25jYXRCeXRlcyIsInNpZ25lZEJpZ0ludFRvQnl0ZXMiLCJwYWRTdGFydCIsImJpZ0ludFRvQnl0ZXMiLCJkZWNvZGUiLCJzdWJhcnJheSIsIm51bWJlclZhbHVlIiwiYnl0ZXNUb1NpZ25lZEJpZ0ludCIsImJ5dGVzVG9CaWdJbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/number.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/parser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/parser.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n})); //# sourceMappingURL=parser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDLEVBQzdELGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvcGFyc2VyLmpzPzYzNTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/string.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/string.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.string = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/utils/dist/index.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/bytes.js\");\nexports.string = {\n    isDynamic: true,\n    /**\n     * Check if a type is a string type. Since `string` is a simple type, this\n     * is just a check if the type is \"string\".\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a string type.\n     */ isType: (type)=>type === \"string\",\n    /**\n     * Get the byte length of an encoded string type. Since `string` is a simple\n     * type, this will always return 32.\n     *\n     * Note that actual strings are variable in length, but the encoded static\n     * value (pointer) is always 32 bytes long.\n     *\n     * @returns The byte length of an encoded string.\n     */ getByteLength () {\n        return 32;\n    },\n    /**\n     * Encode the given string value to a byte array.\n     *\n     * @param args - The encoding arguments.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The string value to encode.\n     * @param args.packed - Whether to use packed encoding.\n     * @param args.tight - Whether to use non-standard tight encoding.\n     * @returns The bytes with the encoded string value added to it.\n     */ encode ({ buffer, value, packed, tight }) {\n        // Strings are encoded as UTF-8 bytes, so we use the bytes parser to encode\n        // the string as bytes.\n        return bytes_1.bytes.encode({\n            type: \"bytes\",\n            buffer,\n            value: (0, utils_1.stringToBytes)(value),\n            packed,\n            tight\n        });\n    },\n    /**\n     * Decode the given byte array to a string value.\n     *\n     * @param args - The decoding arguments.\n     * @returns The decoded string value.\n     */ decode (args) {\n        // Strings are encoded as UTF-8 bytes, so we use the bytes parser to decode\n        // the bytes, and convert them to a string.\n        return (0, utils_1.bytesToString)(bytes_1.bytes.decode(args));\n    }\n}; //# sourceMappingURL=string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvc3RyaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixNQUFNRyxVQUFVQyxtQkFBT0EsQ0FBQywyRUFBaUI7QUFDekMsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsK0VBQVM7QUFDakNKLGNBQWMsR0FBRztJQUNiTSxXQUFXO0lBQ1g7Ozs7OztLQU1DLEdBQ0RDLFFBQVEsQ0FBQ0MsT0FBU0EsU0FBUztJQUMzQjs7Ozs7Ozs7S0FRQyxHQUNEQztRQUNJLE9BQU87SUFDWDtJQUNBOzs7Ozs7Ozs7S0FTQyxHQUNEQyxRQUFPLEVBQUVDLE1BQU0sRUFBRVYsS0FBSyxFQUFFVyxNQUFNLEVBQUVDLEtBQUssRUFBRTtRQUNuQywyRUFBMkU7UUFDM0UsdUJBQXVCO1FBQ3ZCLE9BQU9SLFFBQVFTLEtBQUssQ0FBQ0osTUFBTSxDQUFDO1lBQ3hCRixNQUFNO1lBQ05HO1lBQ0FWLE9BQU8sQ0FBQyxHQUFHRSxRQUFRWSxhQUFhLEVBQUVkO1lBQ2xDVztZQUNBQztRQUNKO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNERyxRQUFPQyxJQUFJO1FBQ1AsMkVBQTJFO1FBQzNFLDJDQUEyQztRQUMzQyxPQUFPLENBQUMsR0FBR2QsUUFBUWUsYUFBYSxFQUFFYixRQUFRUyxLQUFLLENBQUNFLE1BQU0sQ0FBQ0M7SUFDM0Q7QUFDSixHQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvc3RyaW5nLmpzPzA2MWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN0cmluZyA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuY29uc3QgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuZXhwb3J0cy5zdHJpbmcgPSB7XG4gICAgaXNEeW5hbWljOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdHlwZSBpcyBhIHN0cmluZyB0eXBlLiBTaW5jZSBgc3RyaW5nYCBpcyBhIHNpbXBsZSB0eXBlLCB0aGlzXG4gICAgICogaXMganVzdCBhIGNoZWNrIGlmIHRoZSB0eXBlIGlzIFwic3RyaW5nXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHR5cGUgaXMgYSBzdHJpbmcgdHlwZS5cbiAgICAgKi9cbiAgICBpc1R5cGU6ICh0eXBlKSA9PiB0eXBlID09PSAnc3RyaW5nJyxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGUgbGVuZ3RoIG9mIGFuIGVuY29kZWQgc3RyaW5nIHR5cGUuIFNpbmNlIGBzdHJpbmdgIGlzIGEgc2ltcGxlXG4gICAgICogdHlwZSwgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gMzIuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgYWN0dWFsIHN0cmluZ3MgYXJlIHZhcmlhYmxlIGluIGxlbmd0aCwgYnV0IHRoZSBlbmNvZGVkIHN0YXRpY1xuICAgICAqIHZhbHVlIChwb2ludGVyKSBpcyBhbHdheXMgMzIgYnl0ZXMgbG9uZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlIGxlbmd0aCBvZiBhbiBlbmNvZGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBnZXRCeXRlTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gMzI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmNvZGUgdGhlIGdpdmVuIHN0cmluZyB2YWx1ZSB0byBhIGJ5dGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBlbmNvZGluZyBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIGFyZ3MuYnVmZmVyIC0gVGhlIGJ5dGUgYXJyYXkgdG8gYWRkIHRvLlxuICAgICAqIEBwYXJhbSBhcmdzLnZhbHVlIC0gVGhlIHN0cmluZyB2YWx1ZSB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIGFyZ3MucGFja2VkIC0gV2hldGhlciB0byB1c2UgcGFja2VkIGVuY29kaW5nLlxuICAgICAqIEBwYXJhbSBhcmdzLnRpZ2h0IC0gV2hldGhlciB0byB1c2Ugbm9uLXN0YW5kYXJkIHRpZ2h0IGVuY29kaW5nLlxuICAgICAqIEByZXR1cm5zIFRoZSBieXRlcyB3aXRoIHRoZSBlbmNvZGVkIHN0cmluZyB2YWx1ZSBhZGRlZCB0byBpdC5cbiAgICAgKi9cbiAgICBlbmNvZGUoeyBidWZmZXIsIHZhbHVlLCBwYWNrZWQsIHRpZ2h0IH0pIHtcbiAgICAgICAgLy8gU3RyaW5ncyBhcmUgZW5jb2RlZCBhcyBVVEYtOCBieXRlcywgc28gd2UgdXNlIHRoZSBieXRlcyBwYXJzZXIgdG8gZW5jb2RlXG4gICAgICAgIC8vIHRoZSBzdHJpbmcgYXMgYnl0ZXMuXG4gICAgICAgIHJldHVybiBieXRlc18xLmJ5dGVzLmVuY29kZSh7XG4gICAgICAgICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgICAgdmFsdWU6ICgwLCB1dGlsc18xLnN0cmluZ1RvQnl0ZXMpKHZhbHVlKSxcbiAgICAgICAgICAgIHBhY2tlZCxcbiAgICAgICAgICAgIHRpZ2h0LFxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERlY29kZSB0aGUgZ2l2ZW4gYnl0ZSBhcnJheSB0byBhIHN0cmluZyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGRlY29kaW5nIGFyZ3VtZW50cy5cbiAgICAgKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBzdHJpbmcgdmFsdWUuXG4gICAgICovXG4gICAgZGVjb2RlKGFyZ3MpIHtcbiAgICAgICAgLy8gU3RyaW5ncyBhcmUgZW5jb2RlZCBhcyBVVEYtOCBieXRlcywgc28gd2UgdXNlIHRoZSBieXRlcyBwYXJzZXIgdG8gZGVjb2RlXG4gICAgICAgIC8vIHRoZSBieXRlcywgYW5kIGNvbnZlcnQgdGhlbSB0byBhIHN0cmluZy5cbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmJ5dGVzVG9TdHJpbmcpKGJ5dGVzXzEuYnl0ZXMuZGVjb2RlKGFyZ3MpKTtcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzdHJpbmciLCJ1dGlsc18xIiwicmVxdWlyZSIsImJ5dGVzXzEiLCJpc0R5bmFtaWMiLCJpc1R5cGUiLCJ0eXBlIiwiZ2V0Qnl0ZUxlbmd0aCIsImVuY29kZSIsImJ1ZmZlciIsInBhY2tlZCIsInRpZ2h0IiwiYnl0ZXMiLCJzdHJpbmdUb0J5dGVzIiwiZGVjb2RlIiwiYXJncyIsImJ5dGVzVG9TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/tuple.js":
/*!****************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/parsers/tuple.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.tuple = exports.getTupleElements = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/utils/dist/index.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/errors.js\");\nconst packer_1 = __webpack_require__(/*! ../packer */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/packer.js\");\nconst TUPLE_REGEX = /^\\((.+)\\)$/u;\nconst isTupleType = (type)=>TUPLE_REGEX.test(type);\n/**\n * Get elements from a tuple type.\n *\n * @param type - The tuple type to get the types for.\n * @returns The elements of the tuple as string array.\n */ const getTupleElements = (type)=>{\n    (0, utils_1.assert)(type.startsWith(\"(\") && type.endsWith(\")\"), new errors_1.ParserError(`Invalid tuple type. Expected tuple type, but received \"${type}\".`));\n    const elements = [];\n    let current = \"\";\n    let depth = 0;\n    for(let i = 1; i < type.length - 1; i++){\n        const char = type[i];\n        if (char === \",\" && depth === 0) {\n            elements.push(current.trim());\n            current = \"\";\n        } else {\n            current += char;\n            if (char === \"(\") {\n                depth += 1;\n            } else if (char === \")\") {\n                depth -= 1;\n            }\n        }\n    }\n    if (current.trim()) {\n        elements.push(current.trim());\n    }\n    return elements;\n};\nexports.getTupleElements = getTupleElements;\nexports.tuple = {\n    /**\n     * Check if the tuple is dynamic. Tuples are dynamic if one or more elements\n     * of the tuple are dynamic.\n     *\n     * @param type - The type to check.\n     * @returns Whether the tuple is dynamic.\n     */ isDynamic (type) {\n        const elements = (0, exports.getTupleElements)(type);\n        return elements.some((element)=>{\n            const parser = (0, packer_1.getParser)(element);\n            return (0, packer_1.isDynamicParser)(parser, element);\n        });\n    },\n    /**\n     * Check if a type is a tuple type.\n     *\n     * @param type - The type to check.\n     * @returns Whether the type is a tuple type.\n     */ isType (type) {\n        return isTupleType(type);\n    },\n    /**\n     * Get the byte length of a tuple type. If the tuple is dynamic, this will\n     * always return 32. If the tuple is static, this will return the sum of the\n     * byte lengths of the tuple elements.\n     *\n     * @param type - The type to get the byte length for.\n     * @returns The byte length of the tuple type.\n     */ getByteLength (type) {\n        if ((0, packer_1.isDynamicParser)(this, type)) {\n            return 32;\n        }\n        const elements = (0, exports.getTupleElements)(type);\n        return elements.reduce((total, element)=>{\n            return total + (0, packer_1.getParser)(element).getByteLength(element);\n        }, 0);\n    },\n    /**\n     * Encode a tuple value.\n     *\n     * @param args - The encoding arguments.\n     * @param args.type - The type of the value.\n     * @param args.buffer - The byte array to add to.\n     * @param args.value - The value to encode.\n     * @param args.packed - Whether to use non-standard packed encoding.\n     * @param args.tight - Whether to use non-standard tight encoding.\n     * @returns The bytes with the encoded value added to it.\n     */ encode ({ type, buffer, value, packed, tight }) {\n        const elements = (0, exports.getTupleElements)(type);\n        return (0, packer_1.pack)({\n            types: elements,\n            values: value,\n            byteArray: buffer,\n            packed,\n            tight\n        });\n    },\n    /**\n     * Decode a tuple value.\n     *\n     * @param args - The decoding arguments.\n     * @param args.type - The type of the value.\n     * @param args.value - The value to decode.\n     * @param args.skip - A function to skip a number of bytes.\n     * @returns The decoded value.\n     */ decode ({ type, value, skip }) {\n        const elements = (0, exports.getTupleElements)(type);\n        const length = this.getByteLength(type) - 32;\n        skip(length);\n        return (0, packer_1.unpack)(elements, value);\n    }\n}; //# sourceMappingURL=tuple.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvdHVwbGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGFBQWEsR0FBR0Esd0JBQXdCLEdBQUcsS0FBSztBQUNoRCxNQUFNSSxVQUFVQyxtQkFBT0EsQ0FBQywyRUFBaUI7QUFDekMsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsMEVBQVc7QUFDcEMsTUFBTUUsV0FBV0YsbUJBQU9BLENBQUMsMEVBQVc7QUFDcEMsTUFBTUcsY0FBYztBQUNwQixNQUFNQyxjQUFjLENBQUNDLE9BQVNGLFlBQVlHLElBQUksQ0FBQ0Q7QUFDL0M7Ozs7O0NBS0MsR0FDRCxNQUFNUCxtQkFBbUIsQ0FBQ087SUFDckIsSUFBR04sUUFBUVEsTUFBTSxFQUFFRixLQUFLRyxVQUFVLENBQUMsUUFBUUgsS0FBS0ksUUFBUSxDQUFDLE1BQU0sSUFBSVIsU0FBU1MsV0FBVyxDQUFDLENBQUMsdURBQXVELEVBQUVMLEtBQUssRUFBRSxDQUFDO0lBQzNKLE1BQU1NLFdBQVcsRUFBRTtJQUNuQixJQUFJQyxVQUFVO0lBQ2QsSUFBSUMsUUFBUTtJQUNaLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJVCxLQUFLVSxNQUFNLEdBQUcsR0FBR0QsSUFBSztRQUN0QyxNQUFNRSxPQUFPWCxJQUFJLENBQUNTLEVBQUU7UUFDcEIsSUFBSUUsU0FBUyxPQUFPSCxVQUFVLEdBQUc7WUFDN0JGLFNBQVNNLElBQUksQ0FBQ0wsUUFBUU0sSUFBSTtZQUMxQk4sVUFBVTtRQUNkLE9BQ0s7WUFDREEsV0FBV0k7WUFDWCxJQUFJQSxTQUFTLEtBQUs7Z0JBQ2RILFNBQVM7WUFDYixPQUNLLElBQUlHLFNBQVMsS0FBSztnQkFDbkJILFNBQVM7WUFDYjtRQUNKO0lBQ0o7SUFDQSxJQUFJRCxRQUFRTSxJQUFJLElBQUk7UUFDaEJQLFNBQVNNLElBQUksQ0FBQ0wsUUFBUU0sSUFBSTtJQUM5QjtJQUNBLE9BQU9QO0FBQ1g7QUFDQWhCLHdCQUF3QixHQUFHRztBQUMzQkgsYUFBYSxHQUFHO0lBQ1o7Ozs7OztLQU1DLEdBQ0R3QixXQUFVZCxJQUFJO1FBQ1YsTUFBTU0sV0FBVyxDQUFDLEdBQUdoQixRQUFRRyxnQkFBZ0IsRUFBRU87UUFDL0MsT0FBT00sU0FBU1MsSUFBSSxDQUFDLENBQUNDO1lBQ2xCLE1BQU1DLFNBQVMsQ0FBQyxHQUFHcEIsU0FBU3FCLFNBQVMsRUFBRUY7WUFDdkMsT0FBTyxDQUFDLEdBQUduQixTQUFTc0IsZUFBZSxFQUFFRixRQUFRRDtRQUNqRDtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDREksUUFBT3BCLElBQUk7UUFDUCxPQUFPRCxZQUFZQztJQUN2QjtJQUNBOzs7Ozs7O0tBT0MsR0FDRHFCLGVBQWNyQixJQUFJO1FBQ2QsSUFBSSxDQUFDLEdBQUdILFNBQVNzQixlQUFlLEVBQUUsSUFBSSxFQUFFbkIsT0FBTztZQUMzQyxPQUFPO1FBQ1g7UUFDQSxNQUFNTSxXQUFXLENBQUMsR0FBR2hCLFFBQVFHLGdCQUFnQixFQUFFTztRQUMvQyxPQUFPTSxTQUFTZ0IsTUFBTSxDQUFDLENBQUNDLE9BQU9QO1lBQzNCLE9BQU9PLFFBQVEsQ0FBQyxHQUFHMUIsU0FBU3FCLFNBQVMsRUFBRUYsU0FBU0ssYUFBYSxDQUFDTDtRQUNsRSxHQUFHO0lBQ1A7SUFDQTs7Ozs7Ozs7OztLQVVDLEdBQ0RRLFFBQU8sRUFBRXhCLElBQUksRUFBRXlCLE1BQU0sRUFBRWxDLEtBQUssRUFBRW1DLE1BQU0sRUFBRUMsS0FBSyxFQUFFO1FBQ3pDLE1BQU1yQixXQUFXLENBQUMsR0FBR2hCLFFBQVFHLGdCQUFnQixFQUFFTztRQUMvQyxPQUFPLENBQUMsR0FBR0gsU0FBUytCLElBQUksRUFBRTtZQUN0QkMsT0FBT3ZCO1lBQ1B3QixRQUFRdkM7WUFDUndDLFdBQVdOO1lBQ1hDO1lBQ0FDO1FBQ0o7SUFDSjtJQUNBOzs7Ozs7OztLQVFDLEdBQ0RLLFFBQU8sRUFBRWhDLElBQUksRUFBRVQsS0FBSyxFQUFFMEMsSUFBSSxFQUFFO1FBQ3hCLE1BQU0zQixXQUFXLENBQUMsR0FBR2hCLFFBQVFHLGdCQUFnQixFQUFFTztRQUMvQyxNQUFNVSxTQUFTLElBQUksQ0FBQ1csYUFBYSxDQUFDckIsUUFBUTtRQUMxQ2lDLEtBQUt2QjtRQUNMLE9BQU8sQ0FBQyxHQUFHYixTQUFTcUMsTUFBTSxFQUFFNUIsVUFBVWY7SUFDMUM7QUFDSixHQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnMvdHVwbGUuanM/NjdiNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudHVwbGUgPSBleHBvcnRzLmdldFR1cGxlRWxlbWVudHMgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IHBhY2tlcl8xID0gcmVxdWlyZShcIi4uL3BhY2tlclwiKTtcbmNvbnN0IFRVUExFX1JFR0VYID0gL15cXCgoLispXFwpJC91O1xuY29uc3QgaXNUdXBsZVR5cGUgPSAodHlwZSkgPT4gVFVQTEVfUkVHRVgudGVzdCh0eXBlKTtcbi8qKlxuICogR2V0IGVsZW1lbnRzIGZyb20gYSB0dXBsZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHR1cGxlIHR5cGUgdG8gZ2V0IHRoZSB0eXBlcyBmb3IuXG4gKiBAcmV0dXJucyBUaGUgZWxlbWVudHMgb2YgdGhlIHR1cGxlIGFzIHN0cmluZyBhcnJheS5cbiAqL1xuY29uc3QgZ2V0VHVwbGVFbGVtZW50cyA9ICh0eXBlKSA9PiB7XG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KSh0eXBlLnN0YXJ0c1dpdGgoJygnKSAmJiB0eXBlLmVuZHNXaXRoKCcpJyksIG5ldyBlcnJvcnNfMS5QYXJzZXJFcnJvcihgSW52YWxpZCB0dXBsZSB0eXBlLiBFeHBlY3RlZCB0dXBsZSB0eXBlLCBidXQgcmVjZWl2ZWQgXCIke3R5cGV9XCIuYCkpO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgbGV0IGN1cnJlbnQgPSAnJztcbiAgICBsZXQgZGVwdGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdHlwZS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hhciA9IHR5cGVbaV07XG4gICAgICAgIGlmIChjaGFyID09PSAnLCcgJiYgZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goY3VycmVudC50cmltKCkpO1xuICAgICAgICAgICAgY3VycmVudCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudCArPSBjaGFyO1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICcoJykge1xuICAgICAgICAgICAgICAgIGRlcHRoICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICBkZXB0aCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50LnRyaW0oKSkge1xuICAgICAgICBlbGVtZW50cy5wdXNoKGN1cnJlbnQudHJpbSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xufTtcbmV4cG9ydHMuZ2V0VHVwbGVFbGVtZW50cyA9IGdldFR1cGxlRWxlbWVudHM7XG5leHBvcnRzLnR1cGxlID0ge1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSB0dXBsZSBpcyBkeW5hbWljLiBUdXBsZXMgYXJlIGR5bmFtaWMgaWYgb25lIG9yIG1vcmUgZWxlbWVudHNcbiAgICAgKiBvZiB0aGUgdHVwbGUgYXJlIGR5bmFtaWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHR1cGxlIGlzIGR5bmFtaWMuXG4gICAgICovXG4gICAgaXNEeW5hbWljKHR5cGUpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSAoMCwgZXhwb3J0cy5nZXRUdXBsZUVsZW1lbnRzKSh0eXBlKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzLnNvbWUoKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlciA9ICgwLCBwYWNrZXJfMS5nZXRQYXJzZXIpKGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBwYWNrZXJfMS5pc0R5bmFtaWNQYXJzZXIpKHBhcnNlciwgZWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB0eXBlIGlzIGEgdHVwbGUgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgdHlwZSBpcyBhIHR1cGxlIHR5cGUuXG4gICAgICovXG4gICAgaXNUeXBlKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGlzVHVwbGVUeXBlKHR5cGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBieXRlIGxlbmd0aCBvZiBhIHR1cGxlIHR5cGUuIElmIHRoZSB0dXBsZSBpcyBkeW5hbWljLCB0aGlzIHdpbGxcbiAgICAgKiBhbHdheXMgcmV0dXJuIDMyLiBJZiB0aGUgdHVwbGUgaXMgc3RhdGljLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBzdW0gb2YgdGhlXG4gICAgICogYnl0ZSBsZW5ndGhzIG9mIHRoZSB0dXBsZSBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgdG8gZ2V0IHRoZSBieXRlIGxlbmd0aCBmb3IuXG4gICAgICogQHJldHVybnMgVGhlIGJ5dGUgbGVuZ3RoIG9mIHRoZSB0dXBsZSB0eXBlLlxuICAgICAqL1xuICAgIGdldEJ5dGVMZW5ndGgodHlwZSkge1xuICAgICAgICBpZiAoKDAsIHBhY2tlcl8xLmlzRHluYW1pY1BhcnNlcikodGhpcywgdHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAzMjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50cyA9ICgwLCBleHBvcnRzLmdldFR1cGxlRWxlbWVudHMpKHR5cGUpO1xuICAgICAgICByZXR1cm4gZWxlbWVudHMucmVkdWNlKCh0b3RhbCwgZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRvdGFsICsgKDAsIHBhY2tlcl8xLmdldFBhcnNlcikoZWxlbWVudCkuZ2V0Qnl0ZUxlbmd0aChlbGVtZW50KTtcbiAgICAgICAgfSwgMCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmNvZGUgYSB0dXBsZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGVuY29kaW5nIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0gYXJncy50eXBlIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlLlxuICAgICAqIEBwYXJhbSBhcmdzLmJ1ZmZlciAtIFRoZSBieXRlIGFycmF5IHRvIGFkZCB0by5cbiAgICAgKiBAcGFyYW0gYXJncy52YWx1ZSAtIFRoZSB2YWx1ZSB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIGFyZ3MucGFja2VkIC0gV2hldGhlciB0byB1c2Ugbm9uLXN0YW5kYXJkIHBhY2tlZCBlbmNvZGluZy5cbiAgICAgKiBAcGFyYW0gYXJncy50aWdodCAtIFdoZXRoZXIgdG8gdXNlIG5vbi1zdGFuZGFyZCB0aWdodCBlbmNvZGluZy5cbiAgICAgKiBAcmV0dXJucyBUaGUgYnl0ZXMgd2l0aCB0aGUgZW5jb2RlZCB2YWx1ZSBhZGRlZCB0byBpdC5cbiAgICAgKi9cbiAgICBlbmNvZGUoeyB0eXBlLCBidWZmZXIsIHZhbHVlLCBwYWNrZWQsIHRpZ2h0IH0pIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSAoMCwgZXhwb3J0cy5nZXRUdXBsZUVsZW1lbnRzKSh0eXBlKTtcbiAgICAgICAgcmV0dXJuICgwLCBwYWNrZXJfMS5wYWNrKSh7XG4gICAgICAgICAgICB0eXBlczogZWxlbWVudHMsXG4gICAgICAgICAgICB2YWx1ZXM6IHZhbHVlLFxuICAgICAgICAgICAgYnl0ZUFycmF5OiBidWZmZXIsXG4gICAgICAgICAgICBwYWNrZWQsXG4gICAgICAgICAgICB0aWdodCxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYSB0dXBsZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGRlY29kaW5nIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0gYXJncy50eXBlIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlLlxuICAgICAqIEBwYXJhbSBhcmdzLnZhbHVlIC0gVGhlIHZhbHVlIHRvIGRlY29kZS5cbiAgICAgKiBAcGFyYW0gYXJncy5za2lwIC0gQSBmdW5jdGlvbiB0byBza2lwIGEgbnVtYmVyIG9mIGJ5dGVzLlxuICAgICAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGRlY29kZSh7IHR5cGUsIHZhbHVlLCBza2lwIH0pIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSAoMCwgZXhwb3J0cy5nZXRUdXBsZUVsZW1lbnRzKSh0eXBlKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5nZXRCeXRlTGVuZ3RoKHR5cGUpIC0gMzI7XG4gICAgICAgIHNraXAobGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuICgwLCBwYWNrZXJfMS51bnBhY2spKGVsZW1lbnRzLCB2YWx1ZSk7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10dXBsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ0dXBsZSIsImdldFR1cGxlRWxlbWVudHMiLCJ1dGlsc18xIiwicmVxdWlyZSIsImVycm9yc18xIiwicGFja2VyXzEiLCJUVVBMRV9SRUdFWCIsImlzVHVwbGVUeXBlIiwidHlwZSIsInRlc3QiLCJhc3NlcnQiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJQYXJzZXJFcnJvciIsImVsZW1lbnRzIiwiY3VycmVudCIsImRlcHRoIiwiaSIsImxlbmd0aCIsImNoYXIiLCJwdXNoIiwidHJpbSIsImlzRHluYW1pYyIsInNvbWUiLCJlbGVtZW50IiwicGFyc2VyIiwiZ2V0UGFyc2VyIiwiaXNEeW5hbWljUGFyc2VyIiwiaXNUeXBlIiwiZ2V0Qnl0ZUxlbmd0aCIsInJlZHVjZSIsInRvdGFsIiwiZW5jb2RlIiwiYnVmZmVyIiwicGFja2VkIiwidGlnaHQiLCJwYWNrIiwidHlwZXMiLCJ2YWx1ZXMiLCJieXRlQXJyYXkiLCJkZWNvZGUiLCJza2lwIiwidW5wYWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/tuple.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/types/abi.js":
/*!************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/types/abi.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n})); //# sourceMappingURL=abi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3R5cGVzL2FiaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQyxFQUM3RCwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hYmktdXRpbHMvZGlzdC90eXBlcy9hYmkuanM/YzM4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFiaS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/types/abi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/types/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/types/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n__exportStar(__webpack_require__(/*! ./abi */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/types/abi.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3R5cGVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLGVBQWUsSUFBSyxJQUFJLElBQUksQ0FBQ0EsWUFBWSxJQUFLLFNBQVNaLENBQUMsRUFBRWEsUUFBTztJQUNqRSxJQUFLLElBQUlDLEtBQUtkLEVBQUcsSUFBSWMsTUFBTSxhQUFhLENBQUNqQixPQUFPa0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osVUFBU0MsSUFBSWxCLGdCQUFnQmlCLFVBQVNiLEdBQUdjO0FBQzNIO0FBQ0FqQiw4Q0FBNkM7SUFBRXFCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0ROLGFBQWFPLG1CQUFPQSxDQUFDLHlFQUFPLEdBQUdOLFVBQy9CLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3R5cGVzL2luZGV4LmpzPzhlY2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hYmlcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZXhwb3J0U3RhciIsImV4cG9ydHMiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmFsdWUiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/types/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/utils/buffer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/utils/buffer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.padEnd = exports.padStart = exports.set = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/utils/dist/index.js\");\nconst BUFFER_WIDTH = 32;\n/**\n * Set `buffer` in `target` at the specified position.\n *\n * @param target - The buffer to set to.\n * @param buffer - The buffer to set in the target.\n * @param position - The position at which to set the target.\n * @returns The combined buffer.\n */ const set = (target, buffer, position)=>{\n    return (0, utils_1.concatBytes)([\n        target.subarray(0, position),\n        buffer,\n        target.subarray(position + buffer.length)\n    ]);\n};\nexports.set = set;\n/**\n * Add padding to a buffer. If the buffer is larger than `length`, this function won't do anything. If it's smaller, the\n * buffer will be padded to the specified length, with extra zeroes at the start.\n *\n * @param buffer - The buffer to add padding to.\n * @param length - The number of bytes to pad the buffer to.\n * @returns The padded buffer.\n */ const padStart = (buffer, length = BUFFER_WIDTH)=>{\n    const padding = new Uint8Array(Math.max(length - buffer.length, 0)).fill(0x00);\n    return (0, utils_1.concatBytes)([\n        padding,\n        buffer\n    ]);\n};\nexports.padStart = padStart;\n/**\n * Add padding to a buffer. If the buffer is larger than `length`, this function won't do anything. If it's smaller, the\n * buffer will be padded to the specified length, with extra zeroes at the end.\n *\n * @param buffer - The buffer to add padding to.\n * @param length - The number of bytes to pad the buffer to.\n * @returns The padded buffer.\n */ const padEnd = (buffer, length = BUFFER_WIDTH)=>{\n    const padding = new Uint8Array(Math.max(length - buffer.length, 0)).fill(0x00);\n    return (0, utils_1.concatBytes)([\n        buffer,\n        padding\n    ]);\n};\nexports.padEnd = padEnd; //# sourceMappingURL=buffer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3V0aWxzL2J1ZmZlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHQSxnQkFBZ0IsR0FBR0EsV0FBVyxHQUFHLEtBQUs7QUFDdkQsTUFBTUssVUFBVUMsbUJBQU9BLENBQUMsMkVBQWlCO0FBQ3pDLE1BQU1DLGVBQWU7QUFDckI7Ozs7Ozs7Q0FPQyxHQUNELE1BQU1ILE1BQU0sQ0FBQ0ksUUFBUUMsUUFBUUM7SUFDekIsT0FBTyxDQUFDLEdBQUdMLFFBQVFNLFdBQVcsRUFBRTtRQUM1QkgsT0FBT0ksUUFBUSxDQUFDLEdBQUdGO1FBQ25CRDtRQUNBRCxPQUFPSSxRQUFRLENBQUNGLFdBQVdELE9BQU9JLE1BQU07S0FDM0M7QUFDTDtBQUNBYixXQUFXLEdBQUdJO0FBQ2Q7Ozs7Ozs7Q0FPQyxHQUNELE1BQU1ELFdBQVcsQ0FBQ00sUUFBUUksU0FBU04sWUFBWTtJQUMzQyxNQUFNTyxVQUFVLElBQUlDLFdBQVdDLEtBQUtDLEdBQUcsQ0FBQ0osU0FBU0osT0FBT0ksTUFBTSxFQUFFLElBQUlLLElBQUksQ0FBQztJQUN6RSxPQUFPLENBQUMsR0FBR2IsUUFBUU0sV0FBVyxFQUFFO1FBQUNHO1FBQVNMO0tBQU87QUFDckQ7QUFDQVQsZ0JBQWdCLEdBQUdHO0FBQ25COzs7Ozs7O0NBT0MsR0FDRCxNQUFNRCxTQUFTLENBQUNPLFFBQVFJLFNBQVNOLFlBQVk7SUFDekMsTUFBTU8sVUFBVSxJQUFJQyxXQUFXQyxLQUFLQyxHQUFHLENBQUNKLFNBQVNKLE9BQU9JLE1BQU0sRUFBRSxJQUFJSyxJQUFJLENBQUM7SUFDekUsT0FBTyxDQUFDLEdBQUdiLFFBQVFNLFdBQVcsRUFBRTtRQUFDRjtRQUFRSztLQUFRO0FBQ3JEO0FBQ0FkLGNBQWMsR0FBR0UsUUFDakIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svYWJpLXV0aWxzL2Rpc3QvdXRpbHMvYnVmZmVyLmpzPzkxNjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhZEVuZCA9IGV4cG9ydHMucGFkU3RhcnQgPSBleHBvcnRzLnNldCA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuY29uc3QgQlVGRkVSX1dJRFRIID0gMzI7XG4vKipcbiAqIFNldCBgYnVmZmVyYCBpbiBgdGFyZ2V0YCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgYnVmZmVyIHRvIHNldCB0by5cbiAqIEBwYXJhbSBidWZmZXIgLSBUaGUgYnVmZmVyIHRvIHNldCBpbiB0aGUgdGFyZ2V0LlxuICogQHBhcmFtIHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRvIHNldCB0aGUgdGFyZ2V0LlxuICogQHJldHVybnMgVGhlIGNvbWJpbmVkIGJ1ZmZlci5cbiAqL1xuY29uc3Qgc2V0ID0gKHRhcmdldCwgYnVmZmVyLCBwb3NpdGlvbikgPT4ge1xuICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoW1xuICAgICAgICB0YXJnZXQuc3ViYXJyYXkoMCwgcG9zaXRpb24pLFxuICAgICAgICBidWZmZXIsXG4gICAgICAgIHRhcmdldC5zdWJhcnJheShwb3NpdGlvbiArIGJ1ZmZlci5sZW5ndGgpLFxuICAgIF0pO1xufTtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuLyoqXG4gKiBBZGQgcGFkZGluZyB0byBhIGJ1ZmZlci4gSWYgdGhlIGJ1ZmZlciBpcyBsYXJnZXIgdGhhbiBgbGVuZ3RoYCwgdGhpcyBmdW5jdGlvbiB3b24ndCBkbyBhbnl0aGluZy4gSWYgaXQncyBzbWFsbGVyLCB0aGVcbiAqIGJ1ZmZlciB3aWxsIGJlIHBhZGRlZCB0byB0aGUgc3BlY2lmaWVkIGxlbmd0aCwgd2l0aCBleHRyYSB6ZXJvZXMgYXQgdGhlIHN0YXJ0LlxuICpcbiAqIEBwYXJhbSBidWZmZXIgLSBUaGUgYnVmZmVyIHRvIGFkZCBwYWRkaW5nIHRvLlxuICogQHBhcmFtIGxlbmd0aCAtIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcGFkIHRoZSBidWZmZXIgdG8uXG4gKiBAcmV0dXJucyBUaGUgcGFkZGVkIGJ1ZmZlci5cbiAqL1xuY29uc3QgcGFkU3RhcnQgPSAoYnVmZmVyLCBsZW5ndGggPSBCVUZGRVJfV0lEVEgpID0+IHtcbiAgICBjb25zdCBwYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5tYXgobGVuZ3RoIC0gYnVmZmVyLmxlbmd0aCwgMCkpLmZpbGwoMHgwMCk7XG4gICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShbcGFkZGluZywgYnVmZmVyXSk7XG59O1xuZXhwb3J0cy5wYWRTdGFydCA9IHBhZFN0YXJ0O1xuLyoqXG4gKiBBZGQgcGFkZGluZyB0byBhIGJ1ZmZlci4gSWYgdGhlIGJ1ZmZlciBpcyBsYXJnZXIgdGhhbiBgbGVuZ3RoYCwgdGhpcyBmdW5jdGlvbiB3b24ndCBkbyBhbnl0aGluZy4gSWYgaXQncyBzbWFsbGVyLCB0aGVcbiAqIGJ1ZmZlciB3aWxsIGJlIHBhZGRlZCB0byB0aGUgc3BlY2lmaWVkIGxlbmd0aCwgd2l0aCBleHRyYSB6ZXJvZXMgYXQgdGhlIGVuZC5cbiAqXG4gKiBAcGFyYW0gYnVmZmVyIC0gVGhlIGJ1ZmZlciB0byBhZGQgcGFkZGluZyB0by5cbiAqIEBwYXJhbSBsZW5ndGggLSBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHBhZCB0aGUgYnVmZmVyIHRvLlxuICogQHJldHVybnMgVGhlIHBhZGRlZCBidWZmZXIuXG4gKi9cbmNvbnN0IHBhZEVuZCA9IChidWZmZXIsIGxlbmd0aCA9IEJVRkZFUl9XSURUSCkgPT4ge1xuICAgIGNvbnN0IHBhZGRpbmcgPSBuZXcgVWludDhBcnJheShNYXRoLm1heChsZW5ndGggLSBidWZmZXIubGVuZ3RoLCAwKSkuZmlsbCgweDAwKTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKFtidWZmZXIsIHBhZGRpbmddKTtcbn07XG5leHBvcnRzLnBhZEVuZCA9IHBhZEVuZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwYWRFbmQiLCJwYWRTdGFydCIsInNldCIsInV0aWxzXzEiLCJyZXF1aXJlIiwiQlVGRkVSX1dJRFRIIiwidGFyZ2V0IiwiYnVmZmVyIiwicG9zaXRpb24iLCJjb25jYXRCeXRlcyIsInN1YmFycmF5IiwibGVuZ3RoIiwicGFkZGluZyIsIlVpbnQ4QXJyYXkiLCJNYXRoIiwibWF4IiwiZmlsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/utils/buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/abi-utils/dist/utils/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@metamask/abi-utils/dist/utils/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n__exportStar(__webpack_require__(/*! ./buffer */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/utils/buffer.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3V0aWxzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLGVBQWUsSUFBSyxJQUFJLElBQUksQ0FBQ0EsWUFBWSxJQUFLLFNBQVNaLENBQUMsRUFBRWEsUUFBTztJQUNqRSxJQUFLLElBQUlDLEtBQUtkLEVBQUcsSUFBSWMsTUFBTSxhQUFhLENBQUNqQixPQUFPa0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osVUFBU0MsSUFBSWxCLGdCQUFnQmlCLFVBQVNiLEdBQUdjO0FBQzNIO0FBQ0FqQiw4Q0FBNkM7SUFBRXFCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0ROLGFBQWFPLG1CQUFPQSxDQUFDLCtFQUFVLEdBQUdOLFVBQ2xDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3V0aWxzL2luZGV4LmpzPzk3MjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9idWZmZXJcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZXhwb3J0U3RhciIsImV4cG9ydHMiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmFsdWUiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/abi-utils/dist/utils/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/detect-provider/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@metamask/detect-provider/dist/index.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\n/**\n * Returns a Promise that resolves to the value of window.ethereum if it is\n * set within the given timeout, or null.\n * The Promise will not reject, but an error will be thrown if invalid options\n * are provided.\n *\n * @param options - Options bag.\n * @param options.mustBeMetaMask - Whether to only look for MetaMask providers.\n * Default: false\n * @param options.silent - Whether to silence console errors. Does not affect\n * thrown errors. Default: false\n * @param options.timeout - Milliseconds to wait for 'ethereum#initialized' to\n * be dispatched. Default: 3000\n * @returns A Promise that resolves with the Provider if it is detected within\n * given timeout, otherwise null.\n */ function detectEthereumProvider({ mustBeMetaMask = false, silent = false, timeout = 3000 } = {}) {\n    _validateInputs();\n    let handled = false;\n    return new Promise((resolve)=>{\n        if (window.ethereum) {\n            handleEthereum();\n        } else {\n            window.addEventListener(\"ethereum#initialized\", handleEthereum, {\n                once: true\n            });\n            setTimeout(()=>{\n                handleEthereum();\n            }, timeout);\n        }\n        function handleEthereum() {\n            if (handled) {\n                return;\n            }\n            handled = true;\n            window.removeEventListener(\"ethereum#initialized\", handleEthereum);\n            const { ethereum } = window;\n            if (ethereum && (!mustBeMetaMask || ethereum.isMetaMask)) {\n                resolve(ethereum);\n            } else {\n                const message = mustBeMetaMask && ethereum ? \"Non-MetaMask window.ethereum detected.\" : \"Unable to detect window.ethereum.\";\n                !silent && console.error(\"@metamask/detect-provider:\", message);\n                resolve(null);\n            }\n        }\n    });\n    function _validateInputs() {\n        if (typeof mustBeMetaMask !== \"boolean\") {\n            throw new Error(`@metamask/detect-provider: Expected option 'mustBeMetaMask' to be a boolean.`);\n        }\n        if (typeof silent !== \"boolean\") {\n            throw new Error(`@metamask/detect-provider: Expected option 'silent' to be a boolean.`);\n        }\n        if (typeof timeout !== \"number\") {\n            throw new Error(`@metamask/detect-provider: Expected option 'timeout' to be a number.`);\n        }\n    }\n}\nmodule.exports = detectEthereumProvider; //# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQWdCQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDSCxTQUFTLHNCQUFzQixDQUErQixFQUM1RCxjQUFjLEdBQUcsS0FBSyxFQUN0QixNQUFNLEdBQUcsS0FBSyxFQUNkLE9BQU8sR0FBRyxJQUFJLEdBQ2YsR0FBRyxFQUFFO0lBRUosZUFBZSxFQUFFLENBQUM7SUFFbEIsSUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFDO0lBRXBCLE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRTtRQUM3QixJQUFLLE1BQWlCLENBQUMsUUFBUSxFQUFFO1lBRS9CLGNBQWMsRUFBRSxDQUFDO1NBRWxCO2FBQU07WUFFTCxNQUFNLENBQUMsZ0JBQWdCLENBQ3JCLHNCQUFzQixFQUN0QixjQUFjLEVBQ2QsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQ2YsQ0FBQztZQUVGLFVBQVUsQ0FBQyxHQUFHLEVBQUU7Z0JBQ2QsY0FBYyxFQUFFLENBQUM7WUFDbkIsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQ2I7UUFFRCxTQUFTLGNBQWM7WUFFckIsSUFBSSxPQUFPLEVBQUU7Z0JBQ1gsT0FBTzthQUNSO1lBQ0QsT0FBTyxHQUFHLElBQUksQ0FBQztZQUVmLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxzQkFBc0IsRUFBRSxjQUFjLENBQUMsQ0FBQztZQUVuRSxNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsTUFBZ0IsQ0FBQztZQUV0QyxJQUFJLFFBQVEsSUFBSSxDQUFDLENBQUMsY0FBYyxJQUFJLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRTtnQkFDeEQsT0FBTyxDQUFDLFFBQXdCLENBQUMsQ0FBQzthQUNuQztpQkFBTTtnQkFFTCxNQUFNLE9BQU8sR0FBRyxjQUFjLElBQUksUUFBUTtvQkFDeEMsQ0FBQyxDQUFDLHdDQUF3QztvQkFDMUMsQ0FBQyxDQUFDLG1DQUFtQyxDQUFDO2dCQUV4QyxDQUFDLE1BQU0sSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLDRCQUE0QixFQUFFLE9BQU8sQ0FBQyxDQUFDO2dCQUNoRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDZjtRQUNILENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztJQUVILFNBQVMsZUFBZTtRQUN0QixJQUFJLE9BQU8sY0FBYyxLQUFLLFNBQVMsRUFBRTtZQUN2QyxNQUFNLElBQUksS0FBSyxDQUFDLDhFQUE4RSxDQUFDLENBQUM7U0FDakc7UUFDRCxJQUFJLE9BQU8sTUFBTSxLQUFLLFNBQVMsRUFBRTtZQUMvQixNQUFNLElBQUksS0FBSyxDQUFDLHNFQUFzRSxDQUFDLENBQUM7U0FDekY7UUFDRCxJQUFJLE9BQU8sT0FBTyxLQUFLLFFBQVEsRUFBRTtZQUMvQixNQUFNLElBQUksS0FBSyxDQUFDLHNFQUFzRSxDQUFDLENBQUM7U0FDekY7SUFDSCxDQUFDO0FBQ0gsQ0FBQztBQWxGRCxpQkFBUyxzQkFBc0IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImludGVyZmFjZSBNZXRhTWFza0V0aGVyZXVtUHJvdmlkZXIge1xuICBpc01ldGFNYXNrPzogYm9vbGVhbjtcbiAgb25jZShldmVudE5hbWU6IHN0cmluZyB8IHN5bWJvbCwgbGlzdGVuZXI6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCk6IHRoaXM7XG4gIG9uKGV2ZW50TmFtZTogc3RyaW5nIHwgc3ltYm9sLCBsaXN0ZW5lcjogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkKTogdGhpcztcbiAgb2ZmKGV2ZW50TmFtZTogc3RyaW5nIHwgc3ltYm9sLCBsaXN0ZW5lcjogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkKTogdGhpcztcbiAgYWRkTGlzdGVuZXIoZXZlbnROYW1lOiBzdHJpbmcgfCBzeW1ib2wsIGxpc3RlbmVyOiAoLi4uYXJnczogYW55W10pID0+IHZvaWQpOiB0aGlzO1xuICByZW1vdmVMaXN0ZW5lcihldmVudE5hbWU6IHN0cmluZyB8IHN5bWJvbCwgbGlzdGVuZXI6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCk6IHRoaXM7XG4gIHJlbW92ZUFsbExpc3RlbmVycyhldmVudD86IHN0cmluZyB8IHN5bWJvbCk6IHRoaXM7XG59XG5cbmludGVyZmFjZSBXaW5kb3cge1xuICBldGhlcmV1bT86IE1ldGFNYXNrRXRoZXJldW1Qcm92aWRlcjtcbn1cblxuZXhwb3J0ID0gZGV0ZWN0RXRoZXJldW1Qcm92aWRlcjtcblxuLyoqXG4gKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB2YWx1ZSBvZiB3aW5kb3cuZXRoZXJldW0gaWYgaXQgaXNcbiAqIHNldCB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQsIG9yIG51bGwuXG4gKiBUaGUgUHJvbWlzZSB3aWxsIG5vdCByZWplY3QsIGJ1dCBhbiBlcnJvciB3aWxsIGJlIHRocm93biBpZiBpbnZhbGlkIG9wdGlvbnNcbiAqIGFyZSBwcm92aWRlZC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYmFnLlxuICogQHBhcmFtIG9wdGlvbnMubXVzdEJlTWV0YU1hc2sgLSBXaGV0aGVyIHRvIG9ubHkgbG9vayBmb3IgTWV0YU1hc2sgcHJvdmlkZXJzLlxuICogRGVmYXVsdDogZmFsc2VcbiAqIEBwYXJhbSBvcHRpb25zLnNpbGVudCAtIFdoZXRoZXIgdG8gc2lsZW5jZSBjb25zb2xlIGVycm9ycy4gRG9lcyBub3QgYWZmZWN0XG4gKiB0aHJvd24gZXJyb3JzLiBEZWZhdWx0OiBmYWxzZVxuICogQHBhcmFtIG9wdGlvbnMudGltZW91dCAtIE1pbGxpc2Vjb25kcyB0byB3YWl0IGZvciAnZXRoZXJldW0jaW5pdGlhbGl6ZWQnIHRvXG4gKiBiZSBkaXNwYXRjaGVkLiBEZWZhdWx0OiAzMDAwXG4gKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBQcm92aWRlciBpZiBpdCBpcyBkZXRlY3RlZCB3aXRoaW5cbiAqIGdpdmVuIHRpbWVvdXQsIG90aGVyd2lzZSBudWxsLlxuICovXG5mdW5jdGlvbiBkZXRlY3RFdGhlcmV1bVByb3ZpZGVyPFQgPSBNZXRhTWFza0V0aGVyZXVtUHJvdmlkZXI+KHtcbiAgbXVzdEJlTWV0YU1hc2sgPSBmYWxzZSxcbiAgc2lsZW50ID0gZmFsc2UsXG4gIHRpbWVvdXQgPSAzMDAwLFxufSA9IHt9KTogUHJvbWlzZTxUIHwgbnVsbD4ge1xuXG4gIF92YWxpZGF0ZUlucHV0cygpO1xuXG4gIGxldCBoYW5kbGVkID0gZmFsc2U7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgaWYgKCh3aW5kb3cgYXMgV2luZG93KS5ldGhlcmV1bSkge1xuXG4gICAgICBoYW5kbGVFdGhlcmV1bSgpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICdldGhlcmV1bSNpbml0aWFsaXplZCcsXG4gICAgICAgIGhhbmRsZUV0aGVyZXVtLFxuICAgICAgICB7IG9uY2U6IHRydWUgfSxcbiAgICAgICk7XG5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBoYW5kbGVFdGhlcmV1bSgpO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlRXRoZXJldW0oKSB7XG5cbiAgICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGhhbmRsZWQgPSB0cnVlO1xuXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXRoZXJldW0jaW5pdGlhbGl6ZWQnLCBoYW5kbGVFdGhlcmV1bSk7XG5cbiAgICAgIGNvbnN0IHsgZXRoZXJldW0gfSA9IHdpbmRvdyBhcyBXaW5kb3c7XG5cbiAgICAgIGlmIChldGhlcmV1bSAmJiAoIW11c3RCZU1ldGFNYXNrIHx8IGV0aGVyZXVtLmlzTWV0YU1hc2spKSB7XG4gICAgICAgIHJlc29sdmUoZXRoZXJldW0gYXMgdW5rbm93biBhcyBUKTtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG11c3RCZU1ldGFNYXNrICYmIGV0aGVyZXVtXG4gICAgICAgICAgPyAnTm9uLU1ldGFNYXNrIHdpbmRvdy5ldGhlcmV1bSBkZXRlY3RlZC4nXG4gICAgICAgICAgOiAnVW5hYmxlIHRvIGRldGVjdCB3aW5kb3cuZXRoZXJldW0uJztcblxuICAgICAgICAhc2lsZW50ICYmIGNvbnNvbGUuZXJyb3IoJ0BtZXRhbWFzay9kZXRlY3QtcHJvdmlkZXI6JywgbWVzc2FnZSk7XG4gICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBfdmFsaWRhdGVJbnB1dHMoKSB7XG4gICAgaWYgKHR5cGVvZiBtdXN0QmVNZXRhTWFzayAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEBtZXRhbWFzay9kZXRlY3QtcHJvdmlkZXI6IEV4cGVjdGVkIG9wdGlvbiAnbXVzdEJlTWV0YU1hc2snIHRvIGJlIGEgYm9vbGVhbi5gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzaWxlbnQgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBAbWV0YW1hc2svZGV0ZWN0LXByb3ZpZGVyOiBFeHBlY3RlZCBvcHRpb24gJ3NpbGVudCcgdG8gYmUgYSBib29sZWFuLmApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRpbWVvdXQgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEBtZXRhbWFzay9kZXRlY3QtcHJvdmlkZXI6IEV4cGVjdGVkIG9wdGlvbiAndGltZW91dCcgdG8gYmUgYSBudW1iZXIuYCk7XG4gICAgfVxuICB9XG59XG4iXX0=\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2RldGVjdC1wcm92aWRlci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsU0FBU0EsdUJBQXVCLEVBQUVDLGlCQUFpQixLQUFLLEVBQUVDLFNBQVMsS0FBSyxFQUFFQyxVQUFVLElBQUksRUFBRyxHQUFHLENBQUMsQ0FBQztJQUM1RkM7SUFDQSxJQUFJQyxVQUFVO0lBQ2QsT0FBTyxJQUFJQyxRQUFRLENBQUNDO1FBQ2hCLElBQUlDLE9BQU9DLFFBQVEsRUFBRTtZQUNqQkM7UUFDSixPQUNLO1lBQ0RGLE9BQU9HLGdCQUFnQixDQUFDLHdCQUF3QkQsZ0JBQWdCO2dCQUFFRSxNQUFNO1lBQUs7WUFDN0VDLFdBQVc7Z0JBQ1BIO1lBQ0osR0FBR1A7UUFDUDtRQUNBLFNBQVNPO1lBQ0wsSUFBSUwsU0FBUztnQkFDVDtZQUNKO1lBQ0FBLFVBQVU7WUFDVkcsT0FBT00sbUJBQW1CLENBQUMsd0JBQXdCSjtZQUNuRCxNQUFNLEVBQUVELFFBQVEsRUFBRSxHQUFHRDtZQUNyQixJQUFJQyxZQUFhLEVBQUNSLGtCQUFrQlEsU0FBU00sVUFBVSxHQUFHO2dCQUN0RFIsUUFBUUU7WUFDWixPQUNLO2dCQUNELE1BQU1PLFVBQVVmLGtCQUFrQlEsV0FDNUIsMkNBQ0E7Z0JBQ04sQ0FBQ1AsVUFBVWUsUUFBUUMsS0FBSyxDQUFDLDhCQUE4QkY7Z0JBQ3ZEVCxRQUFRO1lBQ1o7UUFDSjtJQUNKO0lBQ0EsU0FBU0g7UUFDTCxJQUFJLE9BQU9ILG1CQUFtQixXQUFXO1lBQ3JDLE1BQU0sSUFBSWtCLE1BQU0sQ0FBQyw0RUFBNEUsQ0FBQztRQUNsRztRQUNBLElBQUksT0FBT2pCLFdBQVcsV0FBVztZQUM3QixNQUFNLElBQUlpQixNQUFNLENBQUMsb0VBQW9FLENBQUM7UUFDMUY7UUFDQSxJQUFJLE9BQU9oQixZQUFZLFVBQVU7WUFDN0IsTUFBTSxJQUFJZ0IsTUFBTSxDQUFDLG9FQUFvRSxDQUFDO1FBQzFGO0lBQ0o7QUFDSjtBQUNBQyxPQUFPQyxPQUFPLEdBQUdyQix3QkFDakIsMHlMQUEweUwiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9kZXRlY3QtcHJvdmlkZXIvZGlzdC9pbmRleC5qcz8wZWU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB2YWx1ZSBvZiB3aW5kb3cuZXRoZXJldW0gaWYgaXQgaXNcbiAqIHNldCB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQsIG9yIG51bGwuXG4gKiBUaGUgUHJvbWlzZSB3aWxsIG5vdCByZWplY3QsIGJ1dCBhbiBlcnJvciB3aWxsIGJlIHRocm93biBpZiBpbnZhbGlkIG9wdGlvbnNcbiAqIGFyZSBwcm92aWRlZC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYmFnLlxuICogQHBhcmFtIG9wdGlvbnMubXVzdEJlTWV0YU1hc2sgLSBXaGV0aGVyIHRvIG9ubHkgbG9vayBmb3IgTWV0YU1hc2sgcHJvdmlkZXJzLlxuICogRGVmYXVsdDogZmFsc2VcbiAqIEBwYXJhbSBvcHRpb25zLnNpbGVudCAtIFdoZXRoZXIgdG8gc2lsZW5jZSBjb25zb2xlIGVycm9ycy4gRG9lcyBub3QgYWZmZWN0XG4gKiB0aHJvd24gZXJyb3JzLiBEZWZhdWx0OiBmYWxzZVxuICogQHBhcmFtIG9wdGlvbnMudGltZW91dCAtIE1pbGxpc2Vjb25kcyB0byB3YWl0IGZvciAnZXRoZXJldW0jaW5pdGlhbGl6ZWQnIHRvXG4gKiBiZSBkaXNwYXRjaGVkLiBEZWZhdWx0OiAzMDAwXG4gKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBQcm92aWRlciBpZiBpdCBpcyBkZXRlY3RlZCB3aXRoaW5cbiAqIGdpdmVuIHRpbWVvdXQsIG90aGVyd2lzZSBudWxsLlxuICovXG5mdW5jdGlvbiBkZXRlY3RFdGhlcmV1bVByb3ZpZGVyKHsgbXVzdEJlTWV0YU1hc2sgPSBmYWxzZSwgc2lsZW50ID0gZmFsc2UsIHRpbWVvdXQgPSAzMDAwLCB9ID0ge30pIHtcbiAgICBfdmFsaWRhdGVJbnB1dHMoKTtcbiAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBpZiAod2luZG93LmV0aGVyZXVtKSB7XG4gICAgICAgICAgICBoYW5kbGVFdGhlcmV1bSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2V0aGVyZXVtI2luaXRpYWxpemVkJywgaGFuZGxlRXRoZXJldW0sIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZUV0aGVyZXVtKCk7XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVFdGhlcmV1bSgpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXRoZXJldW0jaW5pdGlhbGl6ZWQnLCBoYW5kbGVFdGhlcmV1bSk7XG4gICAgICAgICAgICBjb25zdCB7IGV0aGVyZXVtIH0gPSB3aW5kb3c7XG4gICAgICAgICAgICBpZiAoZXRoZXJldW0gJiYgKCFtdXN0QmVNZXRhTWFzayB8fCBldGhlcmV1bS5pc01ldGFNYXNrKSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZXRoZXJldW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IG11c3RCZU1ldGFNYXNrICYmIGV0aGVyZXVtXG4gICAgICAgICAgICAgICAgICAgID8gJ05vbi1NZXRhTWFzayB3aW5kb3cuZXRoZXJldW0gZGV0ZWN0ZWQuJ1xuICAgICAgICAgICAgICAgICAgICA6ICdVbmFibGUgdG8gZGV0ZWN0IHdpbmRvdy5ldGhlcmV1bS4nO1xuICAgICAgICAgICAgICAgICFzaWxlbnQgJiYgY29uc29sZS5lcnJvcignQG1ldGFtYXNrL2RldGVjdC1wcm92aWRlcjonLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gX3ZhbGlkYXRlSW5wdXRzKCkge1xuICAgICAgICBpZiAodHlwZW9mIG11c3RCZU1ldGFNYXNrICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQG1ldGFtYXNrL2RldGVjdC1wcm92aWRlcjogRXhwZWN0ZWQgb3B0aW9uICdtdXN0QmVNZXRhTWFzaycgdG8gYmUgYSBib29sZWFuLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2lsZW50ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQG1ldGFtYXNrL2RldGVjdC1wcm92aWRlcjogRXhwZWN0ZWQgb3B0aW9uICdzaWxlbnQnIHRvIGJlIGEgYm9vbGVhbi5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRpbWVvdXQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBtZXRhbWFzay9kZXRlY3QtcHJvdmlkZXI6IEV4cGVjdGVkIG9wdGlvbiAndGltZW91dCcgdG8gYmUgYSBudW1iZXIuYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGRldGVjdEV0aGVyZXVtUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhVzVrWlhndWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk5emNtTXZhVzVrWlhndWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRV2RDUVRzN096czdPenM3T3pzN096czdPMGRCWlVjN1FVRkRTQ3hUUVVGVExITkNRVUZ6UWl4RFFVRXJRaXhGUVVNMVJDeGpRVUZqTEVkQlFVY3NTMEZCU3l4RlFVTjBRaXhOUVVGTkxFZEJRVWNzUzBGQlN5eEZRVU5rTEU5QlFVOHNSMEZCUnl4SlFVRkpMRWRCUTJZc1IwRkJSeXhGUVVGRk8wbEJSVW9zWlVGQlpTeEZRVUZGTEVOQlFVTTdTVUZGYkVJc1NVRkJTU3hQUVVGUExFZEJRVWNzUzBGQlN5eERRVUZETzBsQlJYQkNMRTlCUVU4c1NVRkJTU3hQUVVGUExFTkJRVU1zUTBGQlF5eFBRVUZQTEVWQlFVVXNSVUZCUlR0UlFVTTNRaXhKUVVGTExFMUJRV2xDTEVOQlFVTXNVVUZCVVN4RlFVRkZPMWxCUlM5Q0xHTkJRV01zUlVGQlJTeERRVUZETzFOQlJXeENPMkZCUVUwN1dVRkZUQ3hOUVVGTkxFTkJRVU1zWjBKQlFXZENMRU5CUTNKQ0xITkNRVUZ6UWl4RlFVTjBRaXhqUVVGakxFVkJRMlFzUlVGQlJTeEpRVUZKTEVWQlFVVXNTVUZCU1N4RlFVRkZMRU5CUTJZc1EwRkJRenRaUVVWR0xGVkJRVlVzUTBGQlF5eEhRVUZITEVWQlFVVTdaMEpCUTJRc1kwRkJZeXhGUVVGRkxFTkJRVU03V1VGRGJrSXNRMEZCUXl4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8xTkJRMkk3VVVGRlJDeFRRVUZUTEdOQlFXTTdXVUZGY2tJc1NVRkJTU3hQUVVGUExFVkJRVVU3WjBKQlExZ3NUMEZCVHp0aFFVTlNPMWxCUTBRc1QwRkJUeXhIUVVGSExFbEJRVWtzUTBGQlF6dFpRVVZtTEUxQlFVMHNRMEZCUXl4dFFrRkJiVUlzUTBGQlF5eHpRa0ZCYzBJc1JVRkJSU3hqUVVGakxFTkJRVU1zUTBGQlF6dFpRVVZ1UlN4TlFVRk5MRVZCUVVVc1VVRkJVU3hGUVVGRkxFZEJRVWNzVFVGQlowSXNRMEZCUXp0WlFVVjBReXhKUVVGSkxGRkJRVkVzU1VGQlNTeERRVUZETEVOQlFVTXNZMEZCWXl4SlFVRkpMRkZCUVZFc1EwRkJReXhWUVVGVkxFTkJRVU1zUlVGQlJUdG5Ra0ZEZUVRc1QwRkJUeXhEUVVGRExGRkJRWGRDTEVOQlFVTXNRMEZCUXp0aFFVTnVRenRwUWtGQlRUdG5Ra0ZGVEN4TlFVRk5MRTlCUVU4c1IwRkJSeXhqUVVGakxFbEJRVWtzVVVGQlVUdHZRa0ZEZUVNc1EwRkJReXhEUVVGRExIZERRVUYzUXp0dlFrRkRNVU1zUTBGQlF5eERRVUZETEcxRFFVRnRReXhEUVVGRE8yZENRVVY0UXl4RFFVRkRMRTFCUVUwc1NVRkJTU3hQUVVGUExFTkJRVU1zUzBGQlN5eERRVUZETERSQ1FVRTBRaXhGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETzJkQ1FVTm9SU3hQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdZVUZEWmp0UlFVTklMRU5CUVVNN1NVRkRTQ3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVVZJTEZOQlFWTXNaVUZCWlR0UlFVTjBRaXhKUVVGSkxFOUJRVThzWTBGQll5eExRVUZMTEZOQlFWTXNSVUZCUlR0WlFVTjJReXhOUVVGTkxFbEJRVWtzUzBGQlN5eERRVUZETERoRlFVRTRSU3hEUVVGRExFTkJRVU03VTBGRGFrYzdVVUZEUkN4SlFVRkpMRTlCUVU4c1RVRkJUU3hMUVVGTExGTkJRVk1zUlVGQlJUdFpRVU12UWl4TlFVRk5MRWxCUVVrc1MwRkJTeXhEUVVGRExITkZRVUZ6UlN4RFFVRkRMRU5CUVVNN1UwRkRla1k3VVVGRFJDeEpRVUZKTEU5QlFVOHNUMEZCVHl4TFFVRkxMRkZCUVZFc1JVRkJSVHRaUVVNdlFpeE5RVUZOTEVsQlFVa3NTMEZCU3l4RFFVRkRMSE5GUVVGelJTeERRVUZETEVOQlFVTTdVMEZEZWtZN1NVRkRTQ3hEUVVGRE8wRkJRMGdzUTBGQlF6dEJRV3hHUkN4cFFrRkJVeXh6UWtGQmMwSXNRMEZCUXlJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYkltbHVkR1Z5Wm1GalpTQk5aWFJoVFdGemEwVjBhR1Z5WlhWdFVISnZkbWxrWlhJZ2UxeHVJQ0JwYzAxbGRHRk5ZWE5yUHpvZ1ltOXZiR1ZoYmp0Y2JpQWdiMjVqWlNobGRtVnVkRTVoYldVNklITjBjbWx1WnlCOElITjViV0p2YkN3Z2JHbHpkR1Z1WlhJNklDZ3VMaTVoY21kek9pQmhibmxiWFNrZ1BUNGdkbTlwWkNrNklIUm9hWE03WEc0Z0lHOXVLR1YyWlc1MFRtRnRaVG9nYzNSeWFXNW5JSHdnYzNsdFltOXNMQ0JzYVhOMFpXNWxjam9nS0M0dUxtRnlaM002SUdGdWVWdGRLU0E5UGlCMmIybGtLVG9nZEdocGN6dGNiaUFnYjJabUtHVjJaVzUwVG1GdFpUb2djM1J5YVc1bklId2djM2x0WW05c0xDQnNhWE4wWlc1bGNqb2dLQzR1TG1GeVozTTZJR0Z1ZVZ0ZEtTQTlQaUIyYjJsa0tUb2dkR2hwY3p0Y2JpQWdZV1JrVEdsemRHVnVaWElvWlhabGJuUk9ZVzFsT2lCemRISnBibWNnZkNCemVXMWliMndzSUd4cGMzUmxibVZ5T2lBb0xpNHVZWEpuY3pvZ1lXNTVXMTBwSUQwK0lIWnZhV1FwT2lCMGFHbHpPMXh1SUNCeVpXMXZkbVZNYVhOMFpXNWxjaWhsZG1WdWRFNWhiV1U2SUhOMGNtbHVaeUI4SUhONWJXSnZiQ3dnYkdsemRHVnVaWEk2SUNndUxpNWhjbWR6T2lCaGJubGJYU2tnUFQ0Z2RtOXBaQ2s2SUhSb2FYTTdYRzRnSUhKbGJXOTJaVUZzYkV4cGMzUmxibVZ5Y3lobGRtVnVkRDg2SUhOMGNtbHVaeUI4SUhONWJXSnZiQ2s2SUhSb2FYTTdYRzU5WEc1Y2JtbHVkR1Z5Wm1GalpTQlhhVzVrYjNjZ2UxeHVJQ0JsZEdobGNtVjFiVDg2SUUxbGRHRk5ZWE5yUlhSb1pYSmxkVzFRY205MmFXUmxjanRjYm4xY2JseHVaWGh3YjNKMElEMGdaR1YwWldOMFJYUm9aWEpsZFcxUWNtOTJhV1JsY2p0Y2JseHVMeW9xWEc0Z0tpQlNaWFIxY201eklHRWdVSEp2YldselpTQjBhR0YwSUhKbGMyOXNkbVZ6SUhSdklIUm9aU0IyWVd4MVpTQnZaaUIzYVc1a2IzY3VaWFJvWlhKbGRXMGdhV1lnYVhRZ2FYTmNiaUFxSUhObGRDQjNhWFJvYVc0Z2RHaGxJR2RwZG1WdUlIUnBiV1Z2ZFhRc0lHOXlJRzUxYkd3dVhHNGdLaUJVYUdVZ1VISnZiV2x6WlNCM2FXeHNJRzV2ZENCeVpXcGxZM1FzSUdKMWRDQmhiaUJsY25KdmNpQjNhV3hzSUdKbElIUm9jbTkzYmlCcFppQnBiblpoYkdsa0lHOXdkR2x2Ym5OY2JpQXFJR0Z5WlNCd2NtOTJhV1JsWkM1Y2JpQXFYRzRnS2lCQWNHRnlZVzBnYjNCMGFXOXVjeUF0SUU5d2RHbHZibk1nWW1GbkxseHVJQ29nUUhCaGNtRnRJRzl3ZEdsdmJuTXViWFZ6ZEVKbFRXVjBZVTFoYzJzZ0xTQlhhR1YwYUdWeUlIUnZJRzl1YkhrZ2JHOXZheUJtYjNJZ1RXVjBZVTFoYzJzZ2NISnZkbWxrWlhKekxseHVJQ29nUkdWbVlYVnNkRG9nWm1Gc2MyVmNiaUFxSUVCd1lYSmhiU0J2Y0hScGIyNXpMbk5wYkdWdWRDQXRJRmRvWlhSb1pYSWdkRzhnYzJsc1pXNWpaU0JqYjI1emIyeGxJR1Z5Y205eWN5NGdSRzlsY3lCdWIzUWdZV1ptWldOMFhHNGdLaUIwYUhKdmQyNGdaWEp5YjNKekxpQkVaV1poZFd4ME9pQm1ZV3h6WlZ4dUlDb2dRSEJoY21GdElHOXdkR2x2Ym5NdWRHbHRaVzkxZENBdElFMXBiR3hwYzJWamIyNWtjeUIwYnlCM1lXbDBJR1p2Y2lBblpYUm9aWEpsZFcwamFXNXBkR2xoYkdsNlpXUW5JSFJ2WEc0Z0tpQmlaU0JrYVhOd1lYUmphR1ZrTGlCRVpXWmhkV3gwT2lBek1EQXdYRzRnS2lCQWNtVjBkWEp1Y3lCQklGQnliMjFwYzJVZ2RHaGhkQ0J5WlhOdmJIWmxjeUIzYVhSb0lIUm9aU0JRY205MmFXUmxjaUJwWmlCcGRDQnBjeUJrWlhSbFkzUmxaQ0IzYVhSb2FXNWNiaUFxSUdkcGRtVnVJSFJwYldWdmRYUXNJRzkwYUdWeWQybHpaU0J1ZFd4c0xseHVJQ292WEc1bWRXNWpkR2x2YmlCa1pYUmxZM1JGZEdobGNtVjFiVkJ5YjNacFpHVnlQRlFnUFNCTlpYUmhUV0Z6YTBWMGFHVnlaWFZ0VUhKdmRtbGtaWEkrS0h0Y2JpQWdiWFZ6ZEVKbFRXVjBZVTFoYzJzZ1BTQm1ZV3h6WlN4Y2JpQWdjMmxzWlc1MElEMGdabUZzYzJVc1hHNGdJSFJwYldWdmRYUWdQU0F6TURBd0xGeHVmU0E5SUh0OUtUb2dVSEp2YldselpUeFVJSHdnYm5Wc2JENGdlMXh1WEc0Z0lGOTJZV3hwWkdGMFpVbHVjSFYwY3lncE8xeHVYRzRnSUd4bGRDQm9ZVzVrYkdWa0lEMGdabUZzYzJVN1hHNWNiaUFnY21WMGRYSnVJRzVsZHlCUWNtOXRhWE5sS0NoeVpYTnZiSFpsS1NBOVBpQjdYRzRnSUNBZ2FXWWdLQ2gzYVc1a2IzY2dZWE1nVjJsdVpHOTNLUzVsZEdobGNtVjFiU2tnZTF4dVhHNGdJQ0FnSUNCb1lXNWtiR1ZGZEdobGNtVjFiU2dwTzF4dVhHNGdJQ0FnZlNCbGJITmxJSHRjYmx4dUlDQWdJQ0FnZDJsdVpHOTNMbUZrWkVWMlpXNTBUR2x6ZEdWdVpYSW9YRzRnSUNBZ0lDQWdJQ2RsZEdobGNtVjFiU05wYm1sMGFXRnNhWHBsWkNjc1hHNGdJQ0FnSUNBZ0lHaGhibVJzWlVWMGFHVnlaWFZ0TEZ4dUlDQWdJQ0FnSUNCN0lHOXVZMlU2SUhSeWRXVWdmU3hjYmlBZ0lDQWdJQ2s3WEc1Y2JpQWdJQ0FnSUhObGRGUnBiV1Z2ZFhRb0tDa2dQVDRnZTF4dUlDQWdJQ0FnSUNCb1lXNWtiR1ZGZEdobGNtVjFiU2dwTzF4dUlDQWdJQ0FnZlN3Z2RHbHRaVzkxZENrN1hHNGdJQ0FnZlZ4dVhHNGdJQ0FnWm5WdVkzUnBiMjRnYUdGdVpHeGxSWFJvWlhKbGRXMG9LU0I3WEc1Y2JpQWdJQ0FnSUdsbUlDaG9ZVzVrYkdWa0tTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJqdGNiaUFnSUNBZ0lIMWNiaUFnSUNBZ0lHaGhibVJzWldRZ1BTQjBjblZsTzF4dVhHNGdJQ0FnSUNCM2FXNWtiM2N1Y21WdGIzWmxSWFpsYm5STWFYTjBaVzVsY2lnblpYUm9aWEpsZFcwamFXNXBkR2xoYkdsNlpXUW5MQ0JvWVc1a2JHVkZkR2hsY21WMWJTazdYRzVjYmlBZ0lDQWdJR052Ym5OMElIc2daWFJvWlhKbGRXMGdmU0E5SUhkcGJtUnZkeUJoY3lCWGFXNWtiM2M3WEc1Y2JpQWdJQ0FnSUdsbUlDaGxkR2hsY21WMWJTQW1KaUFvSVcxMWMzUkNaVTFsZEdGTllYTnJJSHg4SUdWMGFHVnlaWFZ0TG1selRXVjBZVTFoYzJzcEtTQjdYRzRnSUNBZ0lDQWdJSEpsYzI5c2RtVW9aWFJvWlhKbGRXMGdZWE1nZFc1cmJtOTNiaUJoY3lCVUtUdGNiaUFnSUNBZ0lIMGdaV3h6WlNCN1hHNWNiaUFnSUNBZ0lDQWdZMjl1YzNRZ2JXVnpjMkZuWlNBOUlHMTFjM1JDWlUxbGRHRk5ZWE5ySUNZbUlHVjBhR1Z5WlhWdFhHNGdJQ0FnSUNBZ0lDQWdQeUFuVG05dUxVMWxkR0ZOWVhOcklIZHBibVJ2ZHk1bGRHaGxjbVYxYlNCa1pYUmxZM1JsWkM0blhHNGdJQ0FnSUNBZ0lDQWdPaUFuVlc1aFlteGxJSFJ2SUdSbGRHVmpkQ0IzYVc1a2IzY3VaWFJvWlhKbGRXMHVKenRjYmx4dUlDQWdJQ0FnSUNBaGMybHNaVzUwSUNZbUlHTnZibk52YkdVdVpYSnliM0lvSjBCdFpYUmhiV0Z6YXk5a1pYUmxZM1F0Y0hKdmRtbGtaWEk2Snl3Z2JXVnpjMkZuWlNrN1hHNGdJQ0FnSUNBZ0lISmxjMjlzZG1Vb2JuVnNiQ2s3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmVnh1SUNCOUtUdGNibHh1SUNCbWRXNWpkR2x2YmlCZmRtRnNhV1JoZEdWSmJuQjFkSE1vS1NCN1hHNGdJQ0FnYVdZZ0tIUjVjR1Z2WmlCdGRYTjBRbVZOWlhSaFRXRnpheUFoUFQwZ0oySnZiMnhsWVc0bktTQjdYRzRnSUNBZ0lDQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb1lFQnRaWFJoYldGemF5OWtaWFJsWTNRdGNISnZkbWxrWlhJNklFVjRjR1ZqZEdWa0lHOXdkR2x2YmlBbmJYVnpkRUpsVFdWMFlVMWhjMnNuSUhSdklHSmxJR0VnWW05dmJHVmhiaTVnS1R0Y2JpQWdJQ0I5WEc0Z0lDQWdhV1lnS0hSNWNHVnZaaUJ6YVd4bGJuUWdJVDA5SUNkaWIyOXNaV0Z1SnlrZ2UxeHVJQ0FnSUNBZ2RHaHliM2NnYm1WM0lFVnljbTl5S0dCQWJXVjBZVzFoYzJzdlpHVjBaV04wTFhCeWIzWnBaR1Z5T2lCRmVIQmxZM1JsWkNCdmNIUnBiMjRnSjNOcGJHVnVkQ2NnZEc4Z1ltVWdZU0JpYjI5c1pXRnVMbUFwTzF4dUlDQWdJSDFjYmlBZ0lDQnBaaUFvZEhsd1pXOW1JSFJwYldWdmRYUWdJVDA5SUNkdWRXMWlaWEluS1NCN1hHNGdJQ0FnSUNCMGFISnZkeUJ1WlhjZ1JYSnliM0lvWUVCdFpYUmhiV0Z6YXk5a1pYUmxZM1F0Y0hKdmRtbGtaWEk2SUVWNGNHVmpkR1ZrSUc5d2RHbHZiaUFuZEdsdFpXOTFkQ2NnZEc4Z1ltVWdZU0J1ZFcxaVpYSXVZQ2s3WEc0Z0lDQWdmVnh1SUNCOVhHNTlYRzRpWFgwPSJdLCJuYW1lcyI6WyJkZXRlY3RFdGhlcmV1bVByb3ZpZGVyIiwibXVzdEJlTWV0YU1hc2siLCJzaWxlbnQiLCJ0aW1lb3V0IiwiX3ZhbGlkYXRlSW5wdXRzIiwiaGFuZGxlZCIsIlByb21pc2UiLCJyZXNvbHZlIiwid2luZG93IiwiZXRoZXJldW0iLCJoYW5kbGVFdGhlcmV1bSIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbmNlIiwic2V0VGltZW91dCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJpc01ldGFNYXNrIiwibWVzc2FnZSIsImNvbnNvbGUiLCJlcnJvciIsIkVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/detect-provider/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/eth-sig-util/dist/encryption.js":
/*!****************************************************************!*\
  !*** ./node_modules/@metamask/eth-sig-util/dist/encryption.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getEncryptionPublicKey = exports.decryptSafely = exports.decrypt = exports.encryptSafely = exports.encrypt = void 0;\nconst nacl = __importStar(__webpack_require__(/*! tweetnacl */ \"(ssr)/./node_modules/tweetnacl/nacl-fast.js\"));\nconst naclUtil = __importStar(__webpack_require__(/*! tweetnacl-util */ \"(ssr)/./node_modules/tweetnacl-util/nacl-util.js\"));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@metamask/eth-sig-util/dist/utils.js\");\n/**\n * Encrypt a message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */ function encrypt({ publicKey, data, version }) {\n    if ((0, utils_1.isNullish)(publicKey)) {\n        throw new Error(\"Missing publicKey parameter\");\n    } else if ((0, utils_1.isNullish)(data)) {\n        throw new Error(\"Missing data parameter\");\n    } else if ((0, utils_1.isNullish)(version)) {\n        throw new Error(\"Missing version parameter\");\n    }\n    switch(version){\n        case \"x25519-xsalsa20-poly1305\":\n            {\n                if (typeof data !== \"string\") {\n                    throw new Error(\"Message data must be given as a string\");\n                }\n                // generate ephemeral keypair\n                const ephemeralKeyPair = nacl.box.keyPair();\n                // assemble encryption parameters - from string to UInt8\n                let pubKeyUInt8Array;\n                try {\n                    pubKeyUInt8Array = naclUtil.decodeBase64(publicKey);\n                } catch (err) {\n                    throw new Error(\"Bad public key\");\n                }\n                const msgParamsUInt8Array = naclUtil.decodeUTF8(data);\n                const nonce = nacl.randomBytes(nacl.box.nonceLength);\n                // encrypt\n                const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey);\n                // handle encrypted data\n                const output = {\n                    version: \"x25519-xsalsa20-poly1305\",\n                    nonce: naclUtil.encodeBase64(nonce),\n                    ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),\n                    ciphertext: naclUtil.encodeBase64(encryptedMessage)\n                };\n                // return encrypted msg data\n                return output;\n            }\n        default:\n            throw new Error(\"Encryption type/version not supported\");\n    }\n}\nexports.encrypt = encrypt;\n/**\n * Encrypt a message in a way that obscures the message length.\n *\n * The message is padded to a multiple of 2048 before being encrypted so that the length of the\n * resulting encrypted message can't be used to guess the exact length of the original message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */ function encryptSafely({ publicKey, data, version }) {\n    if ((0, utils_1.isNullish)(publicKey)) {\n        throw new Error(\"Missing publicKey parameter\");\n    } else if ((0, utils_1.isNullish)(data)) {\n        throw new Error(\"Missing data parameter\");\n    } else if ((0, utils_1.isNullish)(version)) {\n        throw new Error(\"Missing version parameter\");\n    }\n    const DEFAULT_PADDING_LENGTH = 2 ** 11;\n    const NACL_EXTRA_BYTES = 16;\n    if (typeof data === \"object\" && data && \"toJSON\" in data) {\n        // remove toJSON attack vector\n        // TODO, check all possible children\n        throw new Error(\"Cannot encrypt with toJSON property.  Please remove toJSON property\");\n    }\n    // add padding\n    const dataWithPadding = {\n        data,\n        padding: \"\"\n    };\n    // calculate padding\n    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), \"utf-8\");\n    const modVal = dataLength % DEFAULT_PADDING_LENGTH;\n    let padLength = 0;\n    // Only pad if necessary\n    if (modVal > 0) {\n        padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes\n    }\n    dataWithPadding.padding = \"0\".repeat(padLength);\n    const paddedMessage = JSON.stringify(dataWithPadding);\n    return encrypt({\n        publicKey,\n        data: paddedMessage,\n        version\n    });\n}\nexports.encryptSafely = encryptSafely;\n/**\n * Decrypt a message.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */ function decrypt({ encryptedData, privateKey }) {\n    if ((0, utils_1.isNullish)(encryptedData)) {\n        throw new Error(\"Missing encryptedData parameter\");\n    } else if ((0, utils_1.isNullish)(privateKey)) {\n        throw new Error(\"Missing privateKey parameter\");\n    }\n    switch(encryptedData.version){\n        case \"x25519-xsalsa20-poly1305\":\n            {\n                // string to buffer to UInt8Array\n                const receiverPrivateKeyUint8Array = naclDecodeHex(privateKey);\n                const receiverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(receiverPrivateKeyUint8Array).secretKey;\n                // assemble decryption parameters\n                const nonce = naclUtil.decodeBase64(encryptedData.nonce);\n                const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);\n                const ephemPublicKey = naclUtil.decodeBase64(encryptedData.ephemPublicKey);\n                // decrypt\n                const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, receiverEncryptionPrivateKey);\n                // return decrypted msg data\n                try {\n                    if (!decryptedMessage) {\n                        throw new Error();\n                    }\n                    const output = naclUtil.encodeUTF8(decryptedMessage);\n                    // TODO: This is probably extraneous but was kept to minimize changes during refactor\n                    if (!output) {\n                        throw new Error();\n                    }\n                    return output;\n                } catch (err) {\n                    if (err && typeof err.message === \"string\" && err.message.length) {\n                        throw new Error(`Decryption failed: ${err.message}`);\n                    }\n                    throw new Error(`Decryption failed.`);\n                }\n            }\n        default:\n            throw new Error(\"Encryption type/version not supported.\");\n    }\n}\nexports.decrypt = decrypt;\n/**\n * Decrypt a message that has been encrypted using `encryptSafely`.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */ function decryptSafely({ encryptedData, privateKey }) {\n    if ((0, utils_1.isNullish)(encryptedData)) {\n        throw new Error(\"Missing encryptedData parameter\");\n    } else if ((0, utils_1.isNullish)(privateKey)) {\n        throw new Error(\"Missing privateKey parameter\");\n    }\n    const dataWithPadding = JSON.parse(decrypt({\n        encryptedData,\n        privateKey\n    }));\n    return dataWithPadding.data;\n}\nexports.decryptSafely = decryptSafely;\n/**\n * Get the encryption public key for the given key.\n *\n * @param privateKey - The private key to generate the encryption public key with.\n * @returns The encryption public key.\n */ function getEncryptionPublicKey(privateKey) {\n    const privateKeyUint8Array = naclDecodeHex(privateKey);\n    const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;\n    return naclUtil.encodeBase64(encryptionPublicKey);\n}\nexports.getEncryptionPublicKey = getEncryptionPublicKey;\n/**\n * Convert a hex string to the UInt8Array format used by nacl.\n *\n * @param msgHex - The string to convert.\n * @returns The converted string.\n */ function naclDecodeHex(msgHex) {\n    const msgBase64 = Buffer.from(msgHex, \"hex\").toString(\"base64\");\n    return naclUtil.decodeBase64(msgBase64);\n} //# sourceMappingURL=encryption.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L2VuY3J5cHRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsSUFBSyxJQUFJLElBQUksQ0FBQ0EsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPUCxPQUFPUSx3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBSixPQUFPYyxjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0wsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSVcscUJBQXFCLElBQUssSUFBSSxJQUFJLENBQUNBLGtCQUFrQixJQUFNZixDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFYyxDQUFDO0lBQ3pGaEIsT0FBT2MsY0FBYyxDQUFDWixHQUFHLFdBQVc7UUFBRVUsWUFBWTtRQUFNSyxPQUFPRDtJQUFFO0FBQ3JFLElBQUssU0FBU2QsQ0FBQyxFQUFFYyxDQUFDO0lBQ2RkLENBQUMsQ0FBQyxVQUFVLEdBQUdjO0FBQ25CO0FBQ0EsSUFBSUUsZUFBZSxJQUFLLElBQUksSUFBSSxDQUFDQSxZQUFZ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QUFNb0Isa0JBQWtCSyxLQUFLaUIsS0FBSyxDQUFDckQsUUFBUTtRQUFFMEM7UUFBZUM7SUFBVztJQUN2RSxPQUFPWixnQkFBZ0J2QixJQUFJO0FBQy9CO0FBQ0FYLHFCQUFxQixHQUFHRTtBQUN4Qjs7Ozs7Q0FLQyxHQUNELFNBQVNELHVCQUF1QjZDLFVBQVU7SUFDdEMsTUFBTVcsdUJBQXVCVCxjQUFjRjtJQUMzQyxNQUFNWSxzQkFBc0JwRCxLQUFLVSxHQUFHLENBQUNDLE9BQU8sQ0FBQ2lDLGFBQWEsQ0FBQ08sc0JBQXNCL0MsU0FBUztJQUMxRixPQUFPRixTQUFTcUIsWUFBWSxDQUFDNkI7QUFDakM7QUFDQTFELDhCQUE4QixHQUFHQztBQUNqQzs7Ozs7Q0FLQyxHQUNELFNBQVMrQyxjQUFjVyxNQUFNO0lBQ3pCLE1BQU1DLFlBQVl2QixPQUFPd0IsSUFBSSxDQUFDRixRQUFRLE9BQU9HLFFBQVEsQ0FBQztJQUN0RCxPQUFPdEQsU0FBU1csWUFBWSxDQUFDeUM7QUFDakMsRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC9lbmNyeXB0aW9uLmpzP2ZjYzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RW5jcnlwdGlvblB1YmxpY0tleSA9IGV4cG9ydHMuZGVjcnlwdFNhZmVseSA9IGV4cG9ydHMuZGVjcnlwdCA9IGV4cG9ydHMuZW5jcnlwdFNhZmVseSA9IGV4cG9ydHMuZW5jcnlwdCA9IHZvaWQgMDtcbmNvbnN0IG5hY2wgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInR3ZWV0bmFjbFwiKSk7XG5jb25zdCBuYWNsVXRpbCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwidHdlZXRuYWNsLXV0aWxcIikpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBFbmNyeXB0IGEgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBlbmNyeXB0aW9uIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5wdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSBvZiB0aGUgbWVzc2FnZSByZWNpcGllbnQuXG4gKiBAcGFyYW0gb3B0aW9ucy5kYXRhIC0gVGhlIG1lc3NhZ2UgZGF0YS5cbiAqIEBwYXJhbSBvcHRpb25zLnZlcnNpb24gLSBUaGUgdHlwZSBvZiBlbmNyeXB0aW9uIHRvIHVzZS5cbiAqIEByZXR1cm5zIFRoZSBlbmNyeXB0ZWQgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZW5jcnlwdCh7IHB1YmxpY0tleSwgZGF0YSwgdmVyc2lvbiwgfSkge1xuICAgIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKHB1YmxpY0tleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHB1YmxpY0tleSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZGF0YSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKSh2ZXJzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdmVyc2lvbiBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICAgIGNhc2UgJ3gyNTUxOS14c2Fsc2EyMC1wb2x5MTMwNSc6IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lc3NhZ2UgZGF0YSBtdXN0IGJlIGdpdmVuIGFzIGEgc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSBlcGhlbWVyYWwga2V5cGFpclxuICAgICAgICAgICAgY29uc3QgZXBoZW1lcmFsS2V5UGFpciA9IG5hY2wuYm94LmtleVBhaXIoKTtcbiAgICAgICAgICAgIC8vIGFzc2VtYmxlIGVuY3J5cHRpb24gcGFyYW1ldGVycyAtIGZyb20gc3RyaW5nIHRvIFVJbnQ4XG4gICAgICAgICAgICBsZXQgcHViS2V5VUludDhBcnJheTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHViS2V5VUludDhBcnJheSA9IG5hY2xVdGlsLmRlY29kZUJhc2U2NChwdWJsaWNLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIHB1YmxpYyBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1zZ1BhcmFtc1VJbnQ4QXJyYXkgPSBuYWNsVXRpbC5kZWNvZGVVVEY4KGRhdGEpO1xuICAgICAgICAgICAgY29uc3Qgbm9uY2UgPSBuYWNsLnJhbmRvbUJ5dGVzKG5hY2wuYm94Lm5vbmNlTGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIGVuY3J5cHRcbiAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRlZE1lc3NhZ2UgPSBuYWNsLmJveChtc2dQYXJhbXNVSW50OEFycmF5LCBub25jZSwgcHViS2V5VUludDhBcnJheSwgZXBoZW1lcmFsS2V5UGFpci5zZWNyZXRLZXkpO1xuICAgICAgICAgICAgLy8gaGFuZGxlIGVuY3J5cHRlZCBkYXRhXG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogJ3gyNTUxOS14c2Fsc2EyMC1wb2x5MTMwNScsXG4gICAgICAgICAgICAgICAgbm9uY2U6IG5hY2xVdGlsLmVuY29kZUJhc2U2NChub25jZSksXG4gICAgICAgICAgICAgICAgZXBoZW1QdWJsaWNLZXk6IG5hY2xVdGlsLmVuY29kZUJhc2U2NChlcGhlbWVyYWxLZXlQYWlyLnB1YmxpY0tleSksXG4gICAgICAgICAgICAgICAgY2lwaGVydGV4dDogbmFjbFV0aWwuZW5jb2RlQmFzZTY0KGVuY3J5cHRlZE1lc3NhZ2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHJldHVybiBlbmNyeXB0ZWQgbXNnIGRhdGFcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiB0eXBlL3ZlcnNpb24gbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbn1cbmV4cG9ydHMuZW5jcnlwdCA9IGVuY3J5cHQ7XG4vKipcbiAqIEVuY3J5cHQgYSBtZXNzYWdlIGluIGEgd2F5IHRoYXQgb2JzY3VyZXMgdGhlIG1lc3NhZ2UgbGVuZ3RoLlxuICpcbiAqIFRoZSBtZXNzYWdlIGlzIHBhZGRlZCB0byBhIG11bHRpcGxlIG9mIDIwNDggYmVmb3JlIGJlaW5nIGVuY3J5cHRlZCBzbyB0aGF0IHRoZSBsZW5ndGggb2YgdGhlXG4gKiByZXN1bHRpbmcgZW5jcnlwdGVkIG1lc3NhZ2UgY2FuJ3QgYmUgdXNlZCB0byBndWVzcyB0aGUgZXhhY3QgbGVuZ3RoIG9mIHRoZSBvcmlnaW5hbCBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGVuY3J5cHRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLnB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IG9mIHRoZSBtZXNzYWdlIHJlY2lwaWVudC5cbiAqIEBwYXJhbSBvcHRpb25zLmRhdGEgLSBUaGUgbWVzc2FnZSBkYXRhLlxuICogQHBhcmFtIG9wdGlvbnMudmVyc2lvbiAtIFRoZSB0eXBlIG9mIGVuY3J5cHRpb24gdG8gdXNlLlxuICogQHJldHVybnMgVGhlIGVuY3J5cHRlZCBkYXRhLlxuICovXG5mdW5jdGlvbiBlbmNyeXB0U2FmZWx5KHsgcHVibGljS2V5LCBkYXRhLCB2ZXJzaW9uLCB9KSB7XG4gICAgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkocHVibGljS2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHVibGljS2V5IHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBkYXRhIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKHZlcnNpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB2ZXJzaW9uIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBERUZBVUxUX1BBRERJTkdfTEVOR1RIID0gMiAqKiAxMTtcbiAgICBjb25zdCBOQUNMX0VYVFJBX0JZVEVTID0gMTY7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBkYXRhICYmICd0b0pTT04nIGluIGRhdGEpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRvSlNPTiBhdHRhY2sgdmVjdG9yXG4gICAgICAgIC8vIFRPRE8sIGNoZWNrIGFsbCBwb3NzaWJsZSBjaGlsZHJlblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmNyeXB0IHdpdGggdG9KU09OIHByb3BlcnR5LiAgUGxlYXNlIHJlbW92ZSB0b0pTT04gcHJvcGVydHknKTtcbiAgICB9XG4gICAgLy8gYWRkIHBhZGRpbmdcbiAgICBjb25zdCBkYXRhV2l0aFBhZGRpbmcgPSB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIHBhZGRpbmc6ICcnLFxuICAgIH07XG4gICAgLy8gY2FsY3VsYXRlIHBhZGRpbmdcbiAgICBjb25zdCBkYXRhTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoSlNPTi5zdHJpbmdpZnkoZGF0YVdpdGhQYWRkaW5nKSwgJ3V0Zi04Jyk7XG4gICAgY29uc3QgbW9kVmFsID0gZGF0YUxlbmd0aCAlIERFRkFVTFRfUEFERElOR19MRU5HVEg7XG4gICAgbGV0IHBhZExlbmd0aCA9IDA7XG4gICAgLy8gT25seSBwYWQgaWYgbmVjZXNzYXJ5XG4gICAgaWYgKG1vZFZhbCA+IDApIHtcbiAgICAgICAgcGFkTGVuZ3RoID0gREVGQVVMVF9QQURESU5HX0xFTkdUSCAtIG1vZFZhbCAtIE5BQ0xfRVhUUkFfQllURVM7IC8vIG5hY2wgZXh0cmEgYnl0ZXNcbiAgICB9XG4gICAgZGF0YVdpdGhQYWRkaW5nLnBhZGRpbmcgPSAnMCcucmVwZWF0KHBhZExlbmd0aCk7XG4gICAgY29uc3QgcGFkZGVkTWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KGRhdGFXaXRoUGFkZGluZyk7XG4gICAgcmV0dXJuIGVuY3J5cHQoeyBwdWJsaWNLZXksIGRhdGE6IHBhZGRlZE1lc3NhZ2UsIHZlcnNpb24gfSk7XG59XG5leHBvcnRzLmVuY3J5cHRTYWZlbHkgPSBlbmNyeXB0U2FmZWx5O1xuLyoqXG4gKiBEZWNyeXB0IGEgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBkZWNyeXB0aW9uIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5lbmNyeXB0ZWREYXRhIC0gVGhlIGVuY3J5cHRlZCBkYXRhLlxuICogQHBhcmFtIG9wdGlvbnMucHJpdmF0ZUtleSAtIFRoZSBwcml2YXRlIGtleSB0byBkZWNyeXB0IHdpdGguXG4gKiBAcmV0dXJucyBUaGUgZGVjcnlwdGVkIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGRlY3J5cHQoeyBlbmNyeXB0ZWREYXRhLCBwcml2YXRlS2V5LCB9KSB7XG4gICAgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoZW5jcnlwdGVkRGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGVuY3J5cHRlZERhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHByaXZhdGVLZXkgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIHN3aXRjaCAoZW5jcnlwdGVkRGF0YS52ZXJzaW9uKSB7XG4gICAgICAgIGNhc2UgJ3gyNTUxOS14c2Fsc2EyMC1wb2x5MTMwNSc6IHtcbiAgICAgICAgICAgIC8vIHN0cmluZyB0byBidWZmZXIgdG8gVUludDhBcnJheVxuICAgICAgICAgICAgY29uc3QgcmVjZWl2ZXJQcml2YXRlS2V5VWludDhBcnJheSA9IG5hY2xEZWNvZGVIZXgocHJpdmF0ZUtleSk7XG4gICAgICAgICAgICBjb25zdCByZWNlaXZlckVuY3J5cHRpb25Qcml2YXRlS2V5ID0gbmFjbC5ib3gua2V5UGFpci5mcm9tU2VjcmV0S2V5KHJlY2VpdmVyUHJpdmF0ZUtleVVpbnQ4QXJyYXkpLnNlY3JldEtleTtcbiAgICAgICAgICAgIC8vIGFzc2VtYmxlIGRlY3J5cHRpb24gcGFyYW1ldGVyc1xuICAgICAgICAgICAgY29uc3Qgbm9uY2UgPSBuYWNsVXRpbC5kZWNvZGVCYXNlNjQoZW5jcnlwdGVkRGF0YS5ub25jZSk7XG4gICAgICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gbmFjbFV0aWwuZGVjb2RlQmFzZTY0KGVuY3J5cHRlZERhdGEuY2lwaGVydGV4dCk7XG4gICAgICAgICAgICBjb25zdCBlcGhlbVB1YmxpY0tleSA9IG5hY2xVdGlsLmRlY29kZUJhc2U2NChlbmNyeXB0ZWREYXRhLmVwaGVtUHVibGljS2V5KTtcbiAgICAgICAgICAgIC8vIGRlY3J5cHRcbiAgICAgICAgICAgIGNvbnN0IGRlY3J5cHRlZE1lc3NhZ2UgPSBuYWNsLmJveC5vcGVuKGNpcGhlcnRleHQsIG5vbmNlLCBlcGhlbVB1YmxpY0tleSwgcmVjZWl2ZXJFbmNyeXB0aW9uUHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAvLyByZXR1cm4gZGVjcnlwdGVkIG1zZyBkYXRhXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghZGVjcnlwdGVkTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gbmFjbFV0aWwuZW5jb2RlVVRGOChkZWNyeXB0ZWRNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIHByb2JhYmx5IGV4dHJhbmVvdXMgYnV0IHdhcyBrZXB0IHRvIG1pbmltaXplIGNoYW5nZXMgZHVyaW5nIHJlZmFjdG9yXG4gICAgICAgICAgICAgICAgaWYgKCFvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciAmJiB0eXBlb2YgZXJyLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIGVyci5tZXNzYWdlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlY3J5cHRpb24gZmFpbGVkOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERlY3J5cHRpb24gZmFpbGVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gdHlwZS92ZXJzaW9uIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWNyeXB0ID0gZGVjcnlwdDtcbi8qKlxuICogRGVjcnlwdCBhIG1lc3NhZ2UgdGhhdCBoYXMgYmVlbiBlbmNyeXB0ZWQgdXNpbmcgYGVuY3J5cHRTYWZlbHlgLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGRlY3J5cHRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLmVuY3J5cHRlZERhdGEgLSBUaGUgZW5jcnlwdGVkIGRhdGEuXG4gKiBAcGFyYW0gb3B0aW9ucy5wcml2YXRlS2V5IC0gVGhlIHByaXZhdGUga2V5IHRvIGRlY3J5cHQgd2l0aC5cbiAqIEByZXR1cm5zIFRoZSBkZWNyeXB0ZWQgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZGVjcnlwdFNhZmVseSh7IGVuY3J5cHRlZERhdGEsIHByaXZhdGVLZXksIH0pIHtcbiAgICBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShlbmNyeXB0ZWREYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZW5jcnlwdGVkRGF0YSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShwcml2YXRlS2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZUtleSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YVdpdGhQYWRkaW5nID0gSlNPTi5wYXJzZShkZWNyeXB0KHsgZW5jcnlwdGVkRGF0YSwgcHJpdmF0ZUtleSB9KSk7XG4gICAgcmV0dXJuIGRhdGFXaXRoUGFkZGluZy5kYXRhO1xufVxuZXhwb3J0cy5kZWNyeXB0U2FmZWx5ID0gZGVjcnlwdFNhZmVseTtcbi8qKlxuICogR2V0IHRoZSBlbmNyeXB0aW9uIHB1YmxpYyBrZXkgZm9yIHRoZSBnaXZlbiBrZXkuXG4gKlxuICogQHBhcmFtIHByaXZhdGVLZXkgLSBUaGUgcHJpdmF0ZSBrZXkgdG8gZ2VuZXJhdGUgdGhlIGVuY3J5cHRpb24gcHVibGljIGtleSB3aXRoLlxuICogQHJldHVybnMgVGhlIGVuY3J5cHRpb24gcHVibGljIGtleS5cbiAqL1xuZnVuY3Rpb24gZ2V0RW5jcnlwdGlvblB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gICAgY29uc3QgcHJpdmF0ZUtleVVpbnQ4QXJyYXkgPSBuYWNsRGVjb2RlSGV4KHByaXZhdGVLZXkpO1xuICAgIGNvbnN0IGVuY3J5cHRpb25QdWJsaWNLZXkgPSBuYWNsLmJveC5rZXlQYWlyLmZyb21TZWNyZXRLZXkocHJpdmF0ZUtleVVpbnQ4QXJyYXkpLnB1YmxpY0tleTtcbiAgICByZXR1cm4gbmFjbFV0aWwuZW5jb2RlQmFzZTY0KGVuY3J5cHRpb25QdWJsaWNLZXkpO1xufVxuZXhwb3J0cy5nZXRFbmNyeXB0aW9uUHVibGljS2V5ID0gZ2V0RW5jcnlwdGlvblB1YmxpY0tleTtcbi8qKlxuICogQ29udmVydCBhIGhleCBzdHJpbmcgdG8gdGhlIFVJbnQ4QXJyYXkgZm9ybWF0IHVzZWQgYnkgbmFjbC5cbiAqXG4gKiBAcGFyYW0gbXNnSGV4IC0gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG5hY2xEZWNvZGVIZXgobXNnSGV4KSB7XG4gICAgY29uc3QgbXNnQmFzZTY0ID0gQnVmZmVyLmZyb20obXNnSGV4LCAnaGV4JykudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIHJldHVybiBuYWNsVXRpbC5kZWNvZGVCYXNlNjQobXNnQmFzZTY0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuY3J5cHRpb24uanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsInYiLCJ2YWx1ZSIsIl9faW1wb3J0U3RhciIsIm1vZCIsInJlc3VsdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImV4cG9ydHMiLCJnZXRFbmNyeXB0aW9uUHVibGljS2V5IiwiZGVjcnlwdFNhZmVseSIsImRlY3J5cHQiLCJlbmNyeXB0U2FmZWx5IiwiZW5jcnlwdCIsIm5hY2wiLCJyZXF1aXJlIiwibmFjbFV0aWwiLCJ1dGlsc18xIiwicHVibGljS2V5IiwiZGF0YSIsInZlcnNpb24iLCJpc051bGxpc2giLCJFcnJvciIsImVwaGVtZXJhbEtleVBhaXIiLCJib3giLCJrZXlQYWlyIiwicHViS2V5VUludDhBcnJheSIsImRlY29kZUJhc2U2NCIsImVyciIsIm1zZ1BhcmFtc1VJbnQ4QXJyYXkiLCJkZWNvZGVVVEY4Iiwibm9uY2UiLCJyYW5kb21CeXRlcyIsIm5vbmNlTGVuZ3RoIiwiZW5jcnlwdGVkTWVzc2FnZSIsInNlY3JldEtleSIsIm91dHB1dCIsImVuY29kZUJhc2U2NCIsImVwaGVtUHVibGljS2V5IiwiY2lwaGVydGV4dCIsIkRFRkFVTFRfUEFERElOR19MRU5HVEgiLCJOQUNMX0VYVFJBX0JZVEVTIiwiZGF0YVdpdGhQYWRkaW5nIiwicGFkZGluZyIsImRhdGFMZW5ndGgiLCJCdWZmZXIiLCJieXRlTGVuZ3RoIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1vZFZhbCIsInBhZExlbmd0aCIsInJlcGVhdCIsInBhZGRlZE1lc3NhZ2UiLCJlbmNyeXB0ZWREYXRhIiwicHJpdmF0ZUtleSIsInJlY2VpdmVyUHJpdmF0ZUtleVVpbnQ4QXJyYXkiLCJuYWNsRGVjb2RlSGV4IiwicmVjZWl2ZXJFbmNyeXB0aW9uUHJpdmF0ZUtleSIsImZyb21TZWNyZXRLZXkiLCJkZWNyeXB0ZWRNZXNzYWdlIiwib3BlbiIsImVuY29kZVVURjgiLCJtZXNzYWdlIiwibGVuZ3RoIiwicGFyc2UiLCJwcml2YXRlS2V5VWludDhBcnJheSIsImVuY3J5cHRpb25QdWJsaWNLZXkiLCJtc2dIZXgiLCJtc2dCYXNlNjQiLCJmcm9tIiwidG9TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/eth-sig-util/dist/encryption.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/eth-sig-util/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@metamask/eth-sig-util/dist/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.normalize = exports.concatSig = void 0;\n__exportStar(__webpack_require__(/*! ./personal-sign */ \"(ssr)/./node_modules/@metamask/eth-sig-util/dist/personal-sign.js\"), exports);\n__exportStar(__webpack_require__(/*! ./sign-typed-data */ \"(ssr)/./node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js\"), exports);\n__exportStar(__webpack_require__(/*! ./encryption */ \"(ssr)/./node_modules/@metamask/eth-sig-util/dist/encryption.js\"), exports);\nvar utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@metamask/eth-sig-util/dist/utils.js\");\nObject.defineProperty(exports, \"concatSig\", ({\n    enumerable: true,\n    get: function() {\n        return utils_1.concatSig;\n    }\n}));\nObject.defineProperty(exports, \"normalize\", ({\n    enumerable: true,\n    get: function() {\n        return utils_1.normalize;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLGVBQWUsSUFBSyxJQUFJLElBQUksQ0FBQ0EsWUFBWSxJQUFLLFNBQVNaLENBQUMsRUFBRWEsUUFBTztJQUNqRSxJQUFLLElBQUlDLEtBQUtkLEVBQUcsSUFBSWMsTUFBTSxhQUFhLENBQUNqQixPQUFPa0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osVUFBU0MsSUFBSWxCLGdCQUFnQmlCLFVBQVNiLEdBQUdjO0FBQzNIO0FBQ0FqQiw4Q0FBNkM7SUFBRXFCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RMLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBRyxLQUFLO0FBQzdDRCxhQUFhUyxtQkFBT0EsQ0FBQywwRkFBaUIsR0FBR1I7QUFDekNELGFBQWFTLG1CQUFPQSxDQUFDLDhGQUFtQixHQUFHUjtBQUMzQ0QsYUFBYVMsbUJBQU9BLENBQUMsb0ZBQWMsR0FBR1I7QUFDdEMsSUFBSVMsVUFBVUQsbUJBQU9BLENBQUMsMEVBQVM7QUFDL0J4Qiw2Q0FBNEM7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT1ksUUFBUUYsU0FBUztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2pIdkIsNkNBQTRDO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9ZLFFBQVFILFNBQVM7SUFBRTtBQUFFLENBQUMsRUFBQyxFQUNqSCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC9pbmRleC5qcz8wOGM1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IGV4cG9ydHMuY29uY2F0U2lnID0gdm9pZCAwO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3BlcnNvbmFsLXNpZ25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NpZ24tdHlwZWQtZGF0YVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZW5jcnlwdGlvblwiKSwgZXhwb3J0cyk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uY2F0U2lnXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLmNvbmNhdFNpZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5vcm1hbGl6ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5ub3JtYWxpemU7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19leHBvcnRTdGFyIiwiZXhwb3J0cyIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ2YWx1ZSIsIm5vcm1hbGl6ZSIsImNvbmNhdFNpZyIsInJlcXVpcmUiLCJ1dGlsc18xIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/eth-sig-util/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/eth-sig-util/dist/personal-sign.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@metamask/eth-sig-util/dist/personal-sign.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.extractPublicKey = exports.recoverPersonalSignature = exports.personalSign = void 0;\nconst util_1 = __webpack_require__(/*! @ethereumjs/util */ \"(ssr)/./node_modules/@ethereumjs/util/dist/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@metamask/eth-sig-util/dist/utils.js\");\n/**\n * Create an Ethereum-specific signature for a message.\n *\n * This function is equivalent to the `eth_sign` Ethereum JSON-RPC method as specified in EIP-1417,\n * as well as the MetaMask's `personal_sign` method.\n *\n * @param options - The personal sign options.\n * @param options.privateKey - The key to sign with.\n * @param options.data - The hex data to sign.\n * @returns The '0x'-prefixed hex encoded signature.\n */ function personalSign({ privateKey, data }) {\n    if ((0, utils_1.isNullish)(data)) {\n        throw new Error(\"Missing data parameter\");\n    } else if ((0, utils_1.isNullish)(privateKey)) {\n        throw new Error(\"Missing privateKey parameter\");\n    }\n    const message = (0, utils_1.legacyToBuffer)(data);\n    const msgHash = (0, util_1.hashPersonalMessage)(message);\n    const sig = (0, util_1.ecsign)(msgHash, privateKey);\n    const serialized = (0, utils_1.concatSig)((0, util_1.toBuffer)(sig.v), sig.r, sig.s);\n    return serialized;\n}\nexports.personalSign = personalSign;\n/**\n * Recover the address of the account used to create the given Ethereum signature. The message\n * must have been signed using the `personalSign` function, or an equivalent function.\n *\n * @param options - The signature recovery options.\n * @param options.data - The hex data that was signed.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @returns The '0x'-prefixed hex encoded address of the message signer.\n */ function recoverPersonalSignature({ data, signature }) {\n    if ((0, utils_1.isNullish)(data)) {\n        throw new Error(\"Missing data parameter\");\n    } else if ((0, utils_1.isNullish)(signature)) {\n        throw new Error(\"Missing signature parameter\");\n    }\n    const publicKey = getPublicKeyFor(data, signature);\n    const sender = (0, util_1.publicToAddress)(publicKey);\n    const senderHex = (0, util_1.bufferToHex)(sender);\n    return senderHex;\n}\nexports.recoverPersonalSignature = recoverPersonalSignature;\n/**\n * Recover the public key of the account used to create the given Ethereum signature. The message\n * must have been signed using the `personalSign` function, or an equivalent function.\n *\n * @param options - The public key recovery options.\n * @param options.data - The hex data that was signed.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @returns The '0x'-prefixed hex encoded public key of the message signer.\n */ function extractPublicKey({ data, signature }) {\n    if ((0, utils_1.isNullish)(data)) {\n        throw new Error(\"Missing data parameter\");\n    } else if ((0, utils_1.isNullish)(signature)) {\n        throw new Error(\"Missing signature parameter\");\n    }\n    const publicKey = getPublicKeyFor(data, signature);\n    return `0x${publicKey.toString(\"hex\")}`;\n}\nexports.extractPublicKey = extractPublicKey;\n/**\n * Get the public key for the given signature and message.\n *\n * @param message - The message that was signed.\n * @param signature - The '0x'-prefixed hex encoded message signature.\n * @returns The public key of the signer.\n */ function getPublicKeyFor(message, signature) {\n    const messageHash = (0, util_1.hashPersonalMessage)((0, utils_1.legacyToBuffer)(message));\n    return (0, utils_1.recoverPublicKey)(messageHash, signature);\n} //# sourceMappingURL=personal-sign.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L3BlcnNvbmFsLXNpZ24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHdCQUF3QixHQUFHQSxnQ0FBZ0MsR0FBR0Esb0JBQW9CLEdBQUcsS0FBSztBQUMxRixNQUFNSyxTQUFTQyxtQkFBT0EsQ0FBQyw2RUFBa0I7QUFDekMsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsMEVBQVM7QUFDakM7Ozs7Ozs7Ozs7Q0FVQyxHQUNELFNBQVNGLGFBQWEsRUFBRUksVUFBVSxFQUFFQyxJQUFJLEVBQUc7SUFDdkMsSUFBSSxDQUFDLEdBQUdGLFFBQVFHLFNBQVMsRUFBRUQsT0FBTztRQUM5QixNQUFNLElBQUlFLE1BQU07SUFDcEIsT0FDSyxJQUFJLENBQUMsR0FBR0osUUFBUUcsU0FBUyxFQUFFRixhQUFhO1FBQ3pDLE1BQU0sSUFBSUcsTUFBTTtJQUNwQjtJQUNBLE1BQU1DLFVBQVUsQ0FBQyxHQUFHTCxRQUFRTSxjQUFjLEVBQUVKO0lBQzVDLE1BQU1LLFVBQVUsQ0FBQyxHQUFHVCxPQUFPVSxtQkFBbUIsRUFBRUg7SUFDaEQsTUFBTUksTUFBTSxDQUFDLEdBQUdYLE9BQU9ZLE1BQU0sRUFBRUgsU0FBU047SUFDeEMsTUFBTVUsYUFBYSxDQUFDLEdBQUdYLFFBQVFZLFNBQVMsRUFBRSxDQUFDLEdBQUdkLE9BQU9lLFFBQVEsRUFBRUosSUFBSUssQ0FBQyxHQUFHTCxJQUFJTSxDQUFDLEVBQUVOLElBQUlPLENBQUM7SUFDbkYsT0FBT0w7QUFDWDtBQUNBbEIsb0JBQW9CLEdBQUdJO0FBQ3ZCOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0QseUJBQXlCLEVBQUVNLElBQUksRUFBRWUsU0FBUyxFQUFHO0lBQ2xELElBQUksQ0FBQyxHQUFHakIsUUFBUUcsU0FBUyxFQUFFRCxPQUFPO1FBQzlCLE1BQU0sSUFBSUUsTUFBTTtJQUNwQixPQUNLLElBQUksQ0FBQyxHQUFHSixRQUFRRyxTQUFTLEVBQUVjLFlBQVk7UUFDeEMsTUFBTSxJQUFJYixNQUFNO0lBQ3BCO0lBQ0EsTUFBTWMsWUFBWUMsZ0JBQWdCakIsTUFBTWU7SUFDeEMsTUFBTUcsU0FBUyxDQUFDLEdBQUd0QixPQUFPdUIsZUFBZSxFQUFFSDtJQUMzQyxNQUFNSSxZQUFZLENBQUMsR0FBR3hCLE9BQU95QixXQUFXLEVBQUVIO0lBQzFDLE9BQU9FO0FBQ1g7QUFDQTdCLGdDQUFnQyxHQUFHRztBQUNuQzs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNELGlCQUFpQixFQUFFTyxJQUFJLEVBQUVlLFNBQVMsRUFBRztJQUMxQyxJQUFJLENBQUMsR0FBR2pCLFFBQVFHLFNBQVMsRUFBRUQsT0FBTztRQUM5QixNQUFNLElBQUlFLE1BQU07SUFDcEIsT0FDSyxJQUFJLENBQUMsR0FBR0osUUFBUUcsU0FBUyxFQUFFYyxZQUFZO1FBQ3hDLE1BQU0sSUFBSWIsTUFBTTtJQUNwQjtJQUNBLE1BQU1jLFlBQVlDLGdCQUFnQmpCLE1BQU1lO0lBQ3hDLE9BQU8sQ0FBQyxFQUFFLEVBQUVDLFVBQVVNLFFBQVEsQ0FBQyxPQUFPLENBQUM7QUFDM0M7QUFDQS9CLHdCQUF3QixHQUFHRTtBQUMzQjs7Ozs7O0NBTUMsR0FDRCxTQUFTd0IsZ0JBQWdCZCxPQUFPLEVBQUVZLFNBQVM7SUFDdkMsTUFBTVEsY0FBYyxDQUFDLEdBQUczQixPQUFPVSxtQkFBbUIsRUFBRSxDQUFDLEdBQUdSLFFBQVFNLGNBQWMsRUFBRUQ7SUFDaEYsT0FBTyxDQUFDLEdBQUdMLFFBQVEwQixnQkFBZ0IsRUFBRUQsYUFBYVI7QUFDdEQsRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC9wZXJzb25hbC1zaWduLmpzP2MwZjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dHJhY3RQdWJsaWNLZXkgPSBleHBvcnRzLnJlY292ZXJQZXJzb25hbFNpZ25hdHVyZSA9IGV4cG9ydHMucGVyc29uYWxTaWduID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIkBldGhlcmV1bWpzL3V0aWxcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIENyZWF0ZSBhbiBFdGhlcmV1bS1zcGVjaWZpYyBzaWduYXR1cmUgZm9yIGEgbWVzc2FnZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGBldGhfc2lnbmAgRXRoZXJldW0gSlNPTi1SUEMgbWV0aG9kIGFzIHNwZWNpZmllZCBpbiBFSVAtMTQxNyxcbiAqIGFzIHdlbGwgYXMgdGhlIE1ldGFNYXNrJ3MgYHBlcnNvbmFsX3NpZ25gIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwZXJzb25hbCBzaWduIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5wcml2YXRlS2V5IC0gVGhlIGtleSB0byBzaWduIHdpdGguXG4gKiBAcGFyYW0gb3B0aW9ucy5kYXRhIC0gVGhlIGhleCBkYXRhIHRvIHNpZ24uXG4gKiBAcmV0dXJucyBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggZW5jb2RlZCBzaWduYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIHBlcnNvbmFsU2lnbih7IHByaXZhdGVLZXksIGRhdGEsIH0pIHtcbiAgICBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZGF0YSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShwcml2YXRlS2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZUtleSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9ICgwLCB1dGlsc18xLmxlZ2FjeVRvQnVmZmVyKShkYXRhKTtcbiAgICBjb25zdCBtc2dIYXNoID0gKDAsIHV0aWxfMS5oYXNoUGVyc29uYWxNZXNzYWdlKShtZXNzYWdlKTtcbiAgICBjb25zdCBzaWcgPSAoMCwgdXRpbF8xLmVjc2lnbikobXNnSGFzaCwgcHJpdmF0ZUtleSk7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9ICgwLCB1dGlsc18xLmNvbmNhdFNpZykoKDAsIHV0aWxfMS50b0J1ZmZlcikoc2lnLnYpLCBzaWcuciwgc2lnLnMpO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xufVxuZXhwb3J0cy5wZXJzb25hbFNpZ24gPSBwZXJzb25hbFNpZ247XG4vKipcbiAqIFJlY292ZXIgdGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdXNlZCB0byBjcmVhdGUgdGhlIGdpdmVuIEV0aGVyZXVtIHNpZ25hdHVyZS4gVGhlIG1lc3NhZ2VcbiAqIG11c3QgaGF2ZSBiZWVuIHNpZ25lZCB1c2luZyB0aGUgYHBlcnNvbmFsU2lnbmAgZnVuY3Rpb24sIG9yIGFuIGVxdWl2YWxlbnQgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgc2lnbmF0dXJlIHJlY292ZXJ5IG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5kYXRhIC0gVGhlIGhleCBkYXRhIHRoYXQgd2FzIHNpZ25lZC5cbiAqIEBwYXJhbSBvcHRpb25zLnNpZ25hdHVyZSAtIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIG1lc3NhZ2Ugc2lnbmF0dXJlLlxuICogQHJldHVybnMgVGhlICcweCctcHJlZml4ZWQgaGV4IGVuY29kZWQgYWRkcmVzcyBvZiB0aGUgbWVzc2FnZSBzaWduZXIuXG4gKi9cbmZ1bmN0aW9uIHJlY292ZXJQZXJzb25hbFNpZ25hdHVyZSh7IGRhdGEsIHNpZ25hdHVyZSwgfSkge1xuICAgIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBkYXRhIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKHNpZ25hdHVyZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHNpZ25hdHVyZSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5Rm9yKGRhdGEsIHNpZ25hdHVyZSk7XG4gICAgY29uc3Qgc2VuZGVyID0gKDAsIHV0aWxfMS5wdWJsaWNUb0FkZHJlc3MpKHB1YmxpY0tleSk7XG4gICAgY29uc3Qgc2VuZGVySGV4ID0gKDAsIHV0aWxfMS5idWZmZXJUb0hleCkoc2VuZGVyKTtcbiAgICByZXR1cm4gc2VuZGVySGV4O1xufVxuZXhwb3J0cy5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmUgPSByZWNvdmVyUGVyc29uYWxTaWduYXR1cmU7XG4vKipcbiAqIFJlY292ZXIgdGhlIHB1YmxpYyBrZXkgb2YgdGhlIGFjY291bnQgdXNlZCB0byBjcmVhdGUgdGhlIGdpdmVuIEV0aGVyZXVtIHNpZ25hdHVyZS4gVGhlIG1lc3NhZ2VcbiAqIG11c3QgaGF2ZSBiZWVuIHNpZ25lZCB1c2luZyB0aGUgYHBlcnNvbmFsU2lnbmAgZnVuY3Rpb24sIG9yIGFuIGVxdWl2YWxlbnQgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgcHVibGljIGtleSByZWNvdmVyeSBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMuZGF0YSAtIFRoZSBoZXggZGF0YSB0aGF0IHdhcyBzaWduZWQuXG4gKiBAcGFyYW0gb3B0aW9ucy5zaWduYXR1cmUgLSBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggZW5jb2RlZCBtZXNzYWdlIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIHB1YmxpYyBrZXkgb2YgdGhlIG1lc3NhZ2Ugc2lnbmVyLlxuICovXG5mdW5jdGlvbiBleHRyYWN0UHVibGljS2V5KHsgZGF0YSwgc2lnbmF0dXJlLCB9KSB7XG4gICAgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoc2lnbmF0dXJlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc2lnbmF0dXJlIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXlGb3IoZGF0YSwgc2lnbmF0dXJlKTtcbiAgICByZXR1cm4gYDB4JHtwdWJsaWNLZXkudG9TdHJpbmcoJ2hleCcpfWA7XG59XG5leHBvcnRzLmV4dHJhY3RQdWJsaWNLZXkgPSBleHRyYWN0UHVibGljS2V5O1xuLyoqXG4gKiBHZXQgdGhlIHB1YmxpYyBrZXkgZm9yIHRoZSBnaXZlbiBzaWduYXR1cmUgYW5kIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0aGF0IHdhcyBzaWduZWQuXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlICcweCctcHJlZml4ZWQgaGV4IGVuY29kZWQgbWVzc2FnZSBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgcHVibGljIGtleSBvZiB0aGUgc2lnbmVyLlxuICovXG5mdW5jdGlvbiBnZXRQdWJsaWNLZXlGb3IobWVzc2FnZSwgc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgbWVzc2FnZUhhc2ggPSAoMCwgdXRpbF8xLmhhc2hQZXJzb25hbE1lc3NhZ2UpKCgwLCB1dGlsc18xLmxlZ2FjeVRvQnVmZmVyKShtZXNzYWdlKSk7XG4gICAgcmV0dXJuICgwLCB1dGlsc18xLnJlY292ZXJQdWJsaWNLZXkpKG1lc3NhZ2VIYXNoLCBzaWduYXR1cmUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVyc29uYWwtc2lnbi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJleHRyYWN0UHVibGljS2V5IiwicmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlIiwicGVyc29uYWxTaWduIiwidXRpbF8xIiwicmVxdWlyZSIsInV0aWxzXzEiLCJwcml2YXRlS2V5IiwiZGF0YSIsImlzTnVsbGlzaCIsIkVycm9yIiwibWVzc2FnZSIsImxlZ2FjeVRvQnVmZmVyIiwibXNnSGFzaCIsImhhc2hQZXJzb25hbE1lc3NhZ2UiLCJzaWciLCJlY3NpZ24iLCJzZXJpYWxpemVkIiwiY29uY2F0U2lnIiwidG9CdWZmZXIiLCJ2IiwiciIsInMiLCJzaWduYXR1cmUiLCJwdWJsaWNLZXkiLCJnZXRQdWJsaWNLZXlGb3IiLCJzZW5kZXIiLCJwdWJsaWNUb0FkZHJlc3MiLCJzZW5kZXJIZXgiLCJidWZmZXJUb0hleCIsInRvU3RyaW5nIiwibWVzc2FnZUhhc2giLCJyZWNvdmVyUHVibGljS2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/eth-sig-util/dist/personal-sign.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.recoverTypedSignature = exports.signTypedData = exports.typedSignatureHash = exports.TypedDataUtils = exports.TYPED_MESSAGE_SCHEMA = exports.SignTypedDataVersion = void 0;\nconst util_1 = __webpack_require__(/*! @ethereumjs/util */ \"(ssr)/./node_modules/@ethereumjs/util/dist/index.js\");\nconst abi_utils_1 = __webpack_require__(/*! @metamask/abi-utils */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/index.js\");\nconst parsers_1 = __webpack_require__(/*! @metamask/abi-utils/dist/parsers */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/parsers/index.js\");\nconst utils_1 = __webpack_require__(/*! @metamask/abi-utils/dist/utils */ \"(ssr)/./node_modules/@metamask/abi-utils/dist/utils/index.js\");\nconst utils_2 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/utils/dist/index.js\");\nconst keccak_1 = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(ssr)/./node_modules/ethereum-cryptography/keccak.js\");\nconst utils_3 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@metamask/eth-sig-util/dist/utils.js\");\n/**\n * Represents the version of `signTypedData` being used.\n *\n * V1 is based upon [an early version of\n * EIP-712](https://github.com/ethereum/EIPs/pull/712/commits/21abe254fe0452d8583d5b132b1d7be87c0439ca)\n * that lacked some later security improvements, and should generally be neglected in favor of\n * later versions.\n *\n * V3 is based on EIP-712, except that arrays and recursive data structures are not supported.\n *\n * V4 is based on EIP-712, and includes full support of arrays and recursive data structures.\n */ var SignTypedDataVersion;\n(function(SignTypedDataVersion) {\n    SignTypedDataVersion[\"V1\"] = \"V1\";\n    SignTypedDataVersion[\"V3\"] = \"V3\";\n    SignTypedDataVersion[\"V4\"] = \"V4\";\n})(SignTypedDataVersion = exports.SignTypedDataVersion || (exports.SignTypedDataVersion = {}));\nexports.TYPED_MESSAGE_SCHEMA = {\n    type: \"object\",\n    properties: {\n        types: {\n            type: \"object\",\n            additionalProperties: {\n                type: \"array\",\n                items: {\n                    type: \"object\",\n                    properties: {\n                        name: {\n                            type: \"string\"\n                        },\n                        type: {\n                            type: \"string\"\n                        }\n                    },\n                    required: [\n                        \"name\",\n                        \"type\"\n                    ]\n                }\n            }\n        },\n        primaryType: {\n            type: \"string\"\n        },\n        domain: {\n            type: \"object\"\n        },\n        message: {\n            type: \"object\"\n        }\n    },\n    required: [\n        \"types\",\n        \"primaryType\",\n        \"domain\",\n        \"message\"\n    ]\n};\n/**\n * Validate that the given value is a valid version string.\n *\n * @param version - The version value to validate.\n * @param allowedVersions - A list of allowed versions. If omitted, all versions are assumed to be\n * allowed.\n */ function validateVersion(version, allowedVersions) {\n    if (!Object.keys(SignTypedDataVersion).includes(version)) {\n        throw new Error(`Invalid version: '${version}'`);\n    } else if (allowedVersions && !allowedVersions.includes(version)) {\n        throw new Error(`SignTypedDataVersion not allowed: '${version}'. Allowed versions are: ${allowedVersions.join(\", \")}`);\n    }\n}\n/**\n * Parse a string, number, or bigint value into a `Uint8Array`.\n *\n * @param type - The type of the value.\n * @param value - The value to parse.\n * @returns The parsed value.\n */ function parseNumber(type, value) {\n    (0, utils_2.assert)(value !== null, `Unable to encode value: Invalid number. Expected a valid number value, but received \"${value}\".`);\n    const bigIntValue = BigInt(value);\n    const length = (0, parsers_1.getLength)(type);\n    const maxValue = BigInt(2) ** BigInt(length) - BigInt(1);\n    // Note that this is not accurate, since the actual maximum value for unsigned\n    // integers is `2 ^ (length - 1) - 1`, but this is required for backwards\n    // compatibility with the old implementation.\n    (0, utils_2.assert)(bigIntValue >= -maxValue && bigIntValue <= maxValue, `Unable to encode value: Number \"${value}\" is out of range for type \"${type}\".`);\n    return bigIntValue;\n}\n/**\n * Parse an address string to a `Uint8Array`. The behaviour of this is quite\n * strange, in that it does not parse the address as hexadecimal string, nor as\n * UTF-8. It does some weird stuff with the string and char codes, and then\n * returns the result as a `Uint8Array`.\n *\n * This is based on the old `ethereumjs-abi` implementation, which essentially\n * calls `new BN(address, 10)` on the address string, the equivalent of calling\n * `parseInt(address, 10)` in JavaScript. This is not a valid way to parse an\n * address and would result in `NaN` in plain JavaScript, but it is the\n * behaviour of the old implementation, and so we must preserve it for backwards\n * compatibility.\n *\n * @param address - The address to parse.\n * @returns The parsed address.\n */ function reallyStrangeAddressToBytes(address) {\n    let addressValue = BigInt(0);\n    for(let i = 0; i < address.length; i++){\n        const character = BigInt(address.charCodeAt(i) - 48);\n        addressValue *= BigInt(10);\n        // 'a'\n        if (character >= 49) {\n            addressValue += character - BigInt(49) + BigInt(0xa);\n        // 'A'\n        } else if (character >= 17) {\n            addressValue += character - BigInt(17) + BigInt(0xa);\n        // '0' - '9'\n        } else {\n            addressValue += character;\n        }\n    }\n    return (0, utils_1.padStart)((0, utils_2.bigIntToBytes)(addressValue), 20);\n}\n/**\n * Encode a single field.\n *\n * @param types - All type definitions.\n * @param name - The name of the field to encode.\n * @param type - The type of the field being encoded.\n * @param value - The value to encode.\n * @param version - The EIP-712 version the encoding should comply with.\n * @returns Encoded representation of the field.\n */ function encodeField(types, name, type, // TODO: constrain type on `value`\nvalue, version) {\n    validateVersion(version, [\n        SignTypedDataVersion.V3,\n        SignTypedDataVersion.V4\n    ]);\n    if (types[type] !== undefined) {\n        return [\n            \"bytes32\",\n            // TODO: return Buffer, remove string from return type\n            version === SignTypedDataVersion.V4 && value == null // eslint-disable-line no-eq-null\n             ? \"0x0000000000000000000000000000000000000000000000000000000000000000\" : (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(encodeData(type, value, types, version)))\n        ];\n    }\n    // `function` is supported in `@metamask/abi-utils`, but not allowed by\n    // EIP-712, so we throw an error here.\n    if (type === \"function\") {\n        throw new Error('Unsupported or invalid type: \"function\"');\n    }\n    if (value === undefined) {\n        throw new Error(`missing value for field ${name} of type ${type}`);\n    }\n    if (type === \"address\") {\n        if (typeof value === \"number\") {\n            return [\n                \"address\",\n                (0, utils_1.padStart)((0, utils_2.numberToBytes)(value), 20)\n            ];\n        } else if ((0, utils_2.isStrictHexString)(value)) {\n            return [\n                \"address\",\n                (0, utils_2.add0x)(value)\n            ];\n        } else if (typeof value === \"string\") {\n            return [\n                \"address\",\n                reallyStrangeAddressToBytes(value).subarray(0, 20)\n            ];\n        }\n    }\n    if (type === \"bool\") {\n        return [\n            \"bool\",\n            Boolean(value)\n        ];\n    }\n    if (type === \"bytes\") {\n        if (typeof value === \"number\") {\n            value = (0, utils_2.numberToBytes)(value);\n        } else if ((0, utils_2.isStrictHexString)(value) || value === \"0x\") {\n            value = (0, utils_2.hexToBytes)(value);\n        } else if (typeof value === \"string\") {\n            value = (0, utils_2.stringToBytes)(value);\n        }\n        return [\n            \"bytes32\",\n            (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(value))\n        ];\n    }\n    if (type.startsWith(\"bytes\") && type !== \"bytes\" && !type.includes(\"[\")) {\n        if (typeof value === \"number\") {\n            if (value < 0) {\n                return [\n                    \"bytes32\",\n                    new Uint8Array(32)\n                ];\n            }\n            return [\n                \"bytes32\",\n                (0, utils_2.bigIntToBytes)(BigInt(value))\n            ];\n        } else if ((0, utils_2.isStrictHexString)(value)) {\n            return [\n                \"bytes32\",\n                (0, utils_2.hexToBytes)(value)\n            ];\n        }\n        return [\n            \"bytes32\",\n            value\n        ];\n    }\n    if (type.startsWith(\"int\") && !type.includes(\"[\")) {\n        const bigIntValue = parseNumber(type, value);\n        if (bigIntValue >= BigInt(0)) {\n            return [\n                \"uint256\",\n                bigIntValue\n            ];\n        }\n        return [\n            \"int256\",\n            bigIntValue\n        ];\n    }\n    if (type === \"string\") {\n        if (typeof value === \"number\") {\n            value = (0, utils_2.numberToBytes)(value);\n        } else {\n            value = (0, utils_2.stringToBytes)(value !== null && value !== void 0 ? value : \"\");\n        }\n        return [\n            \"bytes32\",\n            (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(value))\n        ];\n    }\n    if (type.endsWith(\"]\")) {\n        if (version === SignTypedDataVersion.V3) {\n            throw new Error(\"Arrays are unimplemented in encodeData; use V4 extension\");\n        }\n        const parsedType = type.slice(0, type.lastIndexOf(\"[\"));\n        const typeValuePairs = value.map((item)=>encodeField(types, name, parsedType, item, version));\n        return [\n            \"bytes32\",\n            (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, abi_utils_1.encode)(typeValuePairs.map(([t])=>t), typeValuePairs.map(([, v])=>v))))\n        ];\n    }\n    return [\n        type,\n        value\n    ];\n}\n/**\n * Encodes an object by encoding and concatenating each of its members.\n *\n * @param primaryType - The root type.\n * @param data - The object to encode.\n * @param types - Type definitions for all types included in the message.\n * @param version - The EIP-712 version the encoding should comply with.\n * @returns An encoded representation of an object.\n */ function encodeData(primaryType, data, types, version) {\n    validateVersion(version, [\n        SignTypedDataVersion.V3,\n        SignTypedDataVersion.V4\n    ]);\n    const encodedTypes = [\n        \"bytes32\"\n    ];\n    const encodedValues = [\n        hashType(primaryType, types)\n    ];\n    for (const field of types[primaryType]){\n        if (version === SignTypedDataVersion.V3 && data[field.name] === undefined) {\n            continue;\n        }\n        const [type, value] = encodeField(types, field.name, field.type, data[field.name], version);\n        encodedTypes.push(type);\n        encodedValues.push(value);\n    }\n    return (0, util_1.arrToBufArr)((0, abi_utils_1.encode)(encodedTypes, encodedValues));\n}\n/**\n * Encodes the type of an object by encoding a comma delimited list of its members.\n *\n * @param primaryType - The root type to encode.\n * @param types - Type definitions for all types included in the message.\n * @returns An encoded representation of the primary type.\n */ function encodeType(primaryType, types) {\n    let result = \"\";\n    const unsortedDeps = findTypeDependencies(primaryType, types);\n    unsortedDeps.delete(primaryType);\n    const deps = [\n        primaryType,\n        ...Array.from(unsortedDeps).sort()\n    ];\n    for (const type of deps){\n        const children = types[type];\n        if (!children) {\n            throw new Error(`No type definition specified: ${type}`);\n        }\n        result += `${type}(${types[type].map(({ name, type: t })=>`${t} ${name}`).join(\",\")})`;\n    }\n    return result;\n}\n/**\n * Finds all types within a type definition object.\n *\n * @param primaryType - The root type.\n * @param types - Type definitions for all types included in the message.\n * @param results - The current set of accumulated types.\n * @returns The set of all types found in the type definition.\n */ function findTypeDependencies(primaryType, types, results = new Set()) {\n    if (typeof primaryType !== \"string\") {\n        throw new Error(`Invalid findTypeDependencies input ${JSON.stringify(primaryType)}`);\n    }\n    const match = primaryType.match(/^\\w*/u);\n    [primaryType] = match;\n    if (results.has(primaryType) || types[primaryType] === undefined) {\n        return results;\n    }\n    results.add(primaryType);\n    for (const field of types[primaryType]){\n        findTypeDependencies(field.type, types, results);\n    }\n    return results;\n}\n/**\n * Hashes an object.\n *\n * @param primaryType - The root type.\n * @param data - The object to hash.\n * @param types - Type definitions for all types included in the message.\n * @param version - The EIP-712 version the encoding should comply with.\n * @returns The hash of the object.\n */ function hashStruct(primaryType, data, types, version) {\n    validateVersion(version, [\n        SignTypedDataVersion.V3,\n        SignTypedDataVersion.V4\n    ]);\n    const encoded = encodeData(primaryType, data, types, version);\n    const hashed = (0, keccak_1.keccak256)(encoded);\n    const buf = (0, util_1.arrToBufArr)(hashed);\n    return buf;\n}\n/**\n * Hashes the type of an object.\n *\n * @param primaryType - The root type to hash.\n * @param types - Type definitions for all types included in the message.\n * @returns The hash of the object type.\n */ function hashType(primaryType, types) {\n    const encodedHashType = (0, utils_2.stringToBytes)(encodeType(primaryType, types));\n    return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(encodedHashType));\n}\n/**\n * Removes properties from a message object that are not defined per EIP-712.\n *\n * @param data - The typed message object.\n * @returns The typed message object with only allowed fields.\n */ function sanitizeData(data) {\n    const sanitizedData = {};\n    for(const key in exports.TYPED_MESSAGE_SCHEMA.properties){\n        if (data[key]) {\n            sanitizedData[key] = data[key];\n        }\n    }\n    if (\"types\" in sanitizedData) {\n        // TODO: Fix types\n        sanitizedData.types = Object.assign({\n            EIP712Domain: []\n        }, sanitizedData.types);\n    }\n    return sanitizedData;\n}\n/**\n * Create a EIP-712 Domain Hash.\n * This hash is used at the top of the EIP-712 encoding.\n *\n * @param typedData - The typed message to hash.\n * @param version - The EIP-712 version the encoding should comply with.\n * @returns The hash of the domain object.\n */ function eip712DomainHash(typedData, version) {\n    validateVersion(version, [\n        SignTypedDataVersion.V3,\n        SignTypedDataVersion.V4\n    ]);\n    const sanitizedData = sanitizeData(typedData);\n    const { domain } = sanitizedData;\n    const domainType = {\n        EIP712Domain: sanitizedData.types.EIP712Domain\n    };\n    return hashStruct(\"EIP712Domain\", domain, domainType, version);\n}\n/**\n * Hash a typed message according to EIP-712. The returned message starts with the EIP-712 prefix,\n * which is \"1901\", followed by the hash of the domain separator, then the data (if any).\n * The result is hashed again and returned.\n *\n * This function does not sign the message. The resulting hash must still be signed to create an\n * EIP-712 signature.\n *\n * @param typedData - The typed message to hash.\n * @param version - The EIP-712 version the encoding should comply with.\n * @returns The hash of the typed message.\n */ function eip712Hash(typedData, version) {\n    validateVersion(version, [\n        SignTypedDataVersion.V3,\n        SignTypedDataVersion.V4\n    ]);\n    const sanitizedData = sanitizeData(typedData);\n    const parts = [\n        (0, utils_2.hexToBytes)(\"1901\")\n    ];\n    parts.push(eip712DomainHash(typedData, version));\n    if (sanitizedData.primaryType !== \"EIP712Domain\") {\n        parts.push(hashStruct(// TODO: Validate that this is a string, so this type cast can be removed.\n        sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, version));\n    }\n    return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, utils_2.concatBytes)(parts)));\n}\n/**\n * A collection of utility functions used for signing typed data.\n */ exports.TypedDataUtils = {\n    encodeData,\n    encodeType,\n    findTypeDependencies,\n    hashStruct,\n    hashType,\n    sanitizeData,\n    eip712Hash,\n    eip712DomainHash\n};\n/**\n * Generate the \"V1\" hash for the provided typed message.\n *\n * The hash will be generated in accordance with an earlier version of the EIP-712\n * specification. This hash is used in `signTypedData_v1`.\n *\n * @param typedData - The typed message.\n * @returns The '0x'-prefixed hex encoded hash representing the type of the provided message.\n */ function typedSignatureHash(typedData) {\n    const hashBuffer = _typedSignatureHash(typedData);\n    return (0, utils_2.bytesToHex)(hashBuffer);\n}\nexports.typedSignatureHash = typedSignatureHash;\n/**\n * Normalize a value, so that `@metamask/abi-utils` can handle it. This\n * matches the behaviour of the `ethereumjs-abi` library.\n *\n * @param type - The type of the value to normalize.\n * @param value - The value to normalize.\n * @returns The normalized value.\n */ function normalizeValue(type, value) {\n    if ((0, parsers_1.isArrayType)(type) && Array.isArray(value)) {\n        const [innerType] = (0, parsers_1.getArrayType)(type);\n        return value.map((item)=>normalizeValue(innerType, item));\n    }\n    if (type === \"address\") {\n        if (typeof value === \"number\") {\n            return (0, utils_1.padStart)((0, utils_2.numberToBytes)(value), 20);\n        }\n        if ((0, utils_2.isStrictHexString)(value)) {\n            return (0, utils_1.padStart)((0, utils_2.hexToBytes)(value).subarray(0, 20), 20);\n        }\n        if (value instanceof Uint8Array) {\n            return (0, utils_1.padStart)(value.subarray(0, 20), 20);\n        }\n    }\n    if (type === \"bool\") {\n        return Boolean(value);\n    }\n    if (type.startsWith(\"bytes\") && type !== \"bytes\") {\n        const length = (0, parsers_1.getByteLength)(type);\n        if (typeof value === \"number\") {\n            if (value < 0) {\n                // `solidityPack(['bytesN'], [-1])` returns `0x00..00`.\n                return new Uint8Array();\n            }\n            return (0, utils_2.numberToBytes)(value).subarray(0, length);\n        }\n        if ((0, utils_2.isStrictHexString)(value)) {\n            return (0, utils_2.hexToBytes)(value).subarray(0, length);\n        }\n        if (value instanceof Uint8Array) {\n            return value.subarray(0, length);\n        }\n    }\n    if (type.startsWith(\"uint\")) {\n        if (typeof value === \"number\") {\n            return Math.abs(value);\n        }\n    }\n    if (type.startsWith(\"int\")) {\n        if (typeof value === \"number\") {\n            const length = (0, parsers_1.getLength)(type);\n            return BigInt.asIntN(length, BigInt(value));\n        }\n    }\n    return value;\n}\n/**\n * For some reason `ethereumjs-abi` treats `address` and `address[]` differently\n * so we need to normalize `address[]` differently.\n *\n * @param values - The values to normalize.\n * @returns The normalized values.\n */ function normalizeAddresses(values) {\n    return values.map((value)=>{\n        if (typeof value === \"number\") {\n            return (0, utils_1.padStart)((0, utils_2.numberToBytes)(value), 32);\n        }\n        if ((0, utils_2.isStrictHexString)(value)) {\n            return (0, utils_1.padStart)((0, utils_2.hexToBytes)(value).subarray(0, 32), 32);\n        }\n        if (value instanceof Uint8Array) {\n            return (0, utils_1.padStart)(value.subarray(0, 32), 32);\n        }\n        return value;\n    });\n}\n/**\n * For some reason `ethereumjs-abi` treats `intN` and `intN[]` differently\n * so we need to normalize `intN[]` differently.\n *\n * @param type - The type of the value to normalize.\n * @param values - The values to normalize.\n * @returns The normalized values.\n */ function normalizeIntegers(type, values) {\n    return values.map((value)=>{\n        if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"bigint\") {\n            const bigIntValue = parseNumber(type, value);\n            if (bigIntValue >= BigInt(0)) {\n                return (0, utils_1.padStart)((0, utils_2.bigIntToBytes)(bigIntValue), 32);\n            }\n            const length = (0, parsers_1.getLength)(type);\n            const asIntN = BigInt.asIntN(length, bigIntValue);\n            return (0, utils_2.signedBigIntToBytes)(asIntN, 32);\n        }\n        return value;\n    });\n}\n/**\n * Generate the \"V1\" hash for the provided typed message.\n *\n * The hash will be generated in accordance with an earlier version of the EIP-712\n * specification. This hash is used in `signTypedData_v1`.\n *\n * @param typedData - The typed message.\n * @returns The hash representing the type of the provided message.\n */ function _typedSignatureHash(typedData) {\n    const error = new Error(\"Expect argument to be non-empty array\");\n    if (typeof typedData !== \"object\" || !(\"length\" in typedData) || !typedData.length) {\n        throw error;\n    }\n    const normalizedData = typedData.map(({ name, type, value })=>{\n        // Handle an edge case with `address[]` types.\n        if (type === \"address[]\") {\n            return {\n                name,\n                type: \"bytes32[]\",\n                value: normalizeAddresses(value)\n            };\n        }\n        // Handle an edge case with `intN[]` types.\n        if (type.startsWith(\"int\") && (0, parsers_1.isArrayType)(type)) {\n            const [innerType, length] = (0, parsers_1.getArrayType)(type);\n            return {\n                name,\n                type: `bytes32[${length !== null && length !== void 0 ? length : \"\"}]`,\n                value: normalizeIntegers(innerType, value)\n            };\n        }\n        return {\n            name,\n            type,\n            value: normalizeValue(type, value)\n        };\n    });\n    const data = normalizedData.map((e)=>{\n        if (e.type !== \"bytes\") {\n            return e.value;\n        }\n        return (0, utils_3.legacyToBuffer)(e.value);\n    });\n    const types = normalizedData.map((e)=>{\n        if (e.type === \"function\") {\n            throw new Error('Unsupported or invalid type: \"function\"');\n        }\n        return e.type;\n    });\n    const schema = typedData.map((e)=>{\n        if (!e.name) {\n            throw error;\n        }\n        return `${e.type} ${e.name}`;\n    });\n    return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, abi_utils_1.encodePacked)([\n        \"bytes32\",\n        \"bytes32\"\n    ], [\n        (0, keccak_1.keccak256)((0, abi_utils_1.encodePacked)([\n            \"string[]\"\n        ], [\n            schema\n        ], true)),\n        (0, keccak_1.keccak256)((0, abi_utils_1.encodePacked)(types, data, true))\n    ])));\n}\n/**\n * Sign typed data according to EIP-712. The signing differs based upon the `version`.\n *\n * V1 is based upon [an early version of\n * EIP-712](https://github.com/ethereum/EIPs/pull/712/commits/21abe254fe0452d8583d5b132b1d7be87c0439ca)\n * that lacked some later security improvements, and should generally be neglected in favor of\n * later versions.\n *\n * V3 is based on [EIP-712](https://eips.ethereum.org/EIPS/eip-712), except that arrays and\n * recursive data structures are not supported.\n *\n * V4 is based on [EIP-712](https://eips.ethereum.org/EIPS/eip-712), and includes full support of\n * arrays and recursive data structures.\n *\n * @param options - The signing options.\n * @param options.privateKey - The private key to sign with.\n * @param options.data - The typed data to sign.\n * @param options.version - The signing version to use.\n * @returns The '0x'-prefixed hex encoded signature.\n */ function signTypedData({ privateKey, data, version }) {\n    validateVersion(version);\n    if ((0, utils_3.isNullish)(data)) {\n        throw new Error(\"Missing data parameter\");\n    } else if ((0, utils_3.isNullish)(privateKey)) {\n        throw new Error(\"Missing private key parameter\");\n    }\n    const messageHash = version === SignTypedDataVersion.V1 ? _typedSignatureHash(data) : exports.TypedDataUtils.eip712Hash(data, version);\n    const sig = (0, util_1.ecsign)(messageHash, privateKey);\n    return (0, utils_3.concatSig)((0, util_1.arrToBufArr)((0, utils_2.bigIntToBytes)(sig.v)), sig.r, sig.s);\n}\nexports.signTypedData = signTypedData;\n/**\n * Recover the address of the account that created the given EIP-712\n * signature. The version provided must match the version used to\n * create the signature.\n *\n * @param options - The signature recovery options.\n * @param options.data - The typed data that was signed.\n * @param options.signature - The '0x-prefixed hex encoded message signature.\n * @param options.version - The signing version to use.\n * @returns The '0x'-prefixed hex address of the signer.\n */ function recoverTypedSignature({ data, signature, version }) {\n    validateVersion(version);\n    if ((0, utils_3.isNullish)(data)) {\n        throw new Error(\"Missing data parameter\");\n    } else if ((0, utils_3.isNullish)(signature)) {\n        throw new Error(\"Missing signature parameter\");\n    }\n    const messageHash = version === SignTypedDataVersion.V1 ? _typedSignatureHash(data) : exports.TypedDataUtils.eip712Hash(data, version);\n    const publicKey = (0, utils_3.recoverPublicKey)(messageHash, signature);\n    const sender = (0, util_1.publicToAddress)(publicKey);\n    return (0, utils_2.bytesToHex)(sender);\n}\nexports.recoverTypedSignature = recoverTypedSignature; //# sourceMappingURL=sign-typed-data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L3NpZ24tdHlwZWQtZGF0YS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNkJBQTZCLEdBQUdBLHFCQUFxQixHQUFHQSwwQkFBMEIsR0FBR0Esc0JBQXNCLEdBQUdBLDRCQUE0QixHQUFHQSw0QkFBNEIsR0FBRyxLQUFLO0FBQ2pMLE1BQU1RLFNBQVNDLG1CQUFPQSxDQUFDLDZFQUFrQjtBQUN6QyxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyxtRkFBcUI7QUFDakQsTUFBTUUsWUFBWUYsbUJBQU9BLENBQUMsd0dBQWtDO0FBQzVELE1BQU1HLFVBQVVILG1CQUFPQSxDQUFDLG9HQUFnQztBQUN4RCxNQUFNSSxVQUFVSixtQkFBT0EsQ0FBQywyRUFBaUI7QUFDekMsTUFBTUssV0FBV0wsbUJBQU9BLENBQUMsMEZBQThCO0FBQ3ZELE1BQU1NLFVBQVVOLG1CQUFPQSxDQUFDLDBFQUFTO0FBQ2pDOzs7Ozs7Ozs7OztDQVdDLEdBQ0QsSUFBSUY7QUFDSCxVQUFVQSxvQkFBb0I7SUFDM0JBLG9CQUFvQixDQUFDLEtBQUssR0FBRztJQUM3QkEsb0JBQW9CLENBQUMsS0FBSyxHQUFHO0lBQzdCQSxvQkFBb0IsQ0FBQyxLQUFLLEdBQUc7QUFDakMsR0FBR0EsdUJBQXVCUCxRQUFRTyxvQkFBb0IsSUFBS1AsQ0FBQUEsNEJBQTRCLEdBQUcsQ0FBQztBQUMzRkEsNEJBQTRCLEdBQUc7SUFDM0JnQixNQUFNO0lBQ05DLFlBQVk7UUFDUkMsT0FBTztZQUNIRixNQUFNO1lBQ05HLHNCQUFzQjtnQkFDbEJILE1BQU07Z0JBQ05JLE9BQU87b0JBQ0hKLE1BQU07b0JBQ05DLFlBQVk7d0JBQ1JJLE1BQU07NEJBQUVMLE1BQU07d0JBQVM7d0JBQ3ZCQSxNQUFNOzRCQUFFQSxNQUFNO3dCQUFTO29CQUMzQjtvQkFDQU0sVUFBVTt3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RSxDQUFDLEdBQUd2QyxRQUFRa0MsYUFBYSxFQUFFNEYsSUFBSWxFLENBQUMsSUFBSWtFLElBQUlHLENBQUMsRUFBRUgsSUFBSUksQ0FBQztBQUMxRztBQUNBL0kscUJBQXFCLEdBQUdHO0FBQ3hCOzs7Ozs7Ozs7O0NBVUMsR0FDRCxTQUFTRCxzQkFBc0IsRUFBRXdFLElBQUksRUFBRXNFLFNBQVMsRUFBRXJILE9BQU8sRUFBRztJQUN4REQsZ0JBQWdCQztJQUNoQixJQUFJLENBQUMsR0FBR1osUUFBUXlILFNBQVMsRUFBRTlELE9BQU87UUFDOUIsTUFBTSxJQUFJM0MsTUFBTTtJQUNwQixPQUNLLElBQUksQ0FBQyxHQUFHaEIsUUFBUXlILFNBQVMsRUFBRVEsWUFBWTtRQUN4QyxNQUFNLElBQUlqSCxNQUFNO0lBQ3BCO0lBQ0EsTUFBTTBHLGNBQWM5RyxZQUFZcEIscUJBQXFCbUksRUFBRSxHQUNqRHhCLG9CQUFvQnhDLFFBQ3BCMUUsUUFBUUssY0FBYyxDQUFDeUcsVUFBVSxDQUFDcEMsTUFBTS9DO0lBQzlDLE1BQU1zSCxZQUFZLENBQUMsR0FBR2xJLFFBQVFtSSxnQkFBZ0IsRUFBRVQsYUFBYU87SUFDN0QsTUFBTUcsU0FBUyxDQUFDLEdBQUczSSxPQUFPNEksZUFBZSxFQUFFSDtJQUMzQyxPQUFPLENBQUMsR0FBR3BJLFFBQVFzRyxVQUFVLEVBQUVnQztBQUNuQztBQUNBbkosNkJBQTZCLEdBQUdFLHVCQUNoQywyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC9zaWduLXR5cGVkLWRhdGEuanM/MGYwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVjb3ZlclR5cGVkU2lnbmF0dXJlID0gZXhwb3J0cy5zaWduVHlwZWREYXRhID0gZXhwb3J0cy50eXBlZFNpZ25hdHVyZUhhc2ggPSBleHBvcnRzLlR5cGVkRGF0YVV0aWxzID0gZXhwb3J0cy5UWVBFRF9NRVNTQUdFX1NDSEVNQSA9IGV4cG9ydHMuU2lnblR5cGVkRGF0YVZlcnNpb24gPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiQGV0aGVyZXVtanMvdXRpbFwiKTtcbmNvbnN0IGFiaV91dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay9hYmktdXRpbHNcIik7XG5jb25zdCBwYXJzZXJzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL2FiaS11dGlscy9kaXN0L3BhcnNlcnNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay9hYmktdXRpbHMvZGlzdC91dGlsc1wiKTtcbmNvbnN0IHV0aWxzXzIgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuY29uc3Qga2VjY2FrXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nha1wiKTtcbmNvbnN0IHV0aWxzXzMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdmVyc2lvbiBvZiBgc2lnblR5cGVkRGF0YWAgYmVpbmcgdXNlZC5cbiAqXG4gKiBWMSBpcyBiYXNlZCB1cG9uIFthbiBlYXJseSB2ZXJzaW9uIG9mXG4gKiBFSVAtNzEyXShodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vRUlQcy9wdWxsLzcxMi9jb21taXRzLzIxYWJlMjU0ZmUwNDUyZDg1ODNkNWIxMzJiMWQ3YmU4N2MwNDM5Y2EpXG4gKiB0aGF0IGxhY2tlZCBzb21lIGxhdGVyIHNlY3VyaXR5IGltcHJvdmVtZW50cywgYW5kIHNob3VsZCBnZW5lcmFsbHkgYmUgbmVnbGVjdGVkIGluIGZhdm9yIG9mXG4gKiBsYXRlciB2ZXJzaW9ucy5cbiAqXG4gKiBWMyBpcyBiYXNlZCBvbiBFSVAtNzEyLCBleGNlcHQgdGhhdCBhcnJheXMgYW5kIHJlY3Vyc2l2ZSBkYXRhIHN0cnVjdHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gKlxuICogVjQgaXMgYmFzZWQgb24gRUlQLTcxMiwgYW5kIGluY2x1ZGVzIGZ1bGwgc3VwcG9ydCBvZiBhcnJheXMgYW5kIHJlY3Vyc2l2ZSBkYXRhIHN0cnVjdHVyZXMuXG4gKi9cbnZhciBTaWduVHlwZWREYXRhVmVyc2lvbjtcbihmdW5jdGlvbiAoU2lnblR5cGVkRGF0YVZlcnNpb24pIHtcbiAgICBTaWduVHlwZWREYXRhVmVyc2lvbltcIlYxXCJdID0gXCJWMVwiO1xuICAgIFNpZ25UeXBlZERhdGFWZXJzaW9uW1wiVjNcIl0gPSBcIlYzXCI7XG4gICAgU2lnblR5cGVkRGF0YVZlcnNpb25bXCJWNFwiXSA9IFwiVjRcIjtcbn0pKFNpZ25UeXBlZERhdGFWZXJzaW9uID0gZXhwb3J0cy5TaWduVHlwZWREYXRhVmVyc2lvbiB8fCAoZXhwb3J0cy5TaWduVHlwZWREYXRhVmVyc2lvbiA9IHt9KSk7XG5leHBvcnRzLlRZUEVEX01FU1NBR0VfU0NIRU1BID0ge1xuICAgIHR5cGU6ICdvYmplY3QnLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgdHlwZXM6IHtcbiAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBbJ25hbWUnLCAndHlwZSddLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBwcmltYXJ5VHlwZTogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICBkb21haW46IHsgdHlwZTogJ29iamVjdCcgfSxcbiAgICAgICAgbWVzc2FnZTogeyB0eXBlOiAnb2JqZWN0JyB9LFxuICAgIH0sXG4gICAgcmVxdWlyZWQ6IFsndHlwZXMnLCAncHJpbWFyeVR5cGUnLCAnZG9tYWluJywgJ21lc3NhZ2UnXSxcbn07XG4vKipcbiAqIFZhbGlkYXRlIHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQgdmVyc2lvbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBUaGUgdmVyc2lvbiB2YWx1ZSB0byB2YWxpZGF0ZS5cbiAqIEBwYXJhbSBhbGxvd2VkVmVyc2lvbnMgLSBBIGxpc3Qgb2YgYWxsb3dlZCB2ZXJzaW9ucy4gSWYgb21pdHRlZCwgYWxsIHZlcnNpb25zIGFyZSBhc3N1bWVkIHRvIGJlXG4gKiBhbGxvd2VkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVZlcnNpb24odmVyc2lvbiwgYWxsb3dlZFZlcnNpb25zKSB7XG4gICAgaWYgKCFPYmplY3Qua2V5cyhTaWduVHlwZWREYXRhVmVyc2lvbikuaW5jbHVkZXModmVyc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZlcnNpb246ICcke3ZlcnNpb259J2ApO1xuICAgIH1cbiAgICBlbHNlIGlmIChhbGxvd2VkVmVyc2lvbnMgJiYgIWFsbG93ZWRWZXJzaW9ucy5pbmNsdWRlcyh2ZXJzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpZ25UeXBlZERhdGFWZXJzaW9uIG5vdCBhbGxvd2VkOiAnJHt2ZXJzaW9ufScuIEFsbG93ZWQgdmVyc2lvbnMgYXJlOiAke2FsbG93ZWRWZXJzaW9ucy5qb2luKCcsICcpfWApO1xuICAgIH1cbn1cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcsIG51bWJlciwgb3IgYmlnaW50IHZhbHVlIGludG8gYSBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBwYXJzZU51bWJlcih0eXBlLCB2YWx1ZSkge1xuICAgICgwLCB1dGlsc18yLmFzc2VydCkodmFsdWUgIT09IG51bGwsIGBVbmFibGUgdG8gZW5jb2RlIHZhbHVlOiBJbnZhbGlkIG51bWJlci4gRXhwZWN0ZWQgYSB2YWxpZCBudW1iZXIgdmFsdWUsIGJ1dCByZWNlaXZlZCBcIiR7dmFsdWV9XCIuYCk7XG4gICAgY29uc3QgYmlnSW50VmFsdWUgPSBCaWdJbnQodmFsdWUpO1xuICAgIGNvbnN0IGxlbmd0aCA9ICgwLCBwYXJzZXJzXzEuZ2V0TGVuZ3RoKSh0eXBlKTtcbiAgICBjb25zdCBtYXhWYWx1ZSA9IEJpZ0ludCgyKSAqKiBCaWdJbnQobGVuZ3RoKSAtIEJpZ0ludCgxKTtcbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBpcyBub3QgYWNjdXJhdGUsIHNpbmNlIHRoZSBhY3R1YWwgbWF4aW11bSB2YWx1ZSBmb3IgdW5zaWduZWRcbiAgICAvLyBpbnRlZ2VycyBpcyBgMiBeIChsZW5ndGggLSAxKSAtIDFgLCBidXQgdGhpcyBpcyByZXF1aXJlZCBmb3IgYmFja3dhcmRzXG4gICAgLy8gY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBvbGQgaW1wbGVtZW50YXRpb24uXG4gICAgKDAsIHV0aWxzXzIuYXNzZXJ0KShiaWdJbnRWYWx1ZSA+PSAtbWF4VmFsdWUgJiYgYmlnSW50VmFsdWUgPD0gbWF4VmFsdWUsIGBVbmFibGUgdG8gZW5jb2RlIHZhbHVlOiBOdW1iZXIgXCIke3ZhbHVlfVwiIGlzIG91dCBvZiByYW5nZSBmb3IgdHlwZSBcIiR7dHlwZX1cIi5gKTtcbiAgICByZXR1cm4gYmlnSW50VmFsdWU7XG59XG4vKipcbiAqIFBhcnNlIGFuIGFkZHJlc3Mgc3RyaW5nIHRvIGEgYFVpbnQ4QXJyYXlgLiBUaGUgYmVoYXZpb3VyIG9mIHRoaXMgaXMgcXVpdGVcbiAqIHN0cmFuZ2UsIGluIHRoYXQgaXQgZG9lcyBub3QgcGFyc2UgdGhlIGFkZHJlc3MgYXMgaGV4YWRlY2ltYWwgc3RyaW5nLCBub3IgYXNcbiAqIFVURi04LiBJdCBkb2VzIHNvbWUgd2VpcmQgc3R1ZmYgd2l0aCB0aGUgc3RyaW5nIGFuZCBjaGFyIGNvZGVzLCBhbmQgdGhlblxuICogcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIFRoaXMgaXMgYmFzZWQgb24gdGhlIG9sZCBgZXRoZXJldW1qcy1hYmlgIGltcGxlbWVudGF0aW9uLCB3aGljaCBlc3NlbnRpYWxseVxuICogY2FsbHMgYG5ldyBCTihhZGRyZXNzLCAxMClgIG9uIHRoZSBhZGRyZXNzIHN0cmluZywgdGhlIGVxdWl2YWxlbnQgb2YgY2FsbGluZ1xuICogYHBhcnNlSW50KGFkZHJlc3MsIDEwKWAgaW4gSmF2YVNjcmlwdC4gVGhpcyBpcyBub3QgYSB2YWxpZCB3YXkgdG8gcGFyc2UgYW5cbiAqIGFkZHJlc3MgYW5kIHdvdWxkIHJlc3VsdCBpbiBgTmFOYCBpbiBwbGFpbiBKYXZhU2NyaXB0LCBidXQgaXQgaXMgdGhlXG4gKiBiZWhhdmlvdXIgb2YgdGhlIG9sZCBpbXBsZW1lbnRhdGlvbiwgYW5kIHNvIHdlIG11c3QgcHJlc2VydmUgaXQgZm9yIGJhY2t3YXJkc1xuICogY29tcGF0aWJpbGl0eS5cbiAqXG4gKiBAcGFyYW0gYWRkcmVzcyAtIFRoZSBhZGRyZXNzIHRvIHBhcnNlLlxuICogQHJldHVybnMgVGhlIHBhcnNlZCBhZGRyZXNzLlxuICovXG5mdW5jdGlvbiByZWFsbHlTdHJhbmdlQWRkcmVzc1RvQnl0ZXMoYWRkcmVzcykge1xuICAgIGxldCBhZGRyZXNzVmFsdWUgPSBCaWdJbnQoMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRyZXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoYXJhY3RlciA9IEJpZ0ludChhZGRyZXNzLmNoYXJDb2RlQXQoaSkgLSA0OCk7XG4gICAgICAgIGFkZHJlc3NWYWx1ZSAqPSBCaWdJbnQoMTApO1xuICAgICAgICAvLyAnYSdcbiAgICAgICAgaWYgKGNoYXJhY3RlciA+PSA0OSkge1xuICAgICAgICAgICAgYWRkcmVzc1ZhbHVlICs9IGNoYXJhY3RlciAtIEJpZ0ludCg0OSkgKyBCaWdJbnQoMHhhKTtcbiAgICAgICAgICAgIC8vICdBJ1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYXJhY3RlciA+PSAxNykge1xuICAgICAgICAgICAgYWRkcmVzc1ZhbHVlICs9IGNoYXJhY3RlciAtIEJpZ0ludCgxNykgKyBCaWdJbnQoMHhhKTtcbiAgICAgICAgICAgIC8vICcwJyAtICc5J1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWRkcmVzc1ZhbHVlICs9IGNoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKDAsIHV0aWxzXzEucGFkU3RhcnQpKCgwLCB1dGlsc18yLmJpZ0ludFRvQnl0ZXMpKGFkZHJlc3NWYWx1ZSksIDIwKTtcbn1cbi8qKlxuICogRW5jb2RlIGEgc2luZ2xlIGZpZWxkLlxuICpcbiAqIEBwYXJhbSB0eXBlcyAtIEFsbCB0eXBlIGRlZmluaXRpb25zLlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZW5jb2RlLlxuICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgZmllbGQgYmVpbmcgZW5jb2RlZC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdmVyc2lvbiAtIFRoZSBFSVAtNzEyIHZlcnNpb24gdGhlIGVuY29kaW5nIHNob3VsZCBjb21wbHkgd2l0aC5cbiAqIEByZXR1cm5zIEVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGZpZWxkLlxuICovXG5mdW5jdGlvbiBlbmNvZGVGaWVsZCh0eXBlcywgbmFtZSwgdHlwZSwgXG4vLyBUT0RPOiBjb25zdHJhaW4gdHlwZSBvbiBgdmFsdWVgXG52YWx1ZSwgdmVyc2lvbikge1xuICAgIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uLCBbU2lnblR5cGVkRGF0YVZlcnNpb24uVjMsIFNpZ25UeXBlZERhdGFWZXJzaW9uLlY0XSk7XG4gICAgaWYgKHR5cGVzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdieXRlczMyJyxcbiAgICAgICAgICAgIC8vIFRPRE86IHJldHVybiBCdWZmZXIsIHJlbW92ZSBzdHJpbmcgZnJvbSByZXR1cm4gdHlwZVxuICAgICAgICAgICAgdmVyc2lvbiA9PT0gU2lnblR5cGVkRGF0YVZlcnNpb24uVjQgJiYgdmFsdWUgPT0gbnVsbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVxLW51bGxcbiAgICAgICAgICAgICAgICA/ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gICAgICAgICAgICAgICAgOiAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KShlbmNvZGVEYXRhKHR5cGUsIHZhbHVlLCB0eXBlcywgdmVyc2lvbikpKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLy8gYGZ1bmN0aW9uYCBpcyBzdXBwb3J0ZWQgaW4gYEBtZXRhbWFzay9hYmktdXRpbHNgLCBidXQgbm90IGFsbG93ZWQgYnlcbiAgICAvLyBFSVAtNzEyLCBzbyB3ZSB0aHJvdyBhbiBlcnJvciBoZXJlLlxuICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgb3IgaW52YWxpZCB0eXBlOiBcImZ1bmN0aW9uXCInKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIHZhbHVlIGZvciBmaWVsZCAke25hbWV9IG9mIHR5cGUgJHt0eXBlfWApO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gWydhZGRyZXNzJywgKDAsIHV0aWxzXzEucGFkU3RhcnQpKCgwLCB1dGlsc18yLm51bWJlclRvQnl0ZXMpKHZhbHVlKSwgMjApXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwgdXRpbHNfMi5pc1N0cmljdEhleFN0cmluZykodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gWydhZGRyZXNzJywgKDAsIHV0aWxzXzIuYWRkMHgpKHZhbHVlKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIFsnYWRkcmVzcycsIHJlYWxseVN0cmFuZ2VBZGRyZXNzVG9CeXRlcyh2YWx1ZSkuc3ViYXJyYXkoMCwgMjApXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHJldHVybiBbJ2Jvb2wnLCBCb29sZWFuKHZhbHVlKV07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICgwLCB1dGlsc18yLm51bWJlclRvQnl0ZXMpKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwgdXRpbHNfMi5pc1N0cmljdEhleFN0cmluZykodmFsdWUpIHx8IHZhbHVlID09PSAnMHgnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICgwLCB1dGlsc18yLmhleFRvQnl0ZXMpKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICgwLCB1dGlsc18yLnN0cmluZ1RvQnl0ZXMpKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWydieXRlczMyJywgKDAsIHV0aWxfMS5hcnJUb0J1ZkFycikoKDAsIGtlY2Nha18xLmtlY2NhazI1NikodmFsdWUpKV07XG4gICAgfVxuICAgIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykgJiYgdHlwZSAhPT0gJ2J5dGVzJyAmJiAhdHlwZS5pbmNsdWRlcygnWycpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsIG5ldyBVaW50OEFycmF5KDMyKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gWydieXRlczMyJywgKDAsIHV0aWxzXzIuYmlnSW50VG9CeXRlcykoQmlnSW50KHZhbHVlKSldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCB1dGlsc18yLmlzU3RyaWN0SGV4U3RyaW5nKSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCAoMCwgdXRpbHNfMi5oZXhUb0J5dGVzKSh2YWx1ZSldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCB2YWx1ZV07XG4gICAgfVxuICAgIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2ludCcpICYmICF0eXBlLmluY2x1ZGVzKCdbJykpIHtcbiAgICAgICAgY29uc3QgYmlnSW50VmFsdWUgPSBwYXJzZU51bWJlcih0eXBlLCB2YWx1ZSk7XG4gICAgICAgIGlmIChiaWdJbnRWYWx1ZSA+PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ3VpbnQyNTYnLCBiaWdJbnRWYWx1ZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsnaW50MjU2JywgYmlnSW50VmFsdWVdO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gKDAsIHV0aWxzXzIubnVtYmVyVG9CeXRlcykodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSAoMCwgdXRpbHNfMi5zdHJpbmdUb0J5dGVzKSh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsICgwLCB1dGlsXzEuYXJyVG9CdWZBcnIpKCgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKHZhbHVlKSldO1xuICAgIH1cbiAgICBpZiAodHlwZS5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSBTaWduVHlwZWREYXRhVmVyc2lvbi5WMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheXMgYXJlIHVuaW1wbGVtZW50ZWQgaW4gZW5jb2RlRGF0YTsgdXNlIFY0IGV4dGVuc2lvbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0eXBlLnNsaWNlKDAsIHR5cGUubGFzdEluZGV4T2YoJ1snKSk7XG4gICAgICAgIGNvbnN0IHR5cGVWYWx1ZVBhaXJzID0gdmFsdWUubWFwKChpdGVtKSA9PiBlbmNvZGVGaWVsZCh0eXBlcywgbmFtZSwgcGFyc2VkVHlwZSwgaXRlbSwgdmVyc2lvbikpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2J5dGVzMzInLFxuICAgICAgICAgICAgKDAsIHV0aWxfMS5hcnJUb0J1ZkFycikoKDAsIGtlY2Nha18xLmtlY2NhazI1NikoKDAsIGFiaV91dGlsc18xLmVuY29kZSkodHlwZVZhbHVlUGFpcnMubWFwKChbdF0pID0+IHQpLCB0eXBlVmFsdWVQYWlycy5tYXAoKFssIHZdKSA9PiB2KSkpKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFt0eXBlLCB2YWx1ZV07XG59XG4vKipcbiAqIEVuY29kZXMgYW4gb2JqZWN0IGJ5IGVuY29kaW5nIGFuZCBjb25jYXRlbmF0aW5nIGVhY2ggb2YgaXRzIG1lbWJlcnMuXG4gKlxuICogQHBhcmFtIHByaW1hcnlUeXBlIC0gVGhlIHJvb3QgdHlwZS5cbiAqIEBwYXJhbSBkYXRhIC0gVGhlIG9iamVjdCB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zIGZvciBhbGwgdHlwZXMgaW5jbHVkZWQgaW4gdGhlIG1lc3NhZ2UuXG4gKiBAcGFyYW0gdmVyc2lvbiAtIFRoZSBFSVAtNzEyIHZlcnNpb24gdGhlIGVuY29kaW5nIHNob3VsZCBjb21wbHkgd2l0aC5cbiAqIEByZXR1cm5zIEFuIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBlbmNvZGVEYXRhKHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdmVyc2lvbikge1xuICAgIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uLCBbU2lnblR5cGVkRGF0YVZlcnNpb24uVjMsIFNpZ25UeXBlZERhdGFWZXJzaW9uLlY0XSk7XG4gICAgY29uc3QgZW5jb2RlZFR5cGVzID0gWydieXRlczMyJ107XG4gICAgY29uc3QgZW5jb2RlZFZhbHVlcyA9IFtcbiAgICAgICAgaGFzaFR5cGUocHJpbWFyeVR5cGUsIHR5cGVzKSxcbiAgICBdO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZXNbcHJpbWFyeVR5cGVdKSB7XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSBTaWduVHlwZWREYXRhVmVyc2lvbi5WMyAmJiBkYXRhW2ZpZWxkLm5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFt0eXBlLCB2YWx1ZV0gPSBlbmNvZGVGaWVsZCh0eXBlcywgZmllbGQubmFtZSwgZmllbGQudHlwZSwgZGF0YVtmaWVsZC5uYW1lXSwgdmVyc2lvbik7XG4gICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKHR5cGUpO1xuICAgICAgICBlbmNvZGVkVmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHV0aWxfMS5hcnJUb0J1ZkFycikoKDAsIGFiaV91dGlsc18xLmVuY29kZSkoZW5jb2RlZFR5cGVzLCBlbmNvZGVkVmFsdWVzKSk7XG59XG4vKipcbiAqIEVuY29kZXMgdGhlIHR5cGUgb2YgYW4gb2JqZWN0IGJ5IGVuY29kaW5nIGEgY29tbWEgZGVsaW1pdGVkIGxpc3Qgb2YgaXRzIG1lbWJlcnMuXG4gKlxuICogQHBhcmFtIHByaW1hcnlUeXBlIC0gVGhlIHJvb3QgdHlwZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zIGZvciBhbGwgdHlwZXMgaW5jbHVkZWQgaW4gdGhlIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyBBbiBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcmltYXJ5IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVR5cGUocHJpbWFyeVR5cGUsIHR5cGVzKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGNvbnN0IHVuc29ydGVkRGVwcyA9IGZpbmRUeXBlRGVwZW5kZW5jaWVzKHByaW1hcnlUeXBlLCB0eXBlcyk7XG4gICAgdW5zb3J0ZWREZXBzLmRlbGV0ZShwcmltYXJ5VHlwZSk7XG4gICAgY29uc3QgZGVwcyA9IFtwcmltYXJ5VHlwZSwgLi4uQXJyYXkuZnJvbSh1bnNvcnRlZERlcHMpLnNvcnQoKV07XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIGRlcHMpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0eXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyB0eXBlIGRlZmluaXRpb24gc3BlY2lmaWVkOiAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IGAke3R5cGV9KCR7dHlwZXNbdHlwZV1cbiAgICAgICAgICAgIC5tYXAoKHsgbmFtZSwgdHlwZTogdCB9KSA9PiBgJHt0fSAke25hbWV9YClcbiAgICAgICAgICAgIC5qb2luKCcsJyl9KWA7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEZpbmRzIGFsbCB0eXBlcyB3aXRoaW4gYSB0eXBlIGRlZmluaXRpb24gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBwcmltYXJ5VHlwZSAtIFRoZSByb290IHR5cGUuXG4gKiBAcGFyYW0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zIGZvciBhbGwgdHlwZXMgaW5jbHVkZWQgaW4gdGhlIG1lc3NhZ2UuXG4gKiBAcGFyYW0gcmVzdWx0cyAtIFRoZSBjdXJyZW50IHNldCBvZiBhY2N1bXVsYXRlZCB0eXBlcy5cbiAqIEByZXR1cm5zIFRoZSBzZXQgb2YgYWxsIHR5cGVzIGZvdW5kIGluIHRoZSB0eXBlIGRlZmluaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGZpbmRUeXBlRGVwZW5kZW5jaWVzKHByaW1hcnlUeXBlLCB0eXBlcywgcmVzdWx0cyA9IG5ldyBTZXQoKSkge1xuICAgIGlmICh0eXBlb2YgcHJpbWFyeVR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaW5kVHlwZURlcGVuZGVuY2llcyBpbnB1dCAke0pTT04uc3RyaW5naWZ5KHByaW1hcnlUeXBlKX1gKTtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSBwcmltYXJ5VHlwZS5tYXRjaCgvXlxcdyovdSk7XG4gICAgW3ByaW1hcnlUeXBlXSA9IG1hdGNoO1xuICAgIGlmIChyZXN1bHRzLmhhcyhwcmltYXJ5VHlwZSkgfHwgdHlwZXNbcHJpbWFyeVR5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIHJlc3VsdHMuYWRkKHByaW1hcnlUeXBlKTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW3ByaW1hcnlUeXBlXSkge1xuICAgICAgICBmaW5kVHlwZURlcGVuZGVuY2llcyhmaWVsZC50eXBlLCB0eXBlcywgcmVzdWx0cyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xufVxuLyoqXG4gKiBIYXNoZXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBwcmltYXJ5VHlwZSAtIFRoZSByb290IHR5cGUuXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBvYmplY3QgdG8gaGFzaC5cbiAqIEBwYXJhbSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnMgZm9yIGFsbCB0eXBlcyBpbmNsdWRlZCBpbiB0aGUgbWVzc2FnZS5cbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIEVJUC03MTIgdmVyc2lvbiB0aGUgZW5jb2Rpbmcgc2hvdWxkIGNvbXBseSB3aXRoLlxuICogQHJldHVybnMgVGhlIGhhc2ggb2YgdGhlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaGFzaFN0cnVjdChwcmltYXJ5VHlwZSwgZGF0YSwgdHlwZXMsIHZlcnNpb24pIHtcbiAgICB2YWxpZGF0ZVZlcnNpb24odmVyc2lvbiwgW1NpZ25UeXBlZERhdGFWZXJzaW9uLlYzLCBTaWduVHlwZWREYXRhVmVyc2lvbi5WNF0pO1xuICAgIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVEYXRhKHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdmVyc2lvbik7XG4gICAgY29uc3QgaGFzaGVkID0gKDAsIGtlY2Nha18xLmtlY2NhazI1NikoZW5jb2RlZCk7XG4gICAgY29uc3QgYnVmID0gKDAsIHV0aWxfMS5hcnJUb0J1ZkFycikoaGFzaGVkKTtcbiAgICByZXR1cm4gYnVmO1xufVxuLyoqXG4gKiBIYXNoZXMgdGhlIHR5cGUgb2YgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBwcmltYXJ5VHlwZSAtIFRoZSByb290IHR5cGUgdG8gaGFzaC5cbiAqIEBwYXJhbSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnMgZm9yIGFsbCB0eXBlcyBpbmNsdWRlZCBpbiB0aGUgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSBvYmplY3QgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFR5cGUocHJpbWFyeVR5cGUsIHR5cGVzKSB7XG4gICAgY29uc3QgZW5jb2RlZEhhc2hUeXBlID0gKDAsIHV0aWxzXzIuc3RyaW5nVG9CeXRlcykoZW5jb2RlVHlwZShwcmltYXJ5VHlwZSwgdHlwZXMpKTtcbiAgICByZXR1cm4gKDAsIHV0aWxfMS5hcnJUb0J1ZkFycikoKDAsIGtlY2Nha18xLmtlY2NhazI1NikoZW5jb2RlZEhhc2hUeXBlKSk7XG59XG4vKipcbiAqIFJlbW92ZXMgcHJvcGVydGllcyBmcm9tIGEgbWVzc2FnZSBvYmplY3QgdGhhdCBhcmUgbm90IGRlZmluZWQgcGVyIEVJUC03MTIuXG4gKlxuICogQHBhcmFtIGRhdGEgLSBUaGUgdHlwZWQgbWVzc2FnZSBvYmplY3QuXG4gKiBAcmV0dXJucyBUaGUgdHlwZWQgbWVzc2FnZSBvYmplY3Qgd2l0aCBvbmx5IGFsbG93ZWQgZmllbGRzLlxuICovXG5mdW5jdGlvbiBzYW5pdGl6ZURhdGEoZGF0YSkge1xuICAgIGNvbnN0IHNhbml0aXplZERhdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBleHBvcnRzLlRZUEVEX01FU1NBR0VfU0NIRU1BLnByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKGRhdGFba2V5XSkge1xuICAgICAgICAgICAgc2FuaXRpemVkRGF0YVtrZXldID0gZGF0YVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgndHlwZXMnIGluIHNhbml0aXplZERhdGEpIHtcbiAgICAgICAgLy8gVE9ETzogRml4IHR5cGVzXG4gICAgICAgIHNhbml0aXplZERhdGEudHlwZXMgPSBPYmplY3QuYXNzaWduKHsgRUlQNzEyRG9tYWluOiBbXSB9LCBzYW5pdGl6ZWREYXRhLnR5cGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNhbml0aXplZERhdGE7XG59XG4vKipcbiAqIENyZWF0ZSBhIEVJUC03MTIgRG9tYWluIEhhc2guXG4gKiBUaGlzIGhhc2ggaXMgdXNlZCBhdCB0aGUgdG9wIG9mIHRoZSBFSVAtNzEyIGVuY29kaW5nLlxuICpcbiAqIEBwYXJhbSB0eXBlZERhdGEgLSBUaGUgdHlwZWQgbWVzc2FnZSB0byBoYXNoLlxuICogQHBhcmFtIHZlcnNpb24gLSBUaGUgRUlQLTcxMiB2ZXJzaW9uIHRoZSBlbmNvZGluZyBzaG91bGQgY29tcGx5IHdpdGguXG4gKiBAcmV0dXJucyBUaGUgaGFzaCBvZiB0aGUgZG9tYWluIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZWlwNzEyRG9tYWluSGFzaCh0eXBlZERhdGEsIHZlcnNpb24pIHtcbiAgICB2YWxpZGF0ZVZlcnNpb24odmVyc2lvbiwgW1NpZ25UeXBlZERhdGFWZXJzaW9uLlYzLCBTaWduVHlwZWREYXRhVmVyc2lvbi5WNF0pO1xuICAgIGNvbnN0IHNhbml0aXplZERhdGEgPSBzYW5pdGl6ZURhdGEodHlwZWREYXRhKTtcbiAgICBjb25zdCB7IGRvbWFpbiB9ID0gc2FuaXRpemVkRGF0YTtcbiAgICBjb25zdCBkb21haW5UeXBlID0geyBFSVA3MTJEb21haW46IHNhbml0aXplZERhdGEudHlwZXMuRUlQNzEyRG9tYWluIH07XG4gICAgcmV0dXJuIGhhc2hTdHJ1Y3QoJ0VJUDcxMkRvbWFpbicsIGRvbWFpbiwgZG9tYWluVHlwZSwgdmVyc2lvbik7XG59XG4vKipcbiAqIEhhc2ggYSB0eXBlZCBtZXNzYWdlIGFjY29yZGluZyB0byBFSVAtNzEyLiBUaGUgcmV0dXJuZWQgbWVzc2FnZSBzdGFydHMgd2l0aCB0aGUgRUlQLTcxMiBwcmVmaXgsXG4gKiB3aGljaCBpcyBcIjE5MDFcIiwgZm9sbG93ZWQgYnkgdGhlIGhhc2ggb2YgdGhlIGRvbWFpbiBzZXBhcmF0b3IsIHRoZW4gdGhlIGRhdGEgKGlmIGFueSkuXG4gKiBUaGUgcmVzdWx0IGlzIGhhc2hlZCBhZ2FpbiBhbmQgcmV0dXJuZWQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBzaWduIHRoZSBtZXNzYWdlLiBUaGUgcmVzdWx0aW5nIGhhc2ggbXVzdCBzdGlsbCBiZSBzaWduZWQgdG8gY3JlYXRlIGFuXG4gKiBFSVAtNzEyIHNpZ25hdHVyZS5cbiAqXG4gKiBAcGFyYW0gdHlwZWREYXRhIC0gVGhlIHR5cGVkIG1lc3NhZ2UgdG8gaGFzaC5cbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIEVJUC03MTIgdmVyc2lvbiB0aGUgZW5jb2Rpbmcgc2hvdWxkIGNvbXBseSB3aXRoLlxuICogQHJldHVybnMgVGhlIGhhc2ggb2YgdGhlIHR5cGVkIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGVpcDcxMkhhc2godHlwZWREYXRhLCB2ZXJzaW9uKSB7XG4gICAgdmFsaWRhdGVWZXJzaW9uKHZlcnNpb24sIFtTaWduVHlwZWREYXRhVmVyc2lvbi5WMywgU2lnblR5cGVkRGF0YVZlcnNpb24uVjRdKTtcbiAgICBjb25zdCBzYW5pdGl6ZWREYXRhID0gc2FuaXRpemVEYXRhKHR5cGVkRGF0YSk7XG4gICAgY29uc3QgcGFydHMgPSBbKDAsIHV0aWxzXzIuaGV4VG9CeXRlcykoJzE5MDEnKV07XG4gICAgcGFydHMucHVzaChlaXA3MTJEb21haW5IYXNoKHR5cGVkRGF0YSwgdmVyc2lvbikpO1xuICAgIGlmIChzYW5pdGl6ZWREYXRhLnByaW1hcnlUeXBlICE9PSAnRUlQNzEyRG9tYWluJykge1xuICAgICAgICBwYXJ0cy5wdXNoKGhhc2hTdHJ1Y3QoXG4gICAgICAgIC8vIFRPRE86IFZhbGlkYXRlIHRoYXQgdGhpcyBpcyBhIHN0cmluZywgc28gdGhpcyB0eXBlIGNhc3QgY2FuIGJlIHJlbW92ZWQuXG4gICAgICAgIHNhbml0aXplZERhdGEucHJpbWFyeVR5cGUsIHNhbml0aXplZERhdGEubWVzc2FnZSwgc2FuaXRpemVkRGF0YS50eXBlcywgdmVyc2lvbikpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHV0aWxfMS5hcnJUb0J1ZkFycikoKDAsIGtlY2Nha18xLmtlY2NhazI1NikoKDAsIHV0aWxzXzIuY29uY2F0Qnl0ZXMpKHBhcnRzKSkpO1xufVxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgdXRpbGl0eSBmdW5jdGlvbnMgdXNlZCBmb3Igc2lnbmluZyB0eXBlZCBkYXRhLlxuICovXG5leHBvcnRzLlR5cGVkRGF0YVV0aWxzID0ge1xuICAgIGVuY29kZURhdGEsXG4gICAgZW5jb2RlVHlwZSxcbiAgICBmaW5kVHlwZURlcGVuZGVuY2llcyxcbiAgICBoYXNoU3RydWN0LFxuICAgIGhhc2hUeXBlLFxuICAgIHNhbml0aXplRGF0YSxcbiAgICBlaXA3MTJIYXNoLFxuICAgIGVpcDcxMkRvbWFpbkhhc2gsXG59O1xuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgXCJWMVwiIGhhc2ggZm9yIHRoZSBwcm92aWRlZCB0eXBlZCBtZXNzYWdlLlxuICpcbiAqIFRoZSBoYXNoIHdpbGwgYmUgZ2VuZXJhdGVkIGluIGFjY29yZGFuY2Ugd2l0aCBhbiBlYXJsaWVyIHZlcnNpb24gb2YgdGhlIEVJUC03MTJcbiAqIHNwZWNpZmljYXRpb24uIFRoaXMgaGFzaCBpcyB1c2VkIGluIGBzaWduVHlwZWREYXRhX3YxYC5cbiAqXG4gKiBAcGFyYW0gdHlwZWREYXRhIC0gVGhlIHR5cGVkIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggZW5jb2RlZCBoYXNoIHJlcHJlc2VudGluZyB0aGUgdHlwZSBvZiB0aGUgcHJvdmlkZWQgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gdHlwZWRTaWduYXR1cmVIYXNoKHR5cGVkRGF0YSkge1xuICAgIGNvbnN0IGhhc2hCdWZmZXIgPSBfdHlwZWRTaWduYXR1cmVIYXNoKHR5cGVkRGF0YSk7XG4gICAgcmV0dXJuICgwLCB1dGlsc18yLmJ5dGVzVG9IZXgpKGhhc2hCdWZmZXIpO1xufVxuZXhwb3J0cy50eXBlZFNpZ25hdHVyZUhhc2ggPSB0eXBlZFNpZ25hdHVyZUhhc2g7XG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZhbHVlLCBzbyB0aGF0IGBAbWV0YW1hc2svYWJpLXV0aWxzYCBjYW4gaGFuZGxlIGl0LiBUaGlzXG4gKiBtYXRjaGVzIHRoZSBiZWhhdmlvdXIgb2YgdGhlIGBldGhlcmV1bWpzLWFiaWAgbGlicmFyeS5cbiAqXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBub3JtYWxpemUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gbm9ybWFsaXplLlxuICogQHJldHVybnMgVGhlIG5vcm1hbGl6ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKCgwLCBwYXJzZXJzXzEuaXNBcnJheVR5cGUpKHR5cGUpICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IFtpbm5lclR5cGVdID0gKDAsIHBhcnNlcnNfMS5nZXRBcnJheVR5cGUpKHR5cGUpO1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKChpdGVtKSA9PiBub3JtYWxpemVWYWx1ZShpbm5lclR5cGUsIGl0ZW0pKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdhZGRyZXNzJykge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLnBhZFN0YXJ0KSgoMCwgdXRpbHNfMi5udW1iZXJUb0J5dGVzKSh2YWx1ZSksIDIwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIHV0aWxzXzIuaXNTdHJpY3RIZXhTdHJpbmcpKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLnBhZFN0YXJ0KSgoMCwgdXRpbHNfMi5oZXhUb0J5dGVzKSh2YWx1ZSkuc3ViYXJyYXkoMCwgMjApLCAyMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLnBhZFN0YXJ0KSh2YWx1ZS5zdWJhcnJheSgwLCAyMCksIDIwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGUuc3RhcnRzV2l0aCgnYnl0ZXMnKSAmJiB0eXBlICE9PSAnYnl0ZXMnKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9ICgwLCBwYXJzZXJzXzEuZ2V0Qnl0ZUxlbmd0aCkodHlwZSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gYHNvbGlkaXR5UGFjayhbJ2J5dGVzTiddLCBbLTFdKWAgcmV0dXJucyBgMHgwMC4uMDBgLlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18yLm51bWJlclRvQnl0ZXMpKHZhbHVlKS5zdWJhcnJheSgwLCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgdXRpbHNfMi5pc1N0cmljdEhleFN0cmluZykodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzIuaGV4VG9CeXRlcykodmFsdWUpLnN1YmFycmF5KDAsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnN1YmFycmF5KDAsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGUuc3RhcnRzV2l0aCgndWludCcpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2ludCcpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSAoMCwgcGFyc2Vyc18xLmdldExlbmd0aCkodHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50LmFzSW50TihsZW5ndGgsIEJpZ0ludCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogRm9yIHNvbWUgcmVhc29uIGBldGhlcmV1bWpzLWFiaWAgdHJlYXRzIGBhZGRyZXNzYCBhbmQgYGFkZHJlc3NbXWAgZGlmZmVyZW50bHlcbiAqIHNvIHdlIG5lZWQgdG8gbm9ybWFsaXplIGBhZGRyZXNzW11gIGRpZmZlcmVudGx5LlxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIG5vcm1hbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBub3JtYWxpemVkIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQWRkcmVzc2VzKHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMubWFwKCh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLnBhZFN0YXJ0KSgoMCwgdXRpbHNfMi5udW1iZXJUb0J5dGVzKSh2YWx1ZSksIDMyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIHV0aWxzXzIuaXNTdHJpY3RIZXhTdHJpbmcpKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLnBhZFN0YXJ0KSgoMCwgdXRpbHNfMi5oZXhUb0J5dGVzKSh2YWx1ZSkuc3ViYXJyYXkoMCwgMzIpLCAzMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLnBhZFN0YXJ0KSh2YWx1ZS5zdWJhcnJheSgwLCAzMiksIDMyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG59XG4vKipcbiAqIEZvciBzb21lIHJlYXNvbiBgZXRoZXJldW1qcy1hYmlgIHRyZWF0cyBgaW50TmAgYW5kIGBpbnROW11gIGRpZmZlcmVudGx5XG4gKiBzbyB3ZSBuZWVkIHRvIG5vcm1hbGl6ZSBgaW50TltdYCBkaWZmZXJlbnRseS5cbiAqXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBub3JtYWxpemUuXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byBub3JtYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUludGVnZXJzKHR5cGUsIHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMubWFwKCh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgY29uc3QgYmlnSW50VmFsdWUgPSBwYXJzZU51bWJlcih0eXBlLCB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoYmlnSW50VmFsdWUgPj0gQmlnSW50KDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLnBhZFN0YXJ0KSgoMCwgdXRpbHNfMi5iaWdJbnRUb0J5dGVzKShiaWdJbnRWYWx1ZSksIDMyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9ICgwLCBwYXJzZXJzXzEuZ2V0TGVuZ3RoKSh0eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGFzSW50TiA9IEJpZ0ludC5hc0ludE4obGVuZ3RoLCBiaWdJbnRWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzIuc2lnbmVkQmlnSW50VG9CeXRlcykoYXNJbnROLCAzMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgXCJWMVwiIGhhc2ggZm9yIHRoZSBwcm92aWRlZCB0eXBlZCBtZXNzYWdlLlxuICpcbiAqIFRoZSBoYXNoIHdpbGwgYmUgZ2VuZXJhdGVkIGluIGFjY29yZGFuY2Ugd2l0aCBhbiBlYXJsaWVyIHZlcnNpb24gb2YgdGhlIEVJUC03MTJcbiAqIHNwZWNpZmljYXRpb24uIFRoaXMgaGFzaCBpcyB1c2VkIGluIGBzaWduVHlwZWREYXRhX3YxYC5cbiAqXG4gKiBAcGFyYW0gdHlwZWREYXRhIC0gVGhlIHR5cGVkIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyBUaGUgaGFzaCByZXByZXNlbnRpbmcgdGhlIHR5cGUgb2YgdGhlIHByb3ZpZGVkIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIF90eXBlZFNpZ25hdHVyZUhhc2godHlwZWREYXRhKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0V4cGVjdCBhcmd1bWVudCB0byBiZSBub24tZW1wdHkgYXJyYXknKTtcbiAgICBpZiAodHlwZW9mIHR5cGVkRGF0YSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgISgnbGVuZ3RoJyBpbiB0eXBlZERhdGEpIHx8XG4gICAgICAgICF0eXBlZERhdGEubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemVkRGF0YSA9IHR5cGVkRGF0YS5tYXAoKHsgbmFtZSwgdHlwZSwgdmFsdWUgfSkgPT4ge1xuICAgICAgICAvLyBIYW5kbGUgYW4gZWRnZSBjYXNlIHdpdGggYGFkZHJlc3NbXWAgdHlwZXMuXG4gICAgICAgIGlmICh0eXBlID09PSAnYWRkcmVzc1tdJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlczMyW10nLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBub3JtYWxpemVBZGRyZXNzZXModmFsdWUpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgYW4gZWRnZSBjYXNlIHdpdGggYGludE5bXWAgdHlwZXMuXG4gICAgICAgIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2ludCcpICYmICgwLCBwYXJzZXJzXzEuaXNBcnJheVR5cGUpKHR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBbaW5uZXJUeXBlLCBsZW5ndGhdID0gKDAsIHBhcnNlcnNfMS5nZXRBcnJheVR5cGUpKHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHR5cGU6IGBieXRlczMyWyR7bGVuZ3RoICE9PSBudWxsICYmIGxlbmd0aCAhPT0gdm9pZCAwID8gbGVuZ3RoIDogJyd9XWAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5vcm1hbGl6ZUludGVnZXJzKGlubmVyVHlwZSwgdmFsdWUpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB2YWx1ZTogbm9ybWFsaXplVmFsdWUodHlwZSwgdmFsdWUpLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGRhdGEgPSBub3JtYWxpemVkRGF0YS5tYXAoKGUpID0+IHtcbiAgICAgICAgaWYgKGUudHlwZSAhPT0gJ2J5dGVzJykge1xuICAgICAgICAgICAgcmV0dXJuIGUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18zLmxlZ2FjeVRvQnVmZmVyKShlLnZhbHVlKTtcbiAgICB9KTtcbiAgICBjb25zdCB0eXBlcyA9IG5vcm1hbGl6ZWREYXRhLm1hcCgoZSkgPT4ge1xuICAgICAgICBpZiAoZS50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG9yIGludmFsaWQgdHlwZTogXCJmdW5jdGlvblwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUudHlwZTtcbiAgICB9KTtcbiAgICBjb25zdCBzY2hlbWEgPSB0eXBlZERhdGEubWFwKChlKSA9PiB7XG4gICAgICAgIGlmICghZS5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7ZS50eXBlfSAke2UubmFtZX1gO1xuICAgIH0pO1xuICAgIHJldHVybiAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KSgoMCwgYWJpX3V0aWxzXzEuZW5jb2RlUGFja2VkKShbJ2J5dGVzMzInLCAnYnl0ZXMzMiddLCBbXG4gICAgICAgICgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKCgwLCBhYmlfdXRpbHNfMS5lbmNvZGVQYWNrZWQpKFsnc3RyaW5nW10nXSwgW3NjaGVtYV0sIHRydWUpKSxcbiAgICAgICAgKDAsIGtlY2Nha18xLmtlY2NhazI1NikoKDAsIGFiaV91dGlsc18xLmVuY29kZVBhY2tlZCkodHlwZXMsIGRhdGEsIHRydWUpKSxcbiAgICBdKSkpO1xufVxuLyoqXG4gKiBTaWduIHR5cGVkIGRhdGEgYWNjb3JkaW5nIHRvIEVJUC03MTIuIFRoZSBzaWduaW5nIGRpZmZlcnMgYmFzZWQgdXBvbiB0aGUgYHZlcnNpb25gLlxuICpcbiAqIFYxIGlzIGJhc2VkIHVwb24gW2FuIGVhcmx5IHZlcnNpb24gb2ZcbiAqIEVJUC03MTJdKGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9FSVBzL3B1bGwvNzEyL2NvbW1pdHMvMjFhYmUyNTRmZTA0NTJkODU4M2Q1YjEzMmIxZDdiZTg3YzA0MzljYSlcbiAqIHRoYXQgbGFja2VkIHNvbWUgbGF0ZXIgc2VjdXJpdHkgaW1wcm92ZW1lbnRzLCBhbmQgc2hvdWxkIGdlbmVyYWxseSBiZSBuZWdsZWN0ZWQgaW4gZmF2b3Igb2ZcbiAqIGxhdGVyIHZlcnNpb25zLlxuICpcbiAqIFYzIGlzIGJhc2VkIG9uIFtFSVAtNzEyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTcxMiksIGV4Y2VwdCB0aGF0IGFycmF5cyBhbmRcbiAqIHJlY3Vyc2l2ZSBkYXRhIHN0cnVjdHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gKlxuICogVjQgaXMgYmFzZWQgb24gW0VJUC03MTJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzEyKSwgYW5kIGluY2x1ZGVzIGZ1bGwgc3VwcG9ydCBvZlxuICogYXJyYXlzIGFuZCByZWN1cnNpdmUgZGF0YSBzdHJ1Y3R1cmVzLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHNpZ25pbmcgb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLnByaXZhdGVLZXkgLSBUaGUgcHJpdmF0ZSBrZXkgdG8gc2lnbiB3aXRoLlxuICogQHBhcmFtIG9wdGlvbnMuZGF0YSAtIFRoZSB0eXBlZCBkYXRhIHRvIHNpZ24uXG4gKiBAcGFyYW0gb3B0aW9ucy52ZXJzaW9uIC0gVGhlIHNpZ25pbmcgdmVyc2lvbiB0byB1c2UuXG4gKiBAcmV0dXJucyBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggZW5jb2RlZCBzaWduYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIHNpZ25UeXBlZERhdGEoeyBwcml2YXRlS2V5LCBkYXRhLCB2ZXJzaW9uLCB9KSB7XG4gICAgdmFsaWRhdGVWZXJzaW9uKHZlcnNpb24pO1xuICAgIGlmICgoMCwgdXRpbHNfMy5pc051bGxpc2gpKGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBkYXRhIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgdXRpbHNfMy5pc051bGxpc2gpKHByaXZhdGVLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcml2YXRlIGtleSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZUhhc2ggPSB2ZXJzaW9uID09PSBTaWduVHlwZWREYXRhVmVyc2lvbi5WMVxuICAgICAgICA/IF90eXBlZFNpZ25hdHVyZUhhc2goZGF0YSlcbiAgICAgICAgOiBleHBvcnRzLlR5cGVkRGF0YVV0aWxzLmVpcDcxMkhhc2goZGF0YSwgdmVyc2lvbik7XG4gICAgY29uc3Qgc2lnID0gKDAsIHV0aWxfMS5lY3NpZ24pKG1lc3NhZ2VIYXNoLCBwcml2YXRlS2V5KTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzMuY29uY2F0U2lnKSgoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwgdXRpbHNfMi5iaWdJbnRUb0J5dGVzKShzaWcudikpLCBzaWcuciwgc2lnLnMpO1xufVxuZXhwb3J0cy5zaWduVHlwZWREYXRhID0gc2lnblR5cGVkRGF0YTtcbi8qKlxuICogUmVjb3ZlciB0aGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCB0aGF0IGNyZWF0ZWQgdGhlIGdpdmVuIEVJUC03MTJcbiAqIHNpZ25hdHVyZS4gVGhlIHZlcnNpb24gcHJvdmlkZWQgbXVzdCBtYXRjaCB0aGUgdmVyc2lvbiB1c2VkIHRvXG4gKiBjcmVhdGUgdGhlIHNpZ25hdHVyZS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBzaWduYXR1cmUgcmVjb3Zlcnkgb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLmRhdGEgLSBUaGUgdHlwZWQgZGF0YSB0aGF0IHdhcyBzaWduZWQuXG4gKiBAcGFyYW0gb3B0aW9ucy5zaWduYXR1cmUgLSBUaGUgJzB4LXByZWZpeGVkIGhleCBlbmNvZGVkIG1lc3NhZ2Ugc2lnbmF0dXJlLlxuICogQHBhcmFtIG9wdGlvbnMudmVyc2lvbiAtIFRoZSBzaWduaW5nIHZlcnNpb24gdG8gdXNlLlxuICogQHJldHVybnMgVGhlICcweCctcHJlZml4ZWQgaGV4IGFkZHJlc3Mgb2YgdGhlIHNpZ25lci5cbiAqL1xuZnVuY3Rpb24gcmVjb3ZlclR5cGVkU2lnbmF0dXJlKHsgZGF0YSwgc2lnbmF0dXJlLCB2ZXJzaW9uLCB9KSB7XG4gICAgdmFsaWRhdGVWZXJzaW9uKHZlcnNpb24pO1xuICAgIGlmICgoMCwgdXRpbHNfMy5pc051bGxpc2gpKGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBkYXRhIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgdXRpbHNfMy5pc051bGxpc2gpKHNpZ25hdHVyZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHNpZ25hdHVyZSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZUhhc2ggPSB2ZXJzaW9uID09PSBTaWduVHlwZWREYXRhVmVyc2lvbi5WMVxuICAgICAgICA/IF90eXBlZFNpZ25hdHVyZUhhc2goZGF0YSlcbiAgICAgICAgOiBleHBvcnRzLlR5cGVkRGF0YVV0aWxzLmVpcDcxMkhhc2goZGF0YSwgdmVyc2lvbik7XG4gICAgY29uc3QgcHVibGljS2V5ID0gKDAsIHV0aWxzXzMucmVjb3ZlclB1YmxpY0tleSkobWVzc2FnZUhhc2gsIHNpZ25hdHVyZSk7XG4gICAgY29uc3Qgc2VuZGVyID0gKDAsIHV0aWxfMS5wdWJsaWNUb0FkZHJlc3MpKHB1YmxpY0tleSk7XG4gICAgcmV0dXJuICgwLCB1dGlsc18yLmJ5dGVzVG9IZXgpKHNlbmRlcik7XG59XG5leHBvcnRzLnJlY292ZXJUeXBlZFNpZ25hdHVyZSA9IHJlY292ZXJUeXBlZFNpZ25hdHVyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ24tdHlwZWQtZGF0YS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyZWNvdmVyVHlwZWRTaWduYXR1cmUiLCJzaWduVHlwZWREYXRhIiwidHlwZWRTaWduYXR1cmVIYXNoIiwiVHlwZWREYXRhVXRpbHMiLCJUWVBFRF9NRVNTQUdFX1NDSEVNQSIsIlNpZ25UeXBlZERhdGFWZXJzaW9uIiwidXRpbF8xIiwicmVxdWlyZSIsImFiaV91dGlsc18xIiwicGFyc2Vyc18xIiwidXRpbHNfMSIsInV0aWxzXzIiLCJrZWNjYWtfMSIsInV0aWxzXzMiLCJ0eXBlIiwicHJvcGVydGllcyIsInR5cGVzIiwiYWRkaXRpb25hbFByb3BlcnRpZXMiLCJpdGVtcyIsIm5hbWUiLCJyZXF1aXJlZCIsInByaW1hcnlUeXBlIiwiZG9tYWluIiwibWVzc2FnZSIsInZhbGlkYXRlVmVyc2lvbiIsInZlcnNpb24iLCJhbGxvd2VkVmVyc2lvbnMiLCJrZXlzIiwiaW5jbHVkZXMiLCJFcnJvciIsImpvaW4iLCJwYXJzZU51bWJlciIsImFzc2VydCIsImJpZ0ludFZhbHVlIiwiQmlnSW50IiwibGVuZ3RoIiwiZ2V0TGVuZ3RoIiwibWF4VmFsdWUiLCJyZWFsbHlTdHJhbmdlQWRkcmVzc1RvQnl0ZXMiLCJhZGRyZXNzIiwiYWRkcmVzc1ZhbHVlIiwiaSIsImNoYXJhY3RlciIsImNoYXJDb2RlQXQiLCJwYWRTdGFydCIsImJpZ0ludFRvQnl0ZXMiLCJlbmNvZGVGaWVsZCIsIlYzIiwiVjQiLCJ1bmRlZmluZWQiLCJhcnJUb0J1ZkFyciIsImtlY2NhazI1NiIsImVuY29kZURhdGEiLCJudW1iZXJUb0J5dGVzIiwiaXNTdHJpY3RIZXhTdHJpbmciLCJhZGQweCIsInN1YmFycmF5IiwiQm9vbGVhbiIsImhleFRvQnl0ZXMiLCJzdHJpbmdUb0J5dGVzIiwic3RhcnRzV2l0aCIsIlVpbnQ4QXJyYXkiLCJlbmRzV2l0aCIsInBhcnNlZFR5cGUiLCJzbGljZSIsImxhc3RJbmRleE9mIiwidHlwZVZhbHVlUGFpcnMiLCJtYXAiLCJpdGVtIiwiZW5jb2RlIiwidCIsInYiLCJkYXRhIiwiZW5jb2RlZFR5cGVzIiwiZW5jb2RlZFZhbHVlcyIsImhhc2hUeXBlIiwiZmllbGQiLCJwdXNoIiwiZW5jb2RlVHlwZSIsInJlc3VsdCIsInVuc29ydGVkRGVwcyIsImZpbmRUeXBlRGVwZW5kZW5jaWVzIiwiZGVsZXRlIiwiZGVwcyIsIkFycmF5IiwiZnJvbSIsInNvcnQiLCJjaGlsZHJlbiIsInJlc3VsdHMiLCJTZXQiLCJKU09OIiwic3RyaW5naWZ5IiwibWF0Y2giLCJoYXMiLCJhZGQiLCJoYXNoU3RydWN0IiwiZW5jb2RlZCIsImhhc2hlZCIsImJ1ZiIsImVuY29kZWRIYXNoVHlwZSIsInNhbml0aXplRGF0YSIsInNhbml0aXplZERhdGEiLCJrZXkiLCJhc3NpZ24iLCJFSVA3MTJEb21haW4iLCJlaXA3MTJEb21haW5IYXNoIiwidHlwZWREYXRhIiwiZG9tYWluVHlwZSIsImVpcDcxMkhhc2giLCJwYXJ0cyIsImNvbmNhdEJ5dGVzIiwiaGFzaEJ1ZmZlciIsIl90eXBlZFNpZ25hdHVyZUhhc2giLCJieXRlc1RvSGV4Iiwibm9ybWFsaXplVmFsdWUiLCJpc0FycmF5VHlwZSIsImlzQXJyYXkiLCJpbm5lclR5cGUiLCJnZXRBcnJheVR5cGUiLCJnZXRCeXRlTGVuZ3RoIiwiTWF0aCIsImFicyIsImFzSW50TiIsIm5vcm1hbGl6ZUFkZHJlc3NlcyIsInZhbHVlcyIsIm5vcm1hbGl6ZUludGVnZXJzIiwic2lnbmVkQmlnSW50VG9CeXRlcyIsImVycm9yIiwibm9ybWFsaXplZERhdGEiLCJlIiwibGVnYWN5VG9CdWZmZXIiLCJzY2hlbWEiLCJlbmNvZGVQYWNrZWQiLCJwcml2YXRlS2V5IiwiaXNOdWxsaXNoIiwibWVzc2FnZUhhc2giLCJWMSIsInNpZyIsImVjc2lnbiIsImNvbmNhdFNpZyIsInIiLCJzIiwic2lnbmF0dXJlIiwicHVibGljS2V5IiwicmVjb3ZlclB1YmxpY0tleSIsInNlbmRlciIsInB1YmxpY1RvQWRkcmVzcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/eth-sig-util/dist/sign-typed-data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/eth-sig-util/dist/utils.js":
/*!***********************************************************!*\
  !*** ./node_modules/@metamask/eth-sig-util/dist/utils.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.normalize = exports.recoverPublicKey = exports.concatSig = exports.legacyToBuffer = exports.isNullish = exports.padWithZeroes = void 0;\nconst util_1 = __webpack_require__(/*! @ethereumjs/util */ \"(ssr)/./node_modules/@ethereumjs/util/dist/index.js\");\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/utils/dist/index.js\");\n/**\n * Pads the front of the given hex string with zeroes until it reaches the\n * target length. If the input string is already longer than or equal to the\n * target length, it is returned unmodified.\n *\n * If the input string is \"0x\"-prefixed or not a hex string, an error will be\n * thrown.\n *\n * @param hexString - The hexadecimal string to pad with zeroes.\n * @param targetLength - The target length of the hexadecimal string.\n * @returns The input string front-padded with zeroes, or the original string\n * if it was already greater than or equal to to the target length.\n */ function padWithZeroes(hexString, targetLength) {\n    if (hexString !== \"\" && !/^[a-f0-9]+$/iu.test(hexString)) {\n        throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);\n    }\n    if (targetLength < 0) {\n        throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);\n    }\n    return String.prototype.padStart.call(hexString, targetLength, \"0\");\n}\nexports.padWithZeroes = padWithZeroes;\n/**\n * Returns `true` if the given value is nullish.\n *\n * @param value - The value being checked.\n * @returns Whether the value is nullish.\n */ function isNullish(value) {\n    return value === null || value === undefined;\n}\nexports.isNullish = isNullish;\n/**\n * Convert a value to a Buffer. This function should be equivalent to the `toBuffer` function in\n * `ethereumjs-util@5.2.1`.\n *\n * @param value - The value to convert to a Buffer.\n * @returns The given value as a Buffer.\n */ function legacyToBuffer(value) {\n    return typeof value === \"string\" && !(0, util_1.isHexString)(value) ? Buffer.from(value) : (0, util_1.toBuffer)(value);\n}\nexports.legacyToBuffer = legacyToBuffer;\n/**\n * Concatenate an extended ECDSA signature into a single '0x'-prefixed hex string.\n *\n * @param v - The 'v' portion of the signature.\n * @param r - The 'r' portion of the signature.\n * @param s - The 's' portion of the signature.\n * @returns The concatenated ECDSA signature as a '0x'-prefixed string.\n */ function concatSig(v, r, s) {\n    const rSig = (0, util_1.fromSigned)(r);\n    const sSig = (0, util_1.fromSigned)(s);\n    const vSig = (0, util_1.bufferToInt)(v);\n    const rStr = padWithZeroes((0, util_1.toUnsigned)(rSig).toString(\"hex\"), 64);\n    const sStr = padWithZeroes((0, util_1.toUnsigned)(sSig).toString(\"hex\"), 64);\n    const vStr = (0, utils_1.remove0x)((0, utils_1.numberToHex)(vSig));\n    return (0, utils_1.add0x)(rStr.concat(sStr, vStr));\n}\nexports.concatSig = concatSig;\n/**\n * Recover the public key from the given signature and message hash.\n *\n * @param messageHash - The hash of the signed message.\n * @param signature - The signature.\n * @returns The public key of the signer.\n */ function recoverPublicKey(messageHash, signature) {\n    const sigParams = (0, util_1.fromRpcSig)(signature);\n    return (0, util_1.ecrecover)(messageHash, sigParams.v, sigParams.r, sigParams.s);\n}\nexports.recoverPublicKey = recoverPublicKey;\n/**\n * Normalize the input to a lower-cased '0x'-prefixed hex string.\n *\n * @param input - The value to normalize.\n * @returns The normalized value.\n */ function normalize(input) {\n    if (isNullish(input)) {\n        return undefined;\n    }\n    if (typeof input === \"number\") {\n        if (input < 0) {\n            return \"0x\";\n        }\n        const buffer = (0, utils_1.numberToBytes)(input);\n        input = (0, utils_1.bytesToHex)(buffer);\n    }\n    if (typeof input !== \"string\") {\n        let msg = \"eth-sig-util.normalize() requires hex string or integer input.\";\n        msg += ` received ${typeof input}: ${input}`;\n        throw new Error(msg);\n    }\n    return (0, utils_1.add0x)(input.toLowerCase());\n}\nexports.normalize = normalize; //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBR0Esd0JBQXdCLEdBQUdBLGlCQUFpQixHQUFHQSxzQkFBc0IsR0FBR0EsaUJBQWlCLEdBQUdBLHFCQUFxQixHQUFHLEtBQUs7QUFDN0ksTUFBTVEsU0FBU0MsbUJBQU9BLENBQUMsNkVBQWtCO0FBQ3pDLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLDJFQUFpQjtBQUN6Qzs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRCxTQUFTRixjQUFjSSxTQUFTLEVBQUVDLFlBQVk7SUFDMUMsSUFBSUQsY0FBYyxNQUFNLENBQUMsZ0JBQWdCRSxJQUFJLENBQUNGLFlBQVk7UUFDdEQsTUFBTSxJQUFJRyxNQUFNLENBQUMsNkNBQTZDLEVBQUVILFVBQVUsQ0FBQztJQUMvRTtJQUNBLElBQUlDLGVBQWUsR0FBRztRQUNsQixNQUFNLElBQUlFLE1BQU0sQ0FBQyx5REFBeUQsRUFBRUYsYUFBYSxDQUFDO0lBQzlGO0lBQ0EsT0FBT0csT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ1AsV0FBV0MsY0FBYztBQUNuRTtBQUNBWixxQkFBcUIsR0FBR087QUFDeEI7Ozs7O0NBS0MsR0FDRCxTQUFTRCxVQUFVTCxLQUFLO0lBQ3BCLE9BQU9BLFVBQVUsUUFBUUEsVUFBVWtCO0FBQ3ZDO0FBQ0FuQixpQkFBaUIsR0FBR007QUFDcEI7Ozs7OztDQU1DLEdBQ0QsU0FBU0QsZUFBZUosS0FBSztJQUN6QixPQUFPLE9BQU9BLFVBQVUsWUFBWSxDQUFDLENBQUMsR0FBR08sT0FBT1ksV0FBVyxFQUFFbkIsU0FDdkRvQixPQUFPQyxJQUFJLENBQUNyQixTQUNaLENBQUMsR0FBR08sT0FBT2UsUUFBUSxFQUFFdEI7QUFDL0I7QUFDQUQsc0JBQXNCLEdBQUdLO0FBQ3pCOzs7Ozs7O0NBT0MsR0FDRCxTQUFTRCxVQUFVb0IsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUM7SUFDdEIsTUFBTUMsT0FBTyxDQUFDLEdBQUduQixPQUFPb0IsVUFBVSxFQUFFSDtJQUNwQyxNQUFNSSxPQUFPLENBQUMsR0FBR3JCLE9BQU9vQixVQUFVLEVBQUVGO0lBQ3BDLE1BQU1JLE9BQU8sQ0FBQyxHQUFHdEIsT0FBT3VCLFdBQVcsRUFBRVA7SUFDckMsTUFBTVEsT0FBT3pCLGNBQWMsQ0FBQyxHQUFHQyxPQUFPeUIsVUFBVSxFQUFFTixNQUFNTyxRQUFRLENBQUMsUUFBUTtJQUN6RSxNQUFNQyxPQUFPNUIsY0FBYyxDQUFDLEdBQUdDLE9BQU95QixVQUFVLEVBQUVKLE1BQU1LLFFBQVEsQ0FBQyxRQUFRO0lBQ3pFLE1BQU1FLE9BQU8sQ0FBQyxHQUFHMUIsUUFBUTJCLFFBQVEsRUFBRSxDQUFDLEdBQUczQixRQUFRNEIsV0FBVyxFQUFFUjtJQUM1RCxPQUFPLENBQUMsR0FBR3BCLFFBQVE2QixLQUFLLEVBQUVQLEtBQUtRLE1BQU0sQ0FBQ0wsTUFBTUM7QUFDaEQ7QUFDQXBDLGlCQUFpQixHQUFHSTtBQUNwQjs7Ozs7O0NBTUMsR0FDRCxTQUFTRCxpQkFBaUJzQyxXQUFXLEVBQUVDLFNBQVM7SUFDNUMsTUFBTUMsWUFBWSxDQUFDLEdBQUduQyxPQUFPb0MsVUFBVSxFQUFFRjtJQUN6QyxPQUFPLENBQUMsR0FBR2xDLE9BQU9xQyxTQUFTLEVBQUVKLGFBQWFFLFVBQVVuQixDQUFDLEVBQUVtQixVQUFVbEIsQ0FBQyxFQUFFa0IsVUFBVWpCLENBQUM7QUFDbkY7QUFDQTFCLHdCQUF3QixHQUFHRztBQUMzQjs7Ozs7Q0FLQyxHQUNELFNBQVNELFVBQVU0QyxLQUFLO0lBQ3BCLElBQUl4QyxVQUFVd0MsUUFBUTtRQUNsQixPQUFPM0I7SUFDWDtJQUNBLElBQUksT0FBTzJCLFVBQVUsVUFBVTtRQUMzQixJQUFJQSxRQUFRLEdBQUc7WUFDWCxPQUFPO1FBQ1g7UUFDQSxNQUFNQyxTQUFTLENBQUMsR0FBR3JDLFFBQVFzQyxhQUFhLEVBQUVGO1FBQzFDQSxRQUFRLENBQUMsR0FBR3BDLFFBQVF1QyxVQUFVLEVBQUVGO0lBQ3BDO0lBQ0EsSUFBSSxPQUFPRCxVQUFVLFVBQVU7UUFDM0IsSUFBSUksTUFBTTtRQUNWQSxPQUFPLENBQUMsVUFBVSxFQUFFLE9BQU9KLE1BQU0sRUFBRSxFQUFFQSxNQUFNLENBQUM7UUFDNUMsTUFBTSxJQUFJaEMsTUFBTW9DO0lBQ3BCO0lBQ0EsT0FBTyxDQUFDLEdBQUd4QyxRQUFRNkIsS0FBSyxFQUFFTyxNQUFNSyxXQUFXO0FBQy9DO0FBQ0FuRCxpQkFBaUIsR0FBR0UsV0FDcEIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL2Rpc3QvdXRpbHMuanM/YjllNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubm9ybWFsaXplID0gZXhwb3J0cy5yZWNvdmVyUHVibGljS2V5ID0gZXhwb3J0cy5jb25jYXRTaWcgPSBleHBvcnRzLmxlZ2FjeVRvQnVmZmVyID0gZXhwb3J0cy5pc051bGxpc2ggPSBleHBvcnRzLnBhZFdpdGhaZXJvZXMgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiQGV0aGVyZXVtanMvdXRpbFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuLyoqXG4gKiBQYWRzIHRoZSBmcm9udCBvZiB0aGUgZ2l2ZW4gaGV4IHN0cmluZyB3aXRoIHplcm9lcyB1bnRpbCBpdCByZWFjaGVzIHRoZVxuICogdGFyZ2V0IGxlbmd0aC4gSWYgdGhlIGlucHV0IHN0cmluZyBpcyBhbHJlYWR5IGxvbmdlciB0aGFuIG9yIGVxdWFsIHRvIHRoZVxuICogdGFyZ2V0IGxlbmd0aCwgaXQgaXMgcmV0dXJuZWQgdW5tb2RpZmllZC5cbiAqXG4gKiBJZiB0aGUgaW5wdXQgc3RyaW5nIGlzIFwiMHhcIi1wcmVmaXhlZCBvciBub3QgYSBoZXggc3RyaW5nLCBhbiBlcnJvciB3aWxsIGJlXG4gKiB0aHJvd24uXG4gKlxuICogQHBhcmFtIGhleFN0cmluZyAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gcGFkIHdpdGggemVyb2VzLlxuICogQHBhcmFtIHRhcmdldExlbmd0aCAtIFRoZSB0YXJnZXQgbGVuZ3RoIG9mIHRoZSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaW5wdXQgc3RyaW5nIGZyb250LXBhZGRlZCB3aXRoIHplcm9lcywgb3IgdGhlIG9yaWdpbmFsIHN0cmluZ1xuICogaWYgaXQgd2FzIGFscmVhZHkgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRvIHRoZSB0YXJnZXQgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBwYWRXaXRoWmVyb2VzKGhleFN0cmluZywgdGFyZ2V0TGVuZ3RoKSB7XG4gICAgaWYgKGhleFN0cmluZyAhPT0gJycgJiYgIS9eW2EtZjAtOV0rJC9pdS50ZXN0KGhleFN0cmluZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhbiB1bnByZWZpeGVkIGhleCBzdHJpbmcuIFJlY2VpdmVkOiAke2hleFN0cmluZ31gKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldExlbmd0aCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIHRhcmdldCBsZW5ndGguIFJlY2VpdmVkOiAke3RhcmdldExlbmd0aH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUucGFkU3RhcnQuY2FsbChoZXhTdHJpbmcsIHRhcmdldExlbmd0aCwgJzAnKTtcbn1cbmV4cG9ydHMucGFkV2l0aFplcm9lcyA9IHBhZFdpdGhaZXJvZXM7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBudWxsaXNoLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBiZWluZyBjaGVja2VkLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgbnVsbGlzaC5cbiAqL1xuZnVuY3Rpb24gaXNOdWxsaXNoKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzTnVsbGlzaCA9IGlzTnVsbGlzaDtcbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgQnVmZmVyLiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBlcXVpdmFsZW50IHRvIHRoZSBgdG9CdWZmZXJgIGZ1bmN0aW9uIGluXG4gKiBgZXRoZXJldW1qcy11dGlsQDUuMi4xYC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIEJ1ZmZlci5cbiAqIEByZXR1cm5zIFRoZSBnaXZlbiB2YWx1ZSBhcyBhIEJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gbGVnYWN5VG9CdWZmZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhKDAsIHV0aWxfMS5pc0hleFN0cmluZykodmFsdWUpXG4gICAgICAgID8gQnVmZmVyLmZyb20odmFsdWUpXG4gICAgICAgIDogKDAsIHV0aWxfMS50b0J1ZmZlcikodmFsdWUpO1xufVxuZXhwb3J0cy5sZWdhY3lUb0J1ZmZlciA9IGxlZ2FjeVRvQnVmZmVyO1xuLyoqXG4gKiBDb25jYXRlbmF0ZSBhbiBleHRlbmRlZCBFQ0RTQSBzaWduYXR1cmUgaW50byBhIHNpbmdsZSAnMHgnLXByZWZpeGVkIGhleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHYgLSBUaGUgJ3YnIHBvcnRpb24gb2YgdGhlIHNpZ25hdHVyZS5cbiAqIEBwYXJhbSByIC0gVGhlICdyJyBwb3J0aW9uIG9mIHRoZSBzaWduYXR1cmUuXG4gKiBAcGFyYW0gcyAtIFRoZSAncycgcG9ydGlvbiBvZiB0aGUgc2lnbmF0dXJlLlxuICogQHJldHVybnMgVGhlIGNvbmNhdGVuYXRlZCBFQ0RTQSBzaWduYXR1cmUgYXMgYSAnMHgnLXByZWZpeGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gY29uY2F0U2lnKHYsIHIsIHMpIHtcbiAgICBjb25zdCByU2lnID0gKDAsIHV0aWxfMS5mcm9tU2lnbmVkKShyKTtcbiAgICBjb25zdCBzU2lnID0gKDAsIHV0aWxfMS5mcm9tU2lnbmVkKShzKTtcbiAgICBjb25zdCB2U2lnID0gKDAsIHV0aWxfMS5idWZmZXJUb0ludCkodik7XG4gICAgY29uc3QgclN0ciA9IHBhZFdpdGhaZXJvZXMoKDAsIHV0aWxfMS50b1Vuc2lnbmVkKShyU2lnKS50b1N0cmluZygnaGV4JyksIDY0KTtcbiAgICBjb25zdCBzU3RyID0gcGFkV2l0aFplcm9lcygoMCwgdXRpbF8xLnRvVW5zaWduZWQpKHNTaWcpLnRvU3RyaW5nKCdoZXgnKSwgNjQpO1xuICAgIGNvbnN0IHZTdHIgPSAoMCwgdXRpbHNfMS5yZW1vdmUweCkoKDAsIHV0aWxzXzEubnVtYmVyVG9IZXgpKHZTaWcpKTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzEuYWRkMHgpKHJTdHIuY29uY2F0KHNTdHIsIHZTdHIpKTtcbn1cbmV4cG9ydHMuY29uY2F0U2lnID0gY29uY2F0U2lnO1xuLyoqXG4gKiBSZWNvdmVyIHRoZSBwdWJsaWMga2V5IGZyb20gdGhlIGdpdmVuIHNpZ25hdHVyZSBhbmQgbWVzc2FnZSBoYXNoLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlSGFzaCAtIFRoZSBoYXNoIG9mIHRoZSBzaWduZWQgbWVzc2FnZS5cbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlLlxuICogQHJldHVybnMgVGhlIHB1YmxpYyBrZXkgb2YgdGhlIHNpZ25lci5cbiAqL1xuZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShtZXNzYWdlSGFzaCwgc2lnbmF0dXJlKSB7XG4gICAgY29uc3Qgc2lnUGFyYW1zID0gKDAsIHV0aWxfMS5mcm9tUnBjU2lnKShzaWduYXR1cmUpO1xuICAgIHJldHVybiAoMCwgdXRpbF8xLmVjcmVjb3ZlcikobWVzc2FnZUhhc2gsIHNpZ1BhcmFtcy52LCBzaWdQYXJhbXMuciwgc2lnUGFyYW1zLnMpO1xufVxuZXhwb3J0cy5yZWNvdmVyUHVibGljS2V5ID0gcmVjb3ZlclB1YmxpY0tleTtcbi8qKlxuICogTm9ybWFsaXplIHRoZSBpbnB1dCB0byBhIGxvd2VyLWNhc2VkICcweCctcHJlZml4ZWQgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gbm9ybWFsaXplLlxuICogQHJldHVybnMgVGhlIG5vcm1hbGl6ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShpbnB1dCkge1xuICAgIGlmIChpc051bGxpc2goaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChpbnB1dCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnMHgnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9ICgwLCB1dGlsc18xLm51bWJlclRvQnl0ZXMpKGlucHV0KTtcbiAgICAgICAgaW5wdXQgPSAoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KShidWZmZXIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBsZXQgbXNnID0gJ2V0aC1zaWctdXRpbC5ub3JtYWxpemUoKSByZXF1aXJlcyBoZXggc3RyaW5nIG9yIGludGVnZXIgaW5wdXQuJztcbiAgICAgICAgbXNnICs9IGAgcmVjZWl2ZWQgJHt0eXBlb2YgaW5wdXR9OiAke2lucHV0fWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHV0aWxzXzEuYWRkMHgpKGlucHV0LnRvTG93ZXJDYXNlKCkpO1xufVxuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJub3JtYWxpemUiLCJyZWNvdmVyUHVibGljS2V5IiwiY29uY2F0U2lnIiwibGVnYWN5VG9CdWZmZXIiLCJpc051bGxpc2giLCJwYWRXaXRoWmVyb2VzIiwidXRpbF8xIiwicmVxdWlyZSIsInV0aWxzXzEiLCJoZXhTdHJpbmciLCJ0YXJnZXRMZW5ndGgiLCJ0ZXN0IiwiRXJyb3IiLCJTdHJpbmciLCJwcm90b3R5cGUiLCJwYWRTdGFydCIsImNhbGwiLCJ1bmRlZmluZWQiLCJpc0hleFN0cmluZyIsIkJ1ZmZlciIsImZyb20iLCJ0b0J1ZmZlciIsInYiLCJyIiwicyIsInJTaWciLCJmcm9tU2lnbmVkIiwic1NpZyIsInZTaWciLCJidWZmZXJUb0ludCIsInJTdHIiLCJ0b1Vuc2lnbmVkIiwidG9TdHJpbmciLCJzU3RyIiwidlN0ciIsInJlbW92ZTB4IiwibnVtYmVyVG9IZXgiLCJhZGQweCIsImNvbmNhdCIsIm1lc3NhZ2VIYXNoIiwic2lnbmF0dXJlIiwic2lnUGFyYW1zIiwiZnJvbVJwY1NpZyIsImVjcmVjb3ZlciIsImlucHV0IiwiYnVmZmVyIiwibnVtYmVyVG9CeXRlcyIsImJ5dGVzVG9IZXgiLCJtc2ciLCJ0b0xvd2VyQ2FzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/eth-sig-util/dist/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/rpc-errors/dist/classes.js":
/*!***********************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/dist/classes.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.EthereumProviderError = exports.JsonRpcError = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/utils/dist/index.js\");\nconst fast_safe_stringify_1 = __importDefault(__webpack_require__(/*! fast-safe-stringify */ \"(ssr)/./node_modules/fast-safe-stringify/index.js\"));\nconst utils_2 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@metamask/rpc-errors/dist/utils.js\");\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors\n * per EIP-1474.\n *\n * Permits any integer error code.\n */ class JsonRpcError extends Error {\n    constructor(code, message, data){\n        if (!Number.isInteger(code)) {\n            throw new Error('\"code\" must be an integer.');\n        }\n        if (!message || typeof message !== \"string\") {\n            throw new Error('\"message\" must be a non-empty string.');\n        }\n        super(message);\n        this.code = code;\n        if (data !== undefined) {\n            this.data = data;\n        }\n    }\n    /**\n     * Get the error as JSON-serializable object.\n     *\n     * @returns A plain object with all public class properties.\n     */ serialize() {\n        const serialized = {\n            code: this.code,\n            message: this.message\n        };\n        if (this.data !== undefined) {\n            // `this.data` is not guaranteed to be a plain object, but this simplifies\n            // the type guard below. We can safely cast it because we know it's a\n            // JSON-serializable value.\n            serialized.data = this.data;\n            if ((0, utils_1.isPlainObject)(this.data)) {\n                serialized.data.cause = (0, utils_2.serializeCause)(this.data.cause);\n            }\n        }\n        if (this.stack) {\n            serialized.stack = this.stack;\n        }\n        return serialized;\n    }\n    /**\n     * Get a string representation of the serialized error, omitting any circular\n     * references.\n     *\n     * @returns A string representation of the serialized error.\n     */ toString() {\n        return (0, fast_safe_stringify_1.default)(this.serialize(), stringifyReplacer, 2);\n    }\n}\nexports.JsonRpcError = JsonRpcError;\n/**\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n * Permits integer error codes in the [ 1000 <= 4999 ] range.\n */ class EthereumProviderError extends JsonRpcError {\n    /**\n     * Create an Ethereum Provider JSON-RPC error.\n     *\n     * @param code - The JSON-RPC error code. Must be an integer in the\n     * `1000 <= n <= 4999` range.\n     * @param message - The JSON-RPC error message.\n     * @param data - Optional data to include in the error.\n     */ constructor(code, message, data){\n        if (!isValidEthProviderCode(code)) {\n            throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\n        }\n        super(code, message, data);\n    }\n}\nexports.EthereumProviderError = EthereumProviderError;\n/**\n * Check if the given code is a valid JSON-RPC error code.\n *\n * @param code - The code to check.\n * @returns Whether the code is valid.\n */ function isValidEthProviderCode(code) {\n    return Number.isInteger(code) && code >= 1000 && code <= 4999;\n}\n/**\n * A JSON replacer function that omits circular references.\n *\n * @param _ - The key being replaced.\n * @param value - The value being replaced.\n * @returns The value to use in place of the original value.\n */ function stringifyReplacer(_, value) {\n    if (value === \"[Circular]\") {\n        return undefined;\n    }\n    return value;\n} //# sourceMappingURL=classes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1lcnJvcnMvZGlzdC9jbGFzc2VzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNkJBQTZCLEdBQUdBLG9CQUFvQixHQUFHLEtBQUs7QUFDNUQsTUFBTUksVUFBVUMsbUJBQU9BLENBQUMsMkVBQWlCO0FBQ3pDLE1BQU1DLHdCQUF3QlgsZ0JBQWdCVSxtQkFBT0EsQ0FBQyw4RUFBcUI7QUFDM0UsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMsd0VBQVM7QUFDakM7Ozs7O0NBS0MsR0FDRCxNQUFNRixxQkFBcUJLO0lBQ3ZCQyxZQUFZQyxJQUFJLEVBQUVDLE9BQU8sRUFBRUMsSUFBSSxDQUFFO1FBQzdCLElBQUksQ0FBQ0MsT0FBT0MsU0FBUyxDQUFDSixPQUFPO1lBQ3pCLE1BQU0sSUFBSUYsTUFBTTtRQUNwQjtRQUNBLElBQUksQ0FBQ0csV0FBVyxPQUFPQSxZQUFZLFVBQVU7WUFDekMsTUFBTSxJQUFJSCxNQUFNO1FBQ3BCO1FBQ0EsS0FBSyxDQUFDRztRQUNOLElBQUksQ0FBQ0QsSUFBSSxHQUFHQTtRQUNaLElBQUlFLFNBQVNHLFdBQVc7WUFDcEIsSUFBSSxDQUFDSCxJQUFJLEdBQUdBO1FBQ2hCO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0RJLFlBQVk7UUFDUixNQUFNQyxhQUFhO1lBQ2ZQLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZDLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1FBQ3pCO1FBQ0EsSUFBSSxJQUFJLENBQUNDLElBQUksS0FBS0csV0FBVztZQUN6QiwwRUFBMEU7WUFDMUUscUVBQXFFO1lBQ3JFLDJCQUEyQjtZQUMzQkUsV0FBV0wsSUFBSSxHQUFHLElBQUksQ0FBQ0EsSUFBSTtZQUMzQixJQUFJLENBQUMsR0FBR1IsUUFBUWMsYUFBYSxFQUFFLElBQUksQ0FBQ04sSUFBSSxHQUFHO2dCQUN2Q0ssV0FBV0wsSUFBSSxDQUFDTyxLQUFLLEdBQUcsQ0FBQyxHQUFHWixRQUFRYSxjQUFjLEVBQUUsSUFBSSxDQUFDUixJQUFJLENBQUNPLEtBQUs7WUFDdkU7UUFDSjtRQUNBLElBQUksSUFBSSxDQUFDRSxLQUFLLEVBQUU7WUFDWkosV0FBV0ksS0FBSyxHQUFHLElBQUksQ0FBQ0EsS0FBSztRQUNqQztRQUNBLE9BQU9KO0lBQ1g7SUFDQTs7Ozs7S0FLQyxHQUNESyxXQUFXO1FBQ1AsT0FBTyxDQUFDLEdBQUdoQixzQkFBc0JpQixPQUFPLEVBQUUsSUFBSSxDQUFDUCxTQUFTLElBQUlRLG1CQUFtQjtJQUNuRjtBQUNKO0FBQ0F4QixvQkFBb0IsR0FBR0c7QUFDdkI7OztDQUdDLEdBQ0QsTUFBTUQsOEJBQThCQztJQUNoQzs7Ozs7OztLQU9DLEdBQ0RNLFlBQVlDLElBQUksRUFBRUMsT0FBTyxFQUFFQyxJQUFJLENBQUU7UUFDN0IsSUFBSSxDQUFDYSx1QkFBdUJmLE9BQU87WUFDL0IsTUFBTSxJQUFJRixNQUFNO1FBQ3BCO1FBQ0EsS0FBSyxDQUFDRSxNQUFNQyxTQUFTQztJQUN6QjtBQUNKO0FBQ0FaLDZCQUE2QixHQUFHRTtBQUNoQzs7Ozs7Q0FLQyxHQUNELFNBQVN1Qix1QkFBdUJmLElBQUk7SUFDaEMsT0FBT0csT0FBT0MsU0FBUyxDQUFDSixTQUFTQSxRQUFRLFFBQVFBLFFBQVE7QUFDN0Q7QUFDQTs7Ozs7O0NBTUMsR0FDRCxTQUFTYyxrQkFBa0JFLENBQUMsRUFBRXpCLEtBQUs7SUFDL0IsSUFBSUEsVUFBVSxjQUFjO1FBQ3hCLE9BQU9jO0lBQ1g7SUFDQSxPQUFPZDtBQUNYLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLWVycm9ycy9kaXN0L2NsYXNzZXMuanM/NDA1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRXRoZXJldW1Qcm92aWRlckVycm9yID0gZXhwb3J0cy5Kc29uUnBjRXJyb3IgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbmNvbnN0IGZhc3Rfc2FmZV9zdHJpbmdpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZmFzdC1zYWZlLXN0cmluZ2lmeVwiKSk7XG5jb25zdCB1dGlsc18yID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIEVycm9yIHN1YmNsYXNzIGltcGxlbWVudGluZyBKU09OIFJQQyAyLjAgZXJyb3JzIGFuZCBFdGhlcmV1bSBSUEMgZXJyb3JzXG4gKiBwZXIgRUlQLTE0NzQuXG4gKlxuICogUGVybWl0cyBhbnkgaW50ZWdlciBlcnJvciBjb2RlLlxuICovXG5jbGFzcyBKc29uUnBjRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoY29kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJjb2RlXCIgbXVzdCBiZSBhbiBpbnRlZ2VyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWVzc2FnZSB8fCB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZXNzYWdlXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBlcnJvciBhcyBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHBsYWluIG9iamVjdCB3aXRoIGFsbCBwdWJsaWMgY2xhc3MgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICAgICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gYHRoaXMuZGF0YWAgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgYSBwbGFpbiBvYmplY3QsIGJ1dCB0aGlzIHNpbXBsaWZpZXNcbiAgICAgICAgICAgIC8vIHRoZSB0eXBlIGd1YXJkIGJlbG93LiBXZSBjYW4gc2FmZWx5IGNhc3QgaXQgYmVjYXVzZSB3ZSBrbm93IGl0J3MgYVxuICAgICAgICAgICAgLy8gSlNPTi1zZXJpYWxpemFibGUgdmFsdWUuXG4gICAgICAgICAgICBzZXJpYWxpemVkLmRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQbGFpbk9iamVjdCkodGhpcy5kYXRhKSkge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQuZGF0YS5jYXVzZSA9ICgwLCB1dGlsc18yLnNlcmlhbGl6ZUNhdXNlKSh0aGlzLmRhdGEuY2F1c2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YWNrKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkLnN0YWNrID0gdGhpcy5zdGFjaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzZXJpYWxpemVkIGVycm9yLCBvbWl0dGluZyBhbnkgY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNlcmlhbGl6ZWQgZXJyb3IuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoMCwgZmFzdF9zYWZlX3N0cmluZ2lmeV8xLmRlZmF1bHQpKHRoaXMuc2VyaWFsaXplKCksIHN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgICB9XG59XG5leHBvcnRzLkpzb25ScGNFcnJvciA9IEpzb25ScGNFcnJvcjtcbi8qKlxuICogRXJyb3Igc3ViY2xhc3MgaW1wbGVtZW50aW5nIEV0aGVyZXVtIFByb3ZpZGVyIGVycm9ycyBwZXIgRUlQLTExOTMuXG4gKiBQZXJtaXRzIGludGVnZXIgZXJyb3IgY29kZXMgaW4gdGhlIFsgMTAwMCA8PSA0OTk5IF0gcmFuZ2UuXG4gKi9cbmNsYXNzIEV0aGVyZXVtUHJvdmlkZXJFcnJvciBleHRlbmRzIEpzb25ScGNFcnJvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIEV0aGVyZXVtIFByb3ZpZGVyIEpTT04tUlBDIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvZGUgLSBUaGUgSlNPTi1SUEMgZXJyb3IgY29kZS4gTXVzdCBiZSBhbiBpbnRlZ2VyIGluIHRoZVxuICAgICAqIGAxMDAwIDw9IG4gPD0gNDk5OWAgcmFuZ2UuXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgSlNPTi1SUEMgZXJyb3IgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0gZGF0YSAtIE9wdGlvbmFsIGRhdGEgdG8gaW5jbHVkZSBpbiB0aGUgZXJyb3IuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgICAgICBpZiAoIWlzVmFsaWRFdGhQcm92aWRlckNvZGUoY29kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJjb2RlXCIgbXVzdCBiZSBhbiBpbnRlZ2VyIHN1Y2ggdGhhdDogMTAwMCA8PSBjb2RlIDw9IDQ5OTknKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihjb2RlLCBtZXNzYWdlLCBkYXRhKTtcbiAgICB9XG59XG5leHBvcnRzLkV0aGVyZXVtUHJvdmlkZXJFcnJvciA9IEV0aGVyZXVtUHJvdmlkZXJFcnJvcjtcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGNvZGUgaXMgYSB2YWxpZCBKU09OLVJQQyBlcnJvciBjb2RlLlxuICpcbiAqIEBwYXJhbSBjb2RlIC0gVGhlIGNvZGUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBjb2RlIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkRXRoUHJvdmlkZXJDb2RlKGNvZGUpIHtcbiAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihjb2RlKSAmJiBjb2RlID49IDEwMDAgJiYgY29kZSA8PSA0OTk5O1xufVxuLyoqXG4gKiBBIEpTT04gcmVwbGFjZXIgZnVuY3Rpb24gdGhhdCBvbWl0cyBjaXJjdWxhciByZWZlcmVuY2VzLlxuICpcbiAqIEBwYXJhbSBfIC0gVGhlIGtleSBiZWluZyByZXBsYWNlZC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBiZWluZyByZXBsYWNlZC5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIG9yaWdpbmFsIHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlSZXBsYWNlcihfLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gJ1tDaXJjdWxhcl0nKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsYXNzZXMuanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkV0aGVyZXVtUHJvdmlkZXJFcnJvciIsIkpzb25ScGNFcnJvciIsInV0aWxzXzEiLCJyZXF1aXJlIiwiZmFzdF9zYWZlX3N0cmluZ2lmeV8xIiwidXRpbHNfMiIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJjb2RlIiwibWVzc2FnZSIsImRhdGEiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJ1bmRlZmluZWQiLCJzZXJpYWxpemUiLCJzZXJpYWxpemVkIiwiaXNQbGFpbk9iamVjdCIsImNhdXNlIiwic2VyaWFsaXplQ2F1c2UiLCJzdGFjayIsInRvU3RyaW5nIiwiZGVmYXVsdCIsInN0cmluZ2lmeVJlcGxhY2VyIiwiaXNWYWxpZEV0aFByb3ZpZGVyQ29kZSIsIl8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/rpc-errors/dist/classes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/rpc-errors/dist/error-constants.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/dist/error-constants.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.errorValues = exports.errorCodes = void 0;\nexports.errorCodes = {\n    rpc: {\n        invalidInput: -32000,\n        resourceNotFound: -32001,\n        resourceUnavailable: -32002,\n        transactionRejected: -32003,\n        methodNotSupported: -32004,\n        limitExceeded: -32005,\n        parse: -32700,\n        invalidRequest: -32600,\n        methodNotFound: -32601,\n        invalidParams: -32602,\n        internal: -32603\n    },\n    provider: {\n        userRejectedRequest: 4001,\n        unauthorized: 4100,\n        unsupportedMethod: 4200,\n        disconnected: 4900,\n        chainDisconnected: 4901\n    }\n};\n/* eslint-disable @typescript-eslint/naming-convention */ exports.errorValues = {\n    \"-32700\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.\"\n    },\n    \"-32600\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"The JSON sent is not a valid Request object.\"\n    },\n    \"-32601\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"The method does not exist / is not available.\"\n    },\n    \"-32602\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Invalid method parameter(s).\"\n    },\n    \"-32603\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Internal JSON-RPC error.\"\n    },\n    \"-32000\": {\n        standard: \"EIP-1474\",\n        message: \"Invalid input.\"\n    },\n    \"-32001\": {\n        standard: \"EIP-1474\",\n        message: \"Resource not found.\"\n    },\n    \"-32002\": {\n        standard: \"EIP-1474\",\n        message: \"Resource unavailable.\"\n    },\n    \"-32003\": {\n        standard: \"EIP-1474\",\n        message: \"Transaction rejected.\"\n    },\n    \"-32004\": {\n        standard: \"EIP-1474\",\n        message: \"Method not supported.\"\n    },\n    \"-32005\": {\n        standard: \"EIP-1474\",\n        message: \"Request limit exceeded.\"\n    },\n    \"4001\": {\n        standard: \"EIP-1193\",\n        message: \"User rejected the request.\"\n    },\n    \"4100\": {\n        standard: \"EIP-1193\",\n        message: \"The requested account and/or method has not been authorized by the user.\"\n    },\n    \"4200\": {\n        standard: \"EIP-1193\",\n        message: \"The requested method is not supported by this Ethereum provider.\"\n    },\n    \"4900\": {\n        standard: \"EIP-1193\",\n        message: \"The provider is disconnected from all chains.\"\n    },\n    \"4901\": {\n        standard: \"EIP-1193\",\n        message: \"The provider is disconnected from the specified chain.\"\n    }\n}; /* eslint-enable @typescript-eslint/naming-convention */  //# sourceMappingURL=error-constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1lcnJvcnMvZGlzdC9lcnJvci1jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1CQUFtQixHQUFHQSxrQkFBa0IsR0FBRyxLQUFLO0FBQ2hEQSxrQkFBa0IsR0FBRztJQUNqQkksS0FBSztRQUNEQyxjQUFjLENBQUM7UUFDZkMsa0JBQWtCLENBQUM7UUFDbkJDLHFCQUFxQixDQUFDO1FBQ3RCQyxxQkFBcUIsQ0FBQztRQUN0QkMsb0JBQW9CLENBQUM7UUFDckJDLGVBQWUsQ0FBQztRQUNoQkMsT0FBTyxDQUFDO1FBQ1JDLGdCQUFnQixDQUFDO1FBQ2pCQyxnQkFBZ0IsQ0FBQztRQUNqQkMsZUFBZSxDQUFDO1FBQ2hCQyxVQUFVLENBQUM7SUFDZjtJQUNBQyxVQUFVO1FBQ05DLHFCQUFxQjtRQUNyQkMsY0FBYztRQUNkQyxtQkFBbUI7UUFDbkJDLGNBQWM7UUFDZEMsbUJBQW1CO0lBQ3ZCO0FBQ0o7QUFDQSx1REFBdUQsR0FDdkRyQixtQkFBbUIsR0FBRztJQUNsQixVQUFVO1FBQ05zQixVQUFVO1FBQ1ZDLFNBQVM7SUFDYjtJQUNBLFVBQVU7UUFDTkQsVUFBVTtRQUNWQyxTQUFTO0lBQ2I7SUFDQSxVQUFVO1FBQ05ELFVBQVU7UUFDVkMsU0FBUztJQUNiO0lBQ0EsVUFBVTtRQUNORCxVQUFVO1FBQ1ZDLFNBQVM7SUFDYjtJQUNBLFVBQVU7UUFDTkQsVUFBVTtRQUNWQyxTQUFTO0lBQ2I7SUFDQSxVQUFVO1FBQ05ELFVBQVU7UUFDVkMsU0FBUztJQUNiO0lBQ0EsVUFBVTtRQUNORCxVQUFVO1FBQ1ZDLFNBQVM7SUFDYjtJQUNBLFVBQVU7UUFDTkQsVUFBVTtRQUNWQyxTQUFTO0lBQ2I7SUFDQSxVQUFVO1FBQ05ELFVBQVU7UUFDVkMsU0FBUztJQUNiO0lBQ0EsVUFBVTtRQUNORCxVQUFVO1FBQ1ZDLFNBQVM7SUFDYjtJQUNBLFVBQVU7UUFDTkQsVUFBVTtRQUNWQyxTQUFTO0lBQ2I7SUFDQSxRQUFRO1FBQ0pELFVBQVU7UUFDVkMsU0FBUztJQUNiO0lBQ0EsUUFBUTtRQUNKRCxVQUFVO1FBQ1ZDLFNBQVM7SUFDYjtJQUNBLFFBQVE7UUFDSkQsVUFBVTtRQUNWQyxTQUFTO0lBQ2I7SUFDQSxRQUFRO1FBQ0pELFVBQVU7UUFDVkMsU0FBUztJQUNiO0lBQ0EsUUFBUTtRQUNKRCxVQUFVO1FBQ1ZDLFNBQVM7SUFDYjtBQUNKLEdBQ0Esc0RBQXNELElBQ3RELDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1lcnJvcnMvZGlzdC9lcnJvci1jb25zdGFudHMuanM/NWI0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXJyb3JWYWx1ZXMgPSBleHBvcnRzLmVycm9yQ29kZXMgPSB2b2lkIDA7XG5leHBvcnRzLmVycm9yQ29kZXMgPSB7XG4gICAgcnBjOiB7XG4gICAgICAgIGludmFsaWRJbnB1dDogLTMyMDAwLFxuICAgICAgICByZXNvdXJjZU5vdEZvdW5kOiAtMzIwMDEsXG4gICAgICAgIHJlc291cmNlVW5hdmFpbGFibGU6IC0zMjAwMixcbiAgICAgICAgdHJhbnNhY3Rpb25SZWplY3RlZDogLTMyMDAzLFxuICAgICAgICBtZXRob2ROb3RTdXBwb3J0ZWQ6IC0zMjAwNCxcbiAgICAgICAgbGltaXRFeGNlZWRlZDogLTMyMDA1LFxuICAgICAgICBwYXJzZTogLTMyNzAwLFxuICAgICAgICBpbnZhbGlkUmVxdWVzdDogLTMyNjAwLFxuICAgICAgICBtZXRob2ROb3RGb3VuZDogLTMyNjAxLFxuICAgICAgICBpbnZhbGlkUGFyYW1zOiAtMzI2MDIsXG4gICAgICAgIGludGVybmFsOiAtMzI2MDMsXG4gICAgfSxcbiAgICBwcm92aWRlcjoge1xuICAgICAgICB1c2VyUmVqZWN0ZWRSZXF1ZXN0OiA0MDAxLFxuICAgICAgICB1bmF1dGhvcml6ZWQ6IDQxMDAsXG4gICAgICAgIHVuc3VwcG9ydGVkTWV0aG9kOiA0MjAwLFxuICAgICAgICBkaXNjb25uZWN0ZWQ6IDQ5MDAsXG4gICAgICAgIGNoYWluRGlzY29ubmVjdGVkOiA0OTAxLFxuICAgIH0sXG59O1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXG5leHBvcnRzLmVycm9yVmFsdWVzID0ge1xuICAgICctMzI3MDAnOiB7XG4gICAgICAgIHN0YW5kYXJkOiAnSlNPTiBSUEMgMi4wJyxcbiAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgSlNPTiB3YXMgcmVjZWl2ZWQgYnkgdGhlIHNlcnZlci4gQW4gZXJyb3Igb2NjdXJyZWQgb24gdGhlIHNlcnZlciB3aGlsZSBwYXJzaW5nIHRoZSBKU09OIHRleHQuJyxcbiAgICB9LFxuICAgICctMzI2MDAnOiB7XG4gICAgICAgIHN0YW5kYXJkOiAnSlNPTiBSUEMgMi4wJyxcbiAgICAgICAgbWVzc2FnZTogJ1RoZSBKU09OIHNlbnQgaXMgbm90IGEgdmFsaWQgUmVxdWVzdCBvYmplY3QuJyxcbiAgICB9LFxuICAgICctMzI2MDEnOiB7XG4gICAgICAgIHN0YW5kYXJkOiAnSlNPTiBSUEMgMi4wJyxcbiAgICAgICAgbWVzc2FnZTogJ1RoZSBtZXRob2QgZG9lcyBub3QgZXhpc3QgLyBpcyBub3QgYXZhaWxhYmxlLicsXG4gICAgfSxcbiAgICAnLTMyNjAyJzoge1xuICAgICAgICBzdGFuZGFyZDogJ0pTT04gUlBDIDIuMCcsXG4gICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIG1ldGhvZCBwYXJhbWV0ZXIocykuJyxcbiAgICB9LFxuICAgICctMzI2MDMnOiB7XG4gICAgICAgIHN0YW5kYXJkOiAnSlNPTiBSUEMgMi4wJyxcbiAgICAgICAgbWVzc2FnZTogJ0ludGVybmFsIEpTT04tUlBDIGVycm9yLicsXG4gICAgfSxcbiAgICAnLTMyMDAwJzoge1xuICAgICAgICBzdGFuZGFyZDogJ0VJUC0xNDc0JyxcbiAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgaW5wdXQuJyxcbiAgICB9LFxuICAgICctMzIwMDEnOiB7XG4gICAgICAgIHN0YW5kYXJkOiAnRUlQLTE0NzQnLFxuICAgICAgICBtZXNzYWdlOiAnUmVzb3VyY2Ugbm90IGZvdW5kLicsXG4gICAgfSxcbiAgICAnLTMyMDAyJzoge1xuICAgICAgICBzdGFuZGFyZDogJ0VJUC0xNDc0JyxcbiAgICAgICAgbWVzc2FnZTogJ1Jlc291cmNlIHVuYXZhaWxhYmxlLicsXG4gICAgfSxcbiAgICAnLTMyMDAzJzoge1xuICAgICAgICBzdGFuZGFyZDogJ0VJUC0xNDc0JyxcbiAgICAgICAgbWVzc2FnZTogJ1RyYW5zYWN0aW9uIHJlamVjdGVkLicsXG4gICAgfSxcbiAgICAnLTMyMDA0Jzoge1xuICAgICAgICBzdGFuZGFyZDogJ0VJUC0xNDc0JyxcbiAgICAgICAgbWVzc2FnZTogJ01ldGhvZCBub3Qgc3VwcG9ydGVkLicsXG4gICAgfSxcbiAgICAnLTMyMDA1Jzoge1xuICAgICAgICBzdGFuZGFyZDogJ0VJUC0xNDc0JyxcbiAgICAgICAgbWVzc2FnZTogJ1JlcXVlc3QgbGltaXQgZXhjZWVkZWQuJyxcbiAgICB9LFxuICAgICc0MDAxJzoge1xuICAgICAgICBzdGFuZGFyZDogJ0VJUC0xMTkzJyxcbiAgICAgICAgbWVzc2FnZTogJ1VzZXIgcmVqZWN0ZWQgdGhlIHJlcXVlc3QuJyxcbiAgICB9LFxuICAgICc0MTAwJzoge1xuICAgICAgICBzdGFuZGFyZDogJ0VJUC0xMTkzJyxcbiAgICAgICAgbWVzc2FnZTogJ1RoZSByZXF1ZXN0ZWQgYWNjb3VudCBhbmQvb3IgbWV0aG9kIGhhcyBub3QgYmVlbiBhdXRob3JpemVkIGJ5IHRoZSB1c2VyLicsXG4gICAgfSxcbiAgICAnNDIwMCc6IHtcbiAgICAgICAgc3RhbmRhcmQ6ICdFSVAtMTE5MycsXG4gICAgICAgIG1lc3NhZ2U6ICdUaGUgcmVxdWVzdGVkIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgRXRoZXJldW0gcHJvdmlkZXIuJyxcbiAgICB9LFxuICAgICc0OTAwJzoge1xuICAgICAgICBzdGFuZGFyZDogJ0VJUC0xMTkzJyxcbiAgICAgICAgbWVzc2FnZTogJ1RoZSBwcm92aWRlciBpcyBkaXNjb25uZWN0ZWQgZnJvbSBhbGwgY2hhaW5zLicsXG4gICAgfSxcbiAgICAnNDkwMSc6IHtcbiAgICAgICAgc3RhbmRhcmQ6ICdFSVAtMTE5MycsXG4gICAgICAgIG1lc3NhZ2U6ICdUaGUgcHJvdmlkZXIgaXMgZGlzY29ubmVjdGVkIGZyb20gdGhlIHNwZWNpZmllZCBjaGFpbi4nLFxuICAgIH0sXG59O1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlcnJvclZhbHVlcyIsImVycm9yQ29kZXMiLCJycGMiLCJpbnZhbGlkSW5wdXQiLCJyZXNvdXJjZU5vdEZvdW5kIiwicmVzb3VyY2VVbmF2YWlsYWJsZSIsInRyYW5zYWN0aW9uUmVqZWN0ZWQiLCJtZXRob2ROb3RTdXBwb3J0ZWQiLCJsaW1pdEV4Y2VlZGVkIiwicGFyc2UiLCJpbnZhbGlkUmVxdWVzdCIsIm1ldGhvZE5vdEZvdW5kIiwiaW52YWxpZFBhcmFtcyIsImludGVybmFsIiwicHJvdmlkZXIiLCJ1c2VyUmVqZWN0ZWRSZXF1ZXN0IiwidW5hdXRob3JpemVkIiwidW5zdXBwb3J0ZWRNZXRob2QiLCJkaXNjb25uZWN0ZWQiLCJjaGFpbkRpc2Nvbm5lY3RlZCIsInN0YW5kYXJkIiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/rpc-errors/dist/error-constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/rpc-errors/dist/errors.js":
/*!**********************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/dist/errors.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.providerErrors = exports.rpcErrors = void 0;\nconst classes_1 = __webpack_require__(/*! ./classes */ \"(ssr)/./node_modules/@metamask/rpc-errors/dist/classes.js\");\nconst error_constants_1 = __webpack_require__(/*! ./error-constants */ \"(ssr)/./node_modules/@metamask/rpc-errors/dist/error-constants.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@metamask/rpc-errors/dist/utils.js\");\nexports.rpcErrors = {\n    /**\n     * Get a JSON RPC 2.0 Parse (-32700) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */ parse: (arg)=>getJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),\n    /**\n     * Get a JSON RPC 2.0 Invalid Request (-32600) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */ invalidRequest: (arg)=>getJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),\n    /**\n     * Get a JSON RPC 2.0 Invalid Params (-32602) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */ invalidParams: (arg)=>getJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),\n    /**\n     * Get a JSON RPC 2.0 Method Not Found (-32601) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */ methodNotFound: (arg)=>getJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),\n    /**\n     * Get a JSON RPC 2.0 Internal (-32603) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */ internal: (arg)=>getJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),\n    /**\n     * Get a JSON RPC 2.0 Server error.\n     * Permits integer error codes in the [ -32099 <= -32005 ] range.\n     * Codes -32000 through -32004 are reserved by EIP-1474.\n     *\n     * @param opts - The error options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */ server: (opts)=>{\n        if (!opts || typeof opts !== \"object\" || Array.isArray(opts)) {\n            throw new Error(\"Ethereum RPC Server errors must provide single object argument.\");\n        }\n        const { code } = opts;\n        if (!Number.isInteger(code) || code > -32005 || code < -32099) {\n            throw new Error('\"code\" must be an integer such that: -32099 <= code <= -32005');\n        }\n        return getJsonRpcError(code, opts);\n    },\n    /**\n     * Get an Ethereum JSON RPC Invalid Input (-32000) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */ invalidInput: (arg)=>getJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),\n    /**\n     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */ resourceNotFound: (arg)=>getJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),\n    /**\n     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */ resourceUnavailable: (arg)=>getJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),\n    /**\n     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */ transactionRejected: (arg)=>getJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),\n    /**\n     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */ methodNotSupported: (arg)=>getJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),\n    /**\n     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link JsonRpcError} class.\n     */ limitExceeded: (arg)=>getJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)\n};\nexports.providerErrors = {\n    /**\n     * Get an Ethereum Provider User Rejected Request (4001) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link EthereumProviderError} class.\n     */ userRejectedRequest: (arg)=>{\n        return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);\n    },\n    /**\n     * Get an Ethereum Provider Unauthorized (4100) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link EthereumProviderError} class.\n     */ unauthorized: (arg)=>{\n        return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);\n    },\n    /**\n     * Get an Ethereum Provider Unsupported Method (4200) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link EthereumProviderError} class.\n     */ unsupportedMethod: (arg)=>{\n        return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);\n    },\n    /**\n     * Get an Ethereum Provider Not Connected (4900) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link EthereumProviderError} class.\n     */ disconnected: (arg)=>{\n        return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);\n    },\n    /**\n     * Get an Ethereum Provider Chain Not Connected (4901) error.\n     *\n     * @param arg - The error message or options bag.\n     * @returns An instance of the {@link EthereumProviderError} class.\n     */ chainDisconnected: (arg)=>{\n        return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);\n    },\n    /**\n     * Get a custom Ethereum Provider error.\n     *\n     * @param opts - The error options bag.\n     * @returns An instance of the {@link EthereumProviderError} class.\n     */ custom: (opts)=>{\n        if (!opts || typeof opts !== \"object\" || Array.isArray(opts)) {\n            throw new Error(\"Ethereum Provider custom errors must provide single object argument.\");\n        }\n        const { code, message, data } = opts;\n        if (!message || typeof message !== \"string\") {\n            throw new Error('\"message\" must be a nonempty string');\n        }\n        return new classes_1.EthereumProviderError(code, message, data);\n    }\n};\n/**\n * Get a generic JSON-RPC error class instance.\n *\n * @param code - The error code.\n * @param arg - The error message or options bag.\n * @returns An instance of the {@link JsonRpcError} class.\n */ function getJsonRpcError(code, arg) {\n    const [message, data] = parseOpts(arg);\n    return new classes_1.JsonRpcError(code, message ?? (0, utils_1.getMessageFromCode)(code), data);\n}\n/**\n * Get an Ethereum Provider error class instance.\n *\n * @param code - The error code.\n * @param arg - The error message or options bag.\n * @returns An instance of the {@link EthereumProviderError} class.\n */ function getEthProviderError(code, arg) {\n    const [message, data] = parseOpts(arg);\n    return new classes_1.EthereumProviderError(code, message ?? (0, utils_1.getMessageFromCode)(code), data);\n}\n/**\n * Get an error message and optional data from an options bag.\n *\n * @param arg - The error message or options bag.\n * @returns A tuple containing the error message and optional data.\n */ function parseOpts(arg) {\n    if (arg) {\n        if (typeof arg === \"string\") {\n            return [\n                arg\n            ];\n        } else if (typeof arg === \"object\" && !Array.isArray(arg)) {\n            const { message, data } = arg;\n            if (message && typeof message !== \"string\") {\n                throw new Error(\"Must specify string message.\");\n            }\n            return [\n                message ?? undefined,\n                data\n            ];\n        }\n    }\n    return [];\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1lcnJvcnMvZGlzdC9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHNCQUFzQixHQUFHQSxpQkFBaUIsR0FBRyxLQUFLO0FBQ2xELE1BQU1JLFlBQVlDLG1CQUFPQSxDQUFDLDRFQUFXO0FBQ3JDLE1BQU1DLG9CQUFvQkQsbUJBQU9BLENBQUMsNEZBQW1CO0FBQ3JELE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLHdFQUFTO0FBQ2pDTCxpQkFBaUIsR0FBRztJQUNoQjs7Ozs7S0FLQyxHQUNEUSxPQUFPLENBQUNDLE1BQVFDLGdCQUFnQkosa0JBQWtCSyxVQUFVLENBQUNDLEdBQUcsQ0FBQ0osS0FBSyxFQUFFQztJQUN4RTs7Ozs7S0FLQyxHQUNESSxnQkFBZ0IsQ0FBQ0osTUFBUUMsZ0JBQWdCSixrQkFBa0JLLFVBQVUsQ0FBQ0MsR0FBRyxDQUFDQyxjQUFjLEVBQUVKO0lBQzFGOzs7OztLQUtDLEdBQ0RLLGVBQWUsQ0FBQ0wsTUFBUUMsZ0JBQWdCSixrQkFBa0JLLFVBQVUsQ0FBQ0MsR0FBRyxDQUFDRSxhQUFhLEVBQUVMO0lBQ3hGOzs7OztLQUtDLEdBQ0RNLGdCQUFnQixDQUFDTixNQUFRQyxnQkFBZ0JKLGtCQUFrQkssVUFBVSxDQUFDQyxHQUFHLENBQUNHLGNBQWMsRUFBRU47SUFDMUY7Ozs7O0tBS0MsR0FDRE8sVUFBVSxDQUFDUCxNQUFRQyxnQkFBZ0JKLGtCQUFrQkssVUFBVSxDQUFDQyxHQUFHLENBQUNJLFFBQVEsRUFBRVA7SUFDOUU7Ozs7Ozs7S0FPQyxHQUNEUSxRQUFRLENBQUNDO1FBQ0wsSUFBSSxDQUFDQSxRQUFRLE9BQU9BLFNBQVMsWUFBWUMsTUFBTUMsT0FBTyxDQUFDRixPQUFPO1lBQzFELE1BQU0sSUFBSUcsTUFBTTtRQUNwQjtRQUNBLE1BQU0sRUFBRUMsSUFBSSxFQUFFLEdBQUdKO1FBQ2pC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QUFTQyxLQUFLLEdBQUdFLFVBQVVqQztJQUNsQyxPQUFPLElBQUlMLFVBQVVxQyxxQkFBcUIsQ0FBQ25CLE1BQU1pQixXQUFXLENBQUMsR0FBR2hDLFFBQVFxQyxrQkFBa0IsRUFBRXRCLE9BQU9rQjtBQUN2RztBQUNBOzs7OztDQUtDLEdBQ0QsU0FBU0UsVUFBVWpDLEdBQUc7SUFDbEIsSUFBSUEsS0FBSztRQUNMLElBQUksT0FBT0EsUUFBUSxVQUFVO1lBQ3pCLE9BQU87Z0JBQUNBO2FBQUk7UUFDaEIsT0FDSyxJQUFJLE9BQU9BLFFBQVEsWUFBWSxDQUFDVSxNQUFNQyxPQUFPLENBQUNYLE1BQU07WUFDckQsTUFBTSxFQUFFOEIsT0FBTyxFQUFFQyxJQUFJLEVBQUUsR0FBRy9CO1lBQzFCLElBQUk4QixXQUFXLE9BQU9BLFlBQVksVUFBVTtnQkFDeEMsTUFBTSxJQUFJbEIsTUFBTTtZQUNwQjtZQUNBLE9BQU87Z0JBQUNrQixXQUFXTTtnQkFBV0w7YUFBSztRQUN2QztJQUNKO0lBQ0EsT0FBTyxFQUFFO0FBQ2IsRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ycGMtZXJyb3JzL2Rpc3QvZXJyb3JzLmpzPzQyMjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByb3ZpZGVyRXJyb3JzID0gZXhwb3J0cy5ycGNFcnJvcnMgPSB2b2lkIDA7XG5jb25zdCBjbGFzc2VzXzEgPSByZXF1aXJlKFwiLi9jbGFzc2VzXCIpO1xuY29uc3QgZXJyb3JfY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9lcnJvci1jb25zdGFudHNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5leHBvcnRzLnJwY0Vycm9ycyA9IHtcbiAgICAvKipcbiAgICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgUGFyc2UgKC0zMjcwMCkgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgICAqL1xuICAgIHBhcnNlOiAoYXJnKSA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMucGFyc2UsIGFyZyksXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludmFsaWQgUmVxdWVzdCAoLTMyNjAwKSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAgICovXG4gICAgaW52YWxpZFJlcXVlc3Q6IChhcmcpID0+IGdldEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5pbnZhbGlkUmVxdWVzdCwgYXJnKSxcbiAgICAvKipcbiAgICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgSW52YWxpZCBQYXJhbXMgKC0zMjYwMikgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgICAqL1xuICAgIGludmFsaWRQYXJhbXM6IChhcmcpID0+IGdldEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5pbnZhbGlkUGFyYW1zLCBhcmcpLFxuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBNZXRob2QgTm90IEZvdW5kICgtMzI2MDEpIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICAgKi9cbiAgICBtZXRob2ROb3RGb3VuZDogKGFyZykgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLm1ldGhvZE5vdEZvdW5kLCBhcmcpLFxuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBJbnRlcm5hbCAoLTMyNjAzKSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAgICovXG4gICAgaW50ZXJuYWw6IChhcmcpID0+IGdldEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5pbnRlcm5hbCwgYXJnKSxcbiAgICAvKipcbiAgICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgU2VydmVyIGVycm9yLlxuICAgICAqIFBlcm1pdHMgaW50ZWdlciBlcnJvciBjb2RlcyBpbiB0aGUgWyAtMzIwOTkgPD0gLTMyMDA1IF0gcmFuZ2UuXG4gICAgICogQ29kZXMgLTMyMDAwIHRocm91Z2ggLTMyMDA0IGFyZSByZXNlcnZlZCBieSBFSVAtMTQ3NC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gVGhlIGVycm9yIG9wdGlvbnMgYmFnLlxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICAgKi9cbiAgICBzZXJ2ZXI6IChvcHRzKSA9PiB7XG4gICAgICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdGhlcmV1bSBSUEMgU2VydmVyIGVycm9ycyBtdXN0IHByb3ZpZGUgc2luZ2xlIG9iamVjdCBhcmd1bWVudC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNvZGUgfSA9IG9wdHM7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihjb2RlKSB8fCBjb2RlID4gLTMyMDA1IHx8IGNvZGUgPCAtMzIwOTkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJjb2RlXCIgbXVzdCBiZSBhbiBpbnRlZ2VyIHN1Y2ggdGhhdDogLTMyMDk5IDw9IGNvZGUgPD0gLTMyMDA1Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldEpzb25ScGNFcnJvcihjb2RlLCBvcHRzKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBJbnZhbGlkIElucHV0ICgtMzIwMDApIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICAgKi9cbiAgICBpbnZhbGlkSW5wdXQ6IChhcmcpID0+IGdldEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5pbnZhbGlkSW5wdXQsIGFyZyksXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIFJlc291cmNlIE5vdCBGb3VuZCAoLTMyMDAxKSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAgICovXG4gICAgcmVzb3VyY2VOb3RGb3VuZDogKGFyZykgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLnJlc291cmNlTm90Rm91bmQsIGFyZyksXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIFJlc291cmNlIFVuYXZhaWxhYmxlICgtMzIwMDIpIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICAgKi9cbiAgICByZXNvdXJjZVVuYXZhaWxhYmxlOiAoYXJnKSA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMucmVzb3VyY2VVbmF2YWlsYWJsZSwgYXJnKSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgVHJhbnNhY3Rpb24gUmVqZWN0ZWQgKC0zMjAwMykgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgICAqL1xuICAgIHRyYW5zYWN0aW9uUmVqZWN0ZWQ6IChhcmcpID0+IGdldEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy50cmFuc2FjdGlvblJlamVjdGVkLCBhcmcpLFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBNZXRob2QgTm90IFN1cHBvcnRlZCAoLTMyMDA0KSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAgICovXG4gICAgbWV0aG9kTm90U3VwcG9ydGVkOiAoYXJnKSA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMubWV0aG9kTm90U3VwcG9ydGVkLCBhcmcpLFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBMaW1pdCBFeGNlZWRlZCAoLTMyMDA1KSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAgICovXG4gICAgbGltaXRFeGNlZWRlZDogKGFyZykgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLmxpbWl0RXhjZWVkZWQsIGFyZyksXG59O1xuZXhwb3J0cy5wcm92aWRlckVycm9ycyA9IHtcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgVXNlciBSZWplY3RlZCBSZXF1ZXN0ICg0MDAxKSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEV0aGVyZXVtUHJvdmlkZXJFcnJvcn0gY2xhc3MuXG4gICAgICovXG4gICAgdXNlclJlamVjdGVkUmVxdWVzdDogKGFyZykgPT4ge1xuICAgICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnByb3ZpZGVyLnVzZXJSZWplY3RlZFJlcXVlc3QsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgVW5hdXRob3JpemVkICg0MTAwKSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEV0aGVyZXVtUHJvdmlkZXJFcnJvcn0gY2xhc3MuXG4gICAgICovXG4gICAgdW5hdXRob3JpemVkOiAoYXJnKSA9PiB7XG4gICAgICAgIHJldHVybiBnZXRFdGhQcm92aWRlckVycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucHJvdmlkZXIudW5hdXRob3JpemVkLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVuc3VwcG9ydGVkIE1ldGhvZCAoNDIwMCkgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IGNsYXNzLlxuICAgICAqL1xuICAgIHVuc3VwcG9ydGVkTWV0aG9kOiAoYXJnKSA9PiB7XG4gICAgICAgIHJldHVybiBnZXRFdGhQcm92aWRlckVycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucHJvdmlkZXIudW5zdXBwb3J0ZWRNZXRob2QsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgTm90IENvbm5lY3RlZCAoNDkwMCkgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IGNsYXNzLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RlZDogKGFyZykgPT4ge1xuICAgICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnByb3ZpZGVyLmRpc2Nvbm5lY3RlZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBDaGFpbiBOb3QgQ29ubmVjdGVkICg0OTAxKSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEV0aGVyZXVtUHJvdmlkZXJFcnJvcn0gY2xhc3MuXG4gICAgICovXG4gICAgY2hhaW5EaXNjb25uZWN0ZWQ6IChhcmcpID0+IHtcbiAgICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5wcm92aWRlci5jaGFpbkRpc2Nvbm5lY3RlZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhIGN1c3RvbSBFdGhlcmV1bSBQcm92aWRlciBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gVGhlIGVycm9yIG9wdGlvbnMgYmFnLlxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgRXRoZXJldW1Qcm92aWRlckVycm9yfSBjbGFzcy5cbiAgICAgKi9cbiAgICBjdXN0b206IChvcHRzKSA9PiB7XG4gICAgICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdGhlcmV1bSBQcm92aWRlciBjdXN0b20gZXJyb3JzIG11c3QgcHJvdmlkZSBzaW5nbGUgb2JqZWN0IGFyZ3VtZW50LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY29kZSwgbWVzc2FnZSwgZGF0YSB9ID0gb3B0cztcbiAgICAgICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VcIiBtdXN0IGJlIGEgbm9uZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBjbGFzc2VzXzEuRXRoZXJldW1Qcm92aWRlckVycm9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH0sXG59O1xuLyoqXG4gKiBHZXQgYSBnZW5lcmljIEpTT04tUlBDIGVycm9yIGNsYXNzIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBjb2RlIC0gVGhlIGVycm9yIGNvZGUuXG4gKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIGdldEpzb25ScGNFcnJvcihjb2RlLCBhcmcpIHtcbiAgICBjb25zdCBbbWVzc2FnZSwgZGF0YV0gPSBwYXJzZU9wdHMoYXJnKTtcbiAgICByZXR1cm4gbmV3IGNsYXNzZXNfMS5Kc29uUnBjRXJyb3IoY29kZSwgbWVzc2FnZSA/PyAoMCwgdXRpbHNfMS5nZXRNZXNzYWdlRnJvbUNvZGUpKGNvZGUpLCBkYXRhKTtcbn1cbi8qKlxuICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIGVycm9yIGNsYXNzIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBjb2RlIC0gVGhlIGVycm9yIGNvZGUuXG4gKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEV0aGVyZXVtUHJvdmlkZXJFcnJvcn0gY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIGdldEV0aFByb3ZpZGVyRXJyb3IoY29kZSwgYXJnKSB7XG4gICAgY29uc3QgW21lc3NhZ2UsIGRhdGFdID0gcGFyc2VPcHRzKGFyZyk7XG4gICAgcmV0dXJuIG5ldyBjbGFzc2VzXzEuRXRoZXJldW1Qcm92aWRlckVycm9yKGNvZGUsIG1lc3NhZ2UgPz8gKDAsIHV0aWxzXzEuZ2V0TWVzc2FnZUZyb21Db2RlKShjb2RlKSwgZGF0YSk7XG59XG4vKipcbiAqIEdldCBhbiBlcnJvciBtZXNzYWdlIGFuZCBvcHRpb25hbCBkYXRhIGZyb20gYW4gb3B0aW9ucyBiYWcuXG4gKlxuICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICogQHJldHVybnMgQSB0dXBsZSBjb250YWluaW5nIHRoZSBlcnJvciBtZXNzYWdlIGFuZCBvcHRpb25hbCBkYXRhLlxuICovXG5mdW5jdGlvbiBwYXJzZU9wdHMoYXJnKSB7XG4gICAgaWYgKGFyZykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBbYXJnXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICBjb25zdCB7IG1lc3NhZ2UsIGRhdGEgfSA9IGFyZztcbiAgICAgICAgICAgIGlmIChtZXNzYWdlICYmIHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzcGVjaWZ5IHN0cmluZyBtZXNzYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFttZXNzYWdlID8/IHVuZGVmaW5lZCwgZGF0YV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInByb3ZpZGVyRXJyb3JzIiwicnBjRXJyb3JzIiwiY2xhc3Nlc18xIiwicmVxdWlyZSIsImVycm9yX2NvbnN0YW50c18xIiwidXRpbHNfMSIsInBhcnNlIiwiYXJnIiwiZ2V0SnNvblJwY0Vycm9yIiwiZXJyb3JDb2RlcyIsInJwYyIsImludmFsaWRSZXF1ZXN0IiwiaW52YWxpZFBhcmFtcyIsIm1ldGhvZE5vdEZvdW5kIiwiaW50ZXJuYWwiLCJzZXJ2ZXIiLCJvcHRzIiwiQXJyYXkiLCJpc0FycmF5IiwiRXJyb3IiLCJjb2RlIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiaW52YWxpZElucHV0IiwicmVzb3VyY2VOb3RGb3VuZCIsInJlc291cmNlVW5hdmFpbGFibGUiLCJ0cmFuc2FjdGlvblJlamVjdGVkIiwibWV0aG9kTm90U3VwcG9ydGVkIiwibGltaXRFeGNlZWRlZCIsInVzZXJSZWplY3RlZFJlcXVlc3QiLCJnZXRFdGhQcm92aWRlckVycm9yIiwicHJvdmlkZXIiLCJ1bmF1dGhvcml6ZWQiLCJ1bnN1cHBvcnRlZE1ldGhvZCIsImRpc2Nvbm5lY3RlZCIsImNoYWluRGlzY29ubmVjdGVkIiwiY3VzdG9tIiwibWVzc2FnZSIsImRhdGEiLCJFdGhlcmV1bVByb3ZpZGVyRXJyb3IiLCJwYXJzZU9wdHMiLCJKc29uUnBjRXJyb3IiLCJnZXRNZXNzYWdlRnJvbUNvZGUiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/rpc-errors/dist/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/rpc-errors/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.errorCodes = exports.providerErrors = exports.rpcErrors = exports.getMessageFromCode = exports.serializeError = exports.serializeCause = exports.EthereumProviderError = exports.JsonRpcError = void 0;\nvar classes_1 = __webpack_require__(/*! ./classes */ \"(ssr)/./node_modules/@metamask/rpc-errors/dist/classes.js\");\nObject.defineProperty(exports, \"JsonRpcError\", ({\n    enumerable: true,\n    get: function() {\n        return classes_1.JsonRpcError;\n    }\n}));\nObject.defineProperty(exports, \"EthereumProviderError\", ({\n    enumerable: true,\n    get: function() {\n        return classes_1.EthereumProviderError;\n    }\n}));\nvar utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@metamask/rpc-errors/dist/utils.js\");\nObject.defineProperty(exports, \"serializeCause\", ({\n    enumerable: true,\n    get: function() {\n        return utils_1.serializeCause;\n    }\n}));\nObject.defineProperty(exports, \"serializeError\", ({\n    enumerable: true,\n    get: function() {\n        return utils_1.serializeError;\n    }\n}));\nObject.defineProperty(exports, \"getMessageFromCode\", ({\n    enumerable: true,\n    get: function() {\n        return utils_1.getMessageFromCode;\n    }\n}));\nvar errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@metamask/rpc-errors/dist/errors.js\");\nObject.defineProperty(exports, \"rpcErrors\", ({\n    enumerable: true,\n    get: function() {\n        return errors_1.rpcErrors;\n    }\n}));\nObject.defineProperty(exports, \"providerErrors\", ({\n    enumerable: true,\n    get: function() {\n        return errors_1.providerErrors;\n    }\n}));\nvar error_constants_1 = __webpack_require__(/*! ./error-constants */ \"(ssr)/./node_modules/@metamask/rpc-errors/dist/error-constants.js\");\nObject.defineProperty(exports, \"errorCodes\", ({\n    enumerable: true,\n    get: function() {\n        return error_constants_1.errorCodes;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1lcnJvcnMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0JBQWtCLEdBQUdBLHNCQUFzQixHQUFHQSxpQkFBaUIsR0FBR0EsMEJBQTBCLEdBQUdBLHNCQUFzQixHQUFHQSxzQkFBc0IsR0FBR0EsNkJBQTZCLEdBQUdBLG9CQUFvQixHQUFHLEtBQUs7QUFDN00sSUFBSVUsWUFBWUMsbUJBQU9BLENBQUMsNEVBQVc7QUFDbkNiLGdEQUErQztJQUFFYyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSCxVQUFVRCxZQUFZO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDekhYLHlEQUF3RDtJQUFFYyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSCxVQUFVRixxQkFBcUI7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMzSSxJQUFJTSxVQUFVSCxtQkFBT0EsQ0FBQyx3RUFBUztBQUMvQmIsa0RBQWlEO0lBQUVjLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9DLFFBQVFQLGNBQWM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMzSFQsa0RBQWlEO0lBQUVjLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9DLFFBQVFSLGNBQWM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMzSFIsc0RBQXFEO0lBQUVjLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9DLFFBQVFULGtCQUFrQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ25JLElBQUlVLFdBQVdKLG1CQUFPQSxDQUFDLDBFQUFVO0FBQ2pDYiw2Q0FBNEM7SUFBRWMsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0UsU0FBU1gsU0FBUztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2xITixrREFBaUQ7SUFBRWMsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0UsU0FBU1osY0FBYztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzVILElBQUlhLG9CQUFvQkwsbUJBQU9BLENBQUMsNEZBQW1CO0FBQ25EYiw4Q0FBNkM7SUFBRWMsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0csa0JBQWtCZCxVQUFVO0lBQUU7QUFBRSxDQUFDLEVBQUMsRUFDN0gsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLWVycm9ycy9kaXN0L2luZGV4LmpzPzY2MzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVycm9yQ29kZXMgPSBleHBvcnRzLnByb3ZpZGVyRXJyb3JzID0gZXhwb3J0cy5ycGNFcnJvcnMgPSBleHBvcnRzLmdldE1lc3NhZ2VGcm9tQ29kZSA9IGV4cG9ydHMuc2VyaWFsaXplRXJyb3IgPSBleHBvcnRzLnNlcmlhbGl6ZUNhdXNlID0gZXhwb3J0cy5FdGhlcmV1bVByb3ZpZGVyRXJyb3IgPSBleHBvcnRzLkpzb25ScGNFcnJvciA9IHZvaWQgMDtcbnZhciBjbGFzc2VzXzEgPSByZXF1aXJlKFwiLi9jbGFzc2VzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSnNvblJwY0Vycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGFzc2VzXzEuSnNvblJwY0Vycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXRoZXJldW1Qcm92aWRlckVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGFzc2VzXzEuRXRoZXJldW1Qcm92aWRlckVycm9yOyB9IH0pO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNlcmlhbGl6ZUNhdXNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLnNlcmlhbGl6ZUNhdXNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VyaWFsaXplRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuc2VyaWFsaXplRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRNZXNzYWdlRnJvbUNvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuZ2V0TWVzc2FnZUZyb21Db2RlOyB9IH0pO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicnBjRXJyb3JzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfMS5ycGNFcnJvcnM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwcm92aWRlckVycm9yc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JzXzEucHJvdmlkZXJFcnJvcnM7IH0gfSk7XG52YXIgZXJyb3JfY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9lcnJvci1jb25zdGFudHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlcnJvckNvZGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZXJyb3JDb2RlcyIsInByb3ZpZGVyRXJyb3JzIiwicnBjRXJyb3JzIiwiZ2V0TWVzc2FnZUZyb21Db2RlIiwic2VyaWFsaXplRXJyb3IiLCJzZXJpYWxpemVDYXVzZSIsIkV0aGVyZXVtUHJvdmlkZXJFcnJvciIsIkpzb25ScGNFcnJvciIsImNsYXNzZXNfMSIsInJlcXVpcmUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwidXRpbHNfMSIsImVycm9yc18xIiwiZXJyb3JfY29uc3RhbnRzXzEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/rpc-errors/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/rpc-errors/dist/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@metamask/rpc-errors/dist/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.serializeCause = exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;\nconst utils_1 = __webpack_require__(/*! @metamask/utils */ \"(ssr)/./node_modules/@metamask/utils/dist/index.js\");\nconst error_constants_1 = __webpack_require__(/*! ./error-constants */ \"(ssr)/./node_modules/@metamask/rpc-errors/dist/error-constants.js\");\nconst FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;\nconst FALLBACK_MESSAGE = \"Unspecified error message. This is a bug, please report it.\";\nconst FALLBACK_ERROR = {\n    code: FALLBACK_ERROR_CODE,\n    message: getMessageFromCode(FALLBACK_ERROR_CODE)\n};\nexports.JSON_RPC_SERVER_ERROR_MESSAGE = \"Unspecified server error.\";\n/**\n * Gets the message for a given code, or a fallback message if the code has\n * no corresponding message.\n *\n * @param code - The error code.\n * @param fallbackMessage - The fallback message to use if the code has no\n * corresponding message.\n * @returns The message for the given code, or the fallback message if the code\n * has no corresponding message.\n */ function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {\n    if (isValidCode(code)) {\n        const codeString = code.toString();\n        if ((0, utils_1.hasProperty)(error_constants_1.errorValues, codeString)) {\n            return error_constants_1.errorValues[codeString].message;\n        }\n        if (isJsonRpcServerError(code)) {\n            return exports.JSON_RPC_SERVER_ERROR_MESSAGE;\n        }\n    }\n    return fallbackMessage;\n}\nexports.getMessageFromCode = getMessageFromCode;\n/**\n * Returns whether the given code is valid.\n * A code is valid if it is an integer.\n *\n * @param code - The error code.\n * @returns Whether the given code is valid.\n */ function isValidCode(code) {\n    return Number.isInteger(code);\n}\nexports.isValidCode = isValidCode;\n/**\n * Serializes the given error to an Ethereum JSON RPC-compatible error object.\n * If the given error is not fully compatible, it will be preserved on the\n * returned object's data.cause property.\n *\n * @param error - The error to serialize.\n * @param options - Options bag.\n * @param options.fallbackError - The error to return if the given error is\n * not compatible. Should be a JSON serializable value.\n * @param options.shouldIncludeStack - Whether to include the error's stack\n * on the returned object.\n * @returns The serialized error.\n */ function serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = true } = {}) {\n    if (!(0, utils_1.isJsonRpcError)(fallbackError)) {\n        throw new Error(\"Must provide fallback error with integer number code and string message.\");\n    }\n    const serialized = buildError(error, fallbackError);\n    if (!shouldIncludeStack) {\n        delete serialized.stack;\n    }\n    return serialized;\n}\nexports.serializeError = serializeError;\n/**\n * Construct a JSON-serializable object given an error and a JSON serializable `fallbackError`\n *\n * @param error - The error in question.\n * @param fallbackError - A JSON serializable fallback error.\n * @returns A JSON serializable error object.\n */ function buildError(error, fallbackError) {\n    // If an error specifies a `serialize` function, we call it and return the result.\n    if (error && typeof error === \"object\" && \"serialize\" in error && typeof error.serialize === \"function\") {\n        return error.serialize();\n    }\n    if ((0, utils_1.isJsonRpcError)(error)) {\n        return error;\n    }\n    // If the error does not match the JsonRpcError type, use the fallback error, but try to include the original error as `cause`.\n    const cause = serializeCause(error);\n    const fallbackWithCause = {\n        ...fallbackError,\n        data: {\n            cause\n        }\n    };\n    return fallbackWithCause;\n}\n/**\n * Check if the given code is a valid JSON-RPC server error code.\n *\n * @param code - The error code.\n * @returns Whether the given code is a valid JSON-RPC server error code.\n */ function isJsonRpcServerError(code) {\n    return code >= -32099 && code <= -32000;\n}\n/**\n * Serializes an unknown error to be used as the `cause` in a fallback error.\n *\n * @param error - The unknown error.\n * @returns A JSON-serializable object containing as much information about the original error as possible.\n */ function serializeCause(error) {\n    if (Array.isArray(error)) {\n        return error.map((entry)=>{\n            if ((0, utils_1.isValidJson)(entry)) {\n                return entry;\n            } else if ((0, utils_1.isObject)(entry)) {\n                return serializeObject(entry);\n            }\n            return null;\n        });\n    } else if ((0, utils_1.isObject)(error)) {\n        return serializeObject(error);\n    }\n    if ((0, utils_1.isValidJson)(error)) {\n        return error;\n    }\n    return null;\n}\nexports.serializeCause = serializeCause;\n/**\n * Extracts all JSON-serializable properties from an object.\n *\n * @param object - The object in question.\n * @returns An object containing all the JSON-serializable properties.\n */ function serializeObject(object) {\n    return Object.getOwnPropertyNames(object).reduce((acc, key)=>{\n        const value = object[key];\n        if ((0, utils_1.isValidJson)(value)) {\n            acc[key] = value;\n        }\n        return acc;\n    }, {});\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1lcnJvcnMvZGlzdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsc0JBQXNCLEdBQUdBLHNCQUFzQixHQUFHQSxtQkFBbUIsR0FBR0EsMEJBQTBCLEdBQUdBLHFDQUFxQyxHQUFHLEtBQUs7QUFDbEosTUFBTU8sVUFBVUMsbUJBQU9BLENBQUMsMkVBQWlCO0FBQ3pDLE1BQU1DLG9CQUFvQkQsbUJBQU9BLENBQUMsNEZBQW1CO0FBQ3JELE1BQU1FLHNCQUFzQkQsa0JBQWtCRSxVQUFVLENBQUNDLEdBQUcsQ0FBQ0MsUUFBUTtBQUNyRSxNQUFNQyxtQkFBbUI7QUFDekIsTUFBTUMsaUJBQWlCO0lBQ25CQyxNQUFNTjtJQUNOTyxTQUFTWixtQkFBbUJLO0FBQ2hDO0FBQ0FWLHFDQUFxQyxHQUFHO0FBQ3hDOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVNLLG1CQUFtQlcsSUFBSSxFQUFFRSxrQkFBa0JKLGdCQUFnQjtJQUNoRSxJQUFJVixZQUFZWSxPQUFPO1FBQ25CLE1BQU1HLGFBQWFILEtBQUtJLFFBQVE7UUFDaEMsSUFBSSxDQUFDLEdBQUdiLFFBQVFjLFdBQVcsRUFBRVosa0JBQWtCYSxXQUFXLEVBQUVILGFBQWE7WUFDckUsT0FBT1Ysa0JBQWtCYSxXQUFXLENBQUNILFdBQVcsQ0FBQ0YsT0FBTztRQUM1RDtRQUNBLElBQUlNLHFCQUFxQlAsT0FBTztZQUM1QixPQUFPaEIsUUFBUU0sNkJBQTZCO1FBQ2hEO0lBQ0o7SUFDQSxPQUFPWTtBQUNYO0FBQ0FsQiwwQkFBMEIsR0FBR0s7QUFDN0I7Ozs7OztDQU1DLEdBQ0QsU0FBU0QsWUFBWVksSUFBSTtJQUNyQixPQUFPUSxPQUFPQyxTQUFTLENBQUNUO0FBQzVCO0FBQ0FoQixtQkFBbUIsR0FBR0k7QUFDdEI7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0QsU0FBU0QsZUFBZXVCLEtBQUssRUFBRSxFQUFFQyxnQkFBZ0JaLGNBQWMsRUFBRWEscUJBQXFCLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztJQUM3RixJQUFJLENBQUMsQ0FBQyxHQUFHckIsUUFBUXNCLGNBQWMsRUFBRUYsZ0JBQWdCO1FBQzdDLE1BQU0sSUFBSUcsTUFBTTtJQUNwQjtJQUNBLE1BQU1DLGFBQWFDLFdBQVdOLE9BQU9DO0lBQ3JDLElBQUksQ0FBQ0Msb0JBQW9CO1FBQ3JCLE9BQU9HLFdBQVdFLEtBQUs7SUFDM0I7SUFDQSxPQUFPRjtBQUNYO0FBQ0EvQixzQkFBc0IsR0FBR0c7QUFDekI7Ozs7OztDQU1DLEdBQ0QsU0FBUzZCLFdBQVdOLEtBQUssRUFBRUMsYUFBYTtJQUNwQyxrRkFBa0Y7SUFDbEYsSUFBSUQsU0FDQSxPQUFPQSxVQUFVLFlBQ2pCLGVBQWVBLFNBQ2YsT0FBT0EsTUFBTVEsU0FBUyxLQUFLLFlBQVk7UUFDdkMsT0FBT1IsTUFBTVEsU0FBUztJQUMxQjtJQUNBLElBQUksQ0FBQyxHQUFHM0IsUUFBUXNCLGNBQWMsRUFBRUgsUUFBUTtRQUNwQyxPQUFPQTtJQUNYO0lBQ0EsK0hBQStIO0lBQy9ILE1BQU1TLFFBQVFqQyxlQUFld0I7SUFDN0IsTUFBTVUsb0JBQW9CO1FBQ3RCLEdBQUdULGFBQWE7UUFDaEJVLE1BQU07WUFBRUY7UUFBTTtJQUNsQjtJQUNBLE9BQU9DO0FBQ1g7QUFDQTs7Ozs7Q0FLQyxHQUNELFNBQVNiLHFCQUFxQlAsSUFBSTtJQUM5QixPQUFPQSxRQUFRLENBQUMsU0FBU0EsUUFBUSxDQUFDO0FBQ3RDO0FBQ0E7Ozs7O0NBS0MsR0FDRCxTQUFTZCxlQUFld0IsS0FBSztJQUN6QixJQUFJWSxNQUFNQyxPQUFPLENBQUNiLFFBQVE7UUFDdEIsT0FBT0EsTUFBTWMsR0FBRyxDQUFDLENBQUNDO1lBQ2QsSUFBSSxDQUFDLEdBQUdsQyxRQUFRbUMsV0FBVyxFQUFFRCxRQUFRO2dCQUNqQyxPQUFPQTtZQUNYLE9BQ0ssSUFBSSxDQUFDLEdBQUdsQyxRQUFRb0MsUUFBUSxFQUFFRixRQUFRO2dCQUNuQyxPQUFPRyxnQkFBZ0JIO1lBQzNCO1lBQ0EsT0FBTztRQUNYO0lBQ0osT0FDSyxJQUFJLENBQUMsR0FBR2xDLFFBQVFvQyxRQUFRLEVBQUVqQixRQUFRO1FBQ25DLE9BQU9rQixnQkFBZ0JsQjtJQUMzQjtJQUNBLElBQUksQ0FBQyxHQUFHbkIsUUFBUW1DLFdBQVcsRUFBRWhCLFFBQVE7UUFDakMsT0FBT0E7SUFDWDtJQUNBLE9BQU87QUFDWDtBQUNBMUIsc0JBQXNCLEdBQUdFO0FBQ3pCOzs7OztDQUtDLEdBQ0QsU0FBUzBDLGdCQUFnQkMsTUFBTTtJQUMzQixPQUFPL0MsT0FBT2dELG1CQUFtQixDQUFDRCxRQUFRRSxNQUFNLENBQUMsQ0FBQ0MsS0FBS0M7UUFDbkQsTUFBTWhELFFBQVE0QyxNQUFNLENBQUNJLElBQUk7UUFDekIsSUFBSSxDQUFDLEdBQUcxQyxRQUFRbUMsV0FBVyxFQUFFekMsUUFBUTtZQUNqQytDLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHaEQ7UUFDZjtRQUNBLE9BQU8rQztJQUNYLEdBQUcsQ0FBQztBQUNSLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svcnBjLWVycm9ycy9kaXN0L3V0aWxzLmpzPzEyN2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNlcmlhbGl6ZUNhdXNlID0gZXhwb3J0cy5zZXJpYWxpemVFcnJvciA9IGV4cG9ydHMuaXNWYWxpZENvZGUgPSBleHBvcnRzLmdldE1lc3NhZ2VGcm9tQ29kZSA9IGV4cG9ydHMuSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0UgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbmNvbnN0IGVycm9yX2NvbnN0YW50c18xID0gcmVxdWlyZShcIi4vZXJyb3ItY29uc3RhbnRzXCIpO1xuY29uc3QgRkFMTEJBQ0tfRVJST1JfQ09ERSA9IGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLmludGVybmFsO1xuY29uc3QgRkFMTEJBQ0tfTUVTU0FHRSA9ICdVbnNwZWNpZmllZCBlcnJvciBtZXNzYWdlLiBUaGlzIGlzIGEgYnVnLCBwbGVhc2UgcmVwb3J0IGl0Lic7XG5jb25zdCBGQUxMQkFDS19FUlJPUiA9IHtcbiAgICBjb2RlOiBGQUxMQkFDS19FUlJPUl9DT0RFLFxuICAgIG1lc3NhZ2U6IGdldE1lc3NhZ2VGcm9tQ29kZShGQUxMQkFDS19FUlJPUl9DT0RFKSxcbn07XG5leHBvcnRzLkpTT05fUlBDX1NFUlZFUl9FUlJPUl9NRVNTQUdFID0gJ1Vuc3BlY2lmaWVkIHNlcnZlciBlcnJvci4nO1xuLyoqXG4gKiBHZXRzIHRoZSBtZXNzYWdlIGZvciBhIGdpdmVuIGNvZGUsIG9yIGEgZmFsbGJhY2sgbWVzc2FnZSBpZiB0aGUgY29kZSBoYXNcbiAqIG5vIGNvcnJlc3BvbmRpbmcgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gY29kZSAtIFRoZSBlcnJvciBjb2RlLlxuICogQHBhcmFtIGZhbGxiYWNrTWVzc2FnZSAtIFRoZSBmYWxsYmFjayBtZXNzYWdlIHRvIHVzZSBpZiB0aGUgY29kZSBoYXMgbm9cbiAqIGNvcnJlc3BvbmRpbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSBtZXNzYWdlIGZvciB0aGUgZ2l2ZW4gY29kZSwgb3IgdGhlIGZhbGxiYWNrIG1lc3NhZ2UgaWYgdGhlIGNvZGVcbiAqIGhhcyBubyBjb3JyZXNwb25kaW5nIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGdldE1lc3NhZ2VGcm9tQ29kZShjb2RlLCBmYWxsYmFja01lc3NhZ2UgPSBGQUxMQkFDS19NRVNTQUdFKSB7XG4gICAgaWYgKGlzVmFsaWRDb2RlKGNvZGUpKSB7XG4gICAgICAgIGNvbnN0IGNvZGVTdHJpbmcgPSBjb2RlLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICgoMCwgdXRpbHNfMS5oYXNQcm9wZXJ0eSkoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JWYWx1ZXMsIGNvZGVTdHJpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JWYWx1ZXNbY29kZVN0cmluZ10ubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNKc29uUnBjU2VydmVyRXJyb3IoY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkpTT05fUlBDX1NFUlZFUl9FUlJPUl9NRVNTQUdFO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFja01lc3NhZ2U7XG59XG5leHBvcnRzLmdldE1lc3NhZ2VGcm9tQ29kZSA9IGdldE1lc3NhZ2VGcm9tQ29kZTtcbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBjb2RlIGlzIHZhbGlkLlxuICogQSBjb2RlIGlzIHZhbGlkIGlmIGl0IGlzIGFuIGludGVnZXIuXG4gKlxuICogQHBhcmFtIGNvZGUgLSBUaGUgZXJyb3IgY29kZS5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIGNvZGUgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDb2RlKGNvZGUpIHtcbiAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihjb2RlKTtcbn1cbmV4cG9ydHMuaXNWYWxpZENvZGUgPSBpc1ZhbGlkQ29kZTtcbi8qKlxuICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gZXJyb3IgdG8gYW4gRXRoZXJldW0gSlNPTiBSUEMtY29tcGF0aWJsZSBlcnJvciBvYmplY3QuXG4gKiBJZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgbm90IGZ1bGx5IGNvbXBhdGlibGUsIGl0IHdpbGwgYmUgcHJlc2VydmVkIG9uIHRoZVxuICogcmV0dXJuZWQgb2JqZWN0J3MgZGF0YS5jYXVzZSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gc2VyaWFsaXplLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJhZy5cbiAqIEBwYXJhbSBvcHRpb25zLmZhbGxiYWNrRXJyb3IgLSBUaGUgZXJyb3IgdG8gcmV0dXJuIGlmIHRoZSBnaXZlbiBlcnJvciBpc1xuICogbm90IGNvbXBhdGlibGUuIFNob3VsZCBiZSBhIEpTT04gc2VyaWFsaXphYmxlIHZhbHVlLlxuICogQHBhcmFtIG9wdGlvbnMuc2hvdWxkSW5jbHVkZVN0YWNrIC0gV2hldGhlciB0byBpbmNsdWRlIHRoZSBlcnJvcidzIHN0YWNrXG4gKiBvbiB0aGUgcmV0dXJuZWQgb2JqZWN0LlxuICogQHJldHVybnMgVGhlIHNlcmlhbGl6ZWQgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9yKGVycm9yLCB7IGZhbGxiYWNrRXJyb3IgPSBGQUxMQkFDS19FUlJPUiwgc2hvdWxkSW5jbHVkZVN0YWNrID0gdHJ1ZSB9ID0ge30pIHtcbiAgICBpZiAoISgwLCB1dGlsc18xLmlzSnNvblJwY0Vycm9yKShmYWxsYmFja0Vycm9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBmYWxsYmFjayBlcnJvciB3aXRoIGludGVnZXIgbnVtYmVyIGNvZGUgYW5kIHN0cmluZyBtZXNzYWdlLicpO1xuICAgIH1cbiAgICBjb25zdCBzZXJpYWxpemVkID0gYnVpbGRFcnJvcihlcnJvciwgZmFsbGJhY2tFcnJvcik7XG4gICAgaWYgKCFzaG91bGRJbmNsdWRlU3RhY2spIHtcbiAgICAgICAgZGVsZXRlIHNlcmlhbGl6ZWQuc3RhY2s7XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xufVxuZXhwb3J0cy5zZXJpYWxpemVFcnJvciA9IHNlcmlhbGl6ZUVycm9yO1xuLyoqXG4gKiBDb25zdHJ1Y3QgYSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QgZ2l2ZW4gYW4gZXJyb3IgYW5kIGEgSlNPTiBzZXJpYWxpemFibGUgYGZhbGxiYWNrRXJyb3JgXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIGluIHF1ZXN0aW9uLlxuICogQHBhcmFtIGZhbGxiYWNrRXJyb3IgLSBBIEpTT04gc2VyaWFsaXphYmxlIGZhbGxiYWNrIGVycm9yLlxuICogQHJldHVybnMgQSBKU09OIHNlcmlhbGl6YWJsZSBlcnJvciBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkRXJyb3IoZXJyb3IsIGZhbGxiYWNrRXJyb3IpIHtcbiAgICAvLyBJZiBhbiBlcnJvciBzcGVjaWZpZXMgYSBgc2VyaWFsaXplYCBmdW5jdGlvbiwgd2UgY2FsbCBpdCBhbmQgcmV0dXJuIHRoZSByZXN1bHQuXG4gICAgaWYgKGVycm9yICYmXG4gICAgICAgIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3NlcmlhbGl6ZScgaW4gZXJyb3IgJiZcbiAgICAgICAgdHlwZW9mIGVycm9yLnNlcmlhbGl6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZXJyb3Iuc2VyaWFsaXplKCk7XG4gICAgfVxuICAgIGlmICgoMCwgdXRpbHNfMS5pc0pzb25ScGNFcnJvcikoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGVycm9yIGRvZXMgbm90IG1hdGNoIHRoZSBKc29uUnBjRXJyb3IgdHlwZSwgdXNlIHRoZSBmYWxsYmFjayBlcnJvciwgYnV0IHRyeSB0byBpbmNsdWRlIHRoZSBvcmlnaW5hbCBlcnJvciBhcyBgY2F1c2VgLlxuICAgIGNvbnN0IGNhdXNlID0gc2VyaWFsaXplQ2F1c2UoZXJyb3IpO1xuICAgIGNvbnN0IGZhbGxiYWNrV2l0aENhdXNlID0ge1xuICAgICAgICAuLi5mYWxsYmFja0Vycm9yLFxuICAgICAgICBkYXRhOiB7IGNhdXNlIH0sXG4gICAgfTtcbiAgICByZXR1cm4gZmFsbGJhY2tXaXRoQ2F1c2U7XG59XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBjb2RlIGlzIGEgdmFsaWQgSlNPTi1SUEMgc2VydmVyIGVycm9yIGNvZGUuXG4gKlxuICogQHBhcmFtIGNvZGUgLSBUaGUgZXJyb3IgY29kZS5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdpdmVuIGNvZGUgaXMgYSB2YWxpZCBKU09OLVJQQyBzZXJ2ZXIgZXJyb3IgY29kZS5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjU2VydmVyRXJyb3IoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49IC0zMjA5OSAmJiBjb2RlIDw9IC0zMjAwMDtcbn1cbi8qKlxuICogU2VyaWFsaXplcyBhbiB1bmtub3duIGVycm9yIHRvIGJlIHVzZWQgYXMgdGhlIGBjYXVzZWAgaW4gYSBmYWxsYmFjayBlcnJvci5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgdW5rbm93biBlcnJvci5cbiAqIEByZXR1cm5zIEEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0IGNvbnRhaW5pbmcgYXMgbXVjaCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZXJyb3IgYXMgcG9zc2libGUuXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUNhdXNlKGVycm9yKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiBlcnJvci5tYXAoKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNWYWxpZEpzb24pKGVudHJ5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzT2JqZWN0KShlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplT2JqZWN0KGVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHV0aWxzXzEuaXNPYmplY3QpKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplT2JqZWN0KGVycm9yKTtcbiAgICB9XG4gICAgaWYgKCgwLCB1dGlsc18xLmlzVmFsaWRKc29uKShlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuc2VyaWFsaXplQ2F1c2UgPSBzZXJpYWxpemVDYXVzZTtcbi8qKlxuICogRXh0cmFjdHMgYWxsIEpTT04tc2VyaWFsaXphYmxlIHByb3BlcnRpZXMgZnJvbSBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iamVjdCAtIFRoZSBvYmplY3QgaW4gcXVlc3Rpb24uXG4gKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIEpTT04tc2VyaWFsaXphYmxlIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdChvYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc1ZhbGlkSnNvbikodmFsdWUpKSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2VyaWFsaXplQ2F1c2UiLCJzZXJpYWxpemVFcnJvciIsImlzVmFsaWRDb2RlIiwiZ2V0TWVzc2FnZUZyb21Db2RlIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0UiLCJ1dGlsc18xIiwicmVxdWlyZSIsImVycm9yX2NvbnN0YW50c18xIiwiRkFMTEJBQ0tfRVJST1JfQ09ERSIsImVycm9yQ29kZXMiLCJycGMiLCJpbnRlcm5hbCIsIkZBTExCQUNLX01FU1NBR0UiLCJGQUxMQkFDS19FUlJPUiIsImNvZGUiLCJtZXNzYWdlIiwiZmFsbGJhY2tNZXNzYWdlIiwiY29kZVN0cmluZyIsInRvU3RyaW5nIiwiaGFzUHJvcGVydHkiLCJlcnJvclZhbHVlcyIsImlzSnNvblJwY1NlcnZlckVycm9yIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiZXJyb3IiLCJmYWxsYmFja0Vycm9yIiwic2hvdWxkSW5jbHVkZVN0YWNrIiwiaXNKc29uUnBjRXJyb3IiLCJFcnJvciIsInNlcmlhbGl6ZWQiLCJidWlsZEVycm9yIiwic3RhY2siLCJzZXJpYWxpemUiLCJjYXVzZSIsImZhbGxiYWNrV2l0aENhdXNlIiwiZGF0YSIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsImVudHJ5IiwiaXNWYWxpZEpzb24iLCJpc09iamVjdCIsInNlcmlhbGl6ZU9iamVjdCIsIm9iamVjdCIsImdldE93blByb3BlcnR5TmFtZXMiLCJyZWR1Y2UiLCJhY2MiLCJrZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/rpc-errors/dist/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/chunk-2LBGT4GH.js":
/*!*************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/chunk-2LBGT4GH.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n} // src/logging.ts\nvar _debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\nvar _debug2 = _interopRequireDefault(_debug);\nvar globalLogger = _debug2.default.call(void 0, \"metamask\");\nfunction createProjectLogger(projectName) {\n    return globalLogger.extend(projectName);\n}\nfunction createModuleLogger(projectLogger, moduleName) {\n    return projectLogger.extend(moduleName);\n}\nexports.createProjectLogger = createProjectLogger;\nexports.createModuleLogger = createModuleLogger; //# sourceMappingURL=chunk-2LBGT4GH.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2h1bmstMkxCR1Q0R0guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFBQUEsOENBQTZDO0lBQUNHLE9BQU87QUFBSSxDQUFDLEVBQUM7QUFBRSxTQUFTQyx1QkFBdUJDLEdBQUc7SUFBSSxPQUFPQSxPQUFPQSxJQUFJQyxVQUFVLEdBQUdELE1BQU07UUFBRUUsU0FBU0Y7SUFBSTtBQUFHLEVBQUMsaUJBQWlCO0FBQzFMLElBQUlHLFNBQVNDLG1CQUFPQSxDQUFDO0FBQVUsSUFBSUMsVUFBVU4sdUJBQXVCSTtBQUNwRSxJQUFJRyxlQUFlRCxRQUFRSCxPQUFPLENBQUNLLElBQUksQ0FBQyxLQUFLLEdBQUc7QUFDaEQsU0FBU0Msb0JBQW9CQyxXQUFXO0lBQ3RDLE9BQU9ILGFBQWFJLE1BQU0sQ0FBQ0Q7QUFDN0I7QUFDQSxTQUFTRSxtQkFBbUJDLGFBQWEsRUFBRUMsVUFBVTtJQUNuRCxPQUFPRCxjQUFjRixNQUFNLENBQUNHO0FBQzlCO0FBS0FoQiwyQkFBMkIsR0FBR1c7QUFBcUJYLDBCQUEwQixHQUFHYyxvQkFDaEYsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jaHVuay0yTEJHVDRHSC5qcz9lYTI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7IGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9Ly8gc3JjL2xvZ2dpbmcudHNcbnZhciBfZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpOyB2YXIgX2RlYnVnMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlYnVnKTtcbnZhciBnbG9iYWxMb2dnZXIgPSBfZGVidWcyLmRlZmF1bHQuY2FsbCh2b2lkIDAsIFwibWV0YW1hc2tcIik7XG5mdW5jdGlvbiBjcmVhdGVQcm9qZWN0TG9nZ2VyKHByb2plY3ROYW1lKSB7XG4gIHJldHVybiBnbG9iYWxMb2dnZXIuZXh0ZW5kKHByb2plY3ROYW1lKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1vZHVsZUxvZ2dlcihwcm9qZWN0TG9nZ2VyLCBtb2R1bGVOYW1lKSB7XG4gIHJldHVybiBwcm9qZWN0TG9nZ2VyLmV4dGVuZChtb2R1bGVOYW1lKTtcbn1cblxuXG5cblxuZXhwb3J0cy5jcmVhdGVQcm9qZWN0TG9nZ2VyID0gY3JlYXRlUHJvamVjdExvZ2dlcjsgZXhwb3J0cy5jcmVhdGVNb2R1bGVMb2dnZXIgPSBjcmVhdGVNb2R1bGVMb2dnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay0yTEJHVDRHSC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0Iiwib2JqIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJfZGVidWciLCJyZXF1aXJlIiwiX2RlYnVnMiIsImdsb2JhbExvZ2dlciIsImNhbGwiLCJjcmVhdGVQcm9qZWN0TG9nZ2VyIiwicHJvamVjdE5hbWUiLCJleHRlbmQiLCJjcmVhdGVNb2R1bGVMb2dnZXIiLCJwcm9qZWN0TG9nZ2VyIiwibW9kdWxlTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/chunk-2LBGT4GH.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/chunk-2TBCL6EF.js":
/*!*************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/chunk-2TBCL6EF.js ***!
  \*************************************************************/
/***/ (() => {

eval(" //# sourceMappingURL=chunk-2TBCL6EF.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2h1bmstMlRCQ0w2RUYuanMiLCJtYXBwaW5ncyI6IkFBQWEsMkNBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jaHVuay0yVEJDTDZFRi5qcz81NzNjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiOy8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLTJUQkNMNkVGLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/chunk-2TBCL6EF.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/chunk-3W5G4CYI.js":
/*!*************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/chunk-3W5G4CYI.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar __accessCheck = (obj, member, msg)=>{\n    if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter)=>{\n    __accessCheck(obj, member, \"read from private field\");\n    return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value)=>{\n    if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter)=>{\n    __accessCheck(obj, member, \"write to private field\");\n    setter ? setter.call(obj, value) : member.set(obj, value);\n    return value;\n};\nexports.__privateGet = __privateGet;\nexports.__privateAdd = __privateAdd;\nexports.__privateSet = __privateSet; //# sourceMappingURL=chunk-3W5G4CYI.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2h1bmstM1c1RzRDWUkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFBQUEsOENBQTZDO0lBQUNHLE9BQU87QUFBSSxDQUFDLEVBQUM7QUFBQyxJQUFJQyxnQkFBZ0IsQ0FBQ0MsS0FBS0MsUUFBUUM7SUFDekcsSUFBSSxDQUFDRCxPQUFPRSxHQUFHLENBQUNILE1BQ2QsTUFBTUksVUFBVSxZQUFZRjtBQUNoQztBQUNBLElBQUlHLGVBQWUsQ0FBQ0wsS0FBS0MsUUFBUUs7SUFDL0JQLGNBQWNDLEtBQUtDLFFBQVE7SUFDM0IsT0FBT0ssU0FBU0EsT0FBT0MsSUFBSSxDQUFDUCxPQUFPQyxPQUFPTyxHQUFHLENBQUNSO0FBQ2hEO0FBQ0EsSUFBSVMsZUFBZSxDQUFDVCxLQUFLQyxRQUFRSDtJQUMvQixJQUFJRyxPQUFPRSxHQUFHLENBQUNILE1BQ2IsTUFBTUksVUFBVTtJQUNsQkgsa0JBQWtCUyxVQUFVVCxPQUFPVSxHQUFHLENBQUNYLE9BQU9DLE9BQU9XLEdBQUcsQ0FBQ1osS0FBS0Y7QUFDaEU7QUFDQSxJQUFJZSxlQUFlLENBQUNiLEtBQUtDLFFBQVFILE9BQU9nQjtJQUN0Q2YsY0FBY0MsS0FBS0MsUUFBUTtJQUMzQmEsU0FBU0EsT0FBT1AsSUFBSSxDQUFDUCxLQUFLRixTQUFTRyxPQUFPVyxHQUFHLENBQUNaLEtBQUtGO0lBQ25ELE9BQU9BO0FBQ1Q7QUFNQUQsb0JBQW9CLEdBQUdRO0FBQWNSLG9CQUFvQixHQUFHWTtBQUFjWixvQkFBb0IsR0FBR2dCLGNBQ2pHLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2h1bmstM1c1RzRDWUkuanM/ZjMzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO3ZhciBfX2FjY2Vzc0NoZWNrID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IHtcbiAgaWYgKCFtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IFwiICsgbXNnKTtcbn07XG52YXIgX19wcml2YXRlR2V0ID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgcmV0dXJuIGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiBtZW1iZXIuZ2V0KG9iaik7XG59O1xudmFyIF9fcHJpdmF0ZUFkZCA9IChvYmosIG1lbWJlciwgdmFsdWUpID0+IHtcbiAgaWYgKG1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpO1xuICBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbn07XG52YXIgX19wcml2YXRlU2V0ID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSwgc2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgc2V0dGVyID8gc2V0dGVyLmNhbGwob2JqLCB2YWx1ZSkgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG5cblxuXG5cbmV4cG9ydHMuX19wcml2YXRlR2V0ID0gX19wcml2YXRlR2V0OyBleHBvcnRzLl9fcHJpdmF0ZUFkZCA9IF9fcHJpdmF0ZUFkZDsgZXhwb3J0cy5fX3ByaXZhdGVTZXQgPSBfX3ByaXZhdGVTZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay0zVzVHNENZSS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfX2FjY2Vzc0NoZWNrIiwib2JqIiwibWVtYmVyIiwibXNnIiwiaGFzIiwiVHlwZUVycm9yIiwiX19wcml2YXRlR2V0IiwiZ2V0dGVyIiwiY2FsbCIsImdldCIsIl9fcHJpdmF0ZUFkZCIsIldlYWtTZXQiLCJhZGQiLCJzZXQiLCJfX3ByaXZhdGVTZXQiLCJzZXR0ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/chunk-3W5G4CYI.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/chunk-4D6XQBHA.js":
/*!*************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/chunk-4D6XQBHA.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js\");\n// src/versions.ts\nvar _semver = __webpack_require__(/*! semver */ \"(ssr)/./node_modules/semver/index.js\");\nvar _superstruct = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nvar VersionStruct = _superstruct.refine.call(void 0, _superstruct.string.call(void 0), \"Version\", (value)=>{\n    if (_semver.valid.call(void 0, value) === null) {\n        return `Expected SemVer version, got \"${value}\"`;\n    }\n    return true;\n});\nvar VersionRangeStruct = _superstruct.refine.call(void 0, _superstruct.string.call(void 0), \"Version range\", (value)=>{\n    if (_semver.validRange.call(void 0, value) === null) {\n        return `Expected SemVer range, got \"${value}\"`;\n    }\n    return true;\n});\nfunction isValidSemVerVersion(version) {\n    return _superstruct.is.call(void 0, version, VersionStruct);\n}\nfunction isValidSemVerRange(versionRange) {\n    return _superstruct.is.call(void 0, versionRange, VersionRangeStruct);\n}\nfunction assertIsSemVerVersion(version) {\n    _chunk6ZDHSOUVjs.assertStruct.call(void 0, version, VersionStruct);\n}\nfunction assertIsSemVerRange(range) {\n    _chunk6ZDHSOUVjs.assertStruct.call(void 0, range, VersionRangeStruct);\n}\nfunction gtVersion(version1, version2) {\n    return _semver.gt.call(void 0, version1, version2);\n}\nfunction gtRange(version, range) {\n    return _semver.gtr.call(void 0, version, range);\n}\nfunction satisfiesVersionRange(version, versionRange) {\n    return _semver.satisfies.call(void 0, version, versionRange, {\n        includePrerelease: true\n    });\n}\nexports.VersionStruct = VersionStruct;\nexports.VersionRangeStruct = VersionRangeStruct;\nexports.isValidSemVerVersion = isValidSemVerVersion;\nexports.isValidSemVerRange = isValidSemVerRange;\nexports.assertIsSemVerVersion = assertIsSemVerVersion;\nexports.assertIsSemVerRange = assertIsSemVerRange;\nexports.gtVersion = gtVersion;\nexports.gtRange = gtRange;\nexports.satisfiesVersionRange = satisfiesVersionRange; //# sourceMappingURL=chunk-4D6XQBHA.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2h1bmstNEQ2WFFCSEEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFBQUEsOENBQTZDO0lBQUNHLE9BQU87QUFBSSxDQUFDLEVBQUM7QUFFeEUsSUFBSUMsbUJBQW1CQyxtQkFBT0EsQ0FBQztBQUUvQixrQkFBa0I7QUFPbEIsSUFBSUMsVUFBVUQsbUJBQU9BLENBQUM7QUFDdEIsSUFBSUUsZUFBZUYsbUJBQU9BLENBQUM7QUFDM0IsSUFBSUcsZ0JBQWdCRCxhQUFhRSxNQUFNLENBQUNDLElBQUksQ0FBQyxLQUFLLEdBQ2hESCxhQUFhSSxNQUFNLENBQUNELElBQUksQ0FBQyxLQUFLLElBQzlCLFdBQ0EsQ0FBQ1A7SUFDQyxJQUFJRyxRQUFRTSxLQUFLLENBQUNGLElBQUksQ0FBQyxLQUFLLEdBQUdQLFdBQVcsTUFBTTtRQUM5QyxPQUFPLENBQUMsOEJBQThCLEVBQUVBLE1BQU0sQ0FBQyxDQUFDO0lBQ2xEO0lBQ0EsT0FBTztBQUNUO0FBRUYsSUFBSVUscUJBQXFCTixhQUFhRSxNQUFNLENBQUNDLElBQUksQ0FBQyxLQUFLLEdBQ3JESCxhQUFhSSxNQUFNLENBQUNELElBQUksQ0FBQyxLQUFLLElBQzlCLGlCQUNBLENBQUNQO0lBQ0MsSUFBSUcsUUFBUVEsVUFBVSxDQUFDSixJQUFJLENBQUMsS0FBSyxHQUFHUCxXQUFXLE1BQU07UUFDbkQsT0FBTyxDQUFDLDRCQUE0QixFQUFFQSxNQUFNLENBQUMsQ0FBQztJQUNoRDtJQUNBLE9BQU87QUFDVDtBQUVGLFNBQVNZLHFCQUFxQkMsT0FBTztJQUNuQyxPQUFPVCxhQUFhVSxFQUFFLENBQUNQLElBQUksQ0FBQyxLQUFLLEdBQUdNLFNBQVNSO0FBQy9DO0FBQ0EsU0FBU1UsbUJBQW1CQyxZQUFZO0lBQ3RDLE9BQU9aLGFBQWFVLEVBQUUsQ0FBQ1AsSUFBSSxDQUFDLEtBQUssR0FBR1MsY0FBY047QUFDcEQ7QUFDQSxTQUFTTyxzQkFBc0JKLE9BQU87SUFDcENaLGlCQUFpQmlCLFlBQVksQ0FBQ1gsSUFBSSxDQUFDLEtBQUssR0FBR00sU0FBU1I7QUFDdEQ7QUFDQSxTQUFTYyxvQkFBb0JDLEtBQUs7SUFDaENuQixpQkFBaUJpQixZQUFZLENBQUNYLElBQUksQ0FBQyxLQUFLLEdBQUdhLE9BQU9WO0FBQ3BEO0FBQ0EsU0FBU1csVUFBVUMsUUFBUSxFQUFFQyxRQUFRO0lBQ25DLE9BQU9wQixRQUFRcUIsRUFBRSxDQUFDakIsSUFBSSxDQUFDLEtBQUssR0FBR2UsVUFBVUM7QUFDM0M7QUFDQSxTQUFTRSxRQUFRWixPQUFPLEVBQUVPLEtBQUs7SUFDN0IsT0FBT2pCLFFBQVF1QixHQUFHLENBQUNuQixJQUFJLENBQUMsS0FBSyxHQUFHTSxTQUFTTztBQUMzQztBQUNBLFNBQVNPLHNCQUFzQmQsT0FBTyxFQUFFRyxZQUFZO0lBQ2xELE9BQU9iLFFBQVF5QixTQUFTLENBQUNyQixJQUFJLENBQUMsS0FBSyxHQUFHTSxTQUFTRyxjQUFjO1FBQzNEYSxtQkFBbUI7SUFDckI7QUFDRjtBQVlBOUIscUJBQXFCLEdBQUdNO0FBQWVOLDBCQUEwQixHQUFHVztBQUFvQlgsNEJBQTRCLEdBQUdhO0FBQXNCYiwwQkFBMEIsR0FBR2dCO0FBQW9CaEIsNkJBQTZCLEdBQUdrQjtBQUF1QmxCLDJCQUEyQixHQUFHb0I7QUFBcUJwQixpQkFBaUIsR0FBR3NCO0FBQVd0QixlQUFlLEdBQUcwQjtBQUFTMUIsNkJBQTZCLEdBQUc0Qix1QkFDbFksMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jaHVuay00RDZYUUJIQS5qcz8xNDBlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG5cbnZhciBfY2h1bms2WkRIU09VVmpzID0gcmVxdWlyZSgnLi9jaHVuay02WkRIU09VVi5qcycpO1xuXG4vLyBzcmMvdmVyc2lvbnMudHNcblxuXG5cblxuXG5cbnZhciBfc2VtdmVyID0gcmVxdWlyZSgnc2VtdmVyJyk7XG52YXIgX3N1cGVyc3RydWN0ID0gcmVxdWlyZSgnc3VwZXJzdHJ1Y3QnKTtcbnZhciBWZXJzaW9uU3RydWN0ID0gX3N1cGVyc3RydWN0LnJlZmluZS5jYWxsKHZvaWQgMCwgXG4gIF9zdXBlcnN0cnVjdC5zdHJpbmcuY2FsbCh2b2lkIDAsICksXG4gIFwiVmVyc2lvblwiLFxuICAodmFsdWUpID0+IHtcbiAgICBpZiAoX3NlbXZlci52YWxpZC5jYWxsKHZvaWQgMCwgdmFsdWUpID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gYEV4cGVjdGVkIFNlbVZlciB2ZXJzaW9uLCBnb3QgXCIke3ZhbHVlfVwiYDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbik7XG52YXIgVmVyc2lvblJhbmdlU3RydWN0ID0gX3N1cGVyc3RydWN0LnJlZmluZS5jYWxsKHZvaWQgMCwgXG4gIF9zdXBlcnN0cnVjdC5zdHJpbmcuY2FsbCh2b2lkIDAsICksXG4gIFwiVmVyc2lvbiByYW5nZVwiLFxuICAodmFsdWUpID0+IHtcbiAgICBpZiAoX3NlbXZlci52YWxpZFJhbmdlLmNhbGwodm9pZCAwLCB2YWx1ZSkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBgRXhwZWN0ZWQgU2VtVmVyIHJhbmdlLCBnb3QgXCIke3ZhbHVlfVwiYDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbik7XG5mdW5jdGlvbiBpc1ZhbGlkU2VtVmVyVmVyc2lvbih2ZXJzaW9uKSB7XG4gIHJldHVybiBfc3VwZXJzdHJ1Y3QuaXMuY2FsbCh2b2lkIDAsIHZlcnNpb24sIFZlcnNpb25TdHJ1Y3QpO1xufVxuZnVuY3Rpb24gaXNWYWxpZFNlbVZlclJhbmdlKHZlcnNpb25SYW5nZSkge1xuICByZXR1cm4gX3N1cGVyc3RydWN0LmlzLmNhbGwodm9pZCAwLCB2ZXJzaW9uUmFuZ2UsIFZlcnNpb25SYW5nZVN0cnVjdCk7XG59XG5mdW5jdGlvbiBhc3NlcnRJc1NlbVZlclZlcnNpb24odmVyc2lvbikge1xuICBfY2h1bms2WkRIU09VVmpzLmFzc2VydFN0cnVjdC5jYWxsKHZvaWQgMCwgdmVyc2lvbiwgVmVyc2lvblN0cnVjdCk7XG59XG5mdW5jdGlvbiBhc3NlcnRJc1NlbVZlclJhbmdlKHJhbmdlKSB7XG4gIF9jaHVuazZaREhTT1VWanMuYXNzZXJ0U3RydWN0LmNhbGwodm9pZCAwLCByYW5nZSwgVmVyc2lvblJhbmdlU3RydWN0KTtcbn1cbmZ1bmN0aW9uIGd0VmVyc2lvbih2ZXJzaW9uMSwgdmVyc2lvbjIpIHtcbiAgcmV0dXJuIF9zZW12ZXIuZ3QuY2FsbCh2b2lkIDAsIHZlcnNpb24xLCB2ZXJzaW9uMik7XG59XG5mdW5jdGlvbiBndFJhbmdlKHZlcnNpb24sIHJhbmdlKSB7XG4gIHJldHVybiBfc2VtdmVyLmd0ci5jYWxsKHZvaWQgMCwgdmVyc2lvbiwgcmFuZ2UpO1xufVxuZnVuY3Rpb24gc2F0aXNmaWVzVmVyc2lvblJhbmdlKHZlcnNpb24sIHZlcnNpb25SYW5nZSkge1xuICByZXR1cm4gX3NlbXZlci5zYXRpc2ZpZXMuY2FsbCh2b2lkIDAsIHZlcnNpb24sIHZlcnNpb25SYW5nZSwge1xuICAgIGluY2x1ZGVQcmVyZWxlYXNlOiB0cnVlXG4gIH0pO1xufVxuXG5cblxuXG5cblxuXG5cblxuXG5cbmV4cG9ydHMuVmVyc2lvblN0cnVjdCA9IFZlcnNpb25TdHJ1Y3Q7IGV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0ID0gVmVyc2lvblJhbmdlU3RydWN0OyBleHBvcnRzLmlzVmFsaWRTZW1WZXJWZXJzaW9uID0gaXNWYWxpZFNlbVZlclZlcnNpb247IGV4cG9ydHMuaXNWYWxpZFNlbVZlclJhbmdlID0gaXNWYWxpZFNlbVZlclJhbmdlOyBleHBvcnRzLmFzc2VydElzU2VtVmVyVmVyc2lvbiA9IGFzc2VydElzU2VtVmVyVmVyc2lvbjsgZXhwb3J0cy5hc3NlcnRJc1NlbVZlclJhbmdlID0gYXNzZXJ0SXNTZW1WZXJSYW5nZTsgZXhwb3J0cy5ndFZlcnNpb24gPSBndFZlcnNpb247IGV4cG9ydHMuZ3RSYW5nZSA9IGd0UmFuZ2U7IGV4cG9ydHMuc2F0aXNmaWVzVmVyc2lvblJhbmdlID0gc2F0aXNmaWVzVmVyc2lvblJhbmdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstNEQ2WFFCSEEuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX2NodW5rNlpESFNPVVZqcyIsInJlcXVpcmUiLCJfc2VtdmVyIiwiX3N1cGVyc3RydWN0IiwiVmVyc2lvblN0cnVjdCIsInJlZmluZSIsImNhbGwiLCJzdHJpbmciLCJ2YWxpZCIsIlZlcnNpb25SYW5nZVN0cnVjdCIsInZhbGlkUmFuZ2UiLCJpc1ZhbGlkU2VtVmVyVmVyc2lvbiIsInZlcnNpb24iLCJpcyIsImlzVmFsaWRTZW1WZXJSYW5nZSIsInZlcnNpb25SYW5nZSIsImFzc2VydElzU2VtVmVyVmVyc2lvbiIsImFzc2VydFN0cnVjdCIsImFzc2VydElzU2VtVmVyUmFuZ2UiLCJyYW5nZSIsImd0VmVyc2lvbiIsInZlcnNpb24xIiwidmVyc2lvbjIiLCJndCIsImd0UmFuZ2UiLCJndHIiLCJzYXRpc2ZpZXNWZXJzaW9uUmFuZ2UiLCJzYXRpc2ZpZXMiLCJpbmNsdWRlUHJlcmVsZWFzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/chunk-4D6XQBHA.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/chunk-4RMX5YWE.js":
/*!*************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/chunk-4RMX5YWE.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n})); // src/time.ts\nvar Duration = /* @__PURE__ */ ((Duration2)=>{\n    Duration2[Duration2[\"Millisecond\"] = 1] = \"Millisecond\";\n    Duration2[Duration2[\"Second\"] = 1e3] = \"Second\";\n    Duration2[Duration2[\"Minute\"] = 6e4] = \"Minute\";\n    Duration2[Duration2[\"Hour\"] = 36e5] = \"Hour\";\n    Duration2[Duration2[\"Day\"] = 864e5] = \"Day\";\n    Duration2[Duration2[\"Week\"] = 6048e5] = \"Week\";\n    Duration2[Duration2[\"Year\"] = 31536e6] = \"Year\";\n    return Duration2;\n})(Duration || {});\nvar isNonNegativeInteger = (number)=>Number.isInteger(number) && number >= 0;\nvar assertIsNonNegativeInteger = (number, name)=>{\n    if (!isNonNegativeInteger(number)) {\n        throw new Error(`\"${name}\" must be a non-negative integer. Received: \"${number}\".`);\n    }\n};\nfunction inMilliseconds(count, duration) {\n    assertIsNonNegativeInteger(count, \"count\");\n    return count * duration;\n}\nfunction timeSince(timestamp) {\n    assertIsNonNegativeInteger(timestamp, \"timestamp\");\n    return Date.now() - timestamp;\n}\nexports.Duration = Duration;\nexports.inMilliseconds = inMilliseconds;\nexports.timeSince = timeSince; //# sourceMappingURL=chunk-4RMX5YWE.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2h1bmstNFJNWDVZV0UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFBQUEsOENBQTZDO0lBQUNHLE9BQU87QUFBSSxDQUFDLEVBQUMsRUFBQyxjQUFjO0FBQ3ZGLElBQUlDLFdBQTJCLGFBQUgsR0FBSSxFQUFDQztJQUMvQkEsU0FBUyxDQUFDQSxTQUFTLENBQUMsY0FBYyxHQUFHLEVBQUUsR0FBRztJQUMxQ0EsU0FBUyxDQUFDQSxTQUFTLENBQUMsU0FBUyxHQUFHLElBQUksR0FBRztJQUN2Q0EsU0FBUyxDQUFDQSxTQUFTLENBQUMsU0FBUyxHQUFHLElBQUksR0FBRztJQUN2Q0EsU0FBUyxDQUFDQSxTQUFTLENBQUMsT0FBTyxHQUFHLEtBQUssR0FBRztJQUN0Q0EsU0FBUyxDQUFDQSxTQUFTLENBQUMsTUFBTSxHQUFHLE1BQU0sR0FBRztJQUN0Q0EsU0FBUyxDQUFDQSxTQUFTLENBQUMsT0FBTyxHQUFHLE9BQU8sR0FBRztJQUN4Q0EsU0FBUyxDQUFDQSxTQUFTLENBQUMsT0FBTyxHQUFHLFFBQVEsR0FBRztJQUN6QyxPQUFPQTtBQUNULEdBQUdELFlBQVksQ0FBQztBQUNoQixJQUFJRSx1QkFBdUIsQ0FBQ0MsU0FBV0MsT0FBT0MsU0FBUyxDQUFDRixXQUFXQSxVQUFVO0FBQzdFLElBQUlHLDZCQUE2QixDQUFDSCxRQUFRSTtJQUN4QyxJQUFJLENBQUNMLHFCQUFxQkMsU0FBUztRQUNqQyxNQUFNLElBQUlLLE1BQ1IsQ0FBQyxDQUFDLEVBQUVELEtBQUssNkNBQTZDLEVBQUVKLE9BQU8sRUFBRSxDQUFDO0lBRXRFO0FBQ0Y7QUFDQSxTQUFTTSxlQUFlQyxLQUFLLEVBQUVDLFFBQVE7SUFDckNMLDJCQUEyQkksT0FBTztJQUNsQyxPQUFPQSxRQUFRQztBQUNqQjtBQUNBLFNBQVNDLFVBQVVDLFNBQVM7SUFDMUJQLDJCQUEyQk8sV0FBVztJQUN0QyxPQUFPQyxLQUFLQyxHQUFHLEtBQUtGO0FBQ3RCO0FBTUFmLGdCQUFnQixHQUFHRTtBQUFVRixzQkFBc0IsR0FBR1c7QUFBZ0JYLGlCQUFpQixHQUFHYyxXQUMxRiwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NodW5rLTRSTVg1WVdFLmpzP2NhYTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTsvLyBzcmMvdGltZS50c1xudmFyIER1cmF0aW9uID0gLyogQF9fUFVSRV9fICovICgoRHVyYXRpb24yKSA9PiB7XG4gIER1cmF0aW9uMltEdXJhdGlvbjJbXCJNaWxsaXNlY29uZFwiXSA9IDFdID0gXCJNaWxsaXNlY29uZFwiO1xuICBEdXJhdGlvbjJbRHVyYXRpb24yW1wiU2Vjb25kXCJdID0gMWUzXSA9IFwiU2Vjb25kXCI7XG4gIER1cmF0aW9uMltEdXJhdGlvbjJbXCJNaW51dGVcIl0gPSA2ZTRdID0gXCJNaW51dGVcIjtcbiAgRHVyYXRpb24yW0R1cmF0aW9uMltcIkhvdXJcIl0gPSAzNmU1XSA9IFwiSG91clwiO1xuICBEdXJhdGlvbjJbRHVyYXRpb24yW1wiRGF5XCJdID0gODY0ZTVdID0gXCJEYXlcIjtcbiAgRHVyYXRpb24yW0R1cmF0aW9uMltcIldlZWtcIl0gPSA2MDQ4ZTVdID0gXCJXZWVrXCI7XG4gIER1cmF0aW9uMltEdXJhdGlvbjJbXCJZZWFyXCJdID0gMzE1MzZlNl0gPSBcIlllYXJcIjtcbiAgcmV0dXJuIER1cmF0aW9uMjtcbn0pKER1cmF0aW9uIHx8IHt9KTtcbnZhciBpc05vbk5lZ2F0aXZlSW50ZWdlciA9IChudW1iZXIpID0+IE51bWJlci5pc0ludGVnZXIobnVtYmVyKSAmJiBudW1iZXIgPj0gMDtcbnZhciBhc3NlcnRJc05vbk5lZ2F0aXZlSW50ZWdlciA9IChudW1iZXIsIG5hbWUpID0+IHtcbiAgaWYgKCFpc05vbk5lZ2F0aXZlSW50ZWdlcihudW1iZXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFwiJHtuYW1lfVwiIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlci4gUmVjZWl2ZWQ6IFwiJHtudW1iZXJ9XCIuYFxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiBpbk1pbGxpc2Vjb25kcyhjb3VudCwgZHVyYXRpb24pIHtcbiAgYXNzZXJ0SXNOb25OZWdhdGl2ZUludGVnZXIoY291bnQsIFwiY291bnRcIik7XG4gIHJldHVybiBjb3VudCAqIGR1cmF0aW9uO1xufVxuZnVuY3Rpb24gdGltZVNpbmNlKHRpbWVzdGFtcCkge1xuICBhc3NlcnRJc05vbk5lZ2F0aXZlSW50ZWdlcih0aW1lc3RhbXAsIFwidGltZXN0YW1wXCIpO1xuICByZXR1cm4gRGF0ZS5ub3coKSAtIHRpbWVzdGFtcDtcbn1cblxuXG5cblxuXG5leHBvcnRzLkR1cmF0aW9uID0gRHVyYXRpb247IGV4cG9ydHMuaW5NaWxsaXNlY29uZHMgPSBpbk1pbGxpc2Vjb25kczsgZXhwb3J0cy50aW1lU2luY2UgPSB0aW1lU2luY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay00Uk1YNVlXRS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJEdXJhdGlvbiIsIkR1cmF0aW9uMiIsImlzTm9uTmVnYXRpdmVJbnRlZ2VyIiwibnVtYmVyIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiYXNzZXJ0SXNOb25OZWdhdGl2ZUludGVnZXIiLCJuYW1lIiwiRXJyb3IiLCJpbk1pbGxpc2Vjb25kcyIsImNvdW50IiwiZHVyYXRpb24iLCJ0aW1lU2luY2UiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/chunk-4RMX5YWE.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/chunk-6NZW4WK4.js":
/*!*************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/chunk-6NZW4WK4.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _nullishCoalesce(lhs, rhsFn) {\n    if (lhs != null) {\n        return lhs;\n    } else {\n        return rhsFn();\n    }\n}\nvar _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js\");\n// src/base64.ts\nvar _superstruct = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nvar base64 = (struct, options = {})=>{\n    const paddingRequired = _nullishCoalesce(options.paddingRequired, ()=>false);\n    const characterSet = _nullishCoalesce(options.characterSet, ()=>\"base64\");\n    let letters;\n    if (characterSet === \"base64\") {\n        letters = String.raw`[A-Za-z0-9+\\/]`;\n    } else {\n        _chunk6ZDHSOUVjs.assert.call(void 0, characterSet === \"base64url\");\n        letters = String.raw`[-_A-Za-z0-9]`;\n    }\n    let re;\n    if (paddingRequired) {\n        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, \"u\");\n    } else {\n        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, \"u\");\n    }\n    return _superstruct.pattern.call(void 0, struct, re);\n};\nexports.base64 = base64; //# sourceMappingURL=chunk-6NZW4WK4.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2h1bmstNk5aVzRXSzQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFBQUEsOENBQTZDO0lBQUNHLE9BQU87QUFBSSxDQUFDLEVBQUM7QUFBRSxTQUFTQyxpQkFBaUJDLEdBQUcsRUFBRUMsS0FBSztJQUFJLElBQUlELE9BQU8sTUFBTTtRQUFFLE9BQU9BO0lBQUssT0FBTztRQUFFLE9BQU9DO0lBQVM7QUFBRTtBQUU1SyxJQUFJQyxtQkFBbUJDLG1CQUFPQSxDQUFDO0FBRS9CLGdCQUFnQjtBQUNoQixJQUFJQyxlQUFlRCxtQkFBT0EsQ0FBQztBQUMzQixJQUFJRSxTQUFTLENBQUNDLFFBQVFDLFVBQVUsQ0FBQyxDQUFDO0lBQ2hDLE1BQU1DLGtCQUFrQlQsaUJBQWlCUSxRQUFRQyxlQUFlLEVBQUUsSUFBUTtJQUMxRSxNQUFNQyxlQUFlVixpQkFBaUJRLFFBQVFFLFlBQVksRUFBRSxJQUFRO0lBQ3BFLElBQUlDO0lBQ0osSUFBSUQsaUJBQWlCLFVBQVU7UUFDN0JDLFVBQVVDLE9BQU9DLEdBQUcsQ0FBQyxjQUFjLENBQUM7SUFDdEMsT0FBTztRQUNMVixpQkFBaUJXLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDLEtBQUssR0FBR0wsaUJBQWlCO1FBQ3REQyxVQUFVQyxPQUFPQyxHQUFHLENBQUMsYUFBYSxDQUFDO0lBQ3JDO0lBQ0EsSUFBSUc7SUFDSixJQUFJUCxpQkFBaUI7UUFDbkJPLEtBQUssSUFBSUMsT0FDUCxDQUFDLElBQUksRUFBRU4sUUFBUSxRQUFRLEVBQUVBLFFBQVEsS0FBSyxFQUFFQSxRQUFRLFFBQVEsQ0FBQyxFQUN6RDtJQUVKLE9BQU87UUFDTEssS0FBSyxJQUFJQyxPQUNQLENBQUMsSUFBSSxFQUFFTixRQUFRLFFBQVEsRUFBRUEsUUFBUSxNQUFNLEVBQUVBLFFBQVEsS0FBSyxFQUFFQSxRQUFRLFFBQVEsQ0FBQyxFQUN6RTtJQUVKO0lBQ0EsT0FBT04sYUFBYWEsT0FBTyxDQUFDSCxJQUFJLENBQUMsS0FBSyxHQUFHUixRQUFRUztBQUNuRDtBQUlBbEIsY0FBYyxHQUFHUSxRQUNqQiwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NodW5rLTZOWlc0V0s0LmpzPzYyOWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTsgZnVuY3Rpb24gX251bGxpc2hDb2FsZXNjZShsaHMsIHJoc0ZuKSB7IGlmIChsaHMgIT0gbnVsbCkgeyByZXR1cm4gbGhzOyB9IGVsc2UgeyByZXR1cm4gcmhzRm4oKTsgfSB9XG5cbnZhciBfY2h1bms2WkRIU09VVmpzID0gcmVxdWlyZSgnLi9jaHVuay02WkRIU09VVi5qcycpO1xuXG4vLyBzcmMvYmFzZTY0LnRzXG52YXIgX3N1cGVyc3RydWN0ID0gcmVxdWlyZSgnc3VwZXJzdHJ1Y3QnKTtcbnZhciBiYXNlNjQgPSAoc3RydWN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgcGFkZGluZ1JlcXVpcmVkID0gX251bGxpc2hDb2FsZXNjZShvcHRpb25zLnBhZGRpbmdSZXF1aXJlZCwgKCkgPT4gKCBmYWxzZSkpO1xuICBjb25zdCBjaGFyYWN0ZXJTZXQgPSBfbnVsbGlzaENvYWxlc2NlKG9wdGlvbnMuY2hhcmFjdGVyU2V0LCAoKSA9PiAoIFwiYmFzZTY0XCIpKTtcbiAgbGV0IGxldHRlcnM7XG4gIGlmIChjaGFyYWN0ZXJTZXQgPT09IFwiYmFzZTY0XCIpIHtcbiAgICBsZXR0ZXJzID0gU3RyaW5nLnJhd2BbQS1aYS16MC05K1xcL11gO1xuICB9IGVsc2Uge1xuICAgIF9jaHVuazZaREhTT1VWanMuYXNzZXJ0LmNhbGwodm9pZCAwLCBjaGFyYWN0ZXJTZXQgPT09IFwiYmFzZTY0dXJsXCIpO1xuICAgIGxldHRlcnMgPSBTdHJpbmcucmF3YFstX0EtWmEtejAtOV1gO1xuICB9XG4gIGxldCByZTtcbiAgaWYgKHBhZGRpbmdSZXF1aXJlZCkge1xuICAgIHJlID0gbmV3IFJlZ0V4cChcbiAgICAgIGBeKD86JHtsZXR0ZXJzfXs0fSkqKD86JHtsZXR0ZXJzfXszfT18JHtsZXR0ZXJzfXsyfT09KT8kYCxcbiAgICAgIFwidVwiXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZSA9IG5ldyBSZWdFeHAoXG4gICAgICBgXig/OiR7bGV0dGVyc317NH0pKig/OiR7bGV0dGVyc317MiwzfXwke2xldHRlcnN9ezN9PXwke2xldHRlcnN9ezJ9PT0pPyRgLFxuICAgICAgXCJ1XCJcbiAgICApO1xuICB9XG4gIHJldHVybiBfc3VwZXJzdHJ1Y3QucGF0dGVybi5jYWxsKHZvaWQgMCwgc3RydWN0LCByZSk7XG59O1xuXG5cblxuZXhwb3J0cy5iYXNlNjQgPSBiYXNlNjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay02TlpXNFdLNC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfbnVsbGlzaENvYWxlc2NlIiwibGhzIiwicmhzRm4iLCJfY2h1bms2WkRIU09VVmpzIiwicmVxdWlyZSIsIl9zdXBlcnN0cnVjdCIsImJhc2U2NCIsInN0cnVjdCIsIm9wdGlvbnMiLCJwYWRkaW5nUmVxdWlyZWQiLCJjaGFyYWN0ZXJTZXQiLCJsZXR0ZXJzIiwiU3RyaW5nIiwicmF3IiwiYXNzZXJ0IiwiY2FsbCIsInJlIiwiUmVnRXhwIiwicGF0dGVybiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/chunk-6NZW4WK4.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js":
/*!*************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _optionalChain(ops) {\n    let lastAccessLHS = undefined;\n    let value = ops[0];\n    let i = 1;\n    while(i < ops.length){\n        const op = ops[i];\n        const fn = ops[i + 1];\n        i += 2;\n        if ((op === \"optionalAccess\" || op === \"optionalCall\") && value == null) {\n            return undefined;\n        }\n        if (op === \"access\" || op === \"optionalAccess\") {\n            lastAccessLHS = value;\n            value = fn(value);\n        } else if (op === \"call\" || op === \"optionalCall\") {\n            value = fn((...args)=>value.call(lastAccessLHS, ...args));\n            lastAccessLHS = undefined;\n        }\n    }\n    return value;\n}\nvar _chunkIZC266HSjs = __webpack_require__(/*! ./chunk-IZC266HS.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-IZC266HS.js\");\n// src/assert.ts\nvar _superstruct = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nfunction isConstructable(fn) {\n    return Boolean(typeof _optionalChain([\n        fn,\n        \"optionalAccess\",\n        (_)=>_.prototype,\n        \"optionalAccess\",\n        (_2)=>_2.constructor,\n        \"optionalAccess\",\n        (_3)=>_3.name\n    ]) === \"string\");\n}\nfunction getErrorMessageWithoutTrailingPeriod(error) {\n    return _chunkIZC266HSjs.getErrorMessage.call(void 0, error).replace(/\\.$/u, \"\");\n}\nfunction getError(ErrorWrapper, message) {\n    if (isConstructable(ErrorWrapper)) {\n        return new ErrorWrapper({\n            message\n        });\n    }\n    return ErrorWrapper({\n        message\n    });\n}\nvar AssertionError = class extends Error {\n    constructor(options){\n        super(options.message);\n        this.code = \"ERR_ASSERTION\";\n    }\n};\nfunction assert(value, message = \"Assertion failed.\", ErrorWrapper = AssertionError) {\n    if (!value) {\n        if (message instanceof Error) {\n            throw message;\n        }\n        throw getError(ErrorWrapper, message);\n    }\n}\nfunction assertStruct(value, struct, errorPrefix = \"Assertion failed\", ErrorWrapper = AssertionError) {\n    try {\n        _superstruct.assert.call(void 0, value, struct);\n    } catch (error) {\n        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessageWithoutTrailingPeriod(error)}.`);\n    }\n}\nfunction assertExhaustive(_object) {\n    throw new Error(\"Invalid branch reached. Should be detected during compilation.\");\n}\nexports.AssertionError = AssertionError;\nexports.assert = assert;\nexports.assertStruct = assertStruct;\nexports.assertExhaustive = assertExhaustive; //# sourceMappingURL=chunk-6ZDHSOUV.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2h1bmstNlpESFNPVVYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFBQUEsOENBQTZDO0lBQUNHLE9BQU87QUFBSSxDQUFDLEVBQUM7QUFBRSxTQUFTQyxlQUFlQyxHQUFHO0lBQUksSUFBSUMsZ0JBQWdCQztJQUFXLElBQUlKLFFBQVFFLEdBQUcsQ0FBQyxFQUFFO0lBQUUsSUFBSUcsSUFBSTtJQUFHLE1BQU9BLElBQUlILElBQUlJLE1BQU0sQ0FBRTtRQUFFLE1BQU1DLEtBQUtMLEdBQUcsQ0FBQ0csRUFBRTtRQUFFLE1BQU1HLEtBQUtOLEdBQUcsQ0FBQ0csSUFBSSxFQUFFO1FBQUVBLEtBQUs7UUFBRyxJQUFJLENBQUNFLE9BQU8sb0JBQW9CQSxPQUFPLGNBQWEsS0FBTVAsU0FBUyxNQUFNO1lBQUUsT0FBT0k7UUFBVztRQUFFLElBQUlHLE9BQU8sWUFBWUEsT0FBTyxrQkFBa0I7WUFBRUosZ0JBQWdCSDtZQUFPQSxRQUFRUSxHQUFHUjtRQUFRLE9BQU8sSUFBSU8sT0FBTyxVQUFVQSxPQUFPLGdCQUFnQjtZQUFFUCxRQUFRUSxHQUFHLENBQUMsR0FBR0MsT0FBU1QsTUFBTVUsSUFBSSxDQUFDUCxrQkFBa0JNO1lBQVFOLGdCQUFnQkM7UUFBVztJQUFFO0lBQUUsT0FBT0o7QUFBTztBQUU1a0IsSUFBSVcsbUJBQW1CQyxtQkFBT0EsQ0FBQztBQUUvQixnQkFBZ0I7QUFDaEIsSUFBSUMsZUFBZUQsbUJBQU9BLENBQUM7QUFDM0IsU0FBU0UsZ0JBQWdCTixFQUFFO0lBQ3pCLE9BQU9PLFFBQVEsT0FBT2QsZUFBZTtRQUFDTztRQUFJO1FBQWtCUSxDQUFBQSxJQUFLQSxFQUFFQyxTQUFTO1FBQUU7UUFBa0JDLENBQUFBLEtBQU1BLEdBQUdDLFdBQVc7UUFBRTtRQUFrQkMsQ0FBQUEsS0FBTUEsR0FBR0MsSUFBSTtLQUFDLE1BQU07QUFDOUo7QUFDQSxTQUFTQyxxQ0FBcUNDLEtBQUs7SUFDakQsT0FBT1osaUJBQWlCYSxlQUFlLENBQUNkLElBQUksQ0FBQyxLQUFLLEdBQUdhLE9BQU9FLE9BQU8sQ0FBQyxRQUFRO0FBQzlFO0FBQ0EsU0FBU0MsU0FBU0MsWUFBWSxFQUFFQyxPQUFPO0lBQ3JDLElBQUlkLGdCQUFnQmEsZUFBZTtRQUNqQyxPQUFPLElBQUlBLGFBQWE7WUFDdEJDO1FBQ0Y7SUFDRjtJQUNBLE9BQU9ELGFBQWE7UUFDbEJDO0lBQ0Y7QUFDRjtBQUNBLElBQUlDLGlCQUFpQixjQUFjQztJQUNqQ1gsWUFBWVksT0FBTyxDQUFFO1FBQ25CLEtBQUssQ0FBQ0EsUUFBUUgsT0FBTztRQUNyQixJQUFJLENBQUNJLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFDQSxTQUFTQyxPQUFPakMsS0FBSyxFQUFFNEIsVUFBVSxtQkFBbUIsRUFBRUQsZUFBZUUsY0FBYztJQUNqRixJQUFJLENBQUM3QixPQUFPO1FBQ1YsSUFBSTRCLG1CQUFtQkUsT0FBTztZQUM1QixNQUFNRjtRQUNSO1FBQ0EsTUFBTUYsU0FBU0MsY0FBY0M7SUFDL0I7QUFDRjtBQUNBLFNBQVNNLGFBQWFsQyxLQUFLLEVBQUVtQyxNQUFNLEVBQUVDLGNBQWMsa0JBQWtCLEVBQUVULGVBQWVFLGNBQWM7SUFDbEcsSUFBSTtRQUNGaEIsYUFBYW9CLE1BQU0sQ0FBQ3ZCLElBQUksQ0FBQyxLQUFLLEdBQUdWLE9BQU9tQztJQUMxQyxFQUFFLE9BQU9aLE9BQU87UUFDZCxNQUFNRyxTQUNKQyxjQUNBLENBQUMsRUFBRVMsWUFBWSxFQUFFLEVBQUVkLHFDQUFxQ0MsT0FBTyxDQUFDLENBQUM7SUFFckU7QUFDRjtBQUNBLFNBQVNjLGlCQUFpQkMsT0FBTztJQUMvQixNQUFNLElBQUlSLE1BQ1I7QUFFSjtBQU9BL0Isc0JBQXNCLEdBQUc4QjtBQUFnQjlCLGNBQWMsR0FBR2tDO0FBQVFsQyxvQkFBb0IsR0FBR21DO0FBQWNuQyx3QkFBd0IsR0FBR3NDLGtCQUNsSSwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NodW5rLTZaREhTT1VWLmpzPzllMTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTsgZnVuY3Rpb24gX29wdGlvbmFsQ2hhaW4ob3BzKSB7IGxldCBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyBsZXQgdmFsdWUgPSBvcHNbMF07IGxldCBpID0gMTsgd2hpbGUgKGkgPCBvcHMubGVuZ3RoKSB7IGNvbnN0IG9wID0gb3BzW2ldOyBjb25zdCBmbiA9IG9wc1tpICsgMV07IGkgKz0gMjsgaWYgKChvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpICYmIHZhbHVlID09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBpZiAob3AgPT09ICdhY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnKSB7IGxhc3RBY2Nlc3NMSFMgPSB2YWx1ZTsgdmFsdWUgPSBmbih2YWx1ZSk7IH0gZWxzZSBpZiAob3AgPT09ICdjYWxsJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpIHsgdmFsdWUgPSBmbigoLi4uYXJncykgPT4gdmFsdWUuY2FsbChsYXN0QWNjZXNzTEhTLCAuLi5hcmdzKSk7IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IH0gfSByZXR1cm4gdmFsdWU7IH1cblxudmFyIF9jaHVua0laQzI2NkhTanMgPSByZXF1aXJlKCcuL2NodW5rLUlaQzI2NkhTLmpzJyk7XG5cbi8vIHNyYy9hc3NlcnQudHNcbnZhciBfc3VwZXJzdHJ1Y3QgPSByZXF1aXJlKCdzdXBlcnN0cnVjdCcpO1xuZnVuY3Rpb24gaXNDb25zdHJ1Y3RhYmxlKGZuKSB7XG4gIHJldHVybiBCb29sZWFuKHR5cGVvZiBfb3B0aW9uYWxDaGFpbihbZm4sICdvcHRpb25hbEFjY2VzcycsIF8gPT4gXy5wcm90b3R5cGUsICdvcHRpb25hbEFjY2VzcycsIF8yID0+IF8yLmNvbnN0cnVjdG9yLCAnb3B0aW9uYWxBY2Nlc3MnLCBfMyA9PiBfMy5uYW1lXSkgPT09IFwic3RyaW5nXCIpO1xufVxuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlV2l0aG91dFRyYWlsaW5nUGVyaW9kKGVycm9yKSB7XG4gIHJldHVybiBfY2h1bmtJWkMyNjZIU2pzLmdldEVycm9yTWVzc2FnZS5jYWxsKHZvaWQgMCwgZXJyb3IpLnJlcGxhY2UoL1xcLiQvdSwgXCJcIik7XG59XG5mdW5jdGlvbiBnZXRFcnJvcihFcnJvcldyYXBwZXIsIG1lc3NhZ2UpIHtcbiAgaWYgKGlzQ29uc3RydWN0YWJsZShFcnJvcldyYXBwZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcldyYXBwZXIoe1xuICAgICAgbWVzc2FnZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBFcnJvcldyYXBwZXIoe1xuICAgIG1lc3NhZ2VcbiAgfSk7XG59XG52YXIgQXNzZXJ0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMubWVzc2FnZSk7XG4gICAgdGhpcy5jb2RlID0gXCJFUlJfQVNTRVJUSU9OXCI7XG4gIH1cbn07XG5mdW5jdGlvbiBhc3NlcnQodmFsdWUsIG1lc3NhZ2UgPSBcIkFzc2VydGlvbiBmYWlsZWQuXCIsIEVycm9yV3JhcHBlciA9IEFzc2VydGlvbkVycm9yKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBtZXNzYWdlO1xuICAgIH1cbiAgICB0aHJvdyBnZXRFcnJvcihFcnJvcldyYXBwZXIsIG1lc3NhZ2UpO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRTdHJ1Y3QodmFsdWUsIHN0cnVjdCwgZXJyb3JQcmVmaXggPSBcIkFzc2VydGlvbiBmYWlsZWRcIiwgRXJyb3JXcmFwcGVyID0gQXNzZXJ0aW9uRXJyb3IpIHtcbiAgdHJ5IHtcbiAgICBfc3VwZXJzdHJ1Y3QuYXNzZXJ0LmNhbGwodm9pZCAwLCB2YWx1ZSwgc3RydWN0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBnZXRFcnJvcihcbiAgICAgIEVycm9yV3JhcHBlcixcbiAgICAgIGAke2Vycm9yUHJlZml4fTogJHtnZXRFcnJvck1lc3NhZ2VXaXRob3V0VHJhaWxpbmdQZXJpb2QoZXJyb3IpfS5gXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0RXhoYXVzdGl2ZShfb2JqZWN0KSB7XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBcIkludmFsaWQgYnJhbmNoIHJlYWNoZWQuIFNob3VsZCBiZSBkZXRlY3RlZCBkdXJpbmcgY29tcGlsYXRpb24uXCJcbiAgKTtcbn1cblxuXG5cblxuXG5cbmV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvcjsgZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7IGV4cG9ydHMuYXNzZXJ0U3RydWN0ID0gYXNzZXJ0U3RydWN0OyBleHBvcnRzLmFzc2VydEV4aGF1c3RpdmUgPSBhc3NlcnRFeGhhdXN0aXZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstNlpESFNPVVYuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX29wdGlvbmFsQ2hhaW4iLCJvcHMiLCJsYXN0QWNjZXNzTEhTIiwidW5kZWZpbmVkIiwiaSIsImxlbmd0aCIsIm9wIiwiZm4iLCJhcmdzIiwiY2FsbCIsIl9jaHVua0laQzI2NkhTanMiLCJyZXF1aXJlIiwiX3N1cGVyc3RydWN0IiwiaXNDb25zdHJ1Y3RhYmxlIiwiQm9vbGVhbiIsIl8iLCJwcm90b3R5cGUiLCJfMiIsImNvbnN0cnVjdG9yIiwiXzMiLCJuYW1lIiwiZ2V0RXJyb3JNZXNzYWdlV2l0aG91dFRyYWlsaW5nUGVyaW9kIiwiZXJyb3IiLCJnZXRFcnJvck1lc3NhZ2UiLCJyZXBsYWNlIiwiZ2V0RXJyb3IiLCJFcnJvcldyYXBwZXIiLCJtZXNzYWdlIiwiQXNzZXJ0aW9uRXJyb3IiLCJFcnJvciIsIm9wdGlvbnMiLCJjb2RlIiwiYXNzZXJ0IiwiYXNzZXJ0U3RydWN0Iiwic3RydWN0IiwiZXJyb3JQcmVmaXgiLCJhc3NlcnRFeGhhdXN0aXZlIiwiX29iamVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/chunk-DHVKFDHQ.js":
/*!*************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/chunk-DHVKFDHQ.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _chunkQEPVHEP7js = __webpack_require__(/*! ./chunk-QEPVHEP7.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-QEPVHEP7.js\");\nvar _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js\");\n// src/coercers.ts\nvar _superstruct = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nvar NumberLikeStruct = _superstruct.union.call(void 0, [\n    _superstruct.number.call(void 0),\n    _superstruct.bigint.call(void 0),\n    _superstruct.string.call(void 0),\n    _chunkQEPVHEP7js.StrictHexStruct\n]);\nvar NumberCoercer = _superstruct.coerce.call(void 0, _superstruct.number.call(void 0), NumberLikeStruct, Number);\nvar BigIntCoercer = _superstruct.coerce.call(void 0, _superstruct.bigint.call(void 0), NumberLikeStruct, BigInt);\nvar BytesLikeStruct = _superstruct.union.call(void 0, [\n    _chunkQEPVHEP7js.StrictHexStruct,\n    _superstruct.instance.call(void 0, Uint8Array)\n]);\nvar BytesCoercer = _superstruct.coerce.call(void 0, _superstruct.instance.call(void 0, Uint8Array), _superstruct.union.call(void 0, [\n    _chunkQEPVHEP7js.StrictHexStruct\n]), _chunkQEPVHEP7js.hexToBytes);\nvar HexCoercer = _superstruct.coerce.call(void 0, _chunkQEPVHEP7js.StrictHexStruct, _superstruct.instance.call(void 0, Uint8Array), _chunkQEPVHEP7js.bytesToHex);\nfunction createNumber(value) {\n    try {\n        const result = _superstruct.create.call(void 0, value, NumberCoercer);\n        _chunk6ZDHSOUVjs.assert.call(void 0, Number.isFinite(result), `Expected a number-like value, got \"${value}\".`);\n        return result;\n    } catch (error) {\n        if (error instanceof _superstruct.StructError) {\n            throw new Error(`Expected a number-like value, got \"${value}\".`);\n        }\n        throw error;\n    }\n}\nfunction createBigInt(value) {\n    try {\n        return _superstruct.create.call(void 0, value, BigIntCoercer);\n    } catch (error) {\n        if (error instanceof _superstruct.StructError) {\n            throw new Error(`Expected a number-like value, got \"${String(error.value)}\".`);\n        }\n        throw error;\n    }\n}\nfunction createBytes(value) {\n    if (typeof value === \"string\" && value.toLowerCase() === \"0x\") {\n        return new Uint8Array();\n    }\n    try {\n        return _superstruct.create.call(void 0, value, BytesCoercer);\n    } catch (error) {\n        if (error instanceof _superstruct.StructError) {\n            throw new Error(`Expected a bytes-like value, got \"${String(error.value)}\".`);\n        }\n        throw error;\n    }\n}\nfunction createHex(value) {\n    if (value instanceof Uint8Array && value.length === 0 || typeof value === \"string\" && value.toLowerCase() === \"0x\") {\n        return \"0x\";\n    }\n    try {\n        return _superstruct.create.call(void 0, value, HexCoercer);\n    } catch (error) {\n        if (error instanceof _superstruct.StructError) {\n            throw new Error(`Expected a bytes-like value, got \"${String(error.value)}\".`);\n        }\n        throw error;\n    }\n}\nexports.createNumber = createNumber;\nexports.createBigInt = createBigInt;\nexports.createBytes = createBytes;\nexports.createHex = createHex; //# sourceMappingURL=chunk-DHVKFDHQ.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2h1bmstREhWS0ZESFEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFBQUEsOENBQTZDO0lBQUNHLE9BQU87QUFBSSxDQUFDLEVBQUM7QUFJeEUsSUFBSUMsbUJBQW1CQyxtQkFBT0EsQ0FBQztBQUcvQixJQUFJQyxtQkFBbUJELG1CQUFPQSxDQUFDO0FBRS9CLGtCQUFrQjtBQVVsQixJQUFJRSxlQUFlRixtQkFBT0EsQ0FBQztBQUMzQixJQUFJRyxtQkFBbUJELGFBQWFFLEtBQUssQ0FBQ0MsSUFBSSxDQUFDLEtBQUssR0FBRztJQUFDSCxhQUFhSSxNQUFNLENBQUNELElBQUksQ0FBQyxLQUFLO0lBQU1ILGFBQWFLLE1BQU0sQ0FBQ0YsSUFBSSxDQUFDLEtBQUs7SUFBTUgsYUFBYU0sTUFBTSxDQUFDSCxJQUFJLENBQUMsS0FBSztJQUFNTixpQkFBaUJVLGVBQWU7Q0FBQztBQUNyTSxJQUFJQyxnQkFBZ0JSLGFBQWFTLE1BQU0sQ0FBQ04sSUFBSSxDQUFDLEtBQUssR0FBR0gsYUFBYUksTUFBTSxDQUFDRCxJQUFJLENBQUMsS0FBSyxJQUFNRixrQkFBa0JTO0FBQzNHLElBQUlDLGdCQUFnQlgsYUFBYVMsTUFBTSxDQUFDTixJQUFJLENBQUMsS0FBSyxHQUFHSCxhQUFhSyxNQUFNLENBQUNGLElBQUksQ0FBQyxLQUFLLElBQU1GLGtCQUFrQlc7QUFDM0csSUFBSUMsa0JBQWtCYixhQUFhRSxLQUFLLENBQUNDLElBQUksQ0FBQyxLQUFLLEdBQUc7SUFBQ04saUJBQWlCVSxlQUFlO0lBQUVQLGFBQWFjLFFBQVEsQ0FBQ1gsSUFBSSxDQUFDLEtBQUssR0FBR1k7Q0FBWTtBQUN4SSxJQUFJQyxlQUFlaEIsYUFBYVMsTUFBTSxDQUFDTixJQUFJLENBQUMsS0FBSyxHQUMvQ0gsYUFBYWMsUUFBUSxDQUFDWCxJQUFJLENBQUMsS0FBSyxHQUFHWSxhQUNuQ2YsYUFBYUUsS0FBSyxDQUFDQyxJQUFJLENBQUMsS0FBSyxHQUFHO0lBQUNOLGlCQUFpQlUsZUFBZTtDQUFDLEdBQ2xFVixpQkFBaUJvQixVQUFVO0FBRTdCLElBQUlDLGFBQWFsQixhQUFhUyxNQUFNLENBQUNOLElBQUksQ0FBQyxLQUFLLEdBQUdOLGlCQUFpQlUsZUFBZSxFQUFFUCxhQUFhYyxRQUFRLENBQUNYLElBQUksQ0FBQyxLQUFLLEdBQUdZLGFBQWFsQixpQkFBaUJzQixVQUFVO0FBQy9KLFNBQVNDLGFBQWF4QixLQUFLO0lBQ3pCLElBQUk7UUFDRixNQUFNeUIsU0FBU3JCLGFBQWFzQixNQUFNLENBQUNuQixJQUFJLENBQUMsS0FBSyxHQUFHUCxPQUFPWTtRQUN2RFQsaUJBQWlCd0IsTUFBTSxDQUFDcEIsSUFBSSxDQUFDLEtBQUssR0FDaENPLE9BQU9jLFFBQVEsQ0FBQ0gsU0FDaEIsQ0FBQyxtQ0FBbUMsRUFBRXpCLE1BQU0sRUFBRSxDQUFDO1FBRWpELE9BQU95QjtJQUNULEVBQUUsT0FBT0ksT0FBTztRQUNkLElBQUlBLGlCQUFpQnpCLGFBQWEwQixXQUFXLEVBQUU7WUFDN0MsTUFBTSxJQUFJQyxNQUFNLENBQUMsbUNBQW1DLEVBQUUvQixNQUFNLEVBQUUsQ0FBQztRQUNqRTtRQUNBLE1BQU02QjtJQUNSO0FBQ0Y7QUFDQSxTQUFTRyxhQUFhaEMsS0FBSztJQUN6QixJQUFJO1FBQ0YsT0FBT0ksYUFBYXNCLE1BQU0sQ0FBQ25CLElBQUksQ0FBQyxLQUFLLEdBQUdQLE9BQU9lO0lBQ2pELEVBQUUsT0FBT2MsT0FBTztRQUNkLElBQUlBLGlCQUFpQnpCLGFBQWEwQixXQUFXLEVBQUU7WUFDN0MsTUFBTSxJQUFJQyxNQUNSLENBQUMsbUNBQW1DLEVBQUVFLE9BQU9KLE1BQU03QixLQUFLLEVBQUUsRUFBRSxDQUFDO1FBRWpFO1FBQ0EsTUFBTTZCO0lBQ1I7QUFDRjtBQUNBLFNBQVNLLFlBQVlsQyxLQUFLO0lBQ3hCLElBQUksT0FBT0EsVUFBVSxZQUFZQSxNQUFNbUMsV0FBVyxPQUFPLE1BQU07UUFDN0QsT0FBTyxJQUFJaEI7SUFDYjtJQUNBLElBQUk7UUFDRixPQUFPZixhQUFhc0IsTUFBTSxDQUFDbkIsSUFBSSxDQUFDLEtBQUssR0FBR1AsT0FBT29CO0lBQ2pELEVBQUUsT0FBT1MsT0FBTztRQUNkLElBQUlBLGlCQUFpQnpCLGFBQWEwQixXQUFXLEVBQUU7WUFDN0MsTUFBTSxJQUFJQyxNQUNSLENBQUMsa0NBQWtDLEVBQUVFLE9BQU9KLE1BQU03QixLQUFLLEVBQUUsRUFBRSxDQUFDO1FBRWhFO1FBQ0EsTUFBTTZCO0lBQ1I7QUFDRjtBQUNBLFNBQVNPLFVBQVVwQyxLQUFLO0lBQ3RCLElBQUlBLGlCQUFpQm1CLGNBQWNuQixNQUFNcUMsTUFBTSxLQUFLLEtBQUssT0FBT3JDLFVBQVUsWUFBWUEsTUFBTW1DLFdBQVcsT0FBTyxNQUFNO1FBQ2xILE9BQU87SUFDVDtJQUNBLElBQUk7UUFDRixPQUFPL0IsYUFBYXNCLE1BQU0sQ0FBQ25CLElBQUksQ0FBQyxLQUFLLEdBQUdQLE9BQU9zQjtJQUNqRCxFQUFFLE9BQU9PLE9BQU87UUFDZCxJQUFJQSxpQkFBaUJ6QixhQUFhMEIsV0FBVyxFQUFFO1lBQzdDLE1BQU0sSUFBSUMsTUFDUixDQUFDLGtDQUFrQyxFQUFFRSxPQUFPSixNQUFNN0IsS0FBSyxFQUFFLEVBQUUsQ0FBQztRQUVoRTtRQUNBLE1BQU02QjtJQUNSO0FBQ0Y7QUFPQTlCLG9CQUFvQixHQUFHeUI7QUFBY3pCLG9CQUFvQixHQUFHaUM7QUFBY2pDLG1CQUFtQixHQUFHbUM7QUFBYW5DLGlCQUFpQixHQUFHcUMsV0FDakksMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jaHVuay1ESFZLRkRIUS5qcz81ZDkwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG5cblxuXG52YXIgX2NodW5rUUVQVkhFUDdqcyA9IHJlcXVpcmUoJy4vY2h1bmstUUVQVkhFUDcuanMnKTtcblxuXG52YXIgX2NodW5rNlpESFNPVVZqcyA9IHJlcXVpcmUoJy4vY2h1bmstNlpESFNPVVYuanMnKTtcblxuLy8gc3JjL2NvZXJjZXJzLnRzXG5cblxuXG5cblxuXG5cblxuXG52YXIgX3N1cGVyc3RydWN0ID0gcmVxdWlyZSgnc3VwZXJzdHJ1Y3QnKTtcbnZhciBOdW1iZXJMaWtlU3RydWN0ID0gX3N1cGVyc3RydWN0LnVuaW9uLmNhbGwodm9pZCAwLCBbX3N1cGVyc3RydWN0Lm51bWJlci5jYWxsKHZvaWQgMCwgKSwgX3N1cGVyc3RydWN0LmJpZ2ludC5jYWxsKHZvaWQgMCwgKSwgX3N1cGVyc3RydWN0LnN0cmluZy5jYWxsKHZvaWQgMCwgKSwgX2NodW5rUUVQVkhFUDdqcy5TdHJpY3RIZXhTdHJ1Y3RdKTtcbnZhciBOdW1iZXJDb2VyY2VyID0gX3N1cGVyc3RydWN0LmNvZXJjZS5jYWxsKHZvaWQgMCwgX3N1cGVyc3RydWN0Lm51bWJlci5jYWxsKHZvaWQgMCwgKSwgTnVtYmVyTGlrZVN0cnVjdCwgTnVtYmVyKTtcbnZhciBCaWdJbnRDb2VyY2VyID0gX3N1cGVyc3RydWN0LmNvZXJjZS5jYWxsKHZvaWQgMCwgX3N1cGVyc3RydWN0LmJpZ2ludC5jYWxsKHZvaWQgMCwgKSwgTnVtYmVyTGlrZVN0cnVjdCwgQmlnSW50KTtcbnZhciBCeXRlc0xpa2VTdHJ1Y3QgPSBfc3VwZXJzdHJ1Y3QudW5pb24uY2FsbCh2b2lkIDAsIFtfY2h1bmtRRVBWSEVQN2pzLlN0cmljdEhleFN0cnVjdCwgX3N1cGVyc3RydWN0Lmluc3RhbmNlLmNhbGwodm9pZCAwLCBVaW50OEFycmF5KV0pO1xudmFyIEJ5dGVzQ29lcmNlciA9IF9zdXBlcnN0cnVjdC5jb2VyY2UuY2FsbCh2b2lkIDAsIFxuICBfc3VwZXJzdHJ1Y3QuaW5zdGFuY2UuY2FsbCh2b2lkIDAsIFVpbnQ4QXJyYXkpLFxuICBfc3VwZXJzdHJ1Y3QudW5pb24uY2FsbCh2b2lkIDAsIFtfY2h1bmtRRVBWSEVQN2pzLlN0cmljdEhleFN0cnVjdF0pLFxuICBfY2h1bmtRRVBWSEVQN2pzLmhleFRvQnl0ZXNcbik7XG52YXIgSGV4Q29lcmNlciA9IF9zdXBlcnN0cnVjdC5jb2VyY2UuY2FsbCh2b2lkIDAsIF9jaHVua1FFUFZIRVA3anMuU3RyaWN0SGV4U3RydWN0LCBfc3VwZXJzdHJ1Y3QuaW5zdGFuY2UuY2FsbCh2b2lkIDAsIFVpbnQ4QXJyYXkpLCBfY2h1bmtRRVBWSEVQN2pzLmJ5dGVzVG9IZXgpO1xuZnVuY3Rpb24gY3JlYXRlTnVtYmVyKHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gX3N1cGVyc3RydWN0LmNyZWF0ZS5jYWxsKHZvaWQgMCwgdmFsdWUsIE51bWJlckNvZXJjZXIpO1xuICAgIF9jaHVuazZaREhTT1VWanMuYXNzZXJ0LmNhbGwodm9pZCAwLCBcbiAgICAgIE51bWJlci5pc0Zpbml0ZShyZXN1bHQpLFxuICAgICAgYEV4cGVjdGVkIGEgbnVtYmVyLWxpa2UgdmFsdWUsIGdvdCBcIiR7dmFsdWV9XCIuYFxuICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBfc3VwZXJzdHJ1Y3QuU3RydWN0RXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBudW1iZXItbGlrZSB2YWx1ZSwgZ290IFwiJHt2YWx1ZX1cIi5gKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUJpZ0ludCh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiBfc3VwZXJzdHJ1Y3QuY3JlYXRlLmNhbGwodm9pZCAwLCB2YWx1ZSwgQmlnSW50Q29lcmNlcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgX3N1cGVyc3RydWN0LlN0cnVjdEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCBhIG51bWJlci1saWtlIHZhbHVlLCBnb3QgXCIke1N0cmluZyhlcnJvci52YWx1ZSl9XCIuYFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUJ5dGVzKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gXCIweFwiKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gX3N1cGVyc3RydWN0LmNyZWF0ZS5jYWxsKHZvaWQgMCwgdmFsdWUsIEJ5dGVzQ29lcmNlcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgX3N1cGVyc3RydWN0LlN0cnVjdEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFeHBlY3RlZCBhIGJ5dGVzLWxpa2UgdmFsdWUsIGdvdCBcIiR7U3RyaW5nKGVycm9yLnZhbHVlKX1cIi5gXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlSGV4KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdmFsdWUubGVuZ3RoID09PSAwIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBcIjB4XCIpIHtcbiAgICByZXR1cm4gXCIweFwiO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIF9zdXBlcnN0cnVjdC5jcmVhdGUuY2FsbCh2b2lkIDAsIHZhbHVlLCBIZXhDb2VyY2VyKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBfc3VwZXJzdHJ1Y3QuU3RydWN0RXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEV4cGVjdGVkIGEgYnl0ZXMtbGlrZSB2YWx1ZSwgZ290IFwiJHtTdHJpbmcoZXJyb3IudmFsdWUpfVwiLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cblxuXG5cblxuXG5leHBvcnRzLmNyZWF0ZU51bWJlciA9IGNyZWF0ZU51bWJlcjsgZXhwb3J0cy5jcmVhdGVCaWdJbnQgPSBjcmVhdGVCaWdJbnQ7IGV4cG9ydHMuY3JlYXRlQnl0ZXMgPSBjcmVhdGVCeXRlczsgZXhwb3J0cy5jcmVhdGVIZXggPSBjcmVhdGVIZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1ESFZLRkRIUS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfY2h1bmtRRVBWSEVQN2pzIiwicmVxdWlyZSIsIl9jaHVuazZaREhTT1VWanMiLCJfc3VwZXJzdHJ1Y3QiLCJOdW1iZXJMaWtlU3RydWN0IiwidW5pb24iLCJjYWxsIiwibnVtYmVyIiwiYmlnaW50Iiwic3RyaW5nIiwiU3RyaWN0SGV4U3RydWN0IiwiTnVtYmVyQ29lcmNlciIsImNvZXJjZSIsIk51bWJlciIsIkJpZ0ludENvZXJjZXIiLCJCaWdJbnQiLCJCeXRlc0xpa2VTdHJ1Y3QiLCJpbnN0YW5jZSIsIlVpbnQ4QXJyYXkiLCJCeXRlc0NvZXJjZXIiLCJoZXhUb0J5dGVzIiwiSGV4Q29lcmNlciIsImJ5dGVzVG9IZXgiLCJjcmVhdGVOdW1iZXIiLCJyZXN1bHQiLCJjcmVhdGUiLCJhc3NlcnQiLCJpc0Zpbml0ZSIsImVycm9yIiwiU3RydWN0RXJyb3IiLCJFcnJvciIsImNyZWF0ZUJpZ0ludCIsIlN0cmluZyIsImNyZWF0ZUJ5dGVzIiwidG9Mb3dlckNhc2UiLCJjcmVhdGVIZXgiLCJsZW5ndGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/chunk-DHVKFDHQ.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/chunk-E4C7EW4R.js":
/*!*************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/chunk-E4C7EW4R.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _chunk6NZW4WK4js = __webpack_require__(/*! ./chunk-6NZW4WK4.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-6NZW4WK4.js\");\n// src/checksum.ts\nvar _superstruct = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nvar ChecksumStruct = _superstruct.size.call(void 0, _chunk6NZW4WK4js.base64.call(void 0, _superstruct.string.call(void 0), {\n    paddingRequired: true\n}), 44, 44);\nexports.ChecksumStruct = ChecksumStruct; //# sourceMappingURL=chunk-E4C7EW4R.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2h1bmstRTRDN0VXNFIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFBQUEsOENBQTZDO0lBQUNHLE9BQU87QUFBSSxDQUFDLEVBQUM7QUFFeEUsSUFBSUMsbUJBQW1CQyxtQkFBT0EsQ0FBQztBQUUvQixrQkFBa0I7QUFDbEIsSUFBSUMsZUFBZUQsbUJBQU9BLENBQUM7QUFDM0IsSUFBSUUsaUJBQWlCRCxhQUFhRSxJQUFJLENBQUNDLElBQUksQ0FBQyxLQUFLLEdBQy9DTCxpQkFBaUJNLE1BQU0sQ0FBQ0QsSUFBSSxDQUFDLEtBQUssR0FBR0gsYUFBYUssTUFBTSxDQUFDRixJQUFJLENBQUMsS0FBSyxJQUFNO0lBQUVHLGlCQUFpQjtBQUFLLElBQ2pHLElBQ0E7QUFLRlYsc0JBQXNCLEdBQUdLLGdCQUN6QiwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NodW5rLUU0QzdFVzRSLmpzP2NhYWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcblxudmFyIF9jaHVuazZOWlc0V0s0anMgPSByZXF1aXJlKCcuL2NodW5rLTZOWlc0V0s0LmpzJyk7XG5cbi8vIHNyYy9jaGVja3N1bS50c1xudmFyIF9zdXBlcnN0cnVjdCA9IHJlcXVpcmUoJ3N1cGVyc3RydWN0Jyk7XG52YXIgQ2hlY2tzdW1TdHJ1Y3QgPSBfc3VwZXJzdHJ1Y3Quc2l6ZS5jYWxsKHZvaWQgMCwgXG4gIF9jaHVuazZOWlc0V0s0anMuYmFzZTY0LmNhbGwodm9pZCAwLCBfc3VwZXJzdHJ1Y3Quc3RyaW5nLmNhbGwodm9pZCAwLCApLCB7IHBhZGRpbmdSZXF1aXJlZDogdHJ1ZSB9KSxcbiAgNDQsXG4gIDQ0XG4pO1xuXG5cblxuZXhwb3J0cy5DaGVja3N1bVN0cnVjdCA9IENoZWNrc3VtU3RydWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstRTRDN0VXNFIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX2NodW5rNk5aVzRXSzRqcyIsInJlcXVpcmUiLCJfc3VwZXJzdHJ1Y3QiLCJDaGVja3N1bVN0cnVjdCIsInNpemUiLCJjYWxsIiwiYmFzZTY0Iiwic3RyaW5nIiwicGFkZGluZ1JlcXVpcmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/chunk-E4C7EW4R.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/chunk-EQMZL4XU.js":
/*!*************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/chunk-EQMZL4XU.js ***!
  \*************************************************************/
/***/ (() => {

eval(" //# sourceMappingURL=chunk-EQMZL4XU.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2h1bmstRVFNWkw0WFUuanMiLCJtYXBwaW5ncyI6IkFBQWEsMkNBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jaHVuay1FUU1aTDRYVS5qcz9iNDliIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiOy8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLUVRTVpMNFhVLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/chunk-EQMZL4XU.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/chunk-IZC266HS.js":
/*!*************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/chunk-IZC266HS.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _chunkQVEKZRZ2js = __webpack_require__(/*! ./chunk-QVEKZRZ2.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-QVEKZRZ2.js\");\n// src/errors.ts\nvar _ponycause = __webpack_require__(/*! pony-cause */ \"(ssr)/./node_modules/pony-cause/index.js\");\nfunction isError(error) {\n    return error instanceof Error || _chunkQVEKZRZ2js.isObject.call(void 0, error) && error.constructor.name === \"Error\";\n}\nfunction isErrorWithCode(error) {\n    return typeof error === \"object\" && error !== null && \"code\" in error;\n}\nfunction isErrorWithMessage(error) {\n    return typeof error === \"object\" && error !== null && \"message\" in error;\n}\nfunction isErrorWithStack(error) {\n    return typeof error === \"object\" && error !== null && \"stack\" in error;\n}\nfunction getErrorMessage(error) {\n    if (isErrorWithMessage(error) && typeof error.message === \"string\") {\n        return error.message;\n    }\n    if (_chunkQVEKZRZ2js.isNullOrUndefined.call(void 0, error)) {\n        return \"\";\n    }\n    return String(error);\n}\nfunction wrapError(originalError, message) {\n    if (isError(originalError)) {\n        let error;\n        if (Error.length === 2) {\n            error = new Error(message, {\n                cause: originalError\n            });\n        } else {\n            error = new (0, _ponycause.ErrorWithCause)(message, {\n                cause: originalError\n            });\n        }\n        if (isErrorWithCode(originalError)) {\n            error.code = originalError.code;\n        }\n        return error;\n    }\n    if (message.length > 0) {\n        return new Error(`${String(originalError)}: ${message}`);\n    }\n    return new Error(String(originalError));\n}\nexports.isErrorWithCode = isErrorWithCode;\nexports.isErrorWithMessage = isErrorWithMessage;\nexports.isErrorWithStack = isErrorWithStack;\nexports.getErrorMessage = getErrorMessage;\nexports.wrapError = wrapError; //# sourceMappingURL=chunk-IZC266HS.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2h1bmstSVpDMjY2SFMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFBQUEsOENBQTZDO0lBQUNHLE9BQU87QUFBSSxDQUFDLEVBQUM7QUFHeEUsSUFBSUMsbUJBQW1CQyxtQkFBT0EsQ0FBQztBQUUvQixnQkFBZ0I7QUFDaEIsSUFBSUMsYUFBYUQsbUJBQU9BLENBQUM7QUFDekIsU0FBU0UsUUFBUUMsS0FBSztJQUNwQixPQUFPQSxpQkFBaUJDLFNBQVNMLGlCQUFpQk0sUUFBUSxDQUFDQyxJQUFJLENBQUMsS0FBSyxHQUFHSCxVQUFVQSxNQUFNSSxXQUFXLENBQUNDLElBQUksS0FBSztBQUMvRztBQUNBLFNBQVNDLGdCQUFnQk4sS0FBSztJQUM1QixPQUFPLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxRQUFRLFVBQVVBO0FBQ2xFO0FBQ0EsU0FBU08sbUJBQW1CUCxLQUFLO0lBQy9CLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEsYUFBYUE7QUFDckU7QUFDQSxTQUFTUSxpQkFBaUJSLEtBQUs7SUFDN0IsT0FBTyxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsUUFBUSxXQUFXQTtBQUNuRTtBQUNBLFNBQVNTLGdCQUFnQlQsS0FBSztJQUM1QixJQUFJTyxtQkFBbUJQLFVBQVUsT0FBT0EsTUFBTVUsT0FBTyxLQUFLLFVBQVU7UUFDbEUsT0FBT1YsTUFBTVUsT0FBTztJQUN0QjtJQUNBLElBQUlkLGlCQUFpQmUsaUJBQWlCLENBQUNSLElBQUksQ0FBQyxLQUFLLEdBQUdILFFBQVE7UUFDMUQsT0FBTztJQUNUO0lBQ0EsT0FBT1ksT0FBT1o7QUFDaEI7QUFDQSxTQUFTYSxVQUFVQyxhQUFhLEVBQUVKLE9BQU87SUFDdkMsSUFBSVgsUUFBUWUsZ0JBQWdCO1FBQzFCLElBQUlkO1FBQ0osSUFBSUMsTUFBTWMsTUFBTSxLQUFLLEdBQUc7WUFDdEJmLFFBQVEsSUFBSUMsTUFBTVMsU0FBUztnQkFBRU0sT0FBT0Y7WUFBYztRQUNwRCxPQUFPO1lBQ0xkLFFBQVEsSUFBSyxJQUFHRixXQUFXbUIsY0FBYyxFQUFFUCxTQUFTO2dCQUFFTSxPQUFPRjtZQUFjO1FBQzdFO1FBQ0EsSUFBSVIsZ0JBQWdCUSxnQkFBZ0I7WUFDbENkLE1BQU1rQixJQUFJLEdBQUdKLGNBQWNJLElBQUk7UUFDakM7UUFDQSxPQUFPbEI7SUFDVDtJQUNBLElBQUlVLFFBQVFLLE1BQU0sR0FBRyxHQUFHO1FBQ3RCLE9BQU8sSUFBSWQsTUFBTSxDQUFDLEVBQUVXLE9BQU9FLGVBQWUsRUFBRSxFQUFFSixRQUFRLENBQUM7SUFDekQ7SUFDQSxPQUFPLElBQUlULE1BQU1XLE9BQU9FO0FBQzFCO0FBUUFwQix1QkFBdUIsR0FBR1k7QUFBaUJaLDBCQUEwQixHQUFHYTtBQUFvQmIsd0JBQXdCLEdBQUdjO0FBQWtCZCx1QkFBdUIsR0FBR2U7QUFBaUJmLGlCQUFpQixHQUFHbUIsV0FDeE0sMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jaHVuay1JWkMyNjZIUy5qcz8wMmNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG5cblxudmFyIF9jaHVua1FWRUtaUloyanMgPSByZXF1aXJlKCcuL2NodW5rLVFWRUtaUloyLmpzJyk7XG5cbi8vIHNyYy9lcnJvcnMudHNcbnZhciBfcG9ueWNhdXNlID0gcmVxdWlyZSgncG9ueS1jYXVzZScpO1xuZnVuY3Rpb24gaXNFcnJvcihlcnJvcikge1xuICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciB8fCBfY2h1bmtRVkVLWlJaMmpzLmlzT2JqZWN0LmNhbGwodm9pZCAwLCBlcnJvcikgJiYgZXJyb3IuY29uc3RydWN0b3IubmFtZSA9PT0gXCJFcnJvclwiO1xufVxuZnVuY3Rpb24gaXNFcnJvcldpdGhDb2RlKGVycm9yKSB7XG4gIHJldHVybiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgZXJyb3IgIT09IG51bGwgJiYgXCJjb2RlXCIgaW4gZXJyb3I7XG59XG5mdW5jdGlvbiBpc0Vycm9yV2l0aE1lc3NhZ2UoZXJyb3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBlcnJvciAhPT0gbnVsbCAmJiBcIm1lc3NhZ2VcIiBpbiBlcnJvcjtcbn1cbmZ1bmN0aW9uIGlzRXJyb3JXaXRoU3RhY2soZXJyb3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBlcnJvciAhPT0gbnVsbCAmJiBcInN0YWNrXCIgaW4gZXJyb3I7XG59XG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpIHtcbiAgaWYgKGlzRXJyb3JXaXRoTWVzc2FnZShlcnJvcikgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgfVxuICBpZiAoX2NodW5rUVZFS1pSWjJqcy5pc051bGxPclVuZGVmaW5lZC5jYWxsKHZvaWQgMCwgZXJyb3IpKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyhlcnJvcik7XG59XG5mdW5jdGlvbiB3cmFwRXJyb3Iob3JpZ2luYWxFcnJvciwgbWVzc2FnZSkge1xuICBpZiAoaXNFcnJvcihvcmlnaW5hbEVycm9yKSkge1xuICAgIGxldCBlcnJvcjtcbiAgICBpZiAoRXJyb3IubGVuZ3RoID09PSAyKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlLCB7IGNhdXNlOiBvcmlnaW5hbEVycm9yIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvciA9IG5ldyAoMCwgX3BvbnljYXVzZS5FcnJvcldpdGhDYXVzZSkobWVzc2FnZSwgeyBjYXVzZTogb3JpZ2luYWxFcnJvciB9KTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3JXaXRoQ29kZShvcmlnaW5hbEVycm9yKSkge1xuICAgICAgZXJyb3IuY29kZSA9IG9yaWdpbmFsRXJyb3IuY29kZTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGlmIChtZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKGAke1N0cmluZyhvcmlnaW5hbEVycm9yKX06ICR7bWVzc2FnZX1gKTtcbiAgfVxuICByZXR1cm4gbmV3IEVycm9yKFN0cmluZyhvcmlnaW5hbEVycm9yKSk7XG59XG5cblxuXG5cblxuXG5cbmV4cG9ydHMuaXNFcnJvcldpdGhDb2RlID0gaXNFcnJvcldpdGhDb2RlOyBleHBvcnRzLmlzRXJyb3JXaXRoTWVzc2FnZSA9IGlzRXJyb3JXaXRoTWVzc2FnZTsgZXhwb3J0cy5pc0Vycm9yV2l0aFN0YWNrID0gaXNFcnJvcldpdGhTdGFjazsgZXhwb3J0cy5nZXRFcnJvck1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2U7IGV4cG9ydHMud3JhcEVycm9yID0gd3JhcEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstSVpDMjY2SFMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX2NodW5rUVZFS1pSWjJqcyIsInJlcXVpcmUiLCJfcG9ueWNhdXNlIiwiaXNFcnJvciIsImVycm9yIiwiRXJyb3IiLCJpc09iamVjdCIsImNhbGwiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJpc0Vycm9yV2l0aENvZGUiLCJpc0Vycm9yV2l0aE1lc3NhZ2UiLCJpc0Vycm9yV2l0aFN0YWNrIiwiZ2V0RXJyb3JNZXNzYWdlIiwibWVzc2FnZSIsImlzTnVsbE9yVW5kZWZpbmVkIiwiU3RyaW5nIiwid3JhcEVycm9yIiwib3JpZ2luYWxFcnJvciIsImxlbmd0aCIsImNhdXNlIiwiRXJyb3JXaXRoQ2F1c2UiLCJjb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/chunk-IZC266HS.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/chunk-LC2CRSWD.js":
/*!*************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/chunk-LC2CRSWD.js ***!
  \*************************************************************/
/***/ (() => {

eval(" //# sourceMappingURL=chunk-LC2CRSWD.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2h1bmstTEMyQ1JTV0QuanMiLCJtYXBwaW5ncyI6IkFBQWEsMkNBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jaHVuay1MQzJDUlNXRC5qcz81YTMxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiOy8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLUxDMkNSU1dELmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/chunk-LC2CRSWD.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/chunk-OLLG4H35.js":
/*!*************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/chunk-OLLG4H35.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js\");\nvar _chunkQVEKZRZ2js = __webpack_require__(/*! ./chunk-QVEKZRZ2.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-QVEKZRZ2.js\");\n// src/json.ts\nvar _superstruct = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nvar object = (schema)=>// The type is slightly different from a regular object struct, because we\n    // want to make properties with `undefined` in their type optional, but not\n    // `undefined` itself. This means that we need a type cast.\n    _superstruct.object.call(void 0, schema);\nfunction hasOptional({ path, branch }) {\n    const field = path[path.length - 1];\n    return _chunkQVEKZRZ2js.hasProperty.call(void 0, branch[branch.length - 2], field);\n}\nfunction exactOptional(struct) {\n    return new (0, _superstruct.Struct)({\n        ...struct,\n        type: `optional ${struct.type}`,\n        validator: (value, context)=>!hasOptional(context) || struct.validator(value, context),\n        refiner: (value, context)=>!hasOptional(context) || struct.refiner(value, context)\n    });\n}\nvar finiteNumber = ()=>_superstruct.define.call(void 0, \"finite number\", (value)=>{\n        return _superstruct.is.call(void 0, value, _superstruct.number.call(void 0)) && Number.isFinite(value);\n    });\nvar UnsafeJsonStruct = _superstruct.union.call(void 0, [\n    _superstruct.literal.call(void 0, null),\n    _superstruct.boolean.call(void 0),\n    finiteNumber(),\n    _superstruct.string.call(void 0),\n    _superstruct.array.call(void 0, _superstruct.lazy.call(void 0, ()=>UnsafeJsonStruct)),\n    _superstruct.record.call(void 0, _superstruct.string.call(void 0), _superstruct.lazy.call(void 0, ()=>UnsafeJsonStruct))\n]);\nvar JsonStruct = _superstruct.coerce.call(void 0, UnsafeJsonStruct, _superstruct.any.call(void 0), (value)=>{\n    _chunk6ZDHSOUVjs.assertStruct.call(void 0, value, UnsafeJsonStruct);\n    return JSON.parse(JSON.stringify(value, (propKey, propValue)=>{\n        if (propKey === \"__proto__\" || propKey === \"constructor\") {\n            return void 0;\n        }\n        return propValue;\n    }));\n});\nfunction isValidJson(value) {\n    try {\n        getSafeJson(value);\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction getSafeJson(value) {\n    return _superstruct.create.call(void 0, value, JsonStruct);\n}\nfunction getJsonSize(value) {\n    _chunk6ZDHSOUVjs.assertStruct.call(void 0, value, JsonStruct, \"Invalid JSON value\");\n    const json = JSON.stringify(value);\n    return new TextEncoder().encode(json).byteLength;\n}\nvar jsonrpc2 = \"2.0\";\nvar JsonRpcVersionStruct = _superstruct.literal.call(void 0, jsonrpc2);\nvar JsonRpcIdStruct = _superstruct.nullable.call(void 0, _superstruct.union.call(void 0, [\n    _superstruct.number.call(void 0),\n    _superstruct.string.call(void 0)\n]));\nvar JsonRpcErrorStruct = object({\n    code: _superstruct.integer.call(void 0),\n    message: _superstruct.string.call(void 0),\n    data: exactOptional(JsonStruct),\n    stack: exactOptional(_superstruct.string.call(void 0))\n});\nvar JsonRpcParamsStruct = _superstruct.union.call(void 0, [\n    _superstruct.record.call(void 0, _superstruct.string.call(void 0), JsonStruct),\n    _superstruct.array.call(void 0, JsonStruct)\n]);\nvar JsonRpcRequestStruct = object({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    method: _superstruct.string.call(void 0),\n    params: exactOptional(JsonRpcParamsStruct)\n});\nvar JsonRpcNotificationStruct = object({\n    jsonrpc: JsonRpcVersionStruct,\n    method: _superstruct.string.call(void 0),\n    params: exactOptional(JsonRpcParamsStruct)\n});\nfunction isJsonRpcNotification(value) {\n    return _superstruct.is.call(void 0, value, JsonRpcNotificationStruct);\n}\nfunction assertIsJsonRpcNotification(value, ErrorWrapper) {\n    _chunk6ZDHSOUVjs.assertStruct.call(void 0, value, JsonRpcNotificationStruct, \"Invalid JSON-RPC notification\", ErrorWrapper);\n}\nfunction isJsonRpcRequest(value) {\n    return _superstruct.is.call(void 0, value, JsonRpcRequestStruct);\n}\nfunction assertIsJsonRpcRequest(value, ErrorWrapper) {\n    _chunk6ZDHSOUVjs.assertStruct.call(void 0, value, JsonRpcRequestStruct, \"Invalid JSON-RPC request\", ErrorWrapper);\n}\nvar PendingJsonRpcResponseStruct = _superstruct.object.call(void 0, {\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    result: _superstruct.optional.call(void 0, _superstruct.unknown.call(void 0)),\n    error: _superstruct.optional.call(void 0, JsonRpcErrorStruct)\n});\nvar JsonRpcSuccessStruct = object({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    result: JsonStruct\n});\nvar JsonRpcFailureStruct = object({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    error: JsonRpcErrorStruct\n});\nvar JsonRpcResponseStruct = _superstruct.union.call(void 0, [\n    JsonRpcSuccessStruct,\n    JsonRpcFailureStruct\n]);\nfunction isPendingJsonRpcResponse(response) {\n    return _superstruct.is.call(void 0, response, PendingJsonRpcResponseStruct);\n}\nfunction assertIsPendingJsonRpcResponse(response, ErrorWrapper) {\n    _chunk6ZDHSOUVjs.assertStruct.call(void 0, response, PendingJsonRpcResponseStruct, \"Invalid pending JSON-RPC response\", ErrorWrapper);\n}\nfunction isJsonRpcResponse(response) {\n    return _superstruct.is.call(void 0, response, JsonRpcResponseStruct);\n}\nfunction assertIsJsonRpcResponse(value, ErrorWrapper) {\n    _chunk6ZDHSOUVjs.assertStruct.call(void 0, value, JsonRpcResponseStruct, \"Invalid JSON-RPC response\", ErrorWrapper);\n}\nfunction isJsonRpcSuccess(value) {\n    return _superstruct.is.call(void 0, value, JsonRpcSuccessStruct);\n}\nfunction assertIsJsonRpcSuccess(value, ErrorWrapper) {\n    _chunk6ZDHSOUVjs.assertStruct.call(void 0, value, JsonRpcSuccessStruct, \"Invalid JSON-RPC success response\", ErrorWrapper);\n}\nfunction isJsonRpcFailure(value) {\n    return _superstruct.is.call(void 0, value, JsonRpcFailureStruct);\n}\nfunction assertIsJsonRpcFailure(value, ErrorWrapper) {\n    _chunk6ZDHSOUVjs.assertStruct.call(void 0, value, JsonRpcFailureStruct, \"Invalid JSON-RPC failure response\", ErrorWrapper);\n}\nfunction isJsonRpcError(value) {\n    return _superstruct.is.call(void 0, value, JsonRpcErrorStruct);\n}\nfunction assertIsJsonRpcError(value, ErrorWrapper) {\n    _chunk6ZDHSOUVjs.assertStruct.call(void 0, value, JsonRpcErrorStruct, \"Invalid JSON-RPC error\", ErrorWrapper);\n}\nfunction getJsonRpcIdValidator(options) {\n    const { permitEmptyString, permitFractions, permitNull } = {\n        permitEmptyString: true,\n        permitFractions: false,\n        permitNull: true,\n        ...options\n    };\n    const isValidJsonRpcId = (id)=>{\n        return Boolean(typeof id === \"number\" && (permitFractions || Number.isInteger(id)) || typeof id === \"string\" && (permitEmptyString || id.length > 0) || permitNull && id === null);\n    };\n    return isValidJsonRpcId;\n}\nexports.object = object;\nexports.exactOptional = exactOptional;\nexports.UnsafeJsonStruct = UnsafeJsonStruct;\nexports.JsonStruct = JsonStruct;\nexports.isValidJson = isValidJson;\nexports.getSafeJson = getSafeJson;\nexports.getJsonSize = getJsonSize;\nexports.jsonrpc2 = jsonrpc2;\nexports.JsonRpcVersionStruct = JsonRpcVersionStruct;\nexports.JsonRpcIdStruct = JsonRpcIdStruct;\nexports.JsonRpcErrorStruct = JsonRpcErrorStruct;\nexports.JsonRpcParamsStruct = JsonRpcParamsStruct;\nexports.JsonRpcRequestStruct = JsonRpcRequestStruct;\nexports.JsonRpcNotificationStruct = JsonRpcNotificationStruct;\nexports.isJsonRpcNotification = isJsonRpcNotification;\nexports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;\nexports.isJsonRpcRequest = isJsonRpcRequest;\nexports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;\nexports.PendingJsonRpcResponseStruct = PendingJsonRpcResponseStruct;\nexports.JsonRpcSuccessStruct = JsonRpcSuccessStruct;\nexports.JsonRpcFailureStruct = JsonRpcFailureStruct;\nexports.JsonRpcResponseStruct = JsonRpcResponseStruct;\nexports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;\nexports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;\nexports.isJsonRpcResponse = isJsonRpcResponse;\nexports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;\nexports.isJsonRpcSuccess = isJsonRpcSuccess;\nexports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;\nexports.isJsonRpcFailure = isJsonRpcFailure;\nexports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;\nexports.isJsonRpcError = isJsonRpcError;\nexports.assertIsJsonRpcError = assertIsJsonRpcError;\nexports.getJsonRpcIdValidator = getJsonRpcIdValidator; //# sourceMappingURL=chunk-OLLG4H35.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2h1bmstT0xMRzRIMzUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFBQUEsOENBQTZDO0lBQUNHLE9BQU87QUFBSSxDQUFDLEVBQUM7QUFFeEUsSUFBSUMsbUJBQW1CQyxtQkFBT0EsQ0FBQztBQUcvQixJQUFJQyxtQkFBbUJELG1CQUFPQSxDQUFDO0FBRS9CLGNBQWM7QUFxQmQsSUFBSUUsZUFBZUYsbUJBQU9BLENBQUM7QUFDM0IsSUFBSUcsU0FBUyxDQUFDQyxTQUNaLDBFQUEwRTtJQUMxRSwyRUFBMkU7SUFDM0UsMkRBQTJEO0lBQzNERixhQUFhQyxNQUFNLENBQUNFLElBQUksQ0FBQyxLQUFLLEdBQUdEO0FBRW5DLFNBQVNFLFlBQVksRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUU7SUFDbkMsTUFBTUMsUUFBUUYsSUFBSSxDQUFDQSxLQUFLRyxNQUFNLEdBQUcsRUFBRTtJQUNuQyxPQUFPVCxpQkFBaUJVLFdBQVcsQ0FBQ04sSUFBSSxDQUFDLEtBQUssR0FBR0csTUFBTSxDQUFDQSxPQUFPRSxNQUFNLEdBQUcsRUFBRSxFQUFFRDtBQUM5RTtBQUNBLFNBQVNHLGNBQWNDLE1BQU07SUFDM0IsT0FBTyxJQUFLLElBQUdYLGFBQWFZLE1BQU0sRUFBRTtRQUNsQyxHQUFHRCxNQUFNO1FBQ1RFLE1BQU0sQ0FBQyxTQUFTLEVBQUVGLE9BQU9FLElBQUksQ0FBQyxDQUFDO1FBQy9CQyxXQUFXLENBQUNsQixPQUFPbUIsVUFBWSxDQUFDWCxZQUFZVyxZQUFZSixPQUFPRyxTQUFTLENBQUNsQixPQUFPbUI7UUFDaEZDLFNBQVMsQ0FBQ3BCLE9BQU9tQixVQUFZLENBQUNYLFlBQVlXLFlBQVlKLE9BQU9LLE9BQU8sQ0FBQ3BCLE9BQU9tQjtJQUM5RTtBQUNGO0FBQ0EsSUFBSUUsZUFBZSxJQUFNakIsYUFBYWtCLE1BQU0sQ0FBQ2YsSUFBSSxDQUFDLEtBQUssR0FBRyxpQkFBaUIsQ0FBQ1A7UUFD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Z0IsR0FBR3NEO0FBQVV0RCw0QkFBNEIsR0FBR3VEO0FBQXNCdkQsdUJBQXVCLEdBQUd3RDtBQUFpQnhELDBCQUEwQixHQUFHMEQ7QUFBb0IxRCwyQkFBMkIsR0FBR2dFO0FBQXFCaEUsNEJBQTRCLEdBQUdpRTtBQUFzQmpFLGlDQUFpQyxHQUFHc0U7QUFBMkJ0RSw2QkFBNkIsR0FBR3VFO0FBQXVCdkUsbUNBQW1DLEdBQUd3RTtBQUE2QnhFLHdCQUF3QixHQUFHMEU7QUFBa0IxRSw4QkFBOEIsR0FBRzJFO0FBQXdCM0Usb0NBQW9DLEdBQUc0RTtBQUE4QjVFLDRCQUE0QixHQUFHaUY7QUFBc0JqRiw0QkFBNEIsR0FBR2tGO0FBQXNCbEYsNkJBQTZCLEdBQUdtRjtBQUF1Qm5GLGdDQUFnQyxHQUFHb0Y7QUFBMEJwRixzQ0FBc0MsR0FBR3NGO0FBQWdDdEYseUJBQXlCLEdBQUd1RjtBQUFtQnZGLCtCQUErQixHQUFHd0Y7QUFBeUJ4Rix3QkFBd0IsR0FBR3lGO0FBQWtCekYsOEJBQThCLEdBQUcwRjtBQUF3QjFGLHdCQUF3QixHQUFHMkY7QUFBa0IzRiw4QkFBOEIsR0FBRzRGO0FBQXdCNUYsc0JBQXNCLEdBQUc2RjtBQUFnQjdGLDRCQUE0QixHQUFHOEY7QUFBc0I5Riw2QkFBNkIsR0FBRytGLHVCQUM1a0QsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jaHVuay1PTExHNEgzNS5qcz81ZTU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG5cbnZhciBfY2h1bms2WkRIU09VVmpzID0gcmVxdWlyZSgnLi9jaHVuay02WkRIU09VVi5qcycpO1xuXG5cbnZhciBfY2h1bmtRVkVLWlJaMmpzID0gcmVxdWlyZSgnLi9jaHVuay1RVkVLWlJaMi5qcycpO1xuXG4vLyBzcmMvanNvbi50c1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBfc3VwZXJzdHJ1Y3QgPSByZXF1aXJlKCdzdXBlcnN0cnVjdCcpO1xudmFyIG9iamVjdCA9IChzY2hlbWEpID0+IChcbiAgLy8gVGhlIHR5cGUgaXMgc2xpZ2h0bHkgZGlmZmVyZW50IGZyb20gYSByZWd1bGFyIG9iamVjdCBzdHJ1Y3QsIGJlY2F1c2Ugd2VcbiAgLy8gd2FudCB0byBtYWtlIHByb3BlcnRpZXMgd2l0aCBgdW5kZWZpbmVkYCBpbiB0aGVpciB0eXBlIG9wdGlvbmFsLCBidXQgbm90XG4gIC8vIGB1bmRlZmluZWRgIGl0c2VsZi4gVGhpcyBtZWFucyB0aGF0IHdlIG5lZWQgYSB0eXBlIGNhc3QuXG4gIF9zdXBlcnN0cnVjdC5vYmplY3QuY2FsbCh2b2lkIDAsIHNjaGVtYSlcbik7XG5mdW5jdGlvbiBoYXNPcHRpb25hbCh7IHBhdGgsIGJyYW5jaCB9KSB7XG4gIGNvbnN0IGZpZWxkID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gX2NodW5rUVZFS1pSWjJqcy5oYXNQcm9wZXJ0eS5jYWxsKHZvaWQgMCwgYnJhbmNoW2JyYW5jaC5sZW5ndGggLSAyXSwgZmllbGQpO1xufVxuZnVuY3Rpb24gZXhhY3RPcHRpb25hbChzdHJ1Y3QpIHtcbiAgcmV0dXJuIG5ldyAoMCwgX3N1cGVyc3RydWN0LlN0cnVjdCkoe1xuICAgIC4uLnN0cnVjdCxcbiAgICB0eXBlOiBgb3B0aW9uYWwgJHtzdHJ1Y3QudHlwZX1gLFxuICAgIHZhbGlkYXRvcjogKHZhbHVlLCBjb250ZXh0KSA9PiAhaGFzT3B0aW9uYWwoY29udGV4dCkgfHwgc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY29udGV4dCksXG4gICAgcmVmaW5lcjogKHZhbHVlLCBjb250ZXh0KSA9PiAhaGFzT3B0aW9uYWwoY29udGV4dCkgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGNvbnRleHQpXG4gIH0pO1xufVxudmFyIGZpbml0ZU51bWJlciA9ICgpID0+IF9zdXBlcnN0cnVjdC5kZWZpbmUuY2FsbCh2b2lkIDAsIFwiZmluaXRlIG51bWJlclwiLCAodmFsdWUpID0+IHtcbiAgcmV0dXJuIF9zdXBlcnN0cnVjdC5pcy5jYWxsKHZvaWQgMCwgdmFsdWUsIF9zdXBlcnN0cnVjdC5udW1iZXIuY2FsbCh2b2lkIDAsICkpICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSk7XG59KTtcbnZhciBVbnNhZmVKc29uU3RydWN0ID0gX3N1cGVyc3RydWN0LnVuaW9uLmNhbGwodm9pZCAwLCBbXG4gIF9zdXBlcnN0cnVjdC5saXRlcmFsLmNhbGwodm9pZCAwLCBudWxsKSxcbiAgX3N1cGVyc3RydWN0LmJvb2xlYW4uY2FsbCh2b2lkIDAsICksXG4gIGZpbml0ZU51bWJlcigpLFxuICBfc3VwZXJzdHJ1Y3Quc3RyaW5nLmNhbGwodm9pZCAwLCApLFxuICBfc3VwZXJzdHJ1Y3QuYXJyYXkuY2FsbCh2b2lkIDAsIF9zdXBlcnN0cnVjdC5sYXp5LmNhbGwodm9pZCAwLCAoKSA9PiBVbnNhZmVKc29uU3RydWN0KSksXG4gIF9zdXBlcnN0cnVjdC5yZWNvcmQuY2FsbCh2b2lkIDAsIFxuICAgIF9zdXBlcnN0cnVjdC5zdHJpbmcuY2FsbCh2b2lkIDAsICksXG4gICAgX3N1cGVyc3RydWN0LmxhenkuY2FsbCh2b2lkIDAsICgpID0+IFVuc2FmZUpzb25TdHJ1Y3QpXG4gIClcbl0pO1xudmFyIEpzb25TdHJ1Y3QgPSBfc3VwZXJzdHJ1Y3QuY29lcmNlLmNhbGwodm9pZCAwLCBVbnNhZmVKc29uU3RydWN0LCBfc3VwZXJzdHJ1Y3QuYW55LmNhbGwodm9pZCAwLCApLCAodmFsdWUpID0+IHtcbiAgX2NodW5rNlpESFNPVVZqcy5hc3NlcnRTdHJ1Y3QuY2FsbCh2b2lkIDAsIHZhbHVlLCBVbnNhZmVKc29uU3RydWN0KTtcbiAgcmV0dXJuIEpTT04ucGFyc2UoXG4gICAgSlNPTi5zdHJpbmdpZnkodmFsdWUsIChwcm9wS2V5LCBwcm9wVmFsdWUpID0+IHtcbiAgICAgIGlmIChwcm9wS2V5ID09PSBcIl9fcHJvdG9fX1wiIHx8IHByb3BLZXkgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BWYWx1ZTtcbiAgICB9KVxuICApO1xufSk7XG5mdW5jdGlvbiBpc1ZhbGlkSnNvbih2YWx1ZSkge1xuICB0cnkge1xuICAgIGdldFNhZmVKc29uKHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U2FmZUpzb24odmFsdWUpIHtcbiAgcmV0dXJuIF9zdXBlcnN0cnVjdC5jcmVhdGUuY2FsbCh2b2lkIDAsIHZhbHVlLCBKc29uU3RydWN0KTtcbn1cbmZ1bmN0aW9uIGdldEpzb25TaXplKHZhbHVlKSB7XG4gIF9jaHVuazZaREhTT1VWanMuYXNzZXJ0U3RydWN0LmNhbGwodm9pZCAwLCB2YWx1ZSwgSnNvblN0cnVjdCwgXCJJbnZhbGlkIEpTT04gdmFsdWVcIik7XG4gIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoanNvbikuYnl0ZUxlbmd0aDtcbn1cbnZhciBqc29ucnBjMiA9IFwiMi4wXCI7XG52YXIgSnNvblJwY1ZlcnNpb25TdHJ1Y3QgPSBfc3VwZXJzdHJ1Y3QubGl0ZXJhbC5jYWxsKHZvaWQgMCwganNvbnJwYzIpO1xudmFyIEpzb25ScGNJZFN0cnVjdCA9IF9zdXBlcnN0cnVjdC5udWxsYWJsZS5jYWxsKHZvaWQgMCwgX3N1cGVyc3RydWN0LnVuaW9uLmNhbGwodm9pZCAwLCBbX3N1cGVyc3RydWN0Lm51bWJlci5jYWxsKHZvaWQgMCwgKSwgX3N1cGVyc3RydWN0LnN0cmluZy5jYWxsKHZvaWQgMCwgKV0pKTtcbnZhciBKc29uUnBjRXJyb3JTdHJ1Y3QgPSBvYmplY3Qoe1xuICBjb2RlOiBfc3VwZXJzdHJ1Y3QuaW50ZWdlci5jYWxsKHZvaWQgMCwgKSxcbiAgbWVzc2FnZTogX3N1cGVyc3RydWN0LnN0cmluZy5jYWxsKHZvaWQgMCwgKSxcbiAgZGF0YTogZXhhY3RPcHRpb25hbChKc29uU3RydWN0KSxcbiAgc3RhY2s6IGV4YWN0T3B0aW9uYWwoX3N1cGVyc3RydWN0LnN0cmluZy5jYWxsKHZvaWQgMCwgKSlcbn0pO1xudmFyIEpzb25ScGNQYXJhbXNTdHJ1Y3QgPSBfc3VwZXJzdHJ1Y3QudW5pb24uY2FsbCh2b2lkIDAsIFtfc3VwZXJzdHJ1Y3QucmVjb3JkLmNhbGwodm9pZCAwLCBfc3VwZXJzdHJ1Y3Quc3RyaW5nLmNhbGwodm9pZCAwLCApLCBKc29uU3RydWN0KSwgX3N1cGVyc3RydWN0LmFycmF5LmNhbGwodm9pZCAwLCBKc29uU3RydWN0KV0pO1xudmFyIEpzb25ScGNSZXF1ZXN0U3RydWN0ID0gb2JqZWN0KHtcbiAgaWQ6IEpzb25ScGNJZFN0cnVjdCxcbiAganNvbnJwYzogSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gIG1ldGhvZDogX3N1cGVyc3RydWN0LnN0cmluZy5jYWxsKHZvaWQgMCwgKSxcbiAgcGFyYW1zOiBleGFjdE9wdGlvbmFsKEpzb25ScGNQYXJhbXNTdHJ1Y3QpXG59KTtcbnZhciBKc29uUnBjTm90aWZpY2F0aW9uU3RydWN0ID0gb2JqZWN0KHtcbiAganNvbnJwYzogSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gIG1ldGhvZDogX3N1cGVyc3RydWN0LnN0cmluZy5jYWxsKHZvaWQgMCwgKSxcbiAgcGFyYW1zOiBleGFjdE9wdGlvbmFsKEpzb25ScGNQYXJhbXNTdHJ1Y3QpXG59KTtcbmZ1bmN0aW9uIGlzSnNvblJwY05vdGlmaWNhdGlvbih2YWx1ZSkge1xuICByZXR1cm4gX3N1cGVyc3RydWN0LmlzLmNhbGwodm9pZCAwLCB2YWx1ZSwgSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCk7XG59XG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb24odmFsdWUsIEVycm9yV3JhcHBlcikge1xuICBfY2h1bms2WkRIU09VVmpzLmFzc2VydFN0cnVjdC5jYWxsKHZvaWQgMCwgXG4gICAgdmFsdWUsXG4gICAgSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCxcbiAgICBcIkludmFsaWQgSlNPTi1SUEMgbm90aWZpY2F0aW9uXCIsXG4gICAgRXJyb3JXcmFwcGVyXG4gICk7XG59XG5mdW5jdGlvbiBpc0pzb25ScGNSZXF1ZXN0KHZhbHVlKSB7XG4gIHJldHVybiBfc3VwZXJzdHJ1Y3QuaXMuY2FsbCh2b2lkIDAsIHZhbHVlLCBKc29uUnBjUmVxdWVzdFN0cnVjdCk7XG59XG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNSZXF1ZXN0KHZhbHVlLCBFcnJvcldyYXBwZXIpIHtcbiAgX2NodW5rNlpESFNPVVZqcy5hc3NlcnRTdHJ1Y3QuY2FsbCh2b2lkIDAsIFxuICAgIHZhbHVlLFxuICAgIEpzb25ScGNSZXF1ZXN0U3RydWN0LFxuICAgIFwiSW52YWxpZCBKU09OLVJQQyByZXF1ZXN0XCIsXG4gICAgRXJyb3JXcmFwcGVyXG4gICk7XG59XG52YXIgUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCA9IF9zdXBlcnN0cnVjdC5vYmplY3QuY2FsbCh2b2lkIDAsIHtcbiAgaWQ6IEpzb25ScGNJZFN0cnVjdCxcbiAganNvbnJwYzogSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gIHJlc3VsdDogX3N1cGVyc3RydWN0Lm9wdGlvbmFsLmNhbGwodm9pZCAwLCBfc3VwZXJzdHJ1Y3QudW5rbm93bi5jYWxsKHZvaWQgMCwgKSksXG4gIGVycm9yOiBfc3VwZXJzdHJ1Y3Qub3B0aW9uYWwuY2FsbCh2b2lkIDAsIEpzb25ScGNFcnJvclN0cnVjdClcbn0pO1xudmFyIEpzb25ScGNTdWNjZXNzU3RydWN0ID0gb2JqZWN0KHtcbiAgaWQ6IEpzb25ScGNJZFN0cnVjdCxcbiAganNvbnJwYzogSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gIHJlc3VsdDogSnNvblN0cnVjdFxufSk7XG52YXIgSnNvblJwY0ZhaWx1cmVTdHJ1Y3QgPSBvYmplY3Qoe1xuICBpZDogSnNvblJwY0lkU3RydWN0LFxuICBqc29ucnBjOiBKc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgZXJyb3I6IEpzb25ScGNFcnJvclN0cnVjdFxufSk7XG52YXIgSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gX3N1cGVyc3RydWN0LnVuaW9uLmNhbGwodm9pZCAwLCBbXG4gIEpzb25ScGNTdWNjZXNzU3RydWN0LFxuICBKc29uUnBjRmFpbHVyZVN0cnVjdFxuXSk7XG5mdW5jdGlvbiBpc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgcmV0dXJuIF9zdXBlcnN0cnVjdC5pcy5jYWxsKHZvaWQgMCwgcmVzcG9uc2UsIFBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlLCBFcnJvcldyYXBwZXIpIHtcbiAgX2NodW5rNlpESFNPVVZqcy5hc3NlcnRTdHJ1Y3QuY2FsbCh2b2lkIDAsIFxuICAgIHJlc3BvbnNlLFxuICAgIFBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QsXG4gICAgXCJJbnZhbGlkIHBlbmRpbmcgSlNPTi1SUEMgcmVzcG9uc2VcIixcbiAgICBFcnJvcldyYXBwZXJcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIHJldHVybiBfc3VwZXJzdHJ1Y3QuaXMuY2FsbCh2b2lkIDAsIHJlc3BvbnNlLCBKc29uUnBjUmVzcG9uc2VTdHJ1Y3QpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UodmFsdWUsIEVycm9yV3JhcHBlcikge1xuICBfY2h1bms2WkRIU09VVmpzLmFzc2VydFN0cnVjdC5jYWxsKHZvaWQgMCwgXG4gICAgdmFsdWUsXG4gICAgSnNvblJwY1Jlc3BvbnNlU3RydWN0LFxuICAgIFwiSW52YWxpZCBKU09OLVJQQyByZXNwb25zZVwiLFxuICAgIEVycm9yV3JhcHBlclxuICApO1xufVxuZnVuY3Rpb24gaXNKc29uUnBjU3VjY2Vzcyh2YWx1ZSkge1xuICByZXR1cm4gX3N1cGVyc3RydWN0LmlzLmNhbGwodm9pZCAwLCB2YWx1ZSwgSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjU3VjY2Vzcyh2YWx1ZSwgRXJyb3JXcmFwcGVyKSB7XG4gIF9jaHVuazZaREhTT1VWanMuYXNzZXJ0U3RydWN0LmNhbGwodm9pZCAwLCBcbiAgICB2YWx1ZSxcbiAgICBKc29uUnBjU3VjY2Vzc1N0cnVjdCxcbiAgICBcIkludmFsaWQgSlNPTi1SUEMgc3VjY2VzcyByZXNwb25zZVwiLFxuICAgIEVycm9yV3JhcHBlclxuICApO1xufVxuZnVuY3Rpb24gaXNKc29uUnBjRmFpbHVyZSh2YWx1ZSkge1xuICByZXR1cm4gX3N1cGVyc3RydWN0LmlzLmNhbGwodm9pZCAwLCB2YWx1ZSwgSnNvblJwY0ZhaWx1cmVTdHJ1Y3QpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjRmFpbHVyZSh2YWx1ZSwgRXJyb3JXcmFwcGVyKSB7XG4gIF9jaHVuazZaREhTT1VWanMuYXNzZXJ0U3RydWN0LmNhbGwodm9pZCAwLCBcbiAgICB2YWx1ZSxcbiAgICBKc29uUnBjRmFpbHVyZVN0cnVjdCxcbiAgICBcIkludmFsaWQgSlNPTi1SUEMgZmFpbHVyZSByZXNwb25zZVwiLFxuICAgIEVycm9yV3JhcHBlclxuICApO1xufVxuZnVuY3Rpb24gaXNKc29uUnBjRXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuIF9zdXBlcnN0cnVjdC5pcy5jYWxsKHZvaWQgMCwgdmFsdWUsIEpzb25ScGNFcnJvclN0cnVjdCk7XG59XG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNFcnJvcih2YWx1ZSwgRXJyb3JXcmFwcGVyKSB7XG4gIF9jaHVuazZaREhTT1VWanMuYXNzZXJ0U3RydWN0LmNhbGwodm9pZCAwLCBcbiAgICB2YWx1ZSxcbiAgICBKc29uUnBjRXJyb3JTdHJ1Y3QsXG4gICAgXCJJbnZhbGlkIEpTT04tUlBDIGVycm9yXCIsXG4gICAgRXJyb3JXcmFwcGVyXG4gICk7XG59XG5mdW5jdGlvbiBnZXRKc29uUnBjSWRWYWxpZGF0b3Iob3B0aW9ucykge1xuICBjb25zdCB7IHBlcm1pdEVtcHR5U3RyaW5nLCBwZXJtaXRGcmFjdGlvbnMsIHBlcm1pdE51bGwgfSA9IHtcbiAgICBwZXJtaXRFbXB0eVN0cmluZzogdHJ1ZSxcbiAgICBwZXJtaXRGcmFjdGlvbnM6IGZhbHNlLFxuICAgIHBlcm1pdE51bGw6IHRydWUsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBpc1ZhbGlkSnNvblJwY0lkID0gKGlkKSA9PiB7XG4gICAgcmV0dXJuIEJvb2xlYW4oXG4gICAgICB0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIgJiYgKHBlcm1pdEZyYWN0aW9ucyB8fCBOdW1iZXIuaXNJbnRlZ2VyKGlkKSkgfHwgdHlwZW9mIGlkID09PSBcInN0cmluZ1wiICYmIChwZXJtaXRFbXB0eVN0cmluZyB8fCBpZC5sZW5ndGggPiAwKSB8fCBwZXJtaXROdWxsICYmIGlkID09PSBudWxsXG4gICAgKTtcbiAgfTtcbiAgcmV0dXJuIGlzVmFsaWRKc29uUnBjSWQ7XG59XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuZXhwb3J0cy5vYmplY3QgPSBvYmplY3Q7IGV4cG9ydHMuZXhhY3RPcHRpb25hbCA9IGV4YWN0T3B0aW9uYWw7IGV4cG9ydHMuVW5zYWZlSnNvblN0cnVjdCA9IFVuc2FmZUpzb25TdHJ1Y3Q7IGV4cG9ydHMuSnNvblN0cnVjdCA9IEpzb25TdHJ1Y3Q7IGV4cG9ydHMuaXNWYWxpZEpzb24gPSBpc1ZhbGlkSnNvbjsgZXhwb3J0cy5nZXRTYWZlSnNvbiA9IGdldFNhZmVKc29uOyBleHBvcnRzLmdldEpzb25TaXplID0gZ2V0SnNvblNpemU7IGV4cG9ydHMuanNvbnJwYzIgPSBqc29ucnBjMjsgZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCA9IEpzb25ScGNWZXJzaW9uU3RydWN0OyBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCA9IEpzb25ScGNJZFN0cnVjdDsgZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QgPSBKc29uUnBjRXJyb3JTdHJ1Y3Q7IGV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCA9IEpzb25ScGNQYXJhbXNTdHJ1Y3Q7IGV4cG9ydHMuSnNvblJwY1JlcXVlc3RTdHJ1Y3QgPSBKc29uUnBjUmVxdWVzdFN0cnVjdDsgZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0ID0gSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdDsgZXhwb3J0cy5pc0pzb25ScGNOb3RpZmljYXRpb24gPSBpc0pzb25ScGNOb3RpZmljYXRpb247IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uID0gYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uOyBleHBvcnRzLmlzSnNvblJwY1JlcXVlc3QgPSBpc0pzb25ScGNSZXF1ZXN0OyBleHBvcnRzLmFzc2VydElzSnNvblJwY1JlcXVlc3QgPSBhc3NlcnRJc0pzb25ScGNSZXF1ZXN0OyBleHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSBQZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0OyBleHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0ID0gSnNvblJwY1N1Y2Nlc3NTdHJ1Y3Q7IGV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QgPSBKc29uUnBjRmFpbHVyZVN0cnVjdDsgZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSBKc29uUnBjUmVzcG9uc2VTdHJ1Y3Q7IGV4cG9ydHMuaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlID0gaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlOyBleHBvcnRzLmFzc2VydElzUGVuZGluZ0pzb25ScGNSZXNwb25zZSA9IGFzc2VydElzUGVuZGluZ0pzb25ScGNSZXNwb25zZTsgZXhwb3J0cy5pc0pzb25ScGNSZXNwb25zZSA9IGlzSnNvblJwY1Jlc3BvbnNlOyBleHBvcnRzLmFzc2VydElzSnNvblJwY1Jlc3BvbnNlID0gYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2U7IGV4cG9ydHMuaXNKc29uUnBjU3VjY2VzcyA9IGlzSnNvblJwY1N1Y2Nlc3M7IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjU3VjY2VzcyA9IGFzc2VydElzSnNvblJwY1N1Y2Nlc3M7IGV4cG9ydHMuaXNKc29uUnBjRmFpbHVyZSA9IGlzSnNvblJwY0ZhaWx1cmU7IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjRmFpbHVyZSA9IGFzc2VydElzSnNvblJwY0ZhaWx1cmU7IGV4cG9ydHMuaXNKc29uUnBjRXJyb3IgPSBpc0pzb25ScGNFcnJvcjsgZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNFcnJvciA9IGFzc2VydElzSnNvblJwY0Vycm9yOyBleHBvcnRzLmdldEpzb25ScGNJZFZhbGlkYXRvciA9IGdldEpzb25ScGNJZFZhbGlkYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLU9MTEc0SDM1LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIl9jaHVuazZaREhTT1VWanMiLCJyZXF1aXJlIiwiX2NodW5rUVZFS1pSWjJqcyIsIl9zdXBlcnN0cnVjdCIsIm9iamVjdCIsInNjaGVtYSIsImNhbGwiLCJoYXNPcHRpb25hbCIsInBhdGgiLCJicmFuY2giLCJmaWVsZCIsImxlbmd0aCIsImhhc1Byb3BlcnR5IiwiZXhhY3RPcHRpb25hbCIsInN0cnVjdCIsIlN0cnVjdCIsInR5cGUiLCJ2YWxpZGF0b3IiLCJjb250ZXh0IiwicmVmaW5lciIsImZpbml0ZU51bWJlciIsImRlZmluZSIsImlzIiwibnVtYmVyIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJVbnNhZmVKc29uU3RydWN0IiwidW5pb24iLCJsaXRlcmFsIiwiYm9vbGVhbiIsInN0cmluZyIsImFycmF5IiwibGF6eSIsInJlY29yZCIsIkpzb25TdHJ1Y3QiLCJjb2VyY2UiLCJhbnkiLCJhc3NlcnRTdHJ1Y3QiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJwcm9wS2V5IiwicHJvcFZhbHVlIiwiaXNWYWxpZEpzb24iLCJnZXRTYWZlSnNvbiIsImUiLCJjcmVhdGUiLCJnZXRKc29uU2l6ZSIsImpzb24iLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImJ5dGVMZW5ndGgiLCJqc29ucnBjMiIsIkpzb25ScGNWZXJzaW9uU3RydWN0IiwiSnNvblJwY0lkU3RydWN0IiwibnVsbGFibGUiLCJKc29uUnBjRXJyb3JTdHJ1Y3QiLCJjb2RlIiwiaW50ZWdlciIsIm1lc3NhZ2UiLCJkYXRhIiwic3RhY2siLCJKc29uUnBjUGFyYW1zU3RydWN0IiwiSnNvblJwY1JlcXVlc3RTdHJ1Y3QiLCJpZCIsImpzb25ycGMiLCJtZXRob2QiLCJwYXJhbXMiLCJKc29uUnBjTm90aWZpY2F0aW9uU3RydWN0IiwiaXNKc29uUnBjTm90aWZpY2F0aW9uIiwiYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uIiwiRXJyb3JXcmFwcGVyIiwiaXNKc29uUnBjUmVxdWVzdCIsImFzc2VydElzSnNvblJwY1JlcXVlc3QiLCJQZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0IiwicmVzdWx0Iiwib3B0aW9uYWwiLCJ1bmtub3duIiwiZXJyb3IiLCJKc29uUnBjU3VjY2Vzc1N0cnVjdCIsIkpzb25ScGNGYWlsdXJlU3RydWN0IiwiSnNvblJwY1Jlc3BvbnNlU3RydWN0IiwiaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlIiwicmVzcG9uc2UiLCJhc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UiLCJpc0pzb25ScGNSZXNwb25zZSIsImFzc2VydElzSnNvblJwY1Jlc3BvbnNlIiwiaXNKc29uUnBjU3VjY2VzcyIsImFzc2VydElzSnNvblJwY1N1Y2Nlc3MiLCJpc0pzb25ScGNGYWlsdXJlIiwiYXNzZXJ0SXNKc29uUnBjRmFpbHVyZSIsImlzSnNvblJwY0Vycm9yIiwiYXNzZXJ0SXNKc29uUnBjRXJyb3IiLCJnZXRKc29uUnBjSWRWYWxpZGF0b3IiLCJvcHRpb25zIiwicGVybWl0RW1wdHlTdHJpbmciLCJwZXJtaXRGcmFjdGlvbnMiLCJwZXJtaXROdWxsIiwiaXNWYWxpZEpzb25ScGNJZCIsIkJvb2xlYW4iLCJpc0ludGVnZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/chunk-OLLG4H35.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/chunk-QEPVHEP7.js":
/*!*************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/chunk-QEPVHEP7.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _optionalChain(ops) {\n    let lastAccessLHS = undefined;\n    let value = ops[0];\n    let i = 1;\n    while(i < ops.length){\n        const op = ops[i];\n        const fn = ops[i + 1];\n        i += 2;\n        if ((op === \"optionalAccess\" || op === \"optionalCall\") && value == null) {\n            return undefined;\n        }\n        if (op === \"access\" || op === \"optionalAccess\") {\n            lastAccessLHS = value;\n            value = fn(value);\n        } else if (op === \"call\" || op === \"optionalCall\") {\n            value = fn((...args)=>value.call(lastAccessLHS, ...args));\n            lastAccessLHS = undefined;\n        }\n    }\n    return value;\n}\nvar _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js\");\n// src/hex.ts\nvar _sha3 = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/@noble/hashes/sha3.js\");\nvar _superstruct = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\n// src/bytes.ts\nvar _base = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/index.js\");\nvar HEX_MINIMUM_NUMBER_CHARACTER = 48;\nvar HEX_MAXIMUM_NUMBER_CHARACTER = 58;\nvar HEX_CHARACTER_OFFSET = 87;\nfunction getPrecomputedHexValuesBuilder() {\n    const lookupTable = [];\n    return ()=>{\n        if (lookupTable.length === 0) {\n            for(let i = 0; i < 256; i++){\n                lookupTable.push(i.toString(16).padStart(2, \"0\"));\n            }\n        }\n        return lookupTable;\n    };\n}\nvar getPrecomputedHexValues = getPrecomputedHexValuesBuilder();\nfunction isBytes(value) {\n    return value instanceof Uint8Array;\n}\nfunction assertIsBytes(value) {\n    _chunk6ZDHSOUVjs.assert.call(void 0, isBytes(value), \"Value must be a Uint8Array.\");\n}\nfunction bytesToHex(bytes) {\n    assertIsBytes(bytes);\n    if (bytes.length === 0) {\n        return \"0x\";\n    }\n    const lookupTable = getPrecomputedHexValues();\n    const hexadecimal = new Array(bytes.length);\n    for(let i = 0; i < bytes.length; i++){\n        hexadecimal[i] = lookupTable[bytes[i]];\n    }\n    return add0x(hexadecimal.join(\"\"));\n}\nfunction bytesToBigInt(bytes) {\n    assertIsBytes(bytes);\n    const hexadecimal = bytesToHex(bytes);\n    return BigInt(hexadecimal);\n}\nfunction bytesToSignedBigInt(bytes) {\n    assertIsBytes(bytes);\n    let value = BigInt(0);\n    for (const byte of bytes){\n        value = (value << BigInt(8)) + BigInt(byte);\n    }\n    return BigInt.asIntN(bytes.length * 8, value);\n}\nfunction bytesToNumber(bytes) {\n    assertIsBytes(bytes);\n    const bigint = bytesToBigInt(bytes);\n    _chunk6ZDHSOUVjs.assert.call(void 0, bigint <= BigInt(Number.MAX_SAFE_INTEGER), \"Number is not a safe integer. Use `bytesToBigInt` instead.\");\n    return Number(bigint);\n}\nfunction bytesToString(bytes) {\n    assertIsBytes(bytes);\n    return new TextDecoder().decode(bytes);\n}\nfunction bytesToBase64(bytes) {\n    assertIsBytes(bytes);\n    return _base.base64.encode(bytes);\n}\nfunction hexToBytes(value) {\n    if (_optionalChain([\n        value,\n        \"optionalAccess\",\n        (_)=>_.toLowerCase,\n        \"optionalCall\",\n        (_2)=>_2()\n    ]) === \"0x\") {\n        return new Uint8Array();\n    }\n    assertIsHexString(value);\n    const strippedValue = remove0x(value).toLowerCase();\n    const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;\n    const bytes = new Uint8Array(normalizedValue.length / 2);\n    for(let i = 0; i < bytes.length; i++){\n        const c1 = normalizedValue.charCodeAt(i * 2);\n        const c2 = normalizedValue.charCodeAt(i * 2 + 1);\n        const n1 = c1 - (c1 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);\n        const n2 = c2 - (c2 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);\n        bytes[i] = n1 * 16 + n2;\n    }\n    return bytes;\n}\nfunction bigIntToBytes(value) {\n    _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === \"bigint\", \"Value must be a bigint.\");\n    _chunk6ZDHSOUVjs.assert.call(void 0, value >= BigInt(0), \"Value must be a non-negative bigint.\");\n    const hexadecimal = value.toString(16);\n    return hexToBytes(hexadecimal);\n}\nfunction bigIntFits(value, bytes) {\n    _chunk6ZDHSOUVjs.assert.call(void 0, bytes > 0);\n    const mask = value >> BigInt(31);\n    return !((~value & mask) + (value & ~mask) >> BigInt(bytes * 8 + ~0));\n}\nfunction signedBigIntToBytes(value, byteLength) {\n    _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === \"bigint\", \"Value must be a bigint.\");\n    _chunk6ZDHSOUVjs.assert.call(void 0, typeof byteLength === \"number\", \"Byte length must be a number.\");\n    _chunk6ZDHSOUVjs.assert.call(void 0, byteLength > 0, \"Byte length must be greater than 0.\");\n    _chunk6ZDHSOUVjs.assert.call(void 0, bigIntFits(value, byteLength), \"Byte length is too small to represent the given value.\");\n    let numberValue = value;\n    const bytes = new Uint8Array(byteLength);\n    for(let i = 0; i < bytes.length; i++){\n        bytes[i] = Number(BigInt.asUintN(8, numberValue));\n        numberValue >>= BigInt(8);\n    }\n    return bytes.reverse();\n}\nfunction numberToBytes(value) {\n    _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === \"number\", \"Value must be a number.\");\n    _chunk6ZDHSOUVjs.assert.call(void 0, value >= 0, \"Value must be a non-negative number.\");\n    _chunk6ZDHSOUVjs.assert.call(void 0, Number.isSafeInteger(value), \"Value is not a safe integer. Use `bigIntToBytes` instead.\");\n    const hexadecimal = value.toString(16);\n    return hexToBytes(hexadecimal);\n}\nfunction stringToBytes(value) {\n    _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === \"string\", \"Value must be a string.\");\n    return new TextEncoder().encode(value);\n}\nfunction base64ToBytes(value) {\n    _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === \"string\", \"Value must be a string.\");\n    return _base.base64.decode(value);\n}\nfunction valueToBytes(value) {\n    if (typeof value === \"bigint\") {\n        return bigIntToBytes(value);\n    }\n    if (typeof value === \"number\") {\n        return numberToBytes(value);\n    }\n    if (typeof value === \"string\") {\n        if (value.startsWith(\"0x\")) {\n            return hexToBytes(value);\n        }\n        return stringToBytes(value);\n    }\n    if (isBytes(value)) {\n        return value;\n    }\n    throw new TypeError(`Unsupported value type: \"${typeof value}\".`);\n}\nfunction concatBytes(values) {\n    const normalizedValues = new Array(values.length);\n    let byteLength = 0;\n    for(let i = 0; i < values.length; i++){\n        const value = valueToBytes(values[i]);\n        normalizedValues[i] = value;\n        byteLength += value.length;\n    }\n    const bytes = new Uint8Array(byteLength);\n    for(let i = 0, offset = 0; i < normalizedValues.length; i++){\n        bytes.set(normalizedValues[i], offset);\n        offset += normalizedValues[i].length;\n    }\n    return bytes;\n}\nfunction createDataView(bytes) {\n    if (typeof Buffer !== \"undefined\" && bytes instanceof Buffer) {\n        const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);\n        return new DataView(buffer);\n    }\n    return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n}\n// src/hex.ts\nvar HexStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0), /^(?:0x)?[0-9a-f]+$/iu);\nvar StrictHexStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0), /^0x[0-9a-f]+$/iu);\nvar HexAddressStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0), /^0x[0-9a-f]{40}$/u);\nvar HexChecksumAddressStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0), /^0x[0-9a-fA-F]{40}$/u);\nfunction isHexString(value) {\n    return _superstruct.is.call(void 0, value, HexStruct);\n}\nfunction isStrictHexString(value) {\n    return _superstruct.is.call(void 0, value, StrictHexStruct);\n}\nfunction assertIsHexString(value) {\n    _chunk6ZDHSOUVjs.assert.call(void 0, isHexString(value), \"Value must be a hexadecimal string.\");\n}\nfunction assertIsStrictHexString(value) {\n    _chunk6ZDHSOUVjs.assert.call(void 0, isStrictHexString(value), 'Value must be a hexadecimal string, starting with \"0x\".');\n}\nfunction isValidHexAddress(possibleAddress) {\n    return _superstruct.is.call(void 0, possibleAddress, HexAddressStruct) || isValidChecksumAddress(possibleAddress);\n}\nfunction getChecksumAddress(address) {\n    _chunk6ZDHSOUVjs.assert.call(void 0, _superstruct.is.call(void 0, address, HexChecksumAddressStruct), \"Invalid hex address.\");\n    const unPrefixed = remove0x(address.toLowerCase());\n    const unPrefixedHash = remove0x(bytesToHex(_sha3.keccak_256.call(void 0, unPrefixed)));\n    return `0x${unPrefixed.split(\"\").map((character, nibbleIndex)=>{\n        const hashCharacter = unPrefixedHash[nibbleIndex];\n        _chunk6ZDHSOUVjs.assert.call(void 0, _superstruct.is.call(void 0, hashCharacter, _superstruct.string.call(void 0)), \"Hash shorter than address.\");\n        return parseInt(hashCharacter, 16) > 7 ? character.toUpperCase() : character;\n    }).join(\"\")}`;\n}\nfunction isValidChecksumAddress(possibleChecksum) {\n    if (!_superstruct.is.call(void 0, possibleChecksum, HexChecksumAddressStruct)) {\n        return false;\n    }\n    return getChecksumAddress(possibleChecksum) === possibleChecksum;\n}\nfunction add0x(hexadecimal) {\n    if (hexadecimal.startsWith(\"0x\")) {\n        return hexadecimal;\n    }\n    if (hexadecimal.startsWith(\"0X\")) {\n        return `0x${hexadecimal.substring(2)}`;\n    }\n    return `0x${hexadecimal}`;\n}\nfunction remove0x(hexadecimal) {\n    if (hexadecimal.startsWith(\"0x\") || hexadecimal.startsWith(\"0X\")) {\n        return hexadecimal.substring(2);\n    }\n    return hexadecimal;\n}\nexports.HexStruct = HexStruct;\nexports.StrictHexStruct = StrictHexStruct;\nexports.HexAddressStruct = HexAddressStruct;\nexports.HexChecksumAddressStruct = HexChecksumAddressStruct;\nexports.isHexString = isHexString;\nexports.isStrictHexString = isStrictHexString;\nexports.assertIsHexString = assertIsHexString;\nexports.assertIsStrictHexString = assertIsStrictHexString;\nexports.isValidHexAddress = isValidHexAddress;\nexports.getChecksumAddress = getChecksumAddress;\nexports.isValidChecksumAddress = isValidChecksumAddress;\nexports.add0x = add0x;\nexports.remove0x = remove0x;\nexports.isBytes = isBytes;\nexports.assertIsBytes = assertIsBytes;\nexports.bytesToHex = bytesToHex;\nexports.bytesToBigInt = bytesToBigInt;\nexports.bytesToSignedBigInt = bytesToSignedBigInt;\nexports.bytesToNumber = bytesToNumber;\nexports.bytesToString = bytesToString;\nexports.bytesToBase64 = bytesToBase64;\nexports.hexToBytes = hexToBytes;\nexports.bigIntToBytes = bigIntToBytes;\nexports.signedBigIntToBytes = signedBigIntToBytes;\nexports.numberToBytes = numberToBytes;\nexports.stringToBytes = stringToBytes;\nexports.base64ToBytes = base64ToBytes;\nexports.valueToBytes = valueToBytes;\nexports.concatBytes = concatBytes;\nexports.createDataView = createDataView; //# sourceMappingURL=chunk-QEPVHEP7.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2h1bmstUUVQVkhFUDcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFBQUEsOENBQTZDO0lBQUNHLE9BQU87QUFBSSxDQUFDLEVBQUM7QUFBRSxTQUFTQyxlQUFlQyxHQUFHO0lBQUksSUFBSUMsZ0JBQWdCQztJQUFXLElBQUlKLFFBQVFFLEdBQUcsQ0FBQyxFQUFFO0lBQUUsSUFBSUcsSUFBSTtJQUFHLE1BQU9BLElBQUlILElBQUlJLE1BQU0sQ0FBRTtRQUFFLE1BQU1DLEtBQUtMLEdBQUcsQ0FBQ0csRUFBRTtRQUFFLE1BQU1HLEtBQUtOLEdBQUcsQ0FBQ0csSUFBSSxFQUFFO1FBQUVBLEtBQUs7UUFBRyxJQUFJLENBQUNFLE9BQU8sb0JBQW9CQSxPQUFPLGNBQWEsS0FBTVAsU0FBUyxNQUFNO1lBQUUsT0FBT0k7UUFBVztRQUFFLElBQUlHLE9BQU8sWUFBWUEsT0FBTyxrQkFBa0I7WUFBRUosZ0JBQWdCSDtZQUFPQSxRQUFRUSxHQUFHUjtRQUFRLE9BQU8sSUFBSU8sT0FBTyxVQUFVQSxPQUFPLGdCQUFnQjtZQUFFUCxRQUFRUSxHQUFHLENBQUMsR0FBR0MsT0FBU1QsTUFBTVUsSUFBSSxDQUFDUCxrQkFBa0JNO1lBQVFOLGdCQUFnQkM7UUFBVztJQUFFO0lBQUUsT0FBT0o7QUFBTztBQUU1a0IsSUFBSVcsbUJBQW1CQyxtQkFBT0EsQ0FBQztBQUUvQixhQUFhO0FBQ2IsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUUsZUFBZUYsbUJBQU9BLENBQUM7QUFFM0IsZUFBZTtBQUNmLElBQUlHLFFBQVFILG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlJLCtCQUErQjtBQUNuQyxJQUFJQywrQkFBK0I7QUFDbkMsSUFBSUMsdUJBQXVCO0FBQzNCLFNBQVNDO0lBQ1AsTUFBTUMsY0FBYyxFQUFFO0lBQ3RCLE9BQU87UUFDTCxJQUFJQSxZQUFZZCxNQUFNLEtBQUssR0FBRztZQUM1QixJ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QSxPQUFPLENBQUMsRUFBRSxFQUFFckYsWUFBWSxDQUFDO0FBQzNCO0FBQ0EsU0FBU3lCLFNBQVN6QixXQUFXO0lBQzNCLElBQUlBLFlBQVk4QyxVQUFVLENBQUMsU0FBUzlDLFlBQVk4QyxVQUFVLENBQUMsT0FBTztRQUNoRSxPQUFPOUMsWUFBWXFGLFNBQVMsQ0FBQztJQUMvQjtJQUNBLE9BQU9yRjtBQUNUO0FBaUNBaEMsaUJBQWlCLEdBQUcyRjtBQUFXM0YsdUJBQXVCLEdBQUc4RjtBQUFpQjlGLHdCQUF3QixHQUFHK0Y7QUFBa0IvRixnQ0FBZ0MsR0FBR2dHO0FBQTBCaEcsbUJBQW1CLEdBQUdpRztBQUFhakcseUJBQXlCLEdBQUdtRztBQUFtQm5HLHlCQUF5QixHQUFHdUQ7QUFBbUJ2RCwrQkFBK0IsR0FBR29HO0FBQXlCcEcseUJBQXlCLEdBQUdxRztBQUFtQnJHLDBCQUEwQixHQUFHd0c7QUFBb0J4Ryw4QkFBOEIsR0FBR3VHO0FBQXdCdkcsYUFBYSxHQUFHa0M7QUFBT2xDLGdCQUFnQixHQUFHeUQ7QUFBVXpELGVBQWUsR0FBRzBCO0FBQVMxQixxQkFBcUIsR0FBRzRCO0FBQWU1QixrQkFBa0IsR0FBRzhCO0FBQVk5QixxQkFBcUIsR0FBR29DO0FBQWVwQywyQkFBMkIsR0FBR3NDO0FBQXFCdEMscUJBQXFCLEdBQUd5QztBQUFlekMscUJBQXFCLEdBQUc2QztBQUFlN0MscUJBQXFCLEdBQUdnRDtBQUFlaEQsa0JBQWtCLEdBQUdtRDtBQUFZbkQscUJBQXFCLEdBQUdnRTtBQUFlaEUsMkJBQTJCLEdBQUdtRTtBQUFxQm5FLHFCQUFxQixHQUFHd0U7QUFBZXhFLHFCQUFxQixHQUFHMEU7QUFBZTFFLHFCQUFxQixHQUFHNEU7QUFBZTVFLG9CQUFvQixHQUFHNkU7QUFBYzdFLG1CQUFtQixHQUFHZ0Y7QUFBYWhGLHNCQUFzQixHQUFHcUYsZ0JBQ2hzQywwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NodW5rLVFFUFZIRVA3LmpzP2I5NGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTsgZnVuY3Rpb24gX29wdGlvbmFsQ2hhaW4ob3BzKSB7IGxldCBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyBsZXQgdmFsdWUgPSBvcHNbMF07IGxldCBpID0gMTsgd2hpbGUgKGkgPCBvcHMubGVuZ3RoKSB7IGNvbnN0IG9wID0gb3BzW2ldOyBjb25zdCBmbiA9IG9wc1tpICsgMV07IGkgKz0gMjsgaWYgKChvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpICYmIHZhbHVlID09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBpZiAob3AgPT09ICdhY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnKSB7IGxhc3RBY2Nlc3NMSFMgPSB2YWx1ZTsgdmFsdWUgPSBmbih2YWx1ZSk7IH0gZWxzZSBpZiAob3AgPT09ICdjYWxsJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpIHsgdmFsdWUgPSBmbigoLi4uYXJncykgPT4gdmFsdWUuY2FsbChsYXN0QWNjZXNzTEhTLCAuLi5hcmdzKSk7IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IH0gfSByZXR1cm4gdmFsdWU7IH1cblxudmFyIF9jaHVuazZaREhTT1VWanMgPSByZXF1aXJlKCcuL2NodW5rLTZaREhTT1VWLmpzJyk7XG5cbi8vIHNyYy9oZXgudHNcbnZhciBfc2hhMyA9IHJlcXVpcmUoJ0Bub2JsZS9oYXNoZXMvc2hhMycpO1xudmFyIF9zdXBlcnN0cnVjdCA9IHJlcXVpcmUoJ3N1cGVyc3RydWN0Jyk7XG5cbi8vIHNyYy9ieXRlcy50c1xudmFyIF9iYXNlID0gcmVxdWlyZSgnQHNjdXJlL2Jhc2UnKTtcbnZhciBIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSID0gNDg7XG52YXIgSEVYX01BWElNVU1fTlVNQkVSX0NIQVJBQ1RFUiA9IDU4O1xudmFyIEhFWF9DSEFSQUNURVJfT0ZGU0VUID0gODc7XG5mdW5jdGlvbiBnZXRQcmVjb21wdXRlZEhleFZhbHVlc0J1aWxkZXIoKSB7XG4gIGNvbnN0IGxvb2t1cFRhYmxlID0gW107XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKGxvb2t1cFRhYmxlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBsb29rdXBUYWJsZS5wdXNoKGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb29rdXBUYWJsZTtcbiAgfTtcbn1cbnZhciBnZXRQcmVjb21wdXRlZEhleFZhbHVlcyA9IGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcigpO1xuZnVuY3Rpb24gaXNCeXRlcyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNCeXRlcyh2YWx1ZSkge1xuICBfY2h1bms2WkRIU09VVmpzLmFzc2VydC5jYWxsKHZvaWQgMCwgaXNCeXRlcyh2YWx1ZSksIFwiVmFsdWUgbXVzdCBiZSBhIFVpbnQ4QXJyYXkuXCIpO1xufVxuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcIjB4XCI7XG4gIH1cbiAgY29uc3QgbG9va3VwVGFibGUgPSBnZXRQcmVjb21wdXRlZEhleFZhbHVlcygpO1xuICBjb25zdCBoZXhhZGVjaW1hbCA9IG5ldyBBcnJheShieXRlcy5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaGV4YWRlY2ltYWxbaV0gPSBsb29rdXBUYWJsZVtieXRlc1tpXV07XG4gIH1cbiAgcmV0dXJuIGFkZDB4KGhleGFkZWNpbWFsLmpvaW4oXCJcIikpO1xufVxuZnVuY3Rpb24gYnl0ZXNUb0JpZ0ludChieXRlcykge1xuICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgY29uc3QgaGV4YWRlY2ltYWwgPSBieXRlc1RvSGV4KGJ5dGVzKTtcbiAgcmV0dXJuIEJpZ0ludChoZXhhZGVjaW1hbCk7XG59XG5mdW5jdGlvbiBieXRlc1RvU2lnbmVkQmlnSW50KGJ5dGVzKSB7XG4gIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICBsZXQgdmFsdWUgPSBCaWdJbnQoMCk7XG4gIGZvciAoY29uc3QgYnl0ZSBvZiBieXRlcykge1xuICAgIHZhbHVlID0gKHZhbHVlIDw8IEJpZ0ludCg4KSkgKyBCaWdJbnQoYnl0ZSk7XG4gIH1cbiAgcmV0dXJuIEJpZ0ludC5hc0ludE4oYnl0ZXMubGVuZ3RoICogOCwgdmFsdWUpO1xufVxuZnVuY3Rpb24gYnl0ZXNUb051bWJlcihieXRlcykge1xuICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgY29uc3QgYmlnaW50ID0gYnl0ZXNUb0JpZ0ludChieXRlcyk7XG4gIF9jaHVuazZaREhTT1VWanMuYXNzZXJ0LmNhbGwodm9pZCAwLCBcbiAgICBiaWdpbnQgPD0gQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSxcbiAgICBcIk51bWJlciBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgYnl0ZXNUb0JpZ0ludGAgaW5zdGVhZC5cIlxuICApO1xuICByZXR1cm4gTnVtYmVyKGJpZ2ludCk7XG59XG5mdW5jdGlvbiBieXRlc1RvU3RyaW5nKGJ5dGVzKSB7XG4gIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzVG9CYXNlNjQoYnl0ZXMpIHtcbiAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gIHJldHVybiBfYmFzZS5iYXNlNjQuZW5jb2RlKGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGhleFRvQnl0ZXModmFsdWUpIHtcbiAgaWYgKF9vcHRpb25hbENoYWluKFt2YWx1ZSwgJ29wdGlvbmFsQWNjZXNzJywgXyA9PiBfLnRvTG93ZXJDYXNlLCAnb3B0aW9uYWxDYWxsJywgXzIgPT4gXzIoKV0pID09PSBcIjB4XCIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgfVxuICBhc3NlcnRJc0hleFN0cmluZyh2YWx1ZSk7XG4gIGNvbnN0IHN0cmlwcGVkVmFsdWUgPSByZW1vdmUweCh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgY29uc3Qgbm9ybWFsaXplZFZhbHVlID0gc3RyaXBwZWRWYWx1ZS5sZW5ndGggJSAyID09PSAwID8gc3RyaXBwZWRWYWx1ZSA6IGAwJHtzdHJpcHBlZFZhbHVlfWA7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobm9ybWFsaXplZFZhbHVlLmxlbmd0aCAvIDIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYzEgPSBub3JtYWxpemVkVmFsdWUuY2hhckNvZGVBdChpICogMik7XG4gICAgY29uc3QgYzIgPSBub3JtYWxpemVkVmFsdWUuY2hhckNvZGVBdChpICogMiArIDEpO1xuICAgIGNvbnN0IG4xID0gYzEgLSAoYzEgPCBIRVhfTUFYSU1VTV9OVU1CRVJfQ0hBUkFDVEVSID8gSEVYX01JTklNVU1fTlVNQkVSX0NIQVJBQ1RFUiA6IEhFWF9DSEFSQUNURVJfT0ZGU0VUKTtcbiAgICBjb25zdCBuMiA9IGMyIC0gKGMyIDwgSEVYX01BWElNVU1fTlVNQkVSX0NIQVJBQ1RFUiA/IEhFWF9NSU5JTVVNX05VTUJFUl9DSEFSQUNURVIgOiBIRVhfQ0hBUkFDVEVSX09GRlNFVCk7XG4gICAgYnl0ZXNbaV0gPSBuMSAqIDE2ICsgbjI7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuZnVuY3Rpb24gYmlnSW50VG9CeXRlcyh2YWx1ZSkge1xuICBfY2h1bms2WkRIU09VVmpzLmFzc2VydC5jYWxsKHZvaWQgMCwgdHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiLCBcIlZhbHVlIG11c3QgYmUgYSBiaWdpbnQuXCIpO1xuICBfY2h1bms2WkRIU09VVmpzLmFzc2VydC5jYWxsKHZvaWQgMCwgdmFsdWUgPj0gQmlnSW50KDApLCBcIlZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgYmlnaW50LlwiKTtcbiAgY29uc3QgaGV4YWRlY2ltYWwgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gIHJldHVybiBoZXhUb0J5dGVzKGhleGFkZWNpbWFsKTtcbn1cbmZ1bmN0aW9uIGJpZ0ludEZpdHModmFsdWUsIGJ5dGVzKSB7XG4gIF9jaHVuazZaREhTT1VWanMuYXNzZXJ0LmNhbGwodm9pZCAwLCBieXRlcyA+IDApO1xuICBjb25zdCBtYXNrID0gdmFsdWUgPj4gQmlnSW50KDMxKTtcbiAgcmV0dXJuICEoKH52YWx1ZSAmIG1hc2spICsgKHZhbHVlICYgfm1hc2spID4+IEJpZ0ludChieXRlcyAqIDggKyB+MCkpO1xufVxuZnVuY3Rpb24gc2lnbmVkQmlnSW50VG9CeXRlcyh2YWx1ZSwgYnl0ZUxlbmd0aCkge1xuICBfY2h1bms2WkRIU09VVmpzLmFzc2VydC5jYWxsKHZvaWQgMCwgdHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiLCBcIlZhbHVlIG11c3QgYmUgYSBiaWdpbnQuXCIpO1xuICBfY2h1bms2WkRIU09VVmpzLmFzc2VydC5jYWxsKHZvaWQgMCwgdHlwZW9mIGJ5dGVMZW5ndGggPT09IFwibnVtYmVyXCIsIFwiQnl0ZSBsZW5ndGggbXVzdCBiZSBhIG51bWJlci5cIik7XG4gIF9jaHVuazZaREhTT1VWanMuYXNzZXJ0LmNhbGwodm9pZCAwLCBieXRlTGVuZ3RoID4gMCwgXCJCeXRlIGxlbmd0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLlwiKTtcbiAgX2NodW5rNlpESFNPVVZqcy5hc3NlcnQuY2FsbCh2b2lkIDAsIFxuICAgIGJpZ0ludEZpdHModmFsdWUsIGJ5dGVMZW5ndGgpLFxuICAgIFwiQnl0ZSBsZW5ndGggaXMgdG9vIHNtYWxsIHRvIHJlcHJlc2VudCB0aGUgZ2l2ZW4gdmFsdWUuXCJcbiAgKTtcbiAgbGV0IG51bWJlclZhbHVlID0gdmFsdWU7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBieXRlc1tpXSA9IE51bWJlcihCaWdJbnQuYXNVaW50Tig4LCBudW1iZXJWYWx1ZSkpO1xuICAgIG51bWJlclZhbHVlID4+PSBCaWdJbnQoOCk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzLnJldmVyc2UoKTtcbn1cbmZ1bmN0aW9uIG51bWJlclRvQnl0ZXModmFsdWUpIHtcbiAgX2NodW5rNlpESFNPVVZqcy5hc3NlcnQuY2FsbCh2b2lkIDAsIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiwgXCJWYWx1ZSBtdXN0IGJlIGEgbnVtYmVyLlwiKTtcbiAgX2NodW5rNlpESFNPVVZqcy5hc3NlcnQuY2FsbCh2b2lkIDAsIHZhbHVlID49IDAsIFwiVmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuXCIpO1xuICBfY2h1bms2WkRIU09VVmpzLmFzc2VydC5jYWxsKHZvaWQgMCwgXG4gICAgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpLFxuICAgIFwiVmFsdWUgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLiBVc2UgYGJpZ0ludFRvQnl0ZXNgIGluc3RlYWQuXCJcbiAgKTtcbiAgY29uc3QgaGV4YWRlY2ltYWwgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gIHJldHVybiBoZXhUb0J5dGVzKGhleGFkZWNpbWFsKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXModmFsdWUpIHtcbiAgX2NodW5rNlpESFNPVVZqcy5hc3NlcnQuY2FsbCh2b2lkIDAsIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiwgXCJWYWx1ZSBtdXN0IGJlIGEgc3RyaW5nLlwiKTtcbiAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzKHZhbHVlKSB7XG4gIF9jaHVuazZaREhTT1VWanMuYXNzZXJ0LmNhbGwodm9pZCAwLCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIsIFwiVmFsdWUgbXVzdCBiZSBhIHN0cmluZy5cIik7XG4gIHJldHVybiBfYmFzZS5iYXNlNjQuZGVjb2RlKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHZhbHVlVG9CeXRlcyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgcmV0dXJuIGJpZ0ludFRvQnl0ZXModmFsdWUpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gbnVtYmVyVG9CeXRlcyh2YWx1ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICAgIHJldHVybiBoZXhUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICB9XG4gIGlmIChpc0J5dGVzKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB2YWx1ZSB0eXBlOiBcIiR7dHlwZW9mIHZhbHVlfVwiLmApO1xufVxuZnVuY3Rpb24gY29uY2F0Qnl0ZXModmFsdWVzKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZXMgPSBuZXcgQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gIGxldCBieXRlTGVuZ3RoID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlVG9CeXRlcyh2YWx1ZXNbaV0pO1xuICAgIG5vcm1hbGl6ZWRWYWx1ZXNbaV0gPSB2YWx1ZTtcbiAgICBieXRlTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgfVxuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IG5vcm1hbGl6ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBieXRlcy5zZXQobm9ybWFsaXplZFZhbHVlc1tpXSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gbm9ybWFsaXplZFZhbHVlc1tpXS5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuZnVuY3Rpb24gY3JlYXRlRGF0YVZpZXcoYnl0ZXMpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgYnl0ZXMgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICBjb25zdCBidWZmZXIgPSBieXRlcy5idWZmZXIuc2xpY2UoXG4gICAgICBieXRlcy5ieXRlT2Zmc2V0LFxuICAgICAgYnl0ZXMuYnl0ZU9mZnNldCArIGJ5dGVzLmJ5dGVMZW5ndGhcbiAgICApO1xuICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgfVxuICByZXR1cm4gbmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aCk7XG59XG5cbi8vIHNyYy9oZXgudHNcbnZhciBIZXhTdHJ1Y3QgPSBfc3VwZXJzdHJ1Y3QucGF0dGVybi5jYWxsKHZvaWQgMCwgX3N1cGVyc3RydWN0LnN0cmluZy5jYWxsKHZvaWQgMCwgKSwgL14oPzoweCk/WzAtOWEtZl0rJC9pdSk7XG52YXIgU3RyaWN0SGV4U3RydWN0ID0gX3N1cGVyc3RydWN0LnBhdHRlcm4uY2FsbCh2b2lkIDAsIF9zdXBlcnN0cnVjdC5zdHJpbmcuY2FsbCh2b2lkIDAsICksIC9eMHhbMC05YS1mXSskL2l1KTtcbnZhciBIZXhBZGRyZXNzU3RydWN0ID0gX3N1cGVyc3RydWN0LnBhdHRlcm4uY2FsbCh2b2lkIDAsIFxuICBfc3VwZXJzdHJ1Y3Quc3RyaW5nLmNhbGwodm9pZCAwLCApLFxuICAvXjB4WzAtOWEtZl17NDB9JC91XG4pO1xudmFyIEhleENoZWNrc3VtQWRkcmVzc1N0cnVjdCA9IF9zdXBlcnN0cnVjdC5wYXR0ZXJuLmNhbGwodm9pZCAwLCBcbiAgX3N1cGVyc3RydWN0LnN0cmluZy5jYWxsKHZvaWQgMCwgKSxcbiAgL14weFswLTlhLWZBLUZdezQwfSQvdVxuKTtcbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBfc3VwZXJzdHJ1Y3QuaXMuY2FsbCh2b2lkIDAsIHZhbHVlLCBIZXhTdHJ1Y3QpO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RIZXhTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIF9zdXBlcnN0cnVjdC5pcy5jYWxsKHZvaWQgMCwgdmFsdWUsIFN0cmljdEhleFN0cnVjdCk7XG59XG5mdW5jdGlvbiBhc3NlcnRJc0hleFN0cmluZyh2YWx1ZSkge1xuICBfY2h1bms2WkRIU09VVmpzLmFzc2VydC5jYWxsKHZvaWQgMCwgaXNIZXhTdHJpbmcodmFsdWUpLCBcIlZhbHVlIG11c3QgYmUgYSBoZXhhZGVjaW1hbCBzdHJpbmcuXCIpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmcodmFsdWUpIHtcbiAgX2NodW5rNlpESFNPVVZqcy5hc3NlcnQuY2FsbCh2b2lkIDAsIFxuICAgIGlzU3RyaWN0SGV4U3RyaW5nKHZhbHVlKSxcbiAgICAnVmFsdWUgbXVzdCBiZSBhIGhleGFkZWNpbWFsIHN0cmluZywgc3RhcnRpbmcgd2l0aCBcIjB4XCIuJ1xuICApO1xufVxuZnVuY3Rpb24gaXNWYWxpZEhleEFkZHJlc3MocG9zc2libGVBZGRyZXNzKSB7XG4gIHJldHVybiBfc3VwZXJzdHJ1Y3QuaXMuY2FsbCh2b2lkIDAsIHBvc3NpYmxlQWRkcmVzcywgSGV4QWRkcmVzc1N0cnVjdCkgfHwgaXNWYWxpZENoZWNrc3VtQWRkcmVzcyhwb3NzaWJsZUFkZHJlc3MpO1xufVxuZnVuY3Rpb24gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcbiAgX2NodW5rNlpESFNPVVZqcy5hc3NlcnQuY2FsbCh2b2lkIDAsIF9zdXBlcnN0cnVjdC5pcy5jYWxsKHZvaWQgMCwgYWRkcmVzcywgSGV4Q2hlY2tzdW1BZGRyZXNzU3RydWN0KSwgXCJJbnZhbGlkIGhleCBhZGRyZXNzLlwiKTtcbiAgY29uc3QgdW5QcmVmaXhlZCA9IHJlbW92ZTB4KGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gIGNvbnN0IHVuUHJlZml4ZWRIYXNoID0gcmVtb3ZlMHgoYnl0ZXNUb0hleChfc2hhMy5rZWNjYWtfMjU2LmNhbGwodm9pZCAwLCB1blByZWZpeGVkKSkpO1xuICByZXR1cm4gYDB4JHt1blByZWZpeGVkLnNwbGl0KFwiXCIpLm1hcCgoY2hhcmFjdGVyLCBuaWJibGVJbmRleCkgPT4ge1xuICAgIGNvbnN0IGhhc2hDaGFyYWN0ZXIgPSB1blByZWZpeGVkSGFzaFtuaWJibGVJbmRleF07XG4gICAgX2NodW5rNlpESFNPVVZqcy5hc3NlcnQuY2FsbCh2b2lkIDAsIF9zdXBlcnN0cnVjdC5pcy5jYWxsKHZvaWQgMCwgaGFzaENoYXJhY3RlciwgX3N1cGVyc3RydWN0LnN0cmluZy5jYWxsKHZvaWQgMCwgKSksIFwiSGFzaCBzaG9ydGVyIHRoYW4gYWRkcmVzcy5cIik7XG4gICAgcmV0dXJuIHBhcnNlSW50KGhhc2hDaGFyYWN0ZXIsIDE2KSA+IDcgPyBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKSA6IGNoYXJhY3RlcjtcbiAgfSkuam9pbihcIlwiKX1gO1xufVxuZnVuY3Rpb24gaXNWYWxpZENoZWNrc3VtQWRkcmVzcyhwb3NzaWJsZUNoZWNrc3VtKSB7XG4gIGlmICghX3N1cGVyc3RydWN0LmlzLmNhbGwodm9pZCAwLCBwb3NzaWJsZUNoZWNrc3VtLCBIZXhDaGVja3N1bUFkZHJlc3NTdHJ1Y3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBnZXRDaGVja3N1bUFkZHJlc3MocG9zc2libGVDaGVja3N1bSkgPT09IHBvc3NpYmxlQ2hlY2tzdW07XG59XG5mdW5jdGlvbiBhZGQweChoZXhhZGVjaW1hbCkge1xuICBpZiAoaGV4YWRlY2ltYWwuc3RhcnRzV2l0aChcIjB4XCIpKSB7XG4gICAgcmV0dXJuIGhleGFkZWNpbWFsO1xuICB9XG4gIGlmIChoZXhhZGVjaW1hbC5zdGFydHNXaXRoKFwiMFhcIikpIHtcbiAgICByZXR1cm4gYDB4JHtoZXhhZGVjaW1hbC5zdWJzdHJpbmcoMil9YDtcbiAgfVxuICByZXR1cm4gYDB4JHtoZXhhZGVjaW1hbH1gO1xufVxuZnVuY3Rpb24gcmVtb3ZlMHgoaGV4YWRlY2ltYWwpIHtcbiAgaWYgKGhleGFkZWNpbWFsLnN0YXJ0c1dpdGgoXCIweFwiKSB8fCBoZXhhZGVjaW1hbC5zdGFydHNXaXRoKFwiMFhcIikpIHtcbiAgICByZXR1cm4gaGV4YWRlY2ltYWwuc3Vic3RyaW5nKDIpO1xuICB9XG4gIHJldHVybiBoZXhhZGVjaW1hbDtcbn1cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5leHBvcnRzLkhleFN0cnVjdCA9IEhleFN0cnVjdDsgZXhwb3J0cy5TdHJpY3RIZXhTdHJ1Y3QgPSBTdHJpY3RIZXhTdHJ1Y3Q7IGV4cG9ydHMuSGV4QWRkcmVzc1N0cnVjdCA9IEhleEFkZHJlc3NTdHJ1Y3Q7IGV4cG9ydHMuSGV4Q2hlY2tzdW1BZGRyZXNzU3RydWN0ID0gSGV4Q2hlY2tzdW1BZGRyZXNzU3RydWN0OyBleHBvcnRzLmlzSGV4U3RyaW5nID0gaXNIZXhTdHJpbmc7IGV4cG9ydHMuaXNTdHJpY3RIZXhTdHJpbmcgPSBpc1N0cmljdEhleFN0cmluZzsgZXhwb3J0cy5hc3NlcnRJc0hleFN0cmluZyA9IGFzc2VydElzSGV4U3RyaW5nOyBleHBvcnRzLmFzc2VydElzU3RyaWN0SGV4U3RyaW5nID0gYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmc7IGV4cG9ydHMuaXNWYWxpZEhleEFkZHJlc3MgPSBpc1ZhbGlkSGV4QWRkcmVzczsgZXhwb3J0cy5nZXRDaGVja3N1bUFkZHJlc3MgPSBnZXRDaGVja3N1bUFkZHJlc3M7IGV4cG9ydHMuaXNWYWxpZENoZWNrc3VtQWRkcmVzcyA9IGlzVmFsaWRDaGVja3N1bUFkZHJlc3M7IGV4cG9ydHMuYWRkMHggPSBhZGQweDsgZXhwb3J0cy5yZW1vdmUweCA9IHJlbW92ZTB4OyBleHBvcnRzLmlzQnl0ZXMgPSBpc0J5dGVzOyBleHBvcnRzLmFzc2VydElzQnl0ZXMgPSBhc3NlcnRJc0J5dGVzOyBleHBvcnRzLmJ5dGVzVG9IZXggPSBieXRlc1RvSGV4OyBleHBvcnRzLmJ5dGVzVG9CaWdJbnQgPSBieXRlc1RvQmlnSW50OyBleHBvcnRzLmJ5dGVzVG9TaWduZWRCaWdJbnQgPSBieXRlc1RvU2lnbmVkQmlnSW50OyBleHBvcnRzLmJ5dGVzVG9OdW1iZXIgPSBieXRlc1RvTnVtYmVyOyBleHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBieXRlc1RvU3RyaW5nOyBleHBvcnRzLmJ5dGVzVG9CYXNlNjQgPSBieXRlc1RvQmFzZTY0OyBleHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzOyBleHBvcnRzLmJpZ0ludFRvQnl0ZXMgPSBiaWdJbnRUb0J5dGVzOyBleHBvcnRzLnNpZ25lZEJpZ0ludFRvQnl0ZXMgPSBzaWduZWRCaWdJbnRUb0J5dGVzOyBleHBvcnRzLm51bWJlclRvQnl0ZXMgPSBudW1iZXJUb0J5dGVzOyBleHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBzdHJpbmdUb0J5dGVzOyBleHBvcnRzLmJhc2U2NFRvQnl0ZXMgPSBiYXNlNjRUb0J5dGVzOyBleHBvcnRzLnZhbHVlVG9CeXRlcyA9IHZhbHVlVG9CeXRlczsgZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzOyBleHBvcnRzLmNyZWF0ZURhdGFWaWV3ID0gY3JlYXRlRGF0YVZpZXc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1RRVBWSEVQNy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfb3B0aW9uYWxDaGFpbiIsIm9wcyIsImxhc3RBY2Nlc3NMSFMiLCJ1bmRlZmluZWQiLCJpIiwibGVuZ3RoIiwib3AiLCJmbiIsImFyZ3MiLCJjYWxsIiwiX2NodW5rNlpESFNPVVZqcyIsInJlcXVpcmUiLCJfc2hhMyIsIl9zdXBlcnN0cnVjdCIsIl9iYXNlIiwiSEVYX01JTklNVU1fTlVNQkVSX0NIQVJBQ1RFUiIsIkhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVIiLCJIRVhfQ0hBUkFDVEVSX09GRlNFVCIsImdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlciIsImxvb2t1cFRhYmxlIiwicHVzaCIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJnZXRQcmVjb21wdXRlZEhleFZhbHVlcyIsImlzQnl0ZXMiLCJVaW50OEFycmF5IiwiYXNzZXJ0SXNCeXRlcyIsImFzc2VydCIsImJ5dGVzVG9IZXgiLCJieXRlcyIsImhleGFkZWNpbWFsIiwiQXJyYXkiLCJhZGQweCIsImpvaW4iLCJieXRlc1RvQmlnSW50IiwiQmlnSW50IiwiYnl0ZXNUb1NpZ25lZEJpZ0ludCIsImJ5dGUiLCJhc0ludE4iLCJieXRlc1RvTnVtYmVyIiwiYmlnaW50IiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsImJ5dGVzVG9TdHJpbmciLCJUZXh0RGVjb2RlciIsImRlY29kZSIsImJ5dGVzVG9CYXNlNjQiLCJiYXNlNjQiLCJlbmNvZGUiLCJoZXhUb0J5dGVzIiwiXyIsInRvTG93ZXJDYXNlIiwiXzIiLCJhc3NlcnRJc0hleFN0cmluZyIsInN0cmlwcGVkVmFsdWUiLCJyZW1vdmUweCIsIm5vcm1hbGl6ZWRWYWx1ZSIsImMxIiwiY2hhckNvZGVBdCIsImMyIiwibjEiLCJuMiIsImJpZ0ludFRvQnl0ZXMiLCJiaWdJbnRGaXRzIiwibWFzayIsInNpZ25lZEJpZ0ludFRvQnl0ZXMiLCJieXRlTGVuZ3RoIiwibnVtYmVyVmFsdWUiLCJhc1VpbnROIiwicmV2ZXJzZSIsIm51bWJlclRvQnl0ZXMiLCJpc1NhZmVJbnRlZ2VyIiwic3RyaW5nVG9CeXRlcyIsIlRleHRFbmNvZGVyIiwiYmFzZTY0VG9CeXRlcyIsInZhbHVlVG9CeXRlcyIsInN0YXJ0c1dpdGgiLCJUeXBlRXJyb3IiLCJjb25jYXRCeXRlcyIsInZhbHVlcyIsIm5vcm1hbGl6ZWRWYWx1ZXMiLCJvZmZzZXQiLCJzZXQiLCJjcmVhdGVEYXRhVmlldyIsIkJ1ZmZlciIsImJ1ZmZlciIsInNsaWNlIiwiYnl0ZU9mZnNldCIsIkRhdGFWaWV3IiwiSGV4U3RydWN0IiwicGF0dGVybiIsInN0cmluZyIsIlN0cmljdEhleFN0cnVjdCIsIkhleEFkZHJlc3NTdHJ1Y3QiLCJIZXhDaGVja3N1bUFkZHJlc3NTdHJ1Y3QiLCJpc0hleFN0cmluZyIsImlzIiwiaXNTdHJpY3RIZXhTdHJpbmciLCJhc3NlcnRJc1N0cmljdEhleFN0cmluZyIsImlzVmFsaWRIZXhBZGRyZXNzIiwicG9zc2libGVBZGRyZXNzIiwiaXNWYWxpZENoZWNrc3VtQWRkcmVzcyIsImdldENoZWNrc3VtQWRkcmVzcyIsImFkZHJlc3MiLCJ1blByZWZpeGVkIiwidW5QcmVmaXhlZEhhc2giLCJrZWNjYWtfMjU2Iiwic3BsaXQiLCJtYXAiLCJjaGFyYWN0ZXIiLCJuaWJibGVJbmRleCIsImhhc2hDaGFyYWN0ZXIiLCJwYXJzZUludCIsInRvVXBwZXJDYXNlIiwicG9zc2libGVDaGVja3N1bSIsInN1YnN0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/chunk-QEPVHEP7.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/chunk-QVEKZRZ2.js":
/*!*************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/chunk-QVEKZRZ2.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _nullishCoalesce(lhs, rhsFn) {\n    if (lhs != null) {\n        return lhs;\n    } else {\n        return rhsFn();\n    }\n} // src/misc.ts\nfunction isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n}\nfunction isNullOrUndefined(value) {\n    return value === null || value === void 0;\n}\nfunction isObject(value) {\n    return Boolean(value) && typeof value === \"object\" && !Array.isArray(value);\n}\nvar hasProperty = (objectToCheck, name)=>Object.hasOwnProperty.call(objectToCheck, name);\nfunction getKnownPropertyNames(object) {\n    return Object.getOwnPropertyNames(object);\n}\nvar JsonSize = /* @__PURE__ */ ((JsonSize2)=>{\n    JsonSize2[JsonSize2[\"Null\"] = 4] = \"Null\";\n    JsonSize2[JsonSize2[\"Comma\"] = 1] = \"Comma\";\n    JsonSize2[JsonSize2[\"Wrapper\"] = 1] = \"Wrapper\";\n    JsonSize2[JsonSize2[\"True\"] = 4] = \"True\";\n    JsonSize2[JsonSize2[\"False\"] = 5] = \"False\";\n    JsonSize2[JsonSize2[\"Quote\"] = 1] = \"Quote\";\n    JsonSize2[JsonSize2[\"Colon\"] = 1] = \"Colon\";\n    JsonSize2[JsonSize2[\"Date\"] = 24] = \"Date\";\n    return JsonSize2;\n})(JsonSize || {});\nvar ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\nfunction isPlainObject(value) {\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    try {\n        let proto = value;\n        while(Object.getPrototypeOf(proto) !== null){\n            proto = Object.getPrototypeOf(proto);\n        }\n        return Object.getPrototypeOf(value) === proto;\n    } catch (_) {\n        return false;\n    }\n}\nfunction isASCII(character) {\n    return character.charCodeAt(0) <= 127;\n}\nfunction calculateStringSize(value) {\n    const size = value.split(\"\").reduce((total, character)=>{\n        if (isASCII(character)) {\n            return total + 1;\n        }\n        return total + 2;\n    }, 0);\n    return size + _nullishCoalesce(value.match(ESCAPE_CHARACTERS_REGEXP), ()=>[]).length;\n}\nfunction calculateNumberSize(value) {\n    return value.toString().length;\n}\nexports.isNonEmptyArray = isNonEmptyArray;\nexports.isNullOrUndefined = isNullOrUndefined;\nexports.isObject = isObject;\nexports.hasProperty = hasProperty;\nexports.getKnownPropertyNames = getKnownPropertyNames;\nexports.JsonSize = JsonSize;\nexports.ESCAPE_CHARACTERS_REGEXP = ESCAPE_CHARACTERS_REGEXP;\nexports.isPlainObject = isPlainObject;\nexports.isASCII = isASCII;\nexports.calculateStringSize = calculateStringSize;\nexports.calculateNumberSize = calculateNumberSize; //# sourceMappingURL=chunk-QVEKZRZ2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2h1bmstUVZFS1pSWjIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFBQUEsOENBQTZDO0lBQUNHLE9BQU87QUFBSSxDQUFDLEVBQUM7QUFBRSxTQUFTQyxpQkFBaUJDLEdBQUcsRUFBRUMsS0FBSztJQUFJLElBQUlELE9BQU8sTUFBTTtRQUFFLE9BQU9BO0lBQUssT0FBTztRQUFFLE9BQU9DO0lBQVM7QUFBRSxFQUFDLGNBQWM7QUFDM0wsU0FBU0MsZ0JBQWdCSixLQUFLO0lBQzVCLE9BQU9LLE1BQU1DLE9BQU8sQ0FBQ04sVUFBVUEsTUFBTU8sTUFBTSxHQUFHO0FBQ2hEO0FBQ0EsU0FBU0Msa0JBQWtCUixLQUFLO0lBQzlCLE9BQU9BLFVBQVUsUUFBUUEsVUFBVSxLQUFLO0FBQzFDO0FBQ0EsU0FBU1MsU0FBU1QsS0FBSztJQUNyQixPQUFPVSxRQUFRVixVQUFVLE9BQU9BLFVBQVUsWUFBWSxDQUFDSyxNQUFNQyxPQUFPLENBQUNOO0FBQ3ZFO0FBQ0EsSUFBSVcsY0FBYyxDQUFDQyxlQUFlQyxPQUFTaEIsT0FBT2lCLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSCxlQUFlQztBQUNyRixTQUFTRyxzQkFBc0JDLE1BQU07SUFDbkMsT0FBT3BCLE9BQU9xQixtQkFBbUIsQ0FBQ0Q7QUFDcEM7QUFDQSxJQUFJRSxXQUEyQixhQUFILEdBQUksRUFBQ0M7SUFDL0JBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDbkNBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDcENBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDdENBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDbkNBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDcENBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDcENBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDcENBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLE9BQU8sR0FBRyxHQUFHLEdBQUc7SUFDcEMsT0FBT0E7QUFDVCxHQUFHRCxZQUFZLENBQUM7QUFDaEIsSUFBSUUsMkJBQTJCO0FBQy9CLFNBQVNDLGNBQWN0QixLQUFLO0lBQzFCLElBQUksT0FBT0EsVUFBVSxZQUFZQSxVQUFVLE1BQU07UUFDL0MsT0FBTztJQUNUO0lBQ0EsSUFBSTtRQUNGLElBQUl1QixRQUFRdkI7UUFDWixNQUFPSCxPQUFPMkIsY0FBYyxDQUFDRCxXQUFXLEtBQU07WUFDNUNBLFFBQVExQixPQUFPMkIsY0FBYyxDQUFDRDtRQUNoQztRQUNBLE9BQU8xQixPQUFPMkIsY0FBYyxDQUFDeEIsV0FBV3VCO0lBQzFDLEVBQUUsT0FBT0UsR0FBRztRQUNWLE9BQU87SUFDVDtBQUNGO0FBQ0EsU0FBU0MsUUFBUUMsU0FBUztJQUN4QixPQUFPQSxVQUFVQyxVQUFVLENBQUMsTUFBTTtBQUNwQztBQUNBLFNBQVNDLG9CQUFvQjdCLEtBQUs7SUFDaEMsTUFBTThCLE9BQU85QixNQUFNK0IsS0FBSyxDQUFDLElBQUlDLE1BQU0sQ0FBQyxDQUFDQyxPQUFPTjtRQUMxQyxJQUFJRCxRQUFRQyxZQUFZO1lBQ3RCLE9BQU9NLFFBQVE7UUFDakI7UUFDQSxPQUFPQSxRQUFRO0lBQ2pCLEdBQUc7SUFDSCxPQUFPSCxPQUFPLGlCQUFrQjlCLE1BQU1rQyxLQUFLLENBQUNiLDJCQUEyQixJQUFRLEVBQUUsRUFBSWQsTUFBTTtBQUM3RjtBQUNBLFNBQVM0QixvQkFBb0JuQyxLQUFLO0lBQ2hDLE9BQU9BLE1BQU1vQyxRQUFRLEdBQUc3QixNQUFNO0FBQ2hDO0FBY0FSLHVCQUF1QixHQUFHSztBQUFpQkwseUJBQXlCLEdBQUdTO0FBQW1CVCxnQkFBZ0IsR0FBR1U7QUFBVVYsbUJBQW1CLEdBQUdZO0FBQWFaLDZCQUE2QixHQUFHaUI7QUFBdUJqQixnQkFBZ0IsR0FBR29CO0FBQVVwQixnQ0FBZ0MsR0FBR3NCO0FBQTBCdEIscUJBQXFCLEdBQUd1QjtBQUFldkIsZUFBZSxHQUFHMkI7QUFBUzNCLDJCQUEyQixHQUFHOEI7QUFBcUI5QiwyQkFBMkIsR0FBR29DLHFCQUM5YiwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NodW5rLVFWRUtaUloyLmpzPzlkNTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTsgZnVuY3Rpb24gX251bGxpc2hDb2FsZXNjZShsaHMsIHJoc0ZuKSB7IGlmIChsaHMgIT0gbnVsbCkgeyByZXR1cm4gbGhzOyB9IGVsc2UgeyByZXR1cm4gcmhzRm4oKTsgfSB9Ly8gc3JjL21pc2MudHNcbmZ1bmN0aW9uIGlzTm9uRW1wdHlBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gMDtcbn1cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4odmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG52YXIgaGFzUHJvcGVydHkgPSAob2JqZWN0VG9DaGVjaywgbmFtZSkgPT4gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0VG9DaGVjaywgbmFtZSk7XG5mdW5jdGlvbiBnZXRLbm93blByb3BlcnR5TmFtZXMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpO1xufVxudmFyIEpzb25TaXplID0gLyogQF9fUFVSRV9fICovICgoSnNvblNpemUyKSA9PiB7XG4gIEpzb25TaXplMltKc29uU2l6ZTJbXCJOdWxsXCJdID0gNF0gPSBcIk51bGxcIjtcbiAgSnNvblNpemUyW0pzb25TaXplMltcIkNvbW1hXCJdID0gMV0gPSBcIkNvbW1hXCI7XG4gIEpzb25TaXplMltKc29uU2l6ZTJbXCJXcmFwcGVyXCJdID0gMV0gPSBcIldyYXBwZXJcIjtcbiAgSnNvblNpemUyW0pzb25TaXplMltcIlRydWVcIl0gPSA0XSA9IFwiVHJ1ZVwiO1xuICBKc29uU2l6ZTJbSnNvblNpemUyW1wiRmFsc2VcIl0gPSA1XSA9IFwiRmFsc2VcIjtcbiAgSnNvblNpemUyW0pzb25TaXplMltcIlF1b3RlXCJdID0gMV0gPSBcIlF1b3RlXCI7XG4gIEpzb25TaXplMltKc29uU2l6ZTJbXCJDb2xvblwiXSA9IDFdID0gXCJDb2xvblwiO1xuICBKc29uU2l6ZTJbSnNvblNpemUyW1wiRGF0ZVwiXSA9IDI0XSA9IFwiRGF0ZVwiO1xuICByZXR1cm4gSnNvblNpemUyO1xufSkoSnNvblNpemUgfHwge30pO1xudmFyIEVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCA9IC9cInxcXFxcfFxcbnxcXHJ8XFx0L2d1O1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgbGV0IHByb3RvID0gdmFsdWU7XG4gICAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykgIT09IG51bGwpIHtcbiAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IHByb3RvO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc0FTQ0lJKGNoYXJhY3Rlcikge1xuICByZXR1cm4gY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCkgPD0gMTI3O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlU3RyaW5nU2l6ZSh2YWx1ZSkge1xuICBjb25zdCBzaXplID0gdmFsdWUuc3BsaXQoXCJcIikucmVkdWNlKCh0b3RhbCwgY2hhcmFjdGVyKSA9PiB7XG4gICAgaWYgKGlzQVNDSUkoY2hhcmFjdGVyKSkge1xuICAgICAgcmV0dXJuIHRvdGFsICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsICsgMjtcbiAgfSwgMCk7XG4gIHJldHVybiBzaXplICsgKF9udWxsaXNoQ29hbGVzY2UodmFsdWUubWF0Y2goRVNDQVBFX0NIQVJBQ1RFUlNfUkVHRVhQKSwgKCkgPT4gKCBbXSkpKS5sZW5ndGg7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVOdW1iZXJTaXplKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS50b1N0cmluZygpLmxlbmd0aDtcbn1cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuZXhwb3J0cy5pc05vbkVtcHR5QXJyYXkgPSBpc05vbkVtcHR5QXJyYXk7IGV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDsgZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0OyBleHBvcnRzLmhhc1Byb3BlcnR5ID0gaGFzUHJvcGVydHk7IGV4cG9ydHMuZ2V0S25vd25Qcm9wZXJ0eU5hbWVzID0gZ2V0S25vd25Qcm9wZXJ0eU5hbWVzOyBleHBvcnRzLkpzb25TaXplID0gSnNvblNpemU7IGV4cG9ydHMuRVNDQVBFX0NIQVJBQ1RFUlNfUkVHRVhQID0gRVNDQVBFX0NIQVJBQ1RFUlNfUkVHRVhQOyBleHBvcnRzLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0OyBleHBvcnRzLmlzQVNDSUkgPSBpc0FTQ0lJOyBleHBvcnRzLmNhbGN1bGF0ZVN0cmluZ1NpemUgPSBjYWxjdWxhdGVTdHJpbmdTaXplOyBleHBvcnRzLmNhbGN1bGF0ZU51bWJlclNpemUgPSBjYWxjdWxhdGVOdW1iZXJTaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstUVZFS1pSWjIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX251bGxpc2hDb2FsZXNjZSIsImxocyIsInJoc0ZuIiwiaXNOb25FbXB0eUFycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJpc09iamVjdCIsIkJvb2xlYW4iLCJoYXNQcm9wZXJ0eSIsIm9iamVjdFRvQ2hlY2siLCJuYW1lIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZ2V0S25vd25Qcm9wZXJ0eU5hbWVzIiwib2JqZWN0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIkpzb25TaXplIiwiSnNvblNpemUyIiwiRVNDQVBFX0NIQVJBQ1RFUlNfUkVHRVhQIiwiaXNQbGFpbk9iamVjdCIsInByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJfIiwiaXNBU0NJSSIsImNoYXJhY3RlciIsImNoYXJDb2RlQXQiLCJjYWxjdWxhdGVTdHJpbmdTaXplIiwic2l6ZSIsInNwbGl0IiwicmVkdWNlIiwidG90YWwiLCJtYXRjaCIsImNhbGN1bGF0ZU51bWJlclNpemUiLCJ0b1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/chunk-QVEKZRZ2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/chunk-RKRGAFXY.js":
/*!*************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/chunk-RKRGAFXY.js ***!
  \*************************************************************/
/***/ (() => {

eval(" //# sourceMappingURL=chunk-RKRGAFXY.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2h1bmstUktSR0FGWFkuanMiLCJtYXBwaW5ncyI6IkFBQWEsMkNBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jaHVuay1SS1JHQUZYWS5qcz8wYzE2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiOy8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLVJLUkdBRlhZLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/chunk-RKRGAFXY.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/chunk-U7ZUGCE7.js":
/*!*************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/chunk-U7ZUGCE7.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _optionalChain(ops) {\n    let lastAccessLHS = undefined;\n    let value = ops[0];\n    let i = 1;\n    while(i < ops.length){\n        const op = ops[i];\n        const fn = ops[i + 1];\n        i += 2;\n        if ((op === \"optionalAccess\" || op === \"optionalCall\") && value == null) {\n            return undefined;\n        }\n        if (op === \"access\" || op === \"optionalAccess\") {\n            lastAccessLHS = value;\n            value = fn(value);\n        } else if (op === \"call\" || op === \"optionalCall\") {\n            value = fn((...args)=>value.call(lastAccessLHS, ...args));\n            lastAccessLHS = undefined;\n        }\n    }\n    return value;\n} // src/caip-types.ts\nvar _superstruct = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\nvar CAIP_CHAIN_ID_REGEX = /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})$/u;\nvar CAIP_NAMESPACE_REGEX = /^[-a-z0-9]{3,8}$/u;\nvar CAIP_REFERENCE_REGEX = /^[-_a-zA-Z0-9]{1,32}$/u;\nvar CAIP_ACCOUNT_ID_REGEX = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})):(?<accountAddress>[-.%a-zA-Z0-9]{1,128})$/u;\nvar CAIP_ACCOUNT_ADDRESS_REGEX = /^[-.%a-zA-Z0-9]{1,128}$/u;\nvar CaipChainIdStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0), CAIP_CHAIN_ID_REGEX);\nvar CaipNamespaceStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0), CAIP_NAMESPACE_REGEX);\nvar CaipReferenceStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0), CAIP_REFERENCE_REGEX);\nvar CaipAccountIdStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0), CAIP_ACCOUNT_ID_REGEX);\nvar CaipAccountAddressStruct = _superstruct.pattern.call(void 0, _superstruct.string.call(void 0), CAIP_ACCOUNT_ADDRESS_REGEX);\nfunction isCaipChainId(value) {\n    return _superstruct.is.call(void 0, value, CaipChainIdStruct);\n}\nfunction isCaipNamespace(value) {\n    return _superstruct.is.call(void 0, value, CaipNamespaceStruct);\n}\nfunction isCaipReference(value) {\n    return _superstruct.is.call(void 0, value, CaipReferenceStruct);\n}\nfunction isCaipAccountId(value) {\n    return _superstruct.is.call(void 0, value, CaipAccountIdStruct);\n}\nfunction isCaipAccountAddress(value) {\n    return _superstruct.is.call(void 0, value, CaipAccountAddressStruct);\n}\nfunction parseCaipChainId(caipChainId) {\n    const match = CAIP_CHAIN_ID_REGEX.exec(caipChainId);\n    if (!_optionalChain([\n        match,\n        \"optionalAccess\",\n        (_)=>_.groups\n    ])) {\n        throw new Error(\"Invalid CAIP chain ID.\");\n    }\n    return {\n        namespace: match.groups.namespace,\n        reference: match.groups.reference\n    };\n}\nfunction parseCaipAccountId(caipAccountId) {\n    const match = CAIP_ACCOUNT_ID_REGEX.exec(caipAccountId);\n    if (!_optionalChain([\n        match,\n        \"optionalAccess\",\n        (_2)=>_2.groups\n    ])) {\n        throw new Error(\"Invalid CAIP account ID.\");\n    }\n    return {\n        address: match.groups.accountAddress,\n        chainId: match.groups.chainId,\n        chain: {\n            namespace: match.groups.namespace,\n            reference: match.groups.reference\n        }\n    };\n}\nexports.CAIP_CHAIN_ID_REGEX = CAIP_CHAIN_ID_REGEX;\nexports.CAIP_NAMESPACE_REGEX = CAIP_NAMESPACE_REGEX;\nexports.CAIP_REFERENCE_REGEX = CAIP_REFERENCE_REGEX;\nexports.CAIP_ACCOUNT_ID_REGEX = CAIP_ACCOUNT_ID_REGEX;\nexports.CAIP_ACCOUNT_ADDRESS_REGEX = CAIP_ACCOUNT_ADDRESS_REGEX;\nexports.CaipChainIdStruct = CaipChainIdStruct;\nexports.CaipNamespaceStruct = CaipNamespaceStruct;\nexports.CaipReferenceStruct = CaipReferenceStruct;\nexports.CaipAccountIdStruct = CaipAccountIdStruct;\nexports.CaipAccountAddressStruct = CaipAccountAddressStruct;\nexports.isCaipChainId = isCaipChainId;\nexports.isCaipNamespace = isCaipNamespace;\nexports.isCaipReference = isCaipReference;\nexports.isCaipAccountId = isCaipAccountId;\nexports.isCaipAccountAddress = isCaipAccountAddress;\nexports.parseCaipChainId = parseCaipChainId;\nexports.parseCaipAccountId = parseCaipAccountId; //# sourceMappingURL=chunk-U7ZUGCE7.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2h1bmstVTdaVUdDRTcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFBQUEsOENBQTZDO0lBQUNHLE9BQU87QUFBSSxDQUFDLEVBQUM7QUFBRSxTQUFTQyxlQUFlQyxHQUFHO0lBQUksSUFBSUMsZ0JBQWdCQztJQUFXLElBQUlKLFFBQVFFLEdBQUcsQ0FBQyxFQUFFO0lBQUUsSUFBSUcsSUFBSTtJQUFHLE1BQU9BLElBQUlILElBQUlJLE1BQU0sQ0FBRTtRQUFFLE1BQU1DLEtBQUtMLEdBQUcsQ0FBQ0csRUFBRTtRQUFFLE1BQU1HLEtBQUtOLEdBQUcsQ0FBQ0csSUFBSSxFQUFFO1FBQUVBLEtBQUs7UUFBRyxJQUFJLENBQUNFLE9BQU8sb0JBQW9CQSxPQUFPLGNBQWEsS0FBTVAsU0FBUyxNQUFNO1lBQUUsT0FBT0k7UUFBVztRQUFFLElBQUlHLE9BQU8sWUFBWUEsT0FBTyxrQkFBa0I7WUFBRUosZ0JBQWdCSDtZQUFPQSxRQUFRUSxHQUFHUjtRQUFRLE9BQU8sSUFBSU8sT0FBTyxVQUFVQSxPQUFPLGdCQUFnQjtZQUFFUCxRQUFRUSxHQUFHLENBQUMsR0FBR0MsT0FBU1QsTUFBTVUsSUFBSSxDQUFDUCxrQkFBa0JNO1lBQVFOLGdCQUFnQkM7UUFBVztJQUFFO0lBQUUsT0FBT0o7QUFBTyxFQUFDLG9CQUFvQjtBQUNqbUIsSUFBSVcsZUFBZUMsbUJBQU9BLENBQUM7QUFDM0IsSUFBSUMsc0JBQXNCO0FBQzFCLElBQUlDLHVCQUF1QjtBQUMzQixJQUFJQyx1QkFBdUI7QUFDM0IsSUFBSUMsd0JBQXdCO0FBQzVCLElBQUlDLDZCQUE2QjtBQUNqQyxJQUFJQyxvQkFBb0JQLGFBQWFRLE9BQU8sQ0FBQ1QsSUFBSSxDQUFDLEtBQUssR0FBR0MsYUFBYVMsTUFBTSxDQUFDVixJQUFJLENBQUMsS0FBSyxJQUFNRztBQUM5RixJQUFJUSxzQkFBc0JWLGFBQWFRLE9BQU8sQ0FBQ1QsSUFBSSxDQUFDLEtB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bW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jaHVuay1VN1pVR0NFNy5qcz84M2Q2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7IGZ1bmN0aW9uIF9vcHRpb25hbENoYWluKG9wcykgeyBsZXQgbGFzdEFjY2Vzc0xIUyA9IHVuZGVmaW5lZDsgbGV0IHZhbHVlID0gb3BzWzBdOyBsZXQgaSA9IDE7IHdoaWxlIChpIDwgb3BzLmxlbmd0aCkgeyBjb25zdCBvcCA9IG9wc1tpXTsgY29uc3QgZm4gPSBvcHNbaSArIDFdOyBpICs9IDI7IGlmICgob3AgPT09ICdvcHRpb25hbEFjY2VzcycgfHwgb3AgPT09ICdvcHRpb25hbENhbGwnKSAmJiB2YWx1ZSA9PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gaWYgKG9wID09PSAnYWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJykgeyBsYXN0QWNjZXNzTEhTID0gdmFsdWU7IHZhbHVlID0gZm4odmFsdWUpOyB9IGVsc2UgaWYgKG9wID09PSAnY2FsbCcgfHwgb3AgPT09ICdvcHRpb25hbENhbGwnKSB7IHZhbHVlID0gZm4oKC4uLmFyZ3MpID0+IHZhbHVlLmNhbGwobGFzdEFjY2Vzc0xIUywgLi4uYXJncykpOyBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyB9IH0gcmV0dXJuIHZhbHVlOyB9Ly8gc3JjL2NhaXAtdHlwZXMudHNcbnZhciBfc3VwZXJzdHJ1Y3QgPSByZXF1aXJlKCdzdXBlcnN0cnVjdCcpO1xudmFyIENBSVBfQ0hBSU5fSURfUkVHRVggPSAvXig/PG5hbWVzcGFjZT5bLWEtejAtOV17Myw4fSk6KD88cmVmZXJlbmNlPlstX2EtekEtWjAtOV17MSwzMn0pJC91O1xudmFyIENBSVBfTkFNRVNQQUNFX1JFR0VYID0gL15bLWEtejAtOV17Myw4fSQvdTtcbnZhciBDQUlQX1JFRkVSRU5DRV9SRUdFWCA9IC9eWy1fYS16QS1aMC05XXsxLDMyfSQvdTtcbnZhciBDQUlQX0FDQ09VTlRfSURfUkVHRVggPSAvXig/PGNoYWluSWQ+KD88bmFtZXNwYWNlPlstYS16MC05XXszLDh9KTooPzxyZWZlcmVuY2U+Wy1fYS16QS1aMC05XXsxLDMyfSkpOig/PGFjY291bnRBZGRyZXNzPlstLiVhLXpBLVowLTldezEsMTI4fSkkL3U7XG52YXIgQ0FJUF9BQ0NPVU5UX0FERFJFU1NfUkVHRVggPSAvXlstLiVhLXpBLVowLTldezEsMTI4fSQvdTtcbnZhciBDYWlwQ2hhaW5JZFN0cnVjdCA9IF9zdXBlcnN0cnVjdC5wYXR0ZXJuLmNhbGwodm9pZCAwLCBfc3VwZXJzdHJ1Y3Quc3RyaW5nLmNhbGwodm9pZCAwLCApLCBDQUlQX0NIQUlOX0lEX1JFR0VYKTtcbnZhciBDYWlwTmFtZXNwYWNlU3RydWN0ID0gX3N1cGVyc3RydWN0LnBhdHRlcm4uY2FsbCh2b2lkIDAsIF9zdXBlcnN0cnVjdC5zdHJpbmcuY2FsbCh2b2lkIDAsICksIENBSVBfTkFNRVNQQUNFX1JFR0VYKTtcbnZhciBDYWlwUmVmZXJlbmNlU3RydWN0ID0gX3N1cGVyc3RydWN0LnBhdHRlcm4uY2FsbCh2b2lkIDAsIF9zdXBlcnN0cnVjdC5zdHJpbmcuY2FsbCh2b2lkIDAsICksIENBSVBfUkVGRVJFTkNFX1JFR0VYKTtcbnZhciBDYWlwQWNjb3VudElkU3RydWN0ID0gX3N1cGVyc3RydWN0LnBhdHRlcm4uY2FsbCh2b2lkIDAsIF9zdXBlcnN0cnVjdC5zdHJpbmcuY2FsbCh2b2lkIDAsICksIENBSVBfQUNDT1VOVF9JRF9SRUdFWCk7XG52YXIgQ2FpcEFjY291bnRBZGRyZXNzU3RydWN0ID0gX3N1cGVyc3RydWN0LnBhdHRlcm4uY2FsbCh2b2lkIDAsIFxuICBfc3VwZXJzdHJ1Y3Quc3RyaW5nLmNhbGwodm9pZCAwLCApLFxuICBDQUlQX0FDQ09VTlRfQUREUkVTU19SRUdFWFxuKTtcbmZ1bmN0aW9uIGlzQ2FpcENoYWluSWQodmFsdWUpIHtcbiAgcmV0dXJuIF9zdXBlcnN0cnVjdC5pcy5jYWxsKHZvaWQgMCwgdmFsdWUsIENhaXBDaGFpbklkU3RydWN0KTtcbn1cbmZ1bmN0aW9uIGlzQ2FpcE5hbWVzcGFjZSh2YWx1ZSkge1xuICByZXR1cm4gX3N1cGVyc3RydWN0LmlzLmNhbGwodm9pZCAwLCB2YWx1ZSwgQ2FpcE5hbWVzcGFjZVN0cnVjdCk7XG59XG5mdW5jdGlvbiBpc0NhaXBSZWZlcmVuY2UodmFsdWUpIHtcbiAgcmV0dXJuIF9zdXBlcnN0cnVjdC5pcy5jYWxsKHZvaWQgMCwgdmFsdWUsIENhaXBSZWZlcmVuY2VTdHJ1Y3QpO1xufVxuZnVuY3Rpb24gaXNDYWlwQWNjb3VudElkKHZhbHVlKSB7XG4gIHJldHVybiBfc3VwZXJzdHJ1Y3QuaXMuY2FsbCh2b2lkIDAsIHZhbHVlLCBDYWlwQWNjb3VudElkU3RydWN0KTtcbn1cbmZ1bmN0aW9uIGlzQ2FpcEFjY291bnRBZGRyZXNzKHZhbHVlKSB7XG4gIHJldHVybiBfc3VwZXJzdHJ1Y3QuaXMuY2FsbCh2b2lkIDAsIHZhbHVlLCBDYWlwQWNjb3VudEFkZHJlc3NTdHJ1Y3QpO1xufVxuZnVuY3Rpb24gcGFyc2VDYWlwQ2hhaW5JZChjYWlwQ2hhaW5JZCkge1xuICBjb25zdCBtYXRjaCA9IENBSVBfQ0hBSU5fSURfUkVHRVguZXhlYyhjYWlwQ2hhaW5JZCk7XG4gIGlmICghX29wdGlvbmFsQ2hhaW4oW21hdGNoLCAnb3B0aW9uYWxBY2Nlc3MnLCBfID0+IF8uZ3JvdXBzXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIENBSVAgY2hhaW4gSUQuXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZXNwYWNlOiBtYXRjaC5ncm91cHMubmFtZXNwYWNlLFxuICAgIHJlZmVyZW5jZTogbWF0Y2guZ3JvdXBzLnJlZmVyZW5jZVxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VDYWlwQWNjb3VudElkKGNhaXBBY2NvdW50SWQpIHtcbiAgY29uc3QgbWF0Y2ggPSBDQUlQX0FDQ09VTlRfSURfUkVHRVguZXhlYyhjYWlwQWNjb3VudElkKTtcbiAgaWYgKCFfb3B0aW9uYWxDaGFpbihbbWF0Y2gsICdvcHRpb25hbEFjY2VzcycsIF8yID0+IF8yLmdyb3Vwc10pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBDQUlQIGFjY291bnQgSUQuXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgYWRkcmVzczogbWF0Y2guZ3JvdXBzLmFjY291bnRBZGRyZXNzLFxuICAgIGNoYWluSWQ6IG1hdGNoLmdyb3Vwcy5jaGFpbklkLFxuICAgIGNoYWluOiB7XG4gICAgICBuYW1lc3BhY2U6IG1hdGNoLmdyb3Vwcy5uYW1lc3BhY2UsXG4gICAgICByZWZlcmVuY2U6IG1hdGNoLmdyb3Vwcy5yZWZlcmVuY2VcbiAgICB9XG4gIH07XG59XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmV4cG9ydHMuQ0FJUF9DSEFJTl9JRF9SRUdFWCA9IENBSVBfQ0hBSU5fSURfUkVHRVg7IGV4cG9ydHMuQ0FJUF9OQU1FU1BBQ0VfUkVHRVggPSBDQUlQX05BTUVTUEFDRV9SRUdFWDsgZXhwb3J0cy5DQUlQX1JFRkVSRU5DRV9SRUdFWCA9IENBSVBfUkVGRVJFTkNFX1JFR0VYOyBleHBvcnRzLkNBSVBfQUNDT1VOVF9JRF9SRUdFWCA9IENBSVBfQUNDT1VOVF9JRF9SRUdFWDsgZXhwb3J0cy5DQUlQX0FDQ09VTlRfQUREUkVTU19SRUdFWCA9IENBSVBfQUNDT1VOVF9BRERSRVNTX1JFR0VYOyBleHBvcnRzLkNhaXBDaGFpbklkU3RydWN0ID0gQ2FpcENoYWluSWRTdHJ1Y3Q7IGV4cG9ydHMuQ2FpcE5hbWVzcGFjZVN0cnVjdCA9IENhaXBOYW1lc3BhY2VTdHJ1Y3Q7IGV4cG9ydHMuQ2FpcFJlZmVyZW5jZVN0cnVjdCA9IENhaXBSZWZlcmVuY2VTdHJ1Y3Q7IGV4cG9ydHMuQ2FpcEFjY291bnRJZFN0cnVjdCA9IENhaXBBY2NvdW50SWRTdHJ1Y3Q7IGV4cG9ydHMuQ2FpcEFjY291bnRBZGRyZXNzU3RydWN0ID0gQ2FpcEFjY291bnRBZGRyZXNzU3RydWN0OyBleHBvcnRzLmlzQ2FpcENoYWluSWQgPSBpc0NhaXBDaGFpbklkOyBleHBvcnRzLmlzQ2FpcE5hbWVzcGFjZSA9IGlzQ2FpcE5hbWVzcGFjZTsgZXhwb3J0cy5pc0NhaXBSZWZlcmVuY2UgPSBpc0NhaXBSZWZlcmVuY2U7IGV4cG9ydHMuaXNDYWlwQWNjb3VudElkID0gaXNDYWlwQWNjb3VudElkOyBleHBvcnRzLmlzQ2FpcEFjY291bnRBZGRyZXNzID0gaXNDYWlwQWNjb3VudEFkZHJlc3M7IGV4cG9ydHMucGFyc2VDYWlwQ2hhaW5JZCA9IHBhcnNlQ2FpcENoYWluSWQ7IGV4cG9ydHMucGFyc2VDYWlwQWNjb3VudElkID0gcGFyc2VDYWlwQWNjb3VudElkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstVTdaVUdDRTcuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX29wdGlvbmFsQ2hhaW4iLCJvcHMiLCJsYXN0QWNjZXNzTEhTIiwidW5kZWZpbmVkIiwiaSIsImxlbmd0aCIsIm9wIiwiZm4iLCJhcmdzIiwiY2FsbCIsIl9zdXBlcnN0cnVjdCIsInJlcXVpcmUiLCJDQUlQX0NIQUlOX0lEX1JFR0VYIiwiQ0FJUF9OQU1FU1BBQ0VfUkVHRVgiLCJDQUlQX1JFRkVSRU5DRV9SRUdFWCIsIkNBSVBfQUNDT1VOVF9JRF9SRUdFWCIsIkNBSVBfQUNDT1VOVF9BRERSRVNTX1JFR0VYIiwiQ2FpcENoYWluSWRTdHJ1Y3QiLCJwYXR0ZXJuIiwic3RyaW5nIiwiQ2FpcE5hbWVzcGFjZVN0cnVjdCIsIkNhaXBSZWZlcmVuY2VTdHJ1Y3QiLCJDYWlwQWNjb3VudElkU3RydWN0IiwiQ2FpcEFjY291bnRBZGRyZXNzU3RydWN0IiwiaXNDYWlwQ2hhaW5JZCIsImlzIiwiaXNDYWlwTmFtZXNwYWNlIiwiaXNDYWlwUmVmZXJlbmNlIiwiaXNDYWlwQWNjb3VudElkIiwiaXNDYWlwQWNjb3VudEFkZHJlc3MiLCJwYXJzZUNhaXBDaGFpbklkIiwiY2FpcENoYWluSWQiLCJtYXRjaCIsImV4ZWMiLCJfIiwiZ3JvdXBzIiwiRXJyb3IiLCJuYW1lc3BhY2UiLCJyZWZlcmVuY2UiLCJwYXJzZUNhaXBBY2NvdW50SWQiLCJjYWlwQWNjb3VudElkIiwiXzIiLCJhZGRyZXNzIiwiYWNjb3VudEFkZHJlc3MiLCJjaGFpbklkIiwiY2hhaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/chunk-U7ZUGCE7.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/chunk-UOTVU7OQ.js":
/*!*************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/chunk-UOTVU7OQ.js ***!
  \*************************************************************/
/***/ (() => {

eval(" //# sourceMappingURL=chunk-UOTVU7OQ.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2h1bmstVU9UVlU3T1EuanMiLCJtYXBwaW5ncyI6IkFBQWEsMkNBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jaHVuay1VT1RWVTdPUS5qcz81Yzk4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiOy8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLVVPVFZVN09RLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/chunk-UOTVU7OQ.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/chunk-VFXTVNXN.js":
/*!*************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/chunk-VFXTVNXN.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _chunkQEPVHEP7js = __webpack_require__(/*! ./chunk-QEPVHEP7.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-QEPVHEP7.js\");\nvar _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js\");\n// src/number.ts\nvar numberToHex = (value)=>{\n    _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === \"number\", \"Value must be a number.\");\n    _chunk6ZDHSOUVjs.assert.call(void 0, value >= 0, \"Value must be a non-negative number.\");\n    _chunk6ZDHSOUVjs.assert.call(void 0, Number.isSafeInteger(value), \"Value is not a safe integer. Use `bigIntToHex` instead.\");\n    return _chunkQEPVHEP7js.add0x.call(void 0, value.toString(16));\n};\nvar bigIntToHex = (value)=>{\n    _chunk6ZDHSOUVjs.assert.call(void 0, typeof value === \"bigint\", \"Value must be a bigint.\");\n    _chunk6ZDHSOUVjs.assert.call(void 0, value >= 0, \"Value must be a non-negative bigint.\");\n    return _chunkQEPVHEP7js.add0x.call(void 0, value.toString(16));\n};\nvar hexToNumber = (value)=>{\n    _chunkQEPVHEP7js.assertIsHexString.call(void 0, value);\n    const numberValue = parseInt(value, 16);\n    _chunk6ZDHSOUVjs.assert.call(void 0, Number.isSafeInteger(numberValue), \"Value is not a safe integer. Use `hexToBigInt` instead.\");\n    return numberValue;\n};\nvar hexToBigInt = (value)=>{\n    _chunkQEPVHEP7js.assertIsHexString.call(void 0, value);\n    return BigInt(_chunkQEPVHEP7js.add0x.call(void 0, value));\n};\nexports.numberToHex = numberToHex;\nexports.bigIntToHex = bigIntToHex;\nexports.hexToNumber = hexToNumber;\nexports.hexToBigInt = hexToBigInt; //# sourceMappingURL=chunk-VFXTVNXN.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2h1bmstVkZYVFZOWE4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFBQUEsOENBQTZDO0lBQUNHLE9BQU87QUFBSSxDQUFDLEVBQUM7QUFHeEUsSUFBSUMsbUJBQW1CQyxtQkFBT0EsQ0FBQztBQUcvQixJQUFJQyxtQkFBbUJELG1CQUFPQSxDQUFDO0FBRS9CLGdCQUFnQjtBQUNoQixJQUFJRSxjQUFjLENBQUNKO0lBQ2pCRyxpQkFBaUJFLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDLEtBQUssR0FBRyxPQUFPTixVQUFVLFVBQVU7SUFDaEVHLGlCQUFpQkUsTUFBTSxDQUFDQyxJQUFJLENBQUMsS0FBSyxHQUFHTixTQUFTLEdBQUc7SUFDakRHLGlCQUFpQkUsTUFBTSxDQUFDQyxJQUFJLENBQUMsS0FBSyxHQUNoQ0MsT0FBT0MsYUFBYSxDQUFDUixRQUNyQjtJQUVGLE9BQU9DLGlCQUFpQlEsS0FBSyxDQUFDSCxJQUFJLENBQUMsS0FBSyxHQUFHTixNQUFNVSxRQUFRLENBQUM7QUFDNUQ7QUFDQSxJQUFJQyxjQUFjLENBQUNYO0lBQ2pCRyxpQkFBaUJFLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDLEtBQUssR0FBRyxPQUFPTixVQUFVLFVBQVU7SUFDaEVHLGlCQUFpQkUsTUFBTSxDQUFDQyxJQUFJLENBQUMsS0FBSyxHQUFHTixTQUFTLEdBQUc7SUFDakQsT0FBT0MsaUJBQWlCUSxLQUFLLENBQUNILElBQUksQ0FBQyxLQUFLLEdBQUdOLE1BQU1VLFFBQVEsQ0FBQztBQUM1RDtBQUNBLElBQUlFLGNBQWMsQ0FBQ1o7SUFDakJDLGlCQUFpQlksaUJBQWlCLENBQUNQLElBQUksQ0FBQyxLQUFLLEdBQUdOO0lBQ2hELE1BQU1jLGNBQWNDLFNBQVNmLE9BQU87SUFDcENHLGlCQUFpQkUsTUFBTSxDQUFDQyxJQUFJLENBQUMsS0FBSyxHQUNoQ0MsT0FBT0MsYUFBYSxDQUFDTSxjQUNyQjtJQUVGLE9BQU9BO0FBQ1Q7QUFDQSxJQUFJRSxjQUFjLENBQUNoQjtJQUNqQkMsaUJBQWlCWSxpQkFBaUIsQ0FBQ1AsSUFBSSxDQUFDLEtBQUssR0FBR047SUFDaEQsT0FBT2lCLE9BQU9oQixpQkFBaUJRLEtBQUssQ0FBQ0gsSUFBSSxDQUFDLEtBQUssR0FBR047QUFDcEQ7QUFPQUQsbUJBQW1CLEdBQUdLO0FBQWFMLG1CQUFtQixHQUFHWTtBQUFhWixtQkFBbUIsR0FBR2E7QUFBYWIsbUJBQW1CLEdBQUdpQixhQUMvSCwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NodW5rLVZGWFRWTlhOLmpzPzBkNDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcblxuXG52YXIgX2NodW5rUUVQVkhFUDdqcyA9IHJlcXVpcmUoJy4vY2h1bmstUUVQVkhFUDcuanMnKTtcblxuXG52YXIgX2NodW5rNlpESFNPVVZqcyA9IHJlcXVpcmUoJy4vY2h1bmstNlpESFNPVVYuanMnKTtcblxuLy8gc3JjL251bWJlci50c1xudmFyIG51bWJlclRvSGV4ID0gKHZhbHVlKSA9PiB7XG4gIF9jaHVuazZaREhTT1VWanMuYXNzZXJ0LmNhbGwodm9pZCAwLCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIsIFwiVmFsdWUgbXVzdCBiZSBhIG51bWJlci5cIik7XG4gIF9jaHVuazZaREhTT1VWanMuYXNzZXJ0LmNhbGwodm9pZCAwLCB2YWx1ZSA+PSAwLCBcIlZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLlwiKTtcbiAgX2NodW5rNlpESFNPVVZqcy5hc3NlcnQuY2FsbCh2b2lkIDAsIFxuICAgIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSxcbiAgICBcIlZhbHVlIGlzIG5vdCBhIHNhZmUgaW50ZWdlci4gVXNlIGBiaWdJbnRUb0hleGAgaW5zdGVhZC5cIlxuICApO1xuICByZXR1cm4gX2NodW5rUUVQVkhFUDdqcy5hZGQweC5jYWxsKHZvaWQgMCwgdmFsdWUudG9TdHJpbmcoMTYpKTtcbn07XG52YXIgYmlnSW50VG9IZXggPSAodmFsdWUpID0+IHtcbiAgX2NodW5rNlpESFNPVVZqcy5hc3NlcnQuY2FsbCh2b2lkIDAsIHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIiwgXCJWYWx1ZSBtdXN0IGJlIGEgYmlnaW50LlwiKTtcbiAgX2NodW5rNlpESFNPVVZqcy5hc3NlcnQuY2FsbCh2b2lkIDAsIHZhbHVlID49IDAsIFwiVmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBiaWdpbnQuXCIpO1xuICByZXR1cm4gX2NodW5rUUVQVkhFUDdqcy5hZGQweC5jYWxsKHZvaWQgMCwgdmFsdWUudG9TdHJpbmcoMTYpKTtcbn07XG52YXIgaGV4VG9OdW1iZXIgPSAodmFsdWUpID0+IHtcbiAgX2NodW5rUUVQVkhFUDdqcy5hc3NlcnRJc0hleFN0cmluZy5jYWxsKHZvaWQgMCwgdmFsdWUpO1xuICBjb25zdCBudW1iZXJWYWx1ZSA9IHBhcnNlSW50KHZhbHVlLCAxNik7XG4gIF9jaHVuazZaREhTT1VWanMuYXNzZXJ0LmNhbGwodm9pZCAwLCBcbiAgICBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXJWYWx1ZSksXG4gICAgXCJWYWx1ZSBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgaGV4VG9CaWdJbnRgIGluc3RlYWQuXCJcbiAgKTtcbiAgcmV0dXJuIG51bWJlclZhbHVlO1xufTtcbnZhciBoZXhUb0JpZ0ludCA9ICh2YWx1ZSkgPT4ge1xuICBfY2h1bmtRRVBWSEVQN2pzLmFzc2VydElzSGV4U3RyaW5nLmNhbGwodm9pZCAwLCB2YWx1ZSk7XG4gIHJldHVybiBCaWdJbnQoX2NodW5rUUVQVkhFUDdqcy5hZGQweC5jYWxsKHZvaWQgMCwgdmFsdWUpKTtcbn07XG5cblxuXG5cblxuXG5leHBvcnRzLm51bWJlclRvSGV4ID0gbnVtYmVyVG9IZXg7IGV4cG9ydHMuYmlnSW50VG9IZXggPSBiaWdJbnRUb0hleDsgZXhwb3J0cy5oZXhUb051bWJlciA9IGhleFRvTnVtYmVyOyBleHBvcnRzLmhleFRvQmlnSW50ID0gaGV4VG9CaWdJbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1WRlhUVk5YTi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfY2h1bmtRRVBWSEVQN2pzIiwicmVxdWlyZSIsIl9jaHVuazZaREhTT1VWanMiLCJudW1iZXJUb0hleCIsImFzc2VydCIsImNhbGwiLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiYWRkMHgiLCJ0b1N0cmluZyIsImJpZ0ludFRvSGV4IiwiaGV4VG9OdW1iZXIiLCJhc3NlcnRJc0hleFN0cmluZyIsIm51bWJlclZhbHVlIiwicGFyc2VJbnQiLCJoZXhUb0JpZ0ludCIsIkJpZ0ludCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/chunk-VFXTVNXN.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/chunk-Z2RGWDD7.js":
/*!*************************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/chunk-Z2RGWDD7.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _chunk3W5G4CYIjs = __webpack_require__(/*! ./chunk-3W5G4CYI.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-3W5G4CYI.js\");\n// src/collections.ts\nvar _map;\nvar FrozenMap = class {\n    constructor(entries){\n        _chunk3W5G4CYIjs.__privateAdd.call(void 0, this, _map, void 0);\n        _chunk3W5G4CYIjs.__privateSet.call(void 0, this, _map, new Map(entries));\n        Object.freeze(this);\n    }\n    get size() {\n        return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).size;\n    }\n    [Symbol.iterator]() {\n        return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map)[Symbol.iterator]();\n    }\n    entries() {\n        return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).entries();\n    }\n    forEach(callbackfn, thisArg) {\n        return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).forEach((value, key, _map2)=>callbackfn.call(thisArg, value, key, this));\n    }\n    get(key) {\n        return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).get(key);\n    }\n    has(key) {\n        return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).has(key);\n    }\n    keys() {\n        return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).keys();\n    }\n    values() {\n        return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _map).values();\n    }\n    toString() {\n        return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[\n            ...this.entries()\n        ].map(([key, value])=>`${String(key)} => ${String(value)}`).join(\", \")} ` : \"\"}}`;\n    }\n};\n_map = new WeakMap();\nvar _set;\nvar FrozenSet = class {\n    constructor(values){\n        _chunk3W5G4CYIjs.__privateAdd.call(void 0, this, _set, void 0);\n        _chunk3W5G4CYIjs.__privateSet.call(void 0, this, _set, new Set(values));\n        Object.freeze(this);\n    }\n    get size() {\n        return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).size;\n    }\n    [Symbol.iterator]() {\n        return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set)[Symbol.iterator]();\n    }\n    entries() {\n        return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).entries();\n    }\n    forEach(callbackfn, thisArg) {\n        return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).forEach((value, value2, _set2)=>callbackfn.call(thisArg, value, value2, this));\n    }\n    has(value) {\n        return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).has(value);\n    }\n    keys() {\n        return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).keys();\n    }\n    values() {\n        return _chunk3W5G4CYIjs.__privateGet.call(void 0, this, _set).values();\n    }\n    toString() {\n        return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[\n            ...this.values()\n        ].map((member)=>String(member)).join(\", \")} ` : \"\"}}`;\n    }\n};\n_set = new WeakMap();\nObject.freeze(FrozenMap);\nObject.freeze(FrozenMap.prototype);\nObject.freeze(FrozenSet);\nObject.freeze(FrozenSet.prototype);\nexports.FrozenMap = FrozenMap;\nexports.FrozenSet = FrozenSet; //# sourceMappingURL=chunk-Z2RGWDD7.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2h1bmstWjJSR1dERDcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFBQUEsOENBQTZDO0lBQUNHLE9BQU87QUFBSSxDQUFDLEVBQUM7QUFJeEUsSUFBSUMsbUJBQW1CQyxtQkFBT0EsQ0FBQztBQUUvQixxQkFBcUI7QUFDckIsSUFBSUM7QUFDSixJQUFJQyxZQUFZO0lBQ2RDLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQkwsaUJBQWlCTSxZQUFZLENBQUNDLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxFQUFFTCxNQUFNLEtBQUs7UUFDNURGLGlCQUFpQlEsWUFBWSxDQUFDRCxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksRUFBRUwsTUFBTSxJQUFJTyxJQUFJSjtRQUMvRFQsT0FBT2MsTUFBTSxDQUFDLElBQUk7SUFDcEI7SUFDQSxJQUFJQyxPQUFPO1FBQ1QsT0FBT1gsaUJBQWlCWSxZQUFZLENBQUNMLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxFQUFFTCxNQUFNUyxJQUFJO0lBQ3BFO0lBQ0EsQ0FBQ0UsT0FBT0MsUUFBUSxDQUFDLEdBQUc7UUFDbEIsT0FBT2QsaUJBQWlCWSxZQUFZLENBQUNMLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxFQUFFTCxLQUFLLENBQUNXLE9BQU9DLFFBQVEsQ0FBQztJQUNoRjtJQUNBVCxVQUFVO1FBQ1IsT0FBT0wsaUJBQWlCWSxZQUFZLENBQUNMLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxFQUFFTCxNQUFNRyxPQUFPO0lBQ3ZFO0lBQ0FVLFFBQVFDLFVBQVUsRUFBRUMsT0FBTyxFQUFFO1FBQzNCLE9BQU9qQixpQkFBaUJZLFlBQVksQ0FBQ0wsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLEVBQUVMLE1BQU1hLE9BQU8sQ0FDbkUsQ0FBQ2hCLE9BQU9tQixLQUFLQyxRQUFVSCxXQUFXVCxJQUFJLENBQUNVLFNBQVNsQixPQUFPbUIsS0FBSyxJQUFJO0lB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QUcsRUFBRSxJQUFJLENBQUNBLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFO2VBQUksSUFBSSxDQUFDWSxNQUFNO1NBQUcsQ0FBQ0UsR0FBRyxDQUFDLENBQUNTLFNBQVdSLE9BQU9RLFNBQVNQLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQ2pJO0FBQ0Y7QUFDQUUsT0FBTyxJQUFJRDtBQUNYaEMsT0FBT2MsTUFBTSxDQUFDUDtBQUNkUCxPQUFPYyxNQUFNLENBQUNQLFVBQVVnQyxTQUFTO0FBQ2pDdkMsT0FBT2MsTUFBTSxDQUFDb0I7QUFDZGxDLE9BQU9jLE1BQU0sQ0FBQ29CLFVBQVVLLFNBQVM7QUFLakNyQyxpQkFBaUIsR0FBR0s7QUFBV0wsaUJBQWlCLEdBQUdnQyxXQUNuRCwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NodW5rLVoyUkdXREQ3LmpzPzIwMmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcblxuXG5cbnZhciBfY2h1bmszVzVHNENZSWpzID0gcmVxdWlyZSgnLi9jaHVuay0zVzVHNENZSS5qcycpO1xuXG4vLyBzcmMvY29sbGVjdGlvbnMudHNcbnZhciBfbWFwO1xudmFyIEZyb3plbk1hcCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZW50cmllcykge1xuICAgIF9jaHVuazNXNUc0Q1lJanMuX19wcml2YXRlQWRkLmNhbGwodm9pZCAwLCB0aGlzLCBfbWFwLCB2b2lkIDApO1xuICAgIF9jaHVuazNXNUc0Q1lJanMuX19wcml2YXRlU2V0LmNhbGwodm9pZCAwLCB0aGlzLCBfbWFwLCBuZXcgTWFwKGVudHJpZXMpKTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiBfY2h1bmszVzVHNENZSWpzLl9fcHJpdmF0ZUdldC5jYWxsKHZvaWQgMCwgdGhpcywgX21hcCkuc2l6ZTtcbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gX2NodW5rM1c1RzRDWUlqcy5fX3ByaXZhdGVHZXQuY2FsbCh2b2lkIDAsIHRoaXMsIF9tYXApW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxuICBlbnRyaWVzKCkge1xuICAgIHJldHVybiBfY2h1bmszVzVHNENZSWpzLl9fcHJpdmF0ZUdldC5jYWxsKHZvaWQgMCwgdGhpcywgX21hcCkuZW50cmllcygpO1xuICB9XG4gIGZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBfY2h1bmszVzVHNENZSWpzLl9fcHJpdmF0ZUdldC5jYWxsKHZvaWQgMCwgdGhpcywgX21hcCkuZm9yRWFjaChcbiAgICAgICh2YWx1ZSwga2V5LCBfbWFwMikgPT4gY2FsbGJhY2tmbi5jYWxsKHRoaXNBcmcsIHZhbHVlLCBrZXksIHRoaXMpXG4gICAgKTtcbiAgfVxuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIF9jaHVuazNXNUc0Q1lJanMuX19wcml2YXRlR2V0LmNhbGwodm9pZCAwLCB0aGlzLCBfbWFwKS5nZXQoa2V5KTtcbiAgfVxuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIF9jaHVuazNXNUc0Q1lJanMuX19wcml2YXRlR2V0LmNhbGwodm9pZCAwLCB0aGlzLCBfbWFwKS5oYXMoa2V5KTtcbiAgfVxuICBrZXlzKCkge1xuICAgIHJldHVybiBfY2h1bmszVzVHNENZSWpzLl9fcHJpdmF0ZUdldC5jYWxsKHZvaWQgMCwgdGhpcywgX21hcCkua2V5cygpO1xuICB9XG4gIHZhbHVlcygpIHtcbiAgICByZXR1cm4gX2NodW5rM1c1RzRDWUlqcy5fX3ByaXZhdGVHZXQuY2FsbCh2b2lkIDAsIHRoaXMsIF9tYXApLnZhbHVlcygpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgRnJvemVuTWFwKCR7dGhpcy5zaXplfSkgeyR7dGhpcy5zaXplID4gMCA/IGAgJHtbLi4udGhpcy5lbnRyaWVzKCldLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgJHtTdHJpbmcoa2V5KX0gPT4gJHtTdHJpbmcodmFsdWUpfWApLmpvaW4oXCIsIFwiKX0gYCA6IFwiXCJ9fWA7XG4gIH1cbn07XG5fbWFwID0gbmV3IFdlYWtNYXAoKTtcbnZhciBfc2V0O1xudmFyIEZyb3plblNldCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodmFsdWVzKSB7XG4gICAgX2NodW5rM1c1RzRDWUlqcy5fX3ByaXZhdGVBZGQuY2FsbCh2b2lkIDAsIHRoaXMsIF9zZXQsIHZvaWQgMCk7XG4gICAgX2NodW5rM1c1RzRDWUlqcy5fX3ByaXZhdGVTZXQuY2FsbCh2b2lkIDAsIHRoaXMsIF9zZXQsIG5ldyBTZXQodmFsdWVzKSk7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gX2NodW5rM1c1RzRDWUlqcy5fX3ByaXZhdGVHZXQuY2FsbCh2b2lkIDAsIHRoaXMsIF9zZXQpLnNpemU7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIF9jaHVuazNXNUc0Q1lJanMuX19wcml2YXRlR2V0LmNhbGwodm9pZCAwLCB0aGlzLCBfc2V0KVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cbiAgZW50cmllcygpIHtcbiAgICByZXR1cm4gX2NodW5rM1c1RzRDWUlqcy5fX3ByaXZhdGVHZXQuY2FsbCh2b2lkIDAsIHRoaXMsIF9zZXQpLmVudHJpZXMoKTtcbiAgfVxuICBmb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gX2NodW5rM1c1RzRDWUlqcy5fX3ByaXZhdGVHZXQuY2FsbCh2b2lkIDAsIHRoaXMsIF9zZXQpLmZvckVhY2goXG4gICAgICAodmFsdWUsIHZhbHVlMiwgX3NldDIpID0+IGNhbGxiYWNrZm4uY2FsbCh0aGlzQXJnLCB2YWx1ZSwgdmFsdWUyLCB0aGlzKVxuICAgICk7XG4gIH1cbiAgaGFzKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9jaHVuazNXNUc0Q1lJanMuX19wcml2YXRlR2V0LmNhbGwodm9pZCAwLCB0aGlzLCBfc2V0KS5oYXModmFsdWUpO1xuICB9XG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIF9jaHVuazNXNUc0Q1lJanMuX19wcml2YXRlR2V0LmNhbGwodm9pZCAwLCB0aGlzLCBfc2V0KS5rZXlzKCk7XG4gIH1cbiAgdmFsdWVzKCkge1xuICAgIHJldHVybiBfY2h1bmszVzVHNENZSWpzLl9fcHJpdmF0ZUdldC5jYWxsKHZvaWQgMCwgdGhpcywgX3NldCkudmFsdWVzKCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBGcm96ZW5TZXQoJHt0aGlzLnNpemV9KSB7JHt0aGlzLnNpemUgPiAwID8gYCAke1suLi50aGlzLnZhbHVlcygpXS5tYXAoKG1lbWJlcikgPT4gU3RyaW5nKG1lbWJlcikpLmpvaW4oXCIsIFwiKX0gYCA6IFwiXCJ9fWA7XG4gIH1cbn07XG5fc2V0ID0gbmV3IFdlYWtNYXAoKTtcbk9iamVjdC5mcmVlemUoRnJvemVuTWFwKTtcbk9iamVjdC5mcmVlemUoRnJvemVuTWFwLnByb3RvdHlwZSk7XG5PYmplY3QuZnJlZXplKEZyb3plblNldCk7XG5PYmplY3QuZnJlZXplKEZyb3plblNldC5wcm90b3R5cGUpO1xuXG5cblxuXG5leHBvcnRzLkZyb3plbk1hcCA9IEZyb3plbk1hcDsgZXhwb3J0cy5Gcm96ZW5TZXQgPSBGcm96ZW5TZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1aMlJHV0RENy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfY2h1bmszVzVHNENZSWpzIiwicmVxdWlyZSIsIl9tYXAiLCJGcm96ZW5NYXAiLCJjb25zdHJ1Y3RvciIsImVudHJpZXMiLCJfX3ByaXZhdGVBZGQiLCJjYWxsIiwiX19wcml2YXRlU2V0IiwiTWFwIiwiZnJlZXplIiwic2l6ZSIsIl9fcHJpdmF0ZUdldCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiZm9yRWFjaCIsImNhbGxiYWNrZm4iLCJ0aGlzQXJnIiwia2V5IiwiX21hcDIiLCJnZXQiLCJoYXMiLCJrZXlzIiwidmFsdWVzIiwidG9TdHJpbmciLCJtYXAiLCJTdHJpbmciLCJqb2luIiwiV2Vha01hcCIsIl9zZXQiLCJGcm96ZW5TZXQiLCJTZXQiLCJ2YWx1ZTIiLCJfc2V0MiIsIm1lbWJlciIsInByb3RvdHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/chunk-Z2RGWDD7.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@metamask/utils/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@metamask/utils/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n__webpack_require__(/*! ./chunk-2TBCL6EF.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-2TBCL6EF.js\");\nvar _chunkVFXTVNXNjs = __webpack_require__(/*! ./chunk-VFXTVNXN.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-VFXTVNXN.js\");\n__webpack_require__(/*! ./chunk-LC2CRSWD.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-LC2CRSWD.js\");\nvar _chunk4RMX5YWEjs = __webpack_require__(/*! ./chunk-4RMX5YWE.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-4RMX5YWE.js\");\n__webpack_require__(/*! ./chunk-UOTVU7OQ.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-UOTVU7OQ.js\");\nvar _chunk4D6XQBHAjs = __webpack_require__(/*! ./chunk-4D6XQBHA.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-4D6XQBHA.js\");\nvar _chunkOLLG4H35js = __webpack_require__(/*! ./chunk-OLLG4H35.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-OLLG4H35.js\");\n__webpack_require__(/*! ./chunk-RKRGAFXY.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-RKRGAFXY.js\");\nvar _chunk2LBGT4GHjs = __webpack_require__(/*! ./chunk-2LBGT4GH.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-2LBGT4GH.js\");\nvar _chunkU7ZUGCE7js = __webpack_require__(/*! ./chunk-U7ZUGCE7.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-U7ZUGCE7.js\");\nvar _chunkE4C7EW4Rjs = __webpack_require__(/*! ./chunk-E4C7EW4R.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-E4C7EW4R.js\");\nvar _chunk6NZW4WK4js = __webpack_require__(/*! ./chunk-6NZW4WK4.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-6NZW4WK4.js\");\nvar _chunkDHVKFDHQjs = __webpack_require__(/*! ./chunk-DHVKFDHQ.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-DHVKFDHQ.js\");\nvar _chunkQEPVHEP7js = __webpack_require__(/*! ./chunk-QEPVHEP7.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-QEPVHEP7.js\");\nvar _chunk6ZDHSOUVjs = __webpack_require__(/*! ./chunk-6ZDHSOUV.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-6ZDHSOUV.js\");\nvar _chunkIZC266HSjs = __webpack_require__(/*! ./chunk-IZC266HS.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-IZC266HS.js\");\nvar _chunkQVEKZRZ2js = __webpack_require__(/*! ./chunk-QVEKZRZ2.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-QVEKZRZ2.js\");\nvar _chunkZ2RGWDD7js = __webpack_require__(/*! ./chunk-Z2RGWDD7.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-Z2RGWDD7.js\");\n__webpack_require__(/*! ./chunk-3W5G4CYI.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-3W5G4CYI.js\");\n__webpack_require__(/*! ./chunk-EQMZL4XU.js */ \"(ssr)/./node_modules/@metamask/utils/dist/chunk-EQMZL4XU.js\");\nexports.AssertionError = _chunk6ZDHSOUVjs.AssertionError;\nexports.CAIP_ACCOUNT_ADDRESS_REGEX = _chunkU7ZUGCE7js.CAIP_ACCOUNT_ADDRESS_REGEX;\nexports.CAIP_ACCOUNT_ID_REGEX = _chunkU7ZUGCE7js.CAIP_ACCOUNT_ID_REGEX;\nexports.CAIP_CHAIN_ID_REGEX = _chunkU7ZUGCE7js.CAIP_CHAIN_ID_REGEX;\nexports.CAIP_NAMESPACE_REGEX = _chunkU7ZUGCE7js.CAIP_NAMESPACE_REGEX;\nexports.CAIP_REFERENCE_REGEX = _chunkU7ZUGCE7js.CAIP_REFERENCE_REGEX;\nexports.CaipAccountAddressStruct = _chunkU7ZUGCE7js.CaipAccountAddressStruct;\nexports.CaipAccountIdStruct = _chunkU7ZUGCE7js.CaipAccountIdStruct;\nexports.CaipChainIdStruct = _chunkU7ZUGCE7js.CaipChainIdStruct;\nexports.CaipNamespaceStruct = _chunkU7ZUGCE7js.CaipNamespaceStruct;\nexports.CaipReferenceStruct = _chunkU7ZUGCE7js.CaipReferenceStruct;\nexports.ChecksumStruct = _chunkE4C7EW4Rjs.ChecksumStruct;\nexports.Duration = _chunk4RMX5YWEjs.Duration;\nexports.ESCAPE_CHARACTERS_REGEXP = _chunkQVEKZRZ2js.ESCAPE_CHARACTERS_REGEXP;\nexports.FrozenMap = _chunkZ2RGWDD7js.FrozenMap;\nexports.FrozenSet = _chunkZ2RGWDD7js.FrozenSet;\nexports.HexAddressStruct = _chunkQEPVHEP7js.HexAddressStruct;\nexports.HexChecksumAddressStruct = _chunkQEPVHEP7js.HexChecksumAddressStruct;\nexports.HexStruct = _chunkQEPVHEP7js.HexStruct;\nexports.JsonRpcErrorStruct = _chunkOLLG4H35js.JsonRpcErrorStruct;\nexports.JsonRpcFailureStruct = _chunkOLLG4H35js.JsonRpcFailureStruct;\nexports.JsonRpcIdStruct = _chunkOLLG4H35js.JsonRpcIdStruct;\nexports.JsonRpcNotificationStruct = _chunkOLLG4H35js.JsonRpcNotificationStruct;\nexports.JsonRpcParamsStruct = _chunkOLLG4H35js.JsonRpcParamsStruct;\nexports.JsonRpcRequestStruct = _chunkOLLG4H35js.JsonRpcRequestStruct;\nexports.JsonRpcResponseStruct = _chunkOLLG4H35js.JsonRpcResponseStruct;\nexports.JsonRpcSuccessStruct = _chunkOLLG4H35js.JsonRpcSuccessStruct;\nexports.JsonRpcVersionStruct = _chunkOLLG4H35js.JsonRpcVersionStruct;\nexports.JsonSize = _chunkQVEKZRZ2js.JsonSize;\nexports.JsonStruct = _chunkOLLG4H35js.JsonStruct;\nexports.PendingJsonRpcResponseStruct = _chunkOLLG4H35js.PendingJsonRpcResponseStruct;\nexports.StrictHexStruct = _chunkQEPVHEP7js.StrictHexStruct;\nexports.UnsafeJsonStruct = _chunkOLLG4H35js.UnsafeJsonStruct;\nexports.VersionRangeStruct = _chunk4D6XQBHAjs.VersionRangeStruct;\nexports.VersionStruct = _chunk4D6XQBHAjs.VersionStruct;\nexports.add0x = _chunkQEPVHEP7js.add0x;\nexports.assert = _chunk6ZDHSOUVjs.assert;\nexports.assertExhaustive = _chunk6ZDHSOUVjs.assertExhaustive;\nexports.assertIsBytes = _chunkQEPVHEP7js.assertIsBytes;\nexports.assertIsHexString = _chunkQEPVHEP7js.assertIsHexString;\nexports.assertIsJsonRpcError = _chunkOLLG4H35js.assertIsJsonRpcError;\nexports.assertIsJsonRpcFailure = _chunkOLLG4H35js.assertIsJsonRpcFailure;\nexports.assertIsJsonRpcNotification = _chunkOLLG4H35js.assertIsJsonRpcNotification;\nexports.assertIsJsonRpcRequest = _chunkOLLG4H35js.assertIsJsonRpcRequest;\nexports.assertIsJsonRpcResponse = _chunkOLLG4H35js.assertIsJsonRpcResponse;\nexports.assertIsJsonRpcSuccess = _chunkOLLG4H35js.assertIsJsonRpcSuccess;\nexports.assertIsPendingJsonRpcResponse = _chunkOLLG4H35js.assertIsPendingJsonRpcResponse;\nexports.assertIsSemVerRange = _chunk4D6XQBHAjs.assertIsSemVerRange;\nexports.assertIsSemVerVersion = _chunk4D6XQBHAjs.assertIsSemVerVersion;\nexports.assertIsStrictHexString = _chunkQEPVHEP7js.assertIsStrictHexString;\nexports.assertStruct = _chunk6ZDHSOUVjs.assertStruct;\nexports.base64 = _chunk6NZW4WK4js.base64;\nexports.base64ToBytes = _chunkQEPVHEP7js.base64ToBytes;\nexports.bigIntToBytes = _chunkQEPVHEP7js.bigIntToBytes;\nexports.bigIntToHex = _chunkVFXTVNXNjs.bigIntToHex;\nexports.bytesToBase64 = _chunkQEPVHEP7js.bytesToBase64;\nexports.bytesToBigInt = _chunkQEPVHEP7js.bytesToBigInt;\nexports.bytesToHex = _chunkQEPVHEP7js.bytesToHex;\nexports.bytesToNumber = _chunkQEPVHEP7js.bytesToNumber;\nexports.bytesToSignedBigInt = _chunkQEPVHEP7js.bytesToSignedBigInt;\nexports.bytesToString = _chunkQEPVHEP7js.bytesToString;\nexports.calculateNumberSize = _chunkQVEKZRZ2js.calculateNumberSize;\nexports.calculateStringSize = _chunkQVEKZRZ2js.calculateStringSize;\nexports.concatBytes = _chunkQEPVHEP7js.concatBytes;\nexports.createBigInt = _chunkDHVKFDHQjs.createBigInt;\nexports.createBytes = _chunkDHVKFDHQjs.createBytes;\nexports.createDataView = _chunkQEPVHEP7js.createDataView;\nexports.createHex = _chunkDHVKFDHQjs.createHex;\nexports.createModuleLogger = _chunk2LBGT4GHjs.createModuleLogger;\nexports.createNumber = _chunkDHVKFDHQjs.createNumber;\nexports.createProjectLogger = _chunk2LBGT4GHjs.createProjectLogger;\nexports.exactOptional = _chunkOLLG4H35js.exactOptional;\nexports.getChecksumAddress = _chunkQEPVHEP7js.getChecksumAddress;\nexports.getErrorMessage = _chunkIZC266HSjs.getErrorMessage;\nexports.getJsonRpcIdValidator = _chunkOLLG4H35js.getJsonRpcIdValidator;\nexports.getJsonSize = _chunkOLLG4H35js.getJsonSize;\nexports.getKnownPropertyNames = _chunkQVEKZRZ2js.getKnownPropertyNames;\nexports.getSafeJson = _chunkOLLG4H35js.getSafeJson;\nexports.gtRange = _chunk4D6XQBHAjs.gtRange;\nexports.gtVersion = _chunk4D6XQBHAjs.gtVersion;\nexports.hasProperty = _chunkQVEKZRZ2js.hasProperty;\nexports.hexToBigInt = _chunkVFXTVNXNjs.hexToBigInt;\nexports.hexToBytes = _chunkQEPVHEP7js.hexToBytes;\nexports.hexToNumber = _chunkVFXTVNXNjs.hexToNumber;\nexports.inMilliseconds = _chunk4RMX5YWEjs.inMilliseconds;\nexports.isASCII = _chunkQVEKZRZ2js.isASCII;\nexports.isBytes = _chunkQEPVHEP7js.isBytes;\nexports.isCaipAccountAddress = _chunkU7ZUGCE7js.isCaipAccountAddress;\nexports.isCaipAccountId = _chunkU7ZUGCE7js.isCaipAccountId;\nexports.isCaipChainId = _chunkU7ZUGCE7js.isCaipChainId;\nexports.isCaipNamespace = _chunkU7ZUGCE7js.isCaipNamespace;\nexports.isCaipReference = _chunkU7ZUGCE7js.isCaipReference;\nexports.isErrorWithCode = _chunkIZC266HSjs.isErrorWithCode;\nexports.isErrorWithMessage = _chunkIZC266HSjs.isErrorWithMessage;\nexports.isErrorWithStack = _chunkIZC266HSjs.isErrorWithStack;\nexports.isHexString = _chunkQEPVHEP7js.isHexString;\nexports.isJsonRpcError = _chunkOLLG4H35js.isJsonRpcError;\nexports.isJsonRpcFailure = _chunkOLLG4H35js.isJsonRpcFailure;\nexports.isJsonRpcNotification = _chunkOLLG4H35js.isJsonRpcNotification;\nexports.isJsonRpcRequest = _chunkOLLG4H35js.isJsonRpcRequest;\nexports.isJsonRpcResponse = _chunkOLLG4H35js.isJsonRpcResponse;\nexports.isJsonRpcSuccess = _chunkOLLG4H35js.isJsonRpcSuccess;\nexports.isNonEmptyArray = _chunkQVEKZRZ2js.isNonEmptyArray;\nexports.isNullOrUndefined = _chunkQVEKZRZ2js.isNullOrUndefined;\nexports.isObject = _chunkQVEKZRZ2js.isObject;\nexports.isPendingJsonRpcResponse = _chunkOLLG4H35js.isPendingJsonRpcResponse;\nexports.isPlainObject = _chunkQVEKZRZ2js.isPlainObject;\nexports.isStrictHexString = _chunkQEPVHEP7js.isStrictHexString;\nexports.isValidChecksumAddress = _chunkQEPVHEP7js.isValidChecksumAddress;\nexports.isValidHexAddress = _chunkQEPVHEP7js.isValidHexAddress;\nexports.isValidJson = _chunkOLLG4H35js.isValidJson;\nexports.isValidSemVerRange = _chunk4D6XQBHAjs.isValidSemVerRange;\nexports.isValidSemVerVersion = _chunk4D6XQBHAjs.isValidSemVerVersion;\nexports.jsonrpc2 = _chunkOLLG4H35js.jsonrpc2;\nexports.numberToBytes = _chunkQEPVHEP7js.numberToBytes;\nexports.numberToHex = _chunkVFXTVNXNjs.numberToHex;\nexports.object = _chunkOLLG4H35js.object;\nexports.parseCaipAccountId = _chunkU7ZUGCE7js.parseCaipAccountId;\nexports.parseCaipChainId = _chunkU7ZUGCE7js.parseCaipChainId;\nexports.remove0x = _chunkQEPVHEP7js.remove0x;\nexports.satisfiesVersionRange = _chunk4D6XQBHAjs.satisfiesVersionRange;\nexports.signedBigIntToBytes = _chunkQEPVHEP7js.signedBigIntToBytes;\nexports.stringToBytes = _chunkQEPVHEP7js.stringToBytes;\nexports.timeSince = _chunk4RMX5YWEjs.timeSince;\nexports.valueToBytes = _chunkQEPVHEP7js.valueToBytes;\nexports.wrapError = _chunkIZC266HSjs.wrapError; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFBQUEsOENBQTZDO0lBQUNHLE9BQU87QUFBSSxDQUFDLEVBQUM7QUFBQ0MsbUJBQU9BLENBQUM7QUFNakYsSUFBSUMsbUJBQW1CRCxtQkFBT0EsQ0FBQztBQUMvQkEsbUJBQU9BLENBQUM7QUFLUixJQUFJRSxtQkFBbUJGLG1CQUFPQSxDQUFDO0FBQy9CQSxtQkFBT0EsQ0FBQztBQVdSLElBQUlHLG1CQUFtQkgsbUJBQU9BLENBQUM7QUFtQy9CLElBQUlJLG1CQUFtQkosbUJBQU9BLENBQUM7QUFDL0JBLG1CQUFPQSxDQUFDO0FBSVIsSUFBSUssbUJBQW1CTCxtQkFBT0EsQ0FBQztBQW1CL0IsSUFBSU0sbUJBQW1CTixtQkFBT0EsQ0FBQztBQUcvQixJQUFJTyxtQkFBbUJQLG1CQUFPQSxDQUFDO0FBRy9CLElBQUlRLG1CQUFtQlIsbUJBQU9BLENBQUM7QUFNL0IsSUFBSVMsbUJBQW1CVCxtQkFBT0EsQ0FBQztBQWdDL0IsSUFBSVUsbUJBQW1CVixtQkFBT0EsQ0FBQztBQU0vQixJQUFJVyxtQkFBbUJYLG1CQUFPQSxDQUFDO0FBTy9CLElBQUlZLG1CQUFtQlosbUJBQU9BLENBQUM7QUFhL0IsSUFBSWEsbUJBQW1CYixtQkFBT0EsQ0FBQztBQUkvQixJQUFJYyxtQkFBbUJkLG1CQUFPQSxDQUFDO0FBQy9CQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQWdJUkYsc0JBQXNCLEdBQUdhLGlCQUFpQkksY0FBYztBQUFFakIsa0NBQWtDLEdBQUdRLGlCQUFpQlUsMEJBQTBCO0FBQUVsQiw2QkFBNkIsR0FBR1EsaUJBQWlCVyxxQkFBcUI7QUFBRW5CLDJCQUEyQixHQUFHUSxpQkFBaUJZLG1CQUFtQjtBQUFFcEIsNEJBQTRCLEdBQUdRLGlCQUFpQmEsb0JBQW9CO0FBQUVyQiw0QkFBNEIsR0FBR1EsaUJBQWlCYyxvQkFBb0I7QUFB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QixHQUFHWSxpQkFBaUJrSCxpQkFBaUI7QUFBRTlILG1CQUFtQixHQUFHTSxpQkFBaUJ5SCxXQUFXO0FBQUUvSCwwQkFBMEIsR0FBR0ssaUJBQWlCMkgsa0JBQWtCO0FBQUVoSSw0QkFBNEIsR0FBR0ssaUJBQWlCNEgsb0JBQW9CO0FBQUVqSSxnQkFBZ0IsR0FBR00saUJBQWlCNEgsUUFBUTtBQUFFbEkscUJBQXFCLEdBQUdZLGlCQUFpQnVILGFBQWE7QUFBRW5JLG1CQUFtQixHQUFHRyxpQkFBaUJpSSxXQUFXO0FBQUVwSSxjQUFjLEdBQUdNLGlCQUFpQitILE1BQU07QUFBRXJJLDBCQUEwQixHQUFHUSxpQkFBaUI4SCxrQkFBa0I7QUFBRXRJLHdCQUF3QixHQUFHUSxpQkFBaUIrSCxnQkFBZ0I7QUFBRXZJLGdCQUFnQixHQUFHWSxpQkFBaUI0SCxRQUFRO0FBQUV4SSw2QkFBNkIsR0FBR0ssaUJBQWlCb0kscUJBQXFCO0FBQUV6SSwyQkFBMkIsR0FBR1ksaUJBQWlCOEgsbUJBQW1CO0FBQUUxSSxxQkFBcUIsR0FBR1ksaUJBQWlCK0gsYUFBYTtBQUFFM0ksaUJBQWlCLEdBQUdJLGlCQUFpQndJLFNBQVM7QUFBRTVJLG9CQUFvQixHQUFHWSxpQkFBaUJpSSxZQUFZO0FBQUU3SSxpQkFBaUIsR0FBR2MsaUJBQWlCZ0ksU0FBUyxFQUN4aFAsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9pbmRleC5qcz8yZGYwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7cmVxdWlyZSgnLi9jaHVuay0yVEJDTDZFRi5qcycpO1xuXG5cblxuXG5cbnZhciBfY2h1bmtWRlhUVk5YTmpzID0gcmVxdWlyZSgnLi9jaHVuay1WRlhUVk5YTi5qcycpO1xucmVxdWlyZSgnLi9jaHVuay1MQzJDUlNXRC5qcycpO1xuXG5cblxuXG52YXIgX2NodW5rNFJNWDVZV0VqcyA9IHJlcXVpcmUoJy4vY2h1bmstNFJNWDVZV0UuanMnKTtcbnJlcXVpcmUoJy4vY2h1bmstVU9UVlU3T1EuanMnKTtcblxuXG5cblxuXG5cblxuXG5cblxudmFyIF9jaHVuazRENlhRQkhBanMgPSByZXF1aXJlKCcuL2NodW5rLTRENlhRQkhBLmpzJyk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBfY2h1bmtPTExHNEgzNWpzID0gcmVxdWlyZSgnLi9jaHVuay1PTExHNEgzNS5qcycpO1xucmVxdWlyZSgnLi9jaHVuay1SS1JHQUZYWS5qcycpO1xuXG5cblxudmFyIF9jaHVuazJMQkdUNEdIanMgPSByZXF1aXJlKCcuL2NodW5rLTJMQkdUNEdILmpzJyk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgX2NodW5rVTdaVUdDRTdqcyA9IHJlcXVpcmUoJy4vY2h1bmstVTdaVUdDRTcuanMnKTtcblxuXG52YXIgX2NodW5rRTRDN0VXNFJqcyA9IHJlcXVpcmUoJy4vY2h1bmstRTRDN0VXNFIuanMnKTtcblxuXG52YXIgX2NodW5rNk5aVzRXSzRqcyA9IHJlcXVpcmUoJy4vY2h1bmstNk5aVzRXSzQuanMnKTtcblxuXG5cblxuXG52YXIgX2NodW5rREhWS0ZESFFqcyA9IHJlcXVpcmUoJy4vY2h1bmstREhWS0ZESFEuanMnKTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIF9jaHVua1FFUFZIRVA3anMgPSByZXF1aXJlKCcuL2NodW5rLVFFUFZIRVA3LmpzJyk7XG5cblxuXG5cblxudmFyIF9jaHVuazZaREhTT1VWanMgPSByZXF1aXJlKCcuL2NodW5rLTZaREhTT1VWLmpzJyk7XG5cblxuXG5cblxuXG52YXIgX2NodW5rSVpDMjY2SFNqcyA9IHJlcXVpcmUoJy4vY2h1bmstSVpDMjY2SFMuanMnKTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBfY2h1bmtRVkVLWlJaMmpzID0gcmVxdWlyZSgnLi9jaHVuay1RVkVLWlJaMi5qcycpO1xuXG5cblxudmFyIF9jaHVua1oyUkdXREQ3anMgPSByZXF1aXJlKCcuL2NodW5rLVoyUkdXREQ3LmpzJyk7XG5yZXF1aXJlKCcuL2NodW5rLTNXNUc0Q1lJLmpzJyk7XG5yZXF1aXJlKCcuL2NodW5rLUVRTVpMNFhVLmpzJyk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSBfY2h1bms2WkRIU09VVmpzLkFzc2VydGlvbkVycm9yOyBleHBvcnRzLkNBSVBfQUNDT1VOVF9BRERSRVNTX1JFR0VYID0gX2NodW5rVTdaVUdDRTdqcy5DQUlQX0FDQ09VTlRfQUREUkVTU19SRUdFWDsgZXhwb3J0cy5DQUlQX0FDQ09VTlRfSURfUkVHRVggPSBfY2h1bmtVN1pVR0NFN2pzLkNBSVBfQUNDT1VOVF9JRF9SRUdFWDsgZXhwb3J0cy5DQUlQX0NIQUlOX0lEX1JFR0VYID0gX2NodW5rVTdaVUdDRTdqcy5DQUlQX0NIQUlOX0lEX1JFR0VYOyBleHBvcnRzLkNBSVBfTkFNRVNQQUNFX1JFR0VYID0gX2NodW5rVTdaVUdDRTdqcy5DQUlQX05BTUVTUEFDRV9SRUdFWDsgZXhwb3J0cy5DQUlQX1JFRkVSRU5DRV9SRUdFWCA9IF9jaHVua1U3WlVHQ0U3anMuQ0FJUF9SRUZFUkVOQ0VfUkVHRVg7IGV4cG9ydHMuQ2FpcEFjY291bnRBZGRyZXNzU3RydWN0ID0gX2NodW5rVTdaVUdDRTdqcy5DYWlwQWNjb3VudEFkZHJlc3NTdHJ1Y3Q7IGV4cG9ydHMuQ2FpcEFjY291bnRJZFN0cnVjdCA9IF9jaHVua1U3WlVHQ0U3anMuQ2FpcEFjY291bnRJZFN0cnVjdDsgZXhwb3J0cy5DYWlwQ2hhaW5JZFN0cnVjdCA9IF9jaHVua1U3WlVHQ0U3anMuQ2FpcENoYWluSWRTdHJ1Y3Q7IGV4cG9ydHMuQ2FpcE5hbWVzcGFjZVN0cnVjdCA9IF9jaHVua1U3WlVHQ0U3anMuQ2FpcE5hbWVzcGFjZVN0cnVjdDsgZXhwb3J0cy5DYWlwUmVmZXJlbmNlU3RydWN0ID0gX2NodW5rVTdaVUdDRTdqcy5DYWlwUmVmZXJlbmNlU3RydWN0OyBleHBvcnRzLkNoZWNrc3VtU3RydWN0ID0gX2NodW5rRTRDN0VXNFJqcy5DaGVja3N1bVN0cnVjdDsgZXhwb3J0cy5EdXJhdGlvbiA9IF9jaHVuazRSTVg1WVdFanMuRHVyYXRpb247IGV4cG9ydHMuRVNDQVBFX0NIQVJBQ1RFUlNfUkVHRVhQID0gX2NodW5rUVZFS1pSWjJqcy5FU0NBUEVfQ0hBUkFDVEVSU19SRUdFWFA7IGV4cG9ydHMuRnJvemVuTWFwID0gX2NodW5rWjJSR1dERDdqcy5Gcm96ZW5NYXA7IGV4cG9ydHMuRnJvemVuU2V0ID0gX2NodW5rWjJSR1dERDdqcy5Gcm96ZW5TZXQ7IGV4cG9ydHMuSGV4QWRkcmVzc1N0cnVjdCA9IF9jaHVua1FFUFZIRVA3anMuSGV4QWRkcmVzc1N0cnVjdDsgZXhwb3J0cy5IZXhDaGVja3N1bUFkZHJlc3NTdHJ1Y3QgPSBfY2h1bmtRRVBWSEVQN2pzLkhleENoZWNrc3VtQWRkcmVzc1N0cnVjdDsgZXhwb3J0cy5IZXhTdHJ1Y3QgPSBfY2h1bmtRRVBWSEVQN2pzLkhleFN0cnVjdDsgZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QgPSBfY2h1bmtPTExHNEgzNWpzLkpzb25ScGNFcnJvclN0cnVjdDsgZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCA9IF9jaHVua09MTEc0SDM1anMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3Q7IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0ID0gX2NodW5rT0xMRzRIMzVqcy5Kc29uUnBjSWRTdHJ1Y3Q7IGV4cG9ydHMuSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCA9IF9jaHVua09MTEc0SDM1anMuSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdDsgZXhwb3J0cy5Kc29uUnBjUGFyYW1zU3RydWN0ID0gX2NodW5rT0xMRzRIMzVqcy5Kc29uUnBjUGFyYW1zU3RydWN0OyBleHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0ID0gX2NodW5rT0xMRzRIMzVqcy5Kc29uUnBjUmVxdWVzdFN0cnVjdDsgZXhwb3J0cy5Kc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSBfY2h1bmtPTExHNEgzNWpzLkpzb25ScGNSZXNwb25zZVN0cnVjdDsgZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCA9IF9jaHVua09MTEc0SDM1anMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3Q7IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QgPSBfY2h1bmtPTExHNEgzNWpzLkpzb25ScGNWZXJzaW9uU3RydWN0OyBleHBvcnRzLkpzb25TaXplID0gX2NodW5rUVZFS1pSWjJqcy5Kc29uU2l6ZTsgZXhwb3J0cy5Kc29uU3RydWN0ID0gX2NodW5rT0xMRzRIMzVqcy5Kc29uU3RydWN0OyBleHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSBfY2h1bmtPTExHNEgzNWpzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3Q7IGV4cG9ydHMuU3RyaWN0SGV4U3RydWN0ID0gX2NodW5rUUVQVkhFUDdqcy5TdHJpY3RIZXhTdHJ1Y3Q7IGV4cG9ydHMuVW5zYWZlSnNvblN0cnVjdCA9IF9jaHVua09MTEc0SDM1anMuVW5zYWZlSnNvblN0cnVjdDsgZXhwb3J0cy5WZXJzaW9uUmFuZ2VTdHJ1Y3QgPSBfY2h1bms0RDZYUUJIQWpzLlZlcnNpb25SYW5nZVN0cnVjdDsgZXhwb3J0cy5WZXJzaW9uU3RydWN0ID0gX2NodW5rNEQ2WFFCSEFqcy5WZXJzaW9uU3RydWN0OyBleHBvcnRzLmFkZDB4ID0gX2NodW5rUUVQVkhFUDdqcy5hZGQweDsgZXhwb3J0cy5hc3NlcnQgPSBfY2h1bms2WkRIU09VVmpzLmFzc2VydDsgZXhwb3J0cy5hc3NlcnRFeGhhdXN0aXZlID0gX2NodW5rNlpESFNPVVZqcy5hc3NlcnRFeGhhdXN0aXZlOyBleHBvcnRzLmFzc2VydElzQnl0ZXMgPSBfY2h1bmtRRVBWSEVQN2pzLmFzc2VydElzQnl0ZXM7IGV4cG9ydHMuYXNzZXJ0SXNIZXhTdHJpbmcgPSBfY2h1bmtRRVBWSEVQN2pzLmFzc2VydElzSGV4U3RyaW5nOyBleHBvcnRzLmFzc2VydElzSnNvblJwY0Vycm9yID0gX2NodW5rT0xMRzRIMzVqcy5hc3NlcnRJc0pzb25ScGNFcnJvcjsgZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNGYWlsdXJlID0gX2NodW5rT0xMRzRIMzVqcy5hc3NlcnRJc0pzb25ScGNGYWlsdXJlOyBleHBvcnRzLmFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbiA9IF9jaHVua09MTEc0SDM1anMuYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uOyBleHBvcnRzLmFzc2VydElzSnNvblJwY1JlcXVlc3QgPSBfY2h1bmtPTExHNEgzNWpzLmFzc2VydElzSnNvblJwY1JlcXVlc3Q7IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UgPSBfY2h1bmtPTExHNEgzNWpzLmFzc2VydElzSnNvblJwY1Jlc3BvbnNlOyBleHBvcnRzLmFzc2VydElzSnNvblJwY1N1Y2Nlc3MgPSBfY2h1bmtPTExHNEgzNWpzLmFzc2VydElzSnNvblJwY1N1Y2Nlc3M7IGV4cG9ydHMuYXNzZXJ0SXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlID0gX2NodW5rT0xMRzRIMzVqcy5hc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2U7IGV4cG9ydHMuYXNzZXJ0SXNTZW1WZXJSYW5nZSA9IF9jaHVuazRENlhRQkhBanMuYXNzZXJ0SXNTZW1WZXJSYW5nZTsgZXhwb3J0cy5hc3NlcnRJc1NlbVZlclZlcnNpb24gPSBfY2h1bms0RDZYUUJIQWpzLmFzc2VydElzU2VtVmVyVmVyc2lvbjsgZXhwb3J0cy5hc3NlcnRJc1N0cmljdEhleFN0cmluZyA9IF9jaHVua1FFUFZIRVA3anMuYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmc7IGV4cG9ydHMuYXNzZXJ0U3RydWN0ID0gX2NodW5rNlpESFNPVVZqcy5hc3NlcnRTdHJ1Y3Q7IGV4cG9ydHMuYmFzZTY0ID0gX2NodW5rNk5aVzRXSzRqcy5iYXNlNjQ7IGV4cG9ydHMuYmFzZTY0VG9CeXRlcyA9IF9jaHVua1FFUFZIRVA3anMuYmFzZTY0VG9CeXRlczsgZXhwb3J0cy5iaWdJbnRUb0J5dGVzID0gX2NodW5rUUVQVkhFUDdqcy5iaWdJbnRUb0J5dGVzOyBleHBvcnRzLmJpZ0ludFRvSGV4ID0gX2NodW5rVkZYVFZOWE5qcy5iaWdJbnRUb0hleDsgZXhwb3J0cy5ieXRlc1RvQmFzZTY0ID0gX2NodW5rUUVQVkhFUDdqcy5ieXRlc1RvQmFzZTY0OyBleHBvcnRzLmJ5dGVzVG9CaWdJbnQgPSBfY2h1bmtRRVBWSEVQN2pzLmJ5dGVzVG9CaWdJbnQ7IGV4cG9ydHMuYnl0ZXNUb0hleCA9IF9jaHVua1FFUFZIRVA3anMuYnl0ZXNUb0hleDsgZXhwb3J0cy5ieXRlc1RvTnVtYmVyID0gX2NodW5rUUVQVkhFUDdqcy5ieXRlc1RvTnVtYmVyOyBleHBvcnRzLmJ5dGVzVG9TaWduZWRCaWdJbnQgPSBfY2h1bmtRRVBWSEVQN2pzLmJ5dGVzVG9TaWduZWRCaWdJbnQ7IGV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IF9jaHVua1FFUFZIRVA3anMuYnl0ZXNUb1N0cmluZzsgZXhwb3J0cy5jYWxjdWxhdGVOdW1iZXJTaXplID0gX2NodW5rUVZFS1pSWjJqcy5jYWxjdWxhdGVOdW1iZXJTaXplOyBleHBvcnRzLmNhbGN1bGF0ZVN0cmluZ1NpemUgPSBfY2h1bmtRVkVLWlJaMmpzLmNhbGN1bGF0ZVN0cmluZ1NpemU7IGV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBfY2h1bmtRRVBWSEVQN2pzLmNvbmNhdEJ5dGVzOyBleHBvcnRzLmNyZWF0ZUJpZ0ludCA9IF9jaHVua0RIVktGREhRanMuY3JlYXRlQmlnSW50OyBleHBvcnRzLmNyZWF0ZUJ5dGVzID0gX2NodW5rREhWS0ZESFFqcy5jcmVhdGVCeXRlczsgZXhwb3J0cy5jcmVhdGVEYXRhVmlldyA9IF9jaHVua1FFUFZIRVA3anMuY3JlYXRlRGF0YVZpZXc7IGV4cG9ydHMuY3JlYXRlSGV4ID0gX2NodW5rREhWS0ZESFFqcy5jcmVhdGVIZXg7IGV4cG9ydHMuY3JlYXRlTW9kdWxlTG9nZ2VyID0gX2NodW5rMkxCR1Q0R0hqcy5jcmVhdGVNb2R1bGVMb2dnZXI7IGV4cG9ydHMuY3JlYXRlTnVtYmVyID0gX2NodW5rREhWS0ZESFFqcy5jcmVhdGVOdW1iZXI7IGV4cG9ydHMuY3JlYXRlUHJvamVjdExvZ2dlciA9IF9jaHVuazJMQkdUNEdIanMuY3JlYXRlUHJvamVjdExvZ2dlcjsgZXhwb3J0cy5leGFjdE9wdGlvbmFsID0gX2NodW5rT0xMRzRIMzVqcy5leGFjdE9wdGlvbmFsOyBleHBvcnRzLmdldENoZWNrc3VtQWRkcmVzcyA9IF9jaHVua1FFUFZIRVA3anMuZ2V0Q2hlY2tzdW1BZGRyZXNzOyBleHBvcnRzLmdldEVycm9yTWVzc2FnZSA9IF9jaHVua0laQzI2NkhTanMuZ2V0RXJyb3JNZXNzYWdlOyBleHBvcnRzLmdldEpzb25ScGNJZFZhbGlkYXRvciA9IF9jaHVua09MTEc0SDM1anMuZ2V0SnNvblJwY0lkVmFsaWRhdG9yOyBleHBvcnRzLmdldEpzb25TaXplID0gX2NodW5rT0xMRzRIMzVqcy5nZXRKc29uU2l6ZTsgZXhwb3J0cy5nZXRLbm93blByb3BlcnR5TmFtZXMgPSBfY2h1bmtRVkVLWlJaMmpzLmdldEtub3duUHJvcGVydHlOYW1lczsgZXhwb3J0cy5nZXRTYWZlSnNvbiA9IF9jaHVua09MTEc0SDM1anMuZ2V0U2FmZUpzb247IGV4cG9ydHMuZ3RSYW5nZSA9IF9jaHVuazRENlhRQkhBanMuZ3RSYW5nZTsgZXhwb3J0cy5ndFZlcnNpb24gPSBfY2h1bms0RDZYUUJIQWpzLmd0VmVyc2lvbjsgZXhwb3J0cy5oYXNQcm9wZXJ0eSA9IF9jaHVua1FWRUtaUloyanMuaGFzUHJvcGVydHk7IGV4cG9ydHMuaGV4VG9CaWdJbnQgPSBfY2h1bmtWRlhUVk5YTmpzLmhleFRvQmlnSW50OyBleHBvcnRzLmhleFRvQnl0ZXMgPSBfY2h1bmtRRVBWSEVQN2pzLmhleFRvQnl0ZXM7IGV4cG9ydHMuaGV4VG9OdW1iZXIgPSBfY2h1bmtWRlhUVk5YTmpzLmhleFRvTnVtYmVyOyBleHBvcnRzLmluTWlsbGlzZWNvbmRzID0gX2NodW5rNFJNWDVZV0Vqcy5pbk1pbGxpc2Vjb25kczsgZXhwb3J0cy5pc0FTQ0lJID0gX2NodW5rUVZFS1pSWjJqcy5pc0FTQ0lJOyBleHBvcnRzLmlzQnl0ZXMgPSBfY2h1bmtRRVBWSEVQN2pzLmlzQnl0ZXM7IGV4cG9ydHMuaXNDYWlwQWNjb3VudEFkZHJlc3MgPSBfY2h1bmtVN1pVR0NFN2pzLmlzQ2FpcEFjY291bnRBZGRyZXNzOyBleHBvcnRzLmlzQ2FpcEFjY291bnRJZCA9IF9jaHVua1U3WlVHQ0U3anMuaXNDYWlwQWNjb3VudElkOyBleHBvcnRzLmlzQ2FpcENoYWluSWQgPSBfY2h1bmtVN1pVR0NFN2pzLmlzQ2FpcENoYWluSWQ7IGV4cG9ydHMuaXNDYWlwTmFtZXNwYWNlID0gX2NodW5rVTdaVUdDRTdqcy5pc0NhaXBOYW1lc3BhY2U7IGV4cG9ydHMuaXNDYWlwUmVmZXJlbmNlID0gX2NodW5rVTdaVUdDRTdqcy5pc0NhaXBSZWZlcmVuY2U7IGV4cG9ydHMuaXNFcnJvcldpdGhDb2RlID0gX2NodW5rSVpDMjY2SFNqcy5pc0Vycm9yV2l0aENvZGU7IGV4cG9ydHMuaXNFcnJvcldpdGhNZXNzYWdlID0gX2NodW5rSVpDMjY2SFNqcy5pc0Vycm9yV2l0aE1lc3NhZ2U7IGV4cG9ydHMuaXNFcnJvcldpdGhTdGFjayA9IF9jaHVua0laQzI2NkhTanMuaXNFcnJvcldpdGhTdGFjazsgZXhwb3J0cy5pc0hleFN0cmluZyA9IF9jaHVua1FFUFZIRVA3anMuaXNIZXhTdHJpbmc7IGV4cG9ydHMuaXNKc29uUnBjRXJyb3IgPSBfY2h1bmtPTExHNEgzNWpzLmlzSnNvblJwY0Vycm9yOyBleHBvcnRzLmlzSnNvblJwY0ZhaWx1cmUgPSBfY2h1bmtPTExHNEgzNWpzLmlzSnNvblJwY0ZhaWx1cmU7IGV4cG9ydHMuaXNKc29uUnBjTm90aWZpY2F0aW9uID0gX2NodW5rT0xMRzRIMzVqcy5pc0pzb25ScGNOb3RpZmljYXRpb247IGV4cG9ydHMuaXNKc29uUnBjUmVxdWVzdCA9IF9jaHVua09MTEc0SDM1anMuaXNKc29uUnBjUmVxdWVzdDsgZXhwb3J0cy5pc0pzb25ScGNSZXNwb25zZSA9IF9jaHVua09MTEc0SDM1anMuaXNKc29uUnBjUmVzcG9uc2U7IGV4cG9ydHMuaXNKc29uUnBjU3VjY2VzcyA9IF9jaHVua09MTEc0SDM1anMuaXNKc29uUnBjU3VjY2VzczsgZXhwb3J0cy5pc05vbkVtcHR5QXJyYXkgPSBfY2h1bmtRVkVLWlJaMmpzLmlzTm9uRW1wdHlBcnJheTsgZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IF9jaHVua1FWRUtaUloyanMuaXNOdWxsT3JVbmRlZmluZWQ7IGV4cG9ydHMuaXNPYmplY3QgPSBfY2h1bmtRVkVLWlJaMmpzLmlzT2JqZWN0OyBleHBvcnRzLmlzUGVuZGluZ0pzb25ScGNSZXNwb25zZSA9IF9jaHVua09MTEc0SDM1anMuaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlOyBleHBvcnRzLmlzUGxhaW5PYmplY3QgPSBfY2h1bmtRVkVLWlJaMmpzLmlzUGxhaW5PYmplY3Q7IGV4cG9ydHMuaXNTdHJpY3RIZXhTdHJpbmcgPSBfY2h1bmtRRVBWSEVQN2pzLmlzU3RyaWN0SGV4U3RyaW5nOyBleHBvcnRzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBfY2h1bmtRRVBWSEVQN2pzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3M7IGV4cG9ydHMuaXNWYWxpZEhleEFkZHJlc3MgPSBfY2h1bmtRRVBWSEVQN2pzLmlzVmFsaWRIZXhBZGRyZXNzOyBleHBvcnRzLmlzVmFsaWRKc29uID0gX2NodW5rT0xMRzRIMzVqcy5pc1ZhbGlkSnNvbjsgZXhwb3J0cy5pc1ZhbGlkU2VtVmVyUmFuZ2UgPSBfY2h1bms0RDZYUUJIQWpzLmlzVmFsaWRTZW1WZXJSYW5nZTsgZXhwb3J0cy5pc1ZhbGlkU2VtVmVyVmVyc2lvbiA9IF9jaHVuazRENlhRQkhBanMuaXNWYWxpZFNlbVZlclZlcnNpb247IGV4cG9ydHMuanNvbnJwYzIgPSBfY2h1bmtPTExHNEgzNWpzLmpzb25ycGMyOyBleHBvcnRzLm51bWJlclRvQnl0ZXMgPSBfY2h1bmtRRVBWSEVQN2pzLm51bWJlclRvQnl0ZXM7IGV4cG9ydHMubnVtYmVyVG9IZXggPSBfY2h1bmtWRlhUVk5YTmpzLm51bWJlclRvSGV4OyBleHBvcnRzLm9iamVjdCA9IF9jaHVua09MTEc0SDM1anMub2JqZWN0OyBleHBvcnRzLnBhcnNlQ2FpcEFjY291bnRJZCA9IF9jaHVua1U3WlVHQ0U3anMucGFyc2VDYWlwQWNjb3VudElkOyBleHBvcnRzLnBhcnNlQ2FpcENoYWluSWQgPSBfY2h1bmtVN1pVR0NFN2pzLnBhcnNlQ2FpcENoYWluSWQ7IGV4cG9ydHMucmVtb3ZlMHggPSBfY2h1bmtRRVBWSEVQN2pzLnJlbW92ZTB4OyBleHBvcnRzLnNhdGlzZmllc1ZlcnNpb25SYW5nZSA9IF9jaHVuazRENlhRQkhBanMuc2F0aXNmaWVzVmVyc2lvblJhbmdlOyBleHBvcnRzLnNpZ25lZEJpZ0ludFRvQnl0ZXMgPSBfY2h1bmtRRVBWSEVQN2pzLnNpZ25lZEJpZ0ludFRvQnl0ZXM7IGV4cG9ydHMuc3RyaW5nVG9CeXRlcyA9IF9jaHVua1FFUFZIRVA3anMuc3RyaW5nVG9CeXRlczsgZXhwb3J0cy50aW1lU2luY2UgPSBfY2h1bms0Uk1YNVlXRWpzLnRpbWVTaW5jZTsgZXhwb3J0cy52YWx1ZVRvQnl0ZXMgPSBfY2h1bmtRRVBWSEVQN2pzLnZhbHVlVG9CeXRlczsgZXhwb3J0cy53cmFwRXJyb3IgPSBfY2h1bmtJWkMyNjZIU2pzLndyYXBFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlcXVpcmUiLCJfY2h1bmtWRlhUVk5YTmpzIiwiX2NodW5rNFJNWDVZV0VqcyIsIl9jaHVuazRENlhRQkhBanMiLCJfY2h1bmtPTExHNEgzNWpzIiwiX2NodW5rMkxCR1Q0R0hqcyIsIl9jaHVua1U3WlVHQ0U3anMiLCJfY2h1bmtFNEM3RVc0UmpzIiwiX2NodW5rNk5aVzRXSzRqcyIsIl9jaHVua0RIVktGREhRanMiLCJfY2h1bmtRRVBWSEVQN2pzIiwiX2NodW5rNlpESFNPVVZqcyIsIl9jaHVua0laQzI2NkhTanMiLCJfY2h1bmtRVkVLWlJaMmpzIiwiX2NodW5rWjJSR1dERDdqcyIsIkFzc2VydGlvbkVycm9yIiwiQ0FJUF9BQ0NPVU5UX0FERFJFU1NfUkVHRVgiLCJDQUlQX0FDQ09VTlRfSURfUkVHRVgiLCJDQUlQX0NIQUlOX0lEX1JFR0VYIiwiQ0FJUF9OQU1FU1BBQ0VfUkVHRVgiLCJDQUlQX1JFRkVSRU5DRV9SRUdFWCIsIkNhaXBBY2NvdW50QWRkcmVzc1N0cnVjdCIsIkNhaXBBY2NvdW50SWRTdHJ1Y3QiLCJDYWlwQ2hhaW5JZFN0cnVjdCIsIkNhaXBOYW1lc3BhY2VTdHJ1Y3QiLCJDYWlwUmVmZXJlbmNlU3RydWN0IiwiQ2hlY2tzdW1TdHJ1Y3QiLCJEdXJhdGlvbiIsIkVTQ0FQRV9DSEFSQUNURVJTX1JFR0VYUCIsIkZyb3plbk1hcCIsIkZyb3plblNldCIsIkhleEFkZHJlc3NTdHJ1Y3QiLCJIZXhDaGVja3N1bUFkZHJlc3NTdHJ1Y3QiLCJIZXhTdHJ1Y3QiLCJKc29uUnBjRXJyb3JTdHJ1Y3QiLCJKc29uUnBjRmFpbHVyZVN0cnVjdCIsIkpzb25ScGNJZFN0cnVjdCIsIkpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QiLCJKc29uUnBjUGFyYW1zU3RydWN0IiwiSnNvblJwY1JlcXVlc3RTdHJ1Y3QiLCJKc29uUnBjUmVzcG9uc2VTdHJ1Y3QiLCJKc29uUnBjU3VjY2Vzc1N0cnVjdCIsIkpzb25ScGNWZXJzaW9uU3RydWN0IiwiSnNvblNpemUiLCJKc29uU3RydWN0IiwiUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCIsIlN0cmljdEhleFN0cnVjdCIsIlVuc2FmZUpzb25TdHJ1Y3QiLCJWZXJzaW9uUmFuZ2VTdHJ1Y3QiLCJWZXJzaW9uU3RydWN0IiwiYWRkMHgiLCJhc3NlcnQiLCJhc3NlcnRFeGhhdXN0aXZlIiwiYXNzZXJ0SXNCeXRlcyIsImFzc2VydElzSGV4U3RyaW5nIiwiYXNzZXJ0SXNKc29uUnBjRXJyb3IiLCJhc3NlcnRJc0pzb25ScGNGYWlsdXJlIiwiYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uIiwiYXNzZXJ0SXNKc29uUnBjUmVxdWVzdCIsImFzc2VydElzSnNvblJwY1Jlc3BvbnNlIiwiYXNzZXJ0SXNKc29uUnBjU3VjY2VzcyIsImFzc2VydElzUGVuZGluZ0pzb25ScGNSZXNwb25zZSIsImFzc2VydElzU2VtVmVyUmFuZ2UiLCJhc3NlcnRJc1NlbVZlclZlcnNpb24iLCJhc3NlcnRJc1N0cmljdEhleFN0cmluZyIsImFzc2VydFN0cnVjdCIsImJhc2U2NCIsImJhc2U2NFRvQnl0ZXMiLCJiaWdJbnRUb0J5dGVzIiwiYmlnSW50VG9IZXgiLCJieXRlc1RvQmFzZTY0IiwiYnl0ZXNUb0JpZ0ludCIsImJ5dGVzVG9IZXgiLCJieXRlc1RvTnVtYmVyIiwiYnl0ZXNUb1NpZ25lZEJpZ0ludCIsImJ5dGVzVG9TdHJpbmciLCJjYWxjdWxhdGVOdW1iZXJTaXplIiwiY2FsY3VsYXRlU3RyaW5nU2l6ZSIsImNvbmNhdEJ5dGVzIiwiY3JlYXRlQmlnSW50IiwiY3JlYXRlQnl0ZXMiLCJjcmVhdGVEYXRhVmlldyIsImNyZWF0ZUhleCIsImNyZWF0ZU1vZHVsZUxvZ2dlciIsImNyZWF0ZU51bWJlciIsImNyZWF0ZVByb2plY3RMb2dnZXIiLCJleGFjdE9wdGlvbmFsIiwiZ2V0Q2hlY2tzdW1BZGRyZXNzIiwiZ2V0RXJyb3JNZXNzYWdlIiwiZ2V0SnNvblJwY0lkVmFsaWRhdG9yIiwiZ2V0SnNvblNpemUiLCJnZXRLbm93blByb3BlcnR5TmFtZXMiLCJnZXRTYWZlSnNvbiIsImd0UmFuZ2UiLCJndFZlcnNpb24iLCJoYXNQcm9wZXJ0eSIsImhleFRvQmlnSW50IiwiaGV4VG9CeXRlcyIsImhleFRvTnVtYmVyIiwiaW5NaWxsaXNlY29uZHMiLCJpc0FTQ0lJIiwiaXNCeXRlcyIsImlzQ2FpcEFjY291bnRBZGRyZXNzIiwiaXNDYWlwQWNjb3VudElkIiwiaXNDYWlwQ2hhaW5JZCIsImlzQ2FpcE5hbWVzcGFjZSIsImlzQ2FpcFJlZmVyZW5jZSIsImlzRXJyb3JXaXRoQ29kZSIsImlzRXJyb3JXaXRoTWVzc2FnZSIsImlzRXJyb3JXaXRoU3RhY2siLCJpc0hleFN0cmluZyIsImlzSnNvblJwY0Vycm9yIiwiaXNKc29uUnBjRmFpbHVyZSIsImlzSnNvblJwY05vdGlmaWNhdGlvbiIsImlzSnNvblJwY1JlcXVlc3QiLCJpc0pzb25ScGNSZXNwb25zZSIsImlzSnNvblJwY1N1Y2Nlc3MiLCJpc05vbkVtcHR5QXJyYXkiLCJpc051bGxPclVuZGVmaW5lZCIsImlzT2JqZWN0IiwiaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlIiwiaXNQbGFpbk9iamVjdCIsImlzU3RyaWN0SGV4U3RyaW5nIiwiaXNWYWxpZENoZWNrc3VtQWRkcmVzcyIsImlzVmFsaWRIZXhBZGRyZXNzIiwiaXNWYWxpZEpzb24iLCJpc1ZhbGlkU2VtVmVyUmFuZ2UiLCJpc1ZhbGlkU2VtVmVyVmVyc2lvbiIsImpzb25ycGMyIiwibnVtYmVyVG9CeXRlcyIsIm51bWJlclRvSGV4Iiwib2JqZWN0IiwicGFyc2VDYWlwQWNjb3VudElkIiwicGFyc2VDYWlwQ2hhaW5JZCIsInJlbW92ZTB4Iiwic2F0aXNmaWVzVmVyc2lvblJhbmdlIiwic2lnbmVkQmlnSW50VG9CeXRlcyIsInN0cmluZ1RvQnl0ZXMiLCJ0aW1lU2luY2UiLCJ2YWx1ZVRvQnl0ZXMiLCJ3cmFwRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@metamask/utils/dist/index.js\n");

/***/ })

};
;