/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/websocket";
exports.ids = ["vendor-chunks/websocket"];
exports.modules = {

/***/ "(ssr)/./node_modules/websocket/index.js":
/*!*****************************************!*\
  !*** ./node_modules/websocket/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/websocket */ \"(ssr)/./node_modules/websocket/lib/websocket.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBQSw4R0FBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9pbmRleC5qcz8zMDNkIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvd2Vic29ja2V0Jyk7Il0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/Deprecation.js":
/*!***************************************************!*\
  !*** ./node_modules/websocket/lib/Deprecation.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ var Deprecation = {\n    disableWarnings: false,\n    deprecationWarningMap: {},\n    warn: function(deprecationName) {\n        if (!this.disableWarnings && this.deprecationWarningMap[deprecationName]) {\n            console.warn(\"DEPRECATION WARNING: \" + this.deprecationWarningMap[deprecationName]);\n            this.deprecationWarningMap[deprecationName] = false;\n        }\n    }\n};\nmodule.exports = Deprecation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvRGVwcmVjYXRpb24uanM/NzljNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQ29weXJpZ2h0IDIwMTAtMjAxNSBCcmlhbiBNY0tlbHZleS5cbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBEZXByZWNhdGlvbiA9IHtcbiAgICBkaXNhYmxlV2FybmluZ3M6IGZhbHNlLFxuXG4gICAgZGVwcmVjYXRpb25XYXJuaW5nTWFwOiB7XG5cbiAgICB9LFxuXG4gICAgd2FybjogZnVuY3Rpb24oZGVwcmVjYXRpb25OYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlV2FybmluZ3MgJiYgdGhpcy5kZXByZWNhdGlvbldhcm5pbmdNYXBbZGVwcmVjYXRpb25OYW1lXSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdERVBSRUNBVElPTiBXQVJOSU5HOiAnICsgdGhpcy5kZXByZWNhdGlvbldhcm5pbmdNYXBbZGVwcmVjYXRpb25OYW1lXSk7XG4gICAgICAgICAgICB0aGlzLmRlcHJlY2F0aW9uV2FybmluZ01hcFtkZXByZWNhdGlvbk5hbWVdID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlcHJlY2F0aW9uO1xuIl0sIm5hbWVzIjpbIkRlcHJlY2F0aW9uIiwiZGlzYWJsZVdhcm5pbmdzIiwiZGVwcmVjYXRpb25XYXJuaW5nTWFwIiwid2FybiIsImRlcHJlY2F0aW9uTmFtZSIsImNvbnNvbGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7dUVBY3VFLEdBRXZFLElBQUlBLGNBQWM7SUFDZEMsaUJBQWlCO0lBRWpCQyx1QkFBdUIsQ0FFdkI7SUFFQUMsTUFBTSxTQUFTQyxlQUFlO1FBQzFCLElBQUksQ0FBQyxJQUFJLENBQUNILGVBQWUsSUFBSSxJQUFJLENBQUNDLHFCQUFxQixDQUFDRSxnQkFBZ0IsRUFBRTtZQUN0RUMsUUFBUUYsSUFBSSxDQUFDLDBCQUEwQixJQUFJLENBQUNELHFCQUFxQixDQUFDRSxnQkFBZ0I7WUFDbEYsSUFBSSxDQUFDRixxQkFBcUIsQ0FBQ0UsZ0JBQWdCLEdBQUc7UUFDbEQ7SUFDSjtBQUNKO0FBRUFFLE9BQU9DLE9BQU8sR0FBR1AiLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9EZXByZWNhdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/Deprecation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/W3CWebSocket.js":
/*!****************************************************!*\
  !*** ./node_modules/websocket/lib/W3CWebSocket.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ var WebSocketClient = __webpack_require__(/*! ./WebSocketClient */ \"(ssr)/./node_modules/websocket/lib/WebSocketClient.js\");\nvar toBuffer = __webpack_require__(/*! typedarray-to-buffer */ \"(ssr)/./node_modules/typedarray-to-buffer/index.js\");\nvar yaeti = __webpack_require__(/*! yaeti */ \"(ssr)/./node_modules/yaeti/index.js\");\nconst CONNECTING = 0;\nconst OPEN = 1;\nconst CLOSING = 2;\nconst CLOSED = 3;\nmodule.exports = W3CWebSocket;\nfunction W3CWebSocket(url, protocols, origin, headers, requestOptions, clientConfig) {\n    // Make this an EventTarget.\n    yaeti.EventTarget.call(this);\n    // Sanitize clientConfig.\n    clientConfig = clientConfig || {};\n    clientConfig.assembleFragments = true; // Required in the W3C API.\n    var self = this;\n    this._url = url;\n    this._readyState = CONNECTING;\n    this._protocol = undefined;\n    this._extensions = \"\";\n    this._bufferedAmount = 0; // Hack, always 0.\n    this._binaryType = \"arraybuffer\"; // TODO: Should be 'blob' by default, but Node has no Blob.\n    // The WebSocketConnection instance.\n    this._connection = undefined;\n    // WebSocketClient instance.\n    this._client = new WebSocketClient(clientConfig);\n    this._client.on(\"connect\", function(connection) {\n        onConnect.call(self, connection);\n    });\n    this._client.on(\"connectFailed\", function() {\n        onConnectFailed.call(self);\n    });\n    this._client.connect(url, protocols, origin, headers, requestOptions);\n}\n// Expose W3C read only attributes.\nObject.defineProperties(W3CWebSocket.prototype, {\n    url: {\n        get: function() {\n            return this._url;\n        }\n    },\n    readyState: {\n        get: function() {\n            return this._readyState;\n        }\n    },\n    protocol: {\n        get: function() {\n            return this._protocol;\n        }\n    },\n    extensions: {\n        get: function() {\n            return this._extensions;\n        }\n    },\n    bufferedAmount: {\n        get: function() {\n            return this._bufferedAmount;\n        }\n    }\n});\n// Expose W3C write/read attributes.\nObject.defineProperties(W3CWebSocket.prototype, {\n    binaryType: {\n        get: function() {\n            return this._binaryType;\n        },\n        set: function(type) {\n            // TODO: Just 'arraybuffer' supported.\n            if (type !== \"arraybuffer\") {\n                throw new SyntaxError('just \"arraybuffer\" type allowed for \"binaryType\" attribute');\n            }\n            this._binaryType = type;\n        }\n    }\n});\n// Expose W3C readyState constants into the WebSocket instance as W3C states.\n[\n    [\n        \"CONNECTING\",\n        CONNECTING\n    ],\n    [\n        \"OPEN\",\n        OPEN\n    ],\n    [\n        \"CLOSING\",\n        CLOSING\n    ],\n    [\n        \"CLOSED\",\n        CLOSED\n    ]\n].forEach(function(property) {\n    Object.defineProperty(W3CWebSocket.prototype, property[0], {\n        get: function() {\n            return property[1];\n        }\n    });\n});\n// Also expose W3C readyState constants into the WebSocket class (not defined by the W3C,\n// but there are so many libs relying on them).\n[\n    [\n        \"CONNECTING\",\n        CONNECTING\n    ],\n    [\n        \"OPEN\",\n        OPEN\n    ],\n    [\n        \"CLOSING\",\n        CLOSING\n    ],\n    [\n        \"CLOSED\",\n        CLOSED\n    ]\n].forEach(function(property) {\n    Object.defineProperty(W3CWebSocket, property[0], {\n        get: function() {\n            return property[1];\n        }\n    });\n});\nW3CWebSocket.prototype.send = function(data) {\n    if (this._readyState !== OPEN) {\n        throw new Error(\"cannot call send() while not connected\");\n    }\n    // Text.\n    if (typeof data === \"string\" || data instanceof String) {\n        this._connection.sendUTF(data);\n    } else {\n        // Node Buffer.\n        if (data instanceof Buffer) {\n            this._connection.sendBytes(data);\n        } else if (data.byteLength || data.byteLength === 0) {\n            data = toBuffer(data);\n            this._connection.sendBytes(data);\n        } else {\n            throw new Error(\"unknown binary data:\", data);\n        }\n    }\n};\nW3CWebSocket.prototype.close = function(code, reason) {\n    switch(this._readyState){\n        case CONNECTING:\n            // NOTE: We don't have the WebSocketConnection instance yet so no\n            // way to close the TCP connection.\n            // Artificially invoke the onConnectFailed event.\n            onConnectFailed.call(this);\n            // And close if it connects after a while.\n            this._client.on(\"connect\", function(connection) {\n                if (code) {\n                    connection.close(code, reason);\n                } else {\n                    connection.close();\n                }\n            });\n            break;\n        case OPEN:\n            this._readyState = CLOSING;\n            if (code) {\n                this._connection.close(code, reason);\n            } else {\n                this._connection.close();\n            }\n            break;\n        case CLOSING:\n        case CLOSED:\n            break;\n    }\n};\n/**\n * Private API.\n */ function createCloseEvent(code, reason) {\n    var event = new yaeti.Event(\"close\");\n    event.code = code;\n    event.reason = reason;\n    event.wasClean = typeof code === \"undefined\" || code === 1000;\n    return event;\n}\nfunction createMessageEvent(data) {\n    var event = new yaeti.Event(\"message\");\n    event.data = data;\n    return event;\n}\nfunction onConnect(connection) {\n    var self = this;\n    this._readyState = OPEN;\n    this._connection = connection;\n    this._protocol = connection.protocol;\n    this._extensions = connection.extensions;\n    this._connection.on(\"close\", function(code, reason) {\n        onClose.call(self, code, reason);\n    });\n    this._connection.on(\"message\", function(msg) {\n        onMessage.call(self, msg);\n    });\n    this.dispatchEvent(new yaeti.Event(\"open\"));\n}\nfunction onConnectFailed() {\n    destroy.call(this);\n    this._readyState = CLOSED;\n    try {\n        this.dispatchEvent(new yaeti.Event(\"error\"));\n    } finally{\n        this.dispatchEvent(createCloseEvent(1006, \"connection failed\"));\n    }\n}\nfunction onClose(code, reason) {\n    destroy.call(this);\n    this._readyState = CLOSED;\n    this.dispatchEvent(createCloseEvent(code, reason || \"\"));\n}\nfunction onMessage(message) {\n    if (message.utf8Data) {\n        this.dispatchEvent(createMessageEvent(message.utf8Data));\n    } else if (message.binaryData) {\n        // Must convert from Node Buffer to ArrayBuffer.\n        // TODO: or to a Blob (which does not exist in Node!).\n        if (this.binaryType === \"arraybuffer\") {\n            var buffer = message.binaryData;\n            var arraybuffer = new ArrayBuffer(buffer.length);\n            var view = new Uint8Array(arraybuffer);\n            for(var i = 0, len = buffer.length; i < len; ++i){\n                view[i] = buffer[i];\n            }\n            this.dispatchEvent(createMessageEvent(arraybuffer));\n        }\n    }\n}\nfunction destroy() {\n    this._client.removeAllListeners();\n    if (this._connection) {\n        this._connection.removeAllListeners();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XM0NXZWJTb2NrZXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O3VFQWN1RSxHQUV2RSxJQUFJQSxrQkFBa0JDLG1CQUFPQSxDQUFDO0FBQzlCLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO0FBQ3ZCLElBQUlFLFFBQVFGLG1CQUFPQSxDQUFDO0FBR3BCLE1BQU1HLGFBQWE7QUFDbkIsTUFBTUMsT0FBTztBQUNiLE1BQU1DLFVBQVU7QUFDaEIsTUFBTUMsU0FBUztBQUdmQyxPQUFPQyxPQUFPLEdBQUdDO0FBR2pCLFNBQVNBLGFBQWFDLEdBQUcsRUFBRUMsU0FBUyxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsY0FBYyxFQUFFQyxZQUFZO0lBQy9FLDRCQUE0QjtJQUM1QmIsTUFBTWMsV0FBVyxDQUFDQyxJQUFJLENBQUMsSUFBSTtJQUUzQix5QkFBeUI7SUFDekJGLGVBQWVBLGdCQUFnQixDQUFDO0lBQ2hDQSxhQUFhRyxpQkFBaUIsR0FBRyxNQUFPLDJCQUEyQjtJQUVuRSxJQUFJQyxPQUFPLElBQUk7SUFFZixJQUFJLENBQUNDLElBQUksR0FBR1Y7SUFDWixJQUFJLENBQUNXLFdBQVcsR0FBR2xCO0lBQ25CLElBQUksQ0FBQ21CLFNBQVMsR0FBR0M7SUFDakIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7SUFDbkIsSUFBSSxDQUFDQyxlQUFlLEdBQUcsR0FBSSxrQkFBa0I7SUFDN0MsSUFBSSxDQUFDQyxXQUFXLEdBQUcsZUFBZ0IsMkRBQTJEO0lBRTlGLG9DQUFvQztJQUNwQyxJQUFJLENBQUNDLFdBQVcsR0FBR0o7SUFFbkIsNEJBQTRCO0lBQzVCLElBQUksQ0FBQ0ssT0FBTyxHQUFHLElBQUk3QixnQkFBZ0JnQjtJQUVuQyxJQUFJLENBQUNhLE9BQU8sQ0FBQ0MsRUFBRSxDQUFDLFdBQVcsU0FBU0MsVUFBVTtRQUMxQ0MsVUFBVWQsSUFBSSxDQUFDRSxNQUFNVztJQUN6QjtJQUVB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QUFNO1lBQy9DLElBQUlDLE9BQU8sSUFBSUMsV0FBV0o7WUFDMUIsSUFBSyxJQUFJSyxJQUFFLEdBQUdDLE1BQUlQLE9BQU9HLE1BQU0sRUFBRUcsSUFBRUMsS0FBSyxFQUFFRCxFQUFHO2dCQUN6Q0YsSUFBSSxDQUFDRSxFQUFFLEdBQUdOLE1BQU0sQ0FBQ00sRUFBRTtZQUN2QjtZQUNBLElBQUksQ0FBQ1gsYUFBYSxDQUFDSixtQkFBbUJVO1FBQzFDO0lBQ0o7QUFDSjtBQUdBLFNBQVNMO0lBQ0wsSUFBSSxDQUFDekMsT0FBTyxDQUFDcUQsa0JBQWtCO0lBQy9CLElBQUksSUFBSSxDQUFDdEQsV0FBVyxFQUFFO1FBQ2xCLElBQUksQ0FBQ0EsV0FBVyxDQUFDc0Qsa0JBQWtCO0lBQ3ZDO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvVzNDV2ViU29ja2V0LmpzPzMzMGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIENvcHlyaWdodCAyMDEwLTIwMTUgQnJpYW4gTWNLZWx2ZXkuXG4gKlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgV2ViU29ja2V0Q2xpZW50ID0gcmVxdWlyZSgnLi9XZWJTb2NrZXRDbGllbnQnKTtcbnZhciB0b0J1ZmZlciA9IHJlcXVpcmUoJ3R5cGVkYXJyYXktdG8tYnVmZmVyJyk7XG52YXIgeWFldGkgPSByZXF1aXJlKCd5YWV0aScpO1xuXG5cbmNvbnN0IENPTk5FQ1RJTkcgPSAwO1xuY29uc3QgT1BFTiA9IDE7XG5jb25zdCBDTE9TSU5HID0gMjtcbmNvbnN0IENMT1NFRCA9IDM7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBXM0NXZWJTb2NrZXQ7XG5cblxuZnVuY3Rpb24gVzNDV2ViU29ja2V0KHVybCwgcHJvdG9jb2xzLCBvcmlnaW4sIGhlYWRlcnMsIHJlcXVlc3RPcHRpb25zLCBjbGllbnRDb25maWcpIHtcbiAgICAvLyBNYWtlIHRoaXMgYW4gRXZlbnRUYXJnZXQuXG4gICAgeWFldGkuRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICAgIC8vIFNhbml0aXplIGNsaWVudENvbmZpZy5cbiAgICBjbGllbnRDb25maWcgPSBjbGllbnRDb25maWcgfHwge307XG4gICAgY2xpZW50Q29uZmlnLmFzc2VtYmxlRnJhZ21lbnRzID0gdHJ1ZTsgIC8vIFJlcXVpcmVkIGluIHRoZSBXM0MgQVBJLlxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5fdXJsID0gdXJsO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBDT05ORUNUSU5HO1xuICAgIHRoaXMuX3Byb3RvY29sID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSAnJztcbiAgICB0aGlzLl9idWZmZXJlZEFtb3VudCA9IDA7ICAvLyBIYWNrLCBhbHdheXMgMC5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJzsgIC8vIFRPRE86IFNob3VsZCBiZSAnYmxvYicgYnkgZGVmYXVsdCwgYnV0IE5vZGUgaGFzIG5vIEJsb2IuXG5cbiAgICAvLyBUaGUgV2ViU29ja2V0Q29ubmVjdGlvbiBpbnN0YW5jZS5cbiAgICB0aGlzLl9jb25uZWN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gV2ViU29ja2V0Q2xpZW50IGluc3RhbmNlLlxuICAgIHRoaXMuX2NsaWVudCA9IG5ldyBXZWJTb2NrZXRDbGllbnQoY2xpZW50Q29uZmlnKTtcblxuICAgIHRoaXMuX2NsaWVudC5vbignY29ubmVjdCcsIGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgb25Db25uZWN0LmNhbGwoc2VsZiwgY29ubmVjdGlvbik7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9jbGllbnQub24oJ2Nvbm5lY3RGYWlsZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgb25Db25uZWN0RmFpbGVkLmNhbGwoc2VsZik7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9jbGllbnQuY29ubmVjdCh1cmwsIHByb3RvY29scywgb3JpZ2luLCBoZWFkZXJzLCByZXF1ZXN0T3B0aW9ucyk7XG59XG5cblxuLy8gRXhwb3NlIFczQyByZWFkIG9ubHkgYXR0cmlidXRlcy5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFczQ1dlYlNvY2tldC5wcm90b3R5cGUsIHtcbiAgICB1cmw6ICAgICAgICAgICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fdXJsOyAgICAgICAgICAgIH0gfSxcbiAgICByZWFkeVN0YXRlOiAgICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fcmVhZHlTdGF0ZTsgICAgIH0gfSxcbiAgICBwcm90b2NvbDogICAgICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fcHJvdG9jb2w7ICAgICAgIH0gfSxcbiAgICBleHRlbnNpb25zOiAgICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fZXh0ZW5zaW9uczsgICAgIH0gfSxcbiAgICBidWZmZXJlZEFtb3VudDogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fYnVmZmVyZWRBbW91bnQ7IH0gfVxufSk7XG5cblxuLy8gRXhwb3NlIFczQyB3cml0ZS9yZWFkIGF0dHJpYnV0ZXMuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhXM0NXZWJTb2NrZXQucHJvdG90eXBlLCB7XG4gICAgYmluYXJ5VHlwZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmFyeVR5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgLy8gVE9ETzogSnVzdCAnYXJyYXlidWZmZXInIHN1cHBvcnRlZC5cbiAgICAgICAgICAgIGlmICh0eXBlICE9PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdqdXN0IFwiYXJyYXlidWZmZXJcIiB0eXBlIGFsbG93ZWQgZm9yIFwiYmluYXJ5VHlwZVwiIGF0dHJpYnV0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYmluYXJ5VHlwZSA9IHR5cGU7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG4vLyBFeHBvc2UgVzNDIHJlYWR5U3RhdGUgY29uc3RhbnRzIGludG8gdGhlIFdlYlNvY2tldCBpbnN0YW5jZSBhcyBXM0Mgc3RhdGVzLlxuW1snQ09OTkVDVElORycsQ09OTkVDVElOR10sIFsnT1BFTicsT1BFTl0sIFsnQ0xPU0lORycsQ0xPU0lOR10sIFsnQ0xPU0VEJyxDTE9TRURdXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFczQ1dlYlNvY2tldC5wcm90b3R5cGUsIHByb3BlcnR5WzBdLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBwcm9wZXJ0eVsxXTsgfVxuICAgIH0pO1xufSk7XG5cbi8vIEFsc28gZXhwb3NlIFczQyByZWFkeVN0YXRlIGNvbnN0YW50cyBpbnRvIHRoZSBXZWJTb2NrZXQgY2xhc3MgKG5vdCBkZWZpbmVkIGJ5IHRoZSBXM0MsXG4vLyBidXQgdGhlcmUgYXJlIHNvIG1hbnkgbGlicyByZWx5aW5nIG9uIHRoZW0pLlxuW1snQ09OTkVDVElORycsQ09OTkVDVElOR10sIFsnT1BFTicsT1BFTl0sIFsnQ0xPU0lORycsQ0xPU0lOR10sIFsnQ0xPU0VEJyxDTE9TRURdXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFczQ1dlYlNvY2tldCwgcHJvcGVydHlbMF0sIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHByb3BlcnR5WzFdOyB9XG4gICAgfSk7XG59KTtcblxuXG5XM0NXZWJTb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYgKHRoaXMuX3JlYWR5U3RhdGUgIT09IE9QRU4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY2FsbCBzZW5kKCkgd2hpbGUgbm90IGNvbm5lY3RlZCcpO1xuICAgIH1cblxuICAgIC8vIFRleHQuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyB8fCBkYXRhIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uc2VuZFVURihkYXRhKTtcbiAgICB9XG4gICAgLy8gQmluYXJ5LlxuICAgIGVsc2Uge1xuICAgICAgICAvLyBOb2RlIEJ1ZmZlci5cbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uc2VuZEJ5dGVzKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldyBjb252ZXJ0IGl0IHRvIE5vZGUgQnVmZmVyLlxuICAgICAgICBlbHNlIGlmIChkYXRhLmJ5dGVMZW5ndGggfHwgZGF0YS5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkYXRhID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uLnNlbmRCeXRlcyhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBiaW5hcnkgZGF0YTonLCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuVzNDV2ViU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgIHN3aXRjaCh0aGlzLl9yZWFkeVN0YXRlKSB7XG4gICAgICAgIGNhc2UgQ09OTkVDVElORzpcbiAgICAgICAgICAgIC8vIE5PVEU6IFdlIGRvbid0IGhhdmUgdGhlIFdlYlNvY2tldENvbm5lY3Rpb24gaW5zdGFuY2UgeWV0IHNvIG5vXG4gICAgICAgICAgICAvLyB3YXkgdG8gY2xvc2UgdGhlIFRDUCBjb25uZWN0aW9uLlxuICAgICAgICAgICAgLy8gQXJ0aWZpY2lhbGx5IGludm9rZSB0aGUgb25Db25uZWN0RmFpbGVkIGV2ZW50LlxuICAgICAgICAgICAgb25Db25uZWN0RmFpbGVkLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAvLyBBbmQgY2xvc2UgaWYgaXQgY29ubmVjdHMgYWZ0ZXIgYSB3aGlsZS5cbiAgICAgICAgICAgIHRoaXMuX2NsaWVudC5vbignY29ubmVjdCcsIGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmNsb3NlKGNvZGUsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgT1BFTjpcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBDTE9TSU5HO1xuICAgICAgICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uLmNsb3NlKGNvZGUsIHJlYXNvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENMT1NJTkc6XG4gICAgICAgIGNhc2UgQ0xPU0VEOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblxuXG4vKipcbiAqIFByaXZhdGUgQVBJLlxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQ2xvc2VFdmVudChjb2RlLCByZWFzb24pIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgeWFldGkuRXZlbnQoJ2Nsb3NlJyk7XG5cbiAgICBldmVudC5jb2RlID0gY29kZTtcbiAgICBldmVudC5yZWFzb24gPSByZWFzb247XG4gICAgZXZlbnQud2FzQ2xlYW4gPSAodHlwZW9mIGNvZGUgPT09ICd1bmRlZmluZWQnIHx8IGNvZGUgPT09IDEwMDApO1xuXG4gICAgcmV0dXJuIGV2ZW50O1xufVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VFdmVudChkYXRhKSB7XG4gICAgdmFyIGV2ZW50ID0gbmV3IHlhZXRpLkV2ZW50KCdtZXNzYWdlJyk7XG5cbiAgICBldmVudC5kYXRhID0gZGF0YTtcblxuICAgIHJldHVybiBldmVudDtcbn1cblxuXG5mdW5jdGlvbiBvbkNvbm5lY3QoY29ubmVjdGlvbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBPUEVOO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgIHRoaXMuX3Byb3RvY29sID0gY29ubmVjdGlvbi5wcm90b2NvbDtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gY29ubmVjdGlvbi5leHRlbnNpb25zO1xuXG4gICAgdGhpcy5fY29ubmVjdGlvbi5vbignY2xvc2UnLCBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgICAgICAgb25DbG9zZS5jYWxsKHNlbGYsIGNvZGUsIHJlYXNvbik7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9jb25uZWN0aW9uLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgICAgIG9uTWVzc2FnZS5jYWxsKHNlbGYsIG1zZyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IHlhZXRpLkV2ZW50KCdvcGVuJykpO1xufVxuXG5cbmZ1bmN0aW9uIG9uQ29ubmVjdEZhaWxlZCgpIHtcbiAgICBkZXN0cm95LmNhbGwodGhpcyk7XG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IENMT1NFRDtcblxuICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgeWFldGkuRXZlbnQoJ2Vycm9yJykpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChjcmVhdGVDbG9zZUV2ZW50KDEwMDYsICdjb25uZWN0aW9uIGZhaWxlZCcpKTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gb25DbG9zZShjb2RlLCByZWFzb24pIHtcbiAgICBkZXN0cm95LmNhbGwodGhpcyk7XG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IENMT1NFRDtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChjcmVhdGVDbG9zZUV2ZW50KGNvZGUsIHJlYXNvbiB8fCAnJykpO1xufVxuXG5cbmZ1bmN0aW9uIG9uTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UudXRmOERhdGEpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGNyZWF0ZU1lc3NhZ2VFdmVudChtZXNzYWdlLnV0ZjhEYXRhKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1lc3NhZ2UuYmluYXJ5RGF0YSkge1xuICAgICAgICAvLyBNdXN0IGNvbnZlcnQgZnJvbSBOb2RlIEJ1ZmZlciB0byBBcnJheUJ1ZmZlci5cbiAgICAgICAgLy8gVE9ETzogb3IgdG8gYSBCbG9iICh3aGljaCBkb2VzIG5vdCBleGlzdCBpbiBOb2RlISkuXG4gICAgICAgIGlmICh0aGlzLmJpbmFyeVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBtZXNzYWdlLmJpbmFyeURhdGE7XG4gICAgICAgICAgICB2YXIgYXJyYXlidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgbGVuPWJ1ZmZlci5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2aWV3W2ldID0gYnVmZmVyW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGNyZWF0ZU1lc3NhZ2VFdmVudChhcnJheWJ1ZmZlcikpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fY2xpZW50LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIGlmICh0aGlzLl9jb25uZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24ucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIldlYlNvY2tldENsaWVudCIsInJlcXVpcmUiLCJ0b0J1ZmZlciIsInlhZXRpIiwiQ09OTkVDVElORyIsIk9QRU4iLCJDTE9TSU5HIiwiQ0xPU0VEIiwibW9kdWxlIiwiZXhwb3J0cyIsIlczQ1dlYlNvY2tldCIsInVybCIsInByb3RvY29scyIsIm9yaWdpbiIsImhlYWRlcnMiLCJyZXF1ZXN0T3B0aW9ucyIsImNsaWVudENvbmZpZyIsIkV2ZW50VGFyZ2V0IiwiY2FsbCIsImFzc2VtYmxlRnJhZ21lbnRzIiwic2VsZiIsIl91cmwiLCJfcmVhZHlTdGF0ZSIsIl9wcm90b2NvbCIsInVuZGVmaW5lZCIsIl9leHRlbnNpb25zIiwiX2J1ZmZlcmVkQW1vdW50IiwiX2JpbmFyeVR5cGUiLCJfY29ubmVjdGlvbiIsIl9jbGllbnQiLCJvbiIsImNvbm5lY3Rpb24iLCJvbkNvbm5lY3QiLCJvbkNvbm5lY3RGYWlsZWQiLCJjb25uZWN0IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsInByb3RvdHlwZSIsImdldCIsInJlYWR5U3RhdGUiLCJwcm90b2NvbCIsImV4dGVuc2lvbnMiLCJidWZmZXJlZEFtb3VudCIsImJpbmFyeVR5cGUiLCJzZXQiLCJ0eXBlIiwiU3ludGF4RXJyb3IiLCJmb3JFYWNoIiwicHJvcGVydHkiLCJkZWZpbmVQcm9wZXJ0eSIsInNlbmQiLCJkYXRhIiwiRXJyb3IiLCJTdHJpbmciLCJzZW5kVVRGIiwiQnVmZmVyIiwic2VuZEJ5dGVzIiwiYnl0ZUxlbmd0aCIsImNsb3NlIiwiY29kZSIsInJlYXNvbiIsImNyZWF0ZUNsb3NlRXZlbnQiLCJldmVudCIsIkV2ZW50Iiwid2FzQ2xlYW4iLCJjcmVhdGVNZXNzYWdlRXZlbnQiLCJvbkNsb3NlIiwibXNnIiwib25NZXNzYWdlIiwiZGlzcGF0Y2hFdmVudCIsImRlc3Ryb3kiLCJtZXNzYWdlIiwidXRmOERhdGEiLCJiaW5hcnlEYXRhIiwiYnVmZmVyIiwiYXJyYXlidWZmZXIiLCJBcnJheUJ1ZmZlciIsImxlbmd0aCIsInZpZXciLCJVaW50OEFycmF5IiwiaSIsImxlbiIsInJlbW92ZUFsbExpc3RlbmVycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/W3CWebSocket.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/WebSocketClient.js":
/*!*******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketClient.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ var utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/websocket/lib/utils.js\");\nvar extend = utils.extend;\nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar url = __webpack_require__(/*! url */ \"url\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar WebSocketConnection = __webpack_require__(/*! ./WebSocketConnection */ \"(ssr)/./node_modules/websocket/lib/WebSocketConnection.js\");\nvar bufferAllocUnsafe = utils.bufferAllocUnsafe;\nvar protocolSeparators = [\n    \"(\",\n    \")\",\n    \"<\",\n    \">\",\n    \"@\",\n    \",\",\n    \";\",\n    \":\",\n    \"\\\\\",\n    '\"',\n    \"/\",\n    \"[\",\n    \"]\",\n    \"?\",\n    \"=\",\n    \"{\",\n    \"}\",\n    \" \",\n    String.fromCharCode(9)\n];\nvar excludedTlsOptions = [\n    \"hostname\",\n    \"port\",\n    \"method\",\n    \"path\",\n    \"headers\"\n];\nfunction WebSocketClient(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n    // TODO: Implement extensions\n    this.config = {\n        // 1MiB max frame size.\n        maxReceivedFrameSize: 0x100000,\n        // 8MiB max message size, only applicable if\n        // assembleFragments is true\n        maxReceivedMessageSize: 0x800000,\n        // Outgoing messages larger than fragmentationThreshold will be\n        // split into multiple fragments.\n        fragmentOutgoingMessages: true,\n        // Outgoing frames are fragmented if they exceed this threshold.\n        // Default is 16KiB\n        fragmentationThreshold: 0x4000,\n        // Which version of the protocol to use for this session.  This\n        // option will be removed once the protocol is finalized by the IETF\n        // It is only available to ease the transition through the\n        // intermediate draft protocol versions.\n        // At present, it only affects the name of the Origin header.\n        webSocketVersion: 13,\n        // If true, fragmented messages will be automatically assembled\n        // and the full message will be emitted via a 'message' event.\n        // If false, each frame will be emitted via a 'frame' event and\n        // the application will be responsible for aggregating multiple\n        // fragmented frames.  Single-frame messages will emit a 'message'\n        // event in addition to the 'frame' event.\n        // Most users will want to leave this set to 'true'\n        assembleFragments: true,\n        // The Nagle Algorithm makes more efficient use of network resources\n        // by introducing a small delay before sending small packets so that\n        // multiple messages can be batched together before going onto the\n        // wire.  This however comes at the cost of latency, so the default\n        // is to disable it.  If you don't need low latency and are streaming\n        // lots of small messages, you can change this to 'false'\n        disableNagleAlgorithm: true,\n        // The number of milliseconds to wait after sending a close frame\n        // for an acknowledgement to come back before giving up and just\n        // closing the socket.\n        closeTimeout: 5000,\n        // Options to pass to https.connect if connecting via TLS\n        tlsOptions: {}\n    };\n    if (config) {\n        var tlsOptions;\n        if (config.tlsOptions) {\n            tlsOptions = config.tlsOptions;\n            delete config.tlsOptions;\n        } else {\n            tlsOptions = {};\n        }\n        extend(this.config, config);\n        extend(this.config.tlsOptions, tlsOptions);\n    }\n    this._req = null;\n    switch(this.config.webSocketVersion){\n        case 8:\n        case 13:\n            break;\n        default:\n            throw new Error(\"Requested webSocketVersion is not supported. Allowed values are 8 and 13.\");\n    }\n}\nutil.inherits(WebSocketClient, EventEmitter);\nWebSocketClient.prototype.connect = function(requestUrl, protocols, origin, headers, extraRequestOptions) {\n    var self = this;\n    if (typeof protocols === \"string\") {\n        if (protocols.length > 0) {\n            protocols = [\n                protocols\n            ];\n        } else {\n            protocols = [];\n        }\n    }\n    if (!(protocols instanceof Array)) {\n        protocols = [];\n    }\n    this.protocols = protocols;\n    this.origin = origin;\n    if (typeof requestUrl === \"string\") {\n        this.url = url.parse(requestUrl);\n    } else {\n        this.url = requestUrl; // in case an already parsed url is passed in.\n    }\n    if (!this.url.protocol) {\n        throw new Error(\"You must specify a full WebSocket URL, including protocol.\");\n    }\n    if (!this.url.host) {\n        throw new Error(\"You must specify a full WebSocket URL, including hostname. Relative URLs are not supported.\");\n    }\n    this.secure = this.url.protocol === \"wss:\";\n    // validate protocol characters:\n    this.protocols.forEach(function(protocol) {\n        for(var i = 0; i < protocol.length; i++){\n            var charCode = protocol.charCodeAt(i);\n            var character = protocol.charAt(i);\n            if (charCode < 0x0021 || charCode > 0x007E || protocolSeparators.indexOf(character) !== -1) {\n                throw new Error('Protocol list contains invalid character \"' + String.fromCharCode(charCode) + '\"');\n            }\n        }\n    });\n    var defaultPorts = {\n        \"ws:\": \"80\",\n        \"wss:\": \"443\"\n    };\n    if (!this.url.port) {\n        this.url.port = defaultPorts[this.url.protocol];\n    }\n    var nonce = bufferAllocUnsafe(16);\n    for(var i = 0; i < 16; i++){\n        nonce[i] = Math.round(Math.random() * 0xFF);\n    }\n    this.base64nonce = nonce.toString(\"base64\");\n    var hostHeaderValue = this.url.hostname;\n    if (this.url.protocol === \"ws:\" && this.url.port !== \"80\" || this.url.protocol === \"wss:\" && this.url.port !== \"443\") {\n        hostHeaderValue += \":\" + this.url.port;\n    }\n    var reqHeaders = {};\n    if (this.secure && this.config.tlsOptions.hasOwnProperty(\"headers\")) {\n        // Allow for additional headers to be provided when connecting via HTTPS\n        extend(reqHeaders, this.config.tlsOptions.headers);\n    }\n    if (headers) {\n        // Explicitly provided headers take priority over any from tlsOptions\n        extend(reqHeaders, headers);\n    }\n    extend(reqHeaders, {\n        \"Upgrade\": \"websocket\",\n        \"Connection\": \"Upgrade\",\n        \"Sec-WebSocket-Version\": this.config.webSocketVersion.toString(10),\n        \"Sec-WebSocket-Key\": this.base64nonce,\n        \"Host\": reqHeaders.Host || hostHeaderValue\n    });\n    if (this.protocols.length > 0) {\n        reqHeaders[\"Sec-WebSocket-Protocol\"] = this.protocols.join(\", \");\n    }\n    if (this.origin) {\n        if (this.config.webSocketVersion === 13) {\n            reqHeaders[\"Origin\"] = this.origin;\n        } else if (this.config.webSocketVersion === 8) {\n            reqHeaders[\"Sec-WebSocket-Origin\"] = this.origin;\n        }\n    }\n    // TODO: Implement extensions\n    var pathAndQuery;\n    // Ensure it begins with '/'.\n    if (this.url.pathname) {\n        pathAndQuery = this.url.path;\n    } else if (this.url.path) {\n        pathAndQuery = \"/\" + this.url.path;\n    } else {\n        pathAndQuery = \"/\";\n    }\n    function handleRequestError(error) {\n        self._req = null;\n        self.emit(\"connectFailed\", error);\n    }\n    var requestOptions = {\n        agent: false\n    };\n    if (extraRequestOptions) {\n        extend(requestOptions, extraRequestOptions);\n    }\n    // These options are always overridden by the library.  The user is not\n    // allowed to specify these directly.\n    extend(requestOptions, {\n        hostname: this.url.hostname,\n        port: this.url.port,\n        method: \"GET\",\n        path: pathAndQuery,\n        headers: reqHeaders\n    });\n    if (this.secure) {\n        var tlsOptions = this.config.tlsOptions;\n        for(var key in tlsOptions){\n            if (tlsOptions.hasOwnProperty(key) && excludedTlsOptions.indexOf(key) === -1) {\n                requestOptions[key] = tlsOptions[key];\n            }\n        }\n    }\n    var req = this._req = (this.secure ? https : http).request(requestOptions);\n    req.on(\"upgrade\", function handleRequestUpgrade(response, socket, head) {\n        self._req = null;\n        req.removeListener(\"error\", handleRequestError);\n        self.socket = socket;\n        self.response = response;\n        self.firstDataChunk = head;\n        self.validateHandshake();\n    });\n    req.on(\"error\", handleRequestError);\n    req.on(\"response\", function(response) {\n        self._req = null;\n        if (utils.eventEmitterListenerCount(self, \"httpResponse\") > 0) {\n            self.emit(\"httpResponse\", response, self);\n            if (response.socket) {\n                response.socket.end();\n            }\n        } else {\n            var headerDumpParts = [];\n            for(var headerName in response.headers){\n                headerDumpParts.push(headerName + \": \" + response.headers[headerName]);\n            }\n            self.failHandshake(\"Server responded with a non-101 status: \" + response.statusCode + \" \" + response.statusMessage + \"\\nResponse Headers Follow:\\n\" + headerDumpParts.join(\"\\n\") + \"\\n\");\n        }\n    });\n    req.end();\n};\nWebSocketClient.prototype.validateHandshake = function() {\n    var headers = this.response.headers;\n    if (this.protocols.length > 0) {\n        this.protocol = headers[\"sec-websocket-protocol\"];\n        if (this.protocol) {\n            if (this.protocols.indexOf(this.protocol) === -1) {\n                this.failHandshake(\"Server did not respond with a requested protocol.\");\n                return;\n            }\n        } else {\n            this.failHandshake(\"Expected a Sec-WebSocket-Protocol header.\");\n            return;\n        }\n    }\n    if (!(headers[\"connection\"] && headers[\"connection\"].toLocaleLowerCase() === \"upgrade\")) {\n        this.failHandshake(\"Expected a Connection: Upgrade header from the server\");\n        return;\n    }\n    if (!(headers[\"upgrade\"] && headers[\"upgrade\"].toLocaleLowerCase() === \"websocket\")) {\n        this.failHandshake(\"Expected an Upgrade: websocket header from the server\");\n        return;\n    }\n    var sha1 = crypto.createHash(\"sha1\");\n    sha1.update(this.base64nonce + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\");\n    var expectedKey = sha1.digest(\"base64\");\n    if (!headers[\"sec-websocket-accept\"]) {\n        this.failHandshake(\"Expected Sec-WebSocket-Accept header from server\");\n        return;\n    }\n    if (headers[\"sec-websocket-accept\"] !== expectedKey) {\n        this.failHandshake(\"Sec-WebSocket-Accept header from server didn't match expected value of \" + expectedKey);\n        return;\n    }\n    // TODO: Support extensions\n    this.succeedHandshake();\n};\nWebSocketClient.prototype.failHandshake = function(errorDescription) {\n    if (this.socket && this.socket.writable) {\n        this.socket.end();\n    }\n    this.emit(\"connectFailed\", new Error(errorDescription));\n};\nWebSocketClient.prototype.succeedHandshake = function() {\n    var connection = new WebSocketConnection(this.socket, [], this.protocol, true, this.config);\n    connection.webSocketVersion = this.config.webSocketVersion;\n    connection._addSocketEventListeners();\n    this.emit(\"connect\", connection);\n    if (this.firstDataChunk.length > 0) {\n        connection.handleSocketData(this.firstDataChunk);\n    }\n    this.firstDataChunk = null;\n};\nWebSocketClient.prototype.abort = function() {\n    if (this._req) {\n        this._req.abort();\n    }\n};\nmodule.exports = WebSocketClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRDbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O3VFQWN1RSxHQUV2RSxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQixJQUFJQyxTQUFTRixNQUFNRSxNQUFNO0FBQ3pCLElBQUlDLE9BQU9GLG1CQUFPQSxDQUFDO0FBQ25CLElBQUlHLGVBQWVILDBEQUE4QjtBQUNqRCxJQUFJSSxPQUFPSixtQkFBT0EsQ0FBQztBQUNuQixJQUFJSyxRQUFRTCxtQkFBT0EsQ0FBQztBQUNwQixJQUFJTSxNQUFNTixtQkFBT0EsQ0FBQztBQUNsQixJQUFJTyxTQUFTUCxtQkFBT0EsQ0FBQztBQUNyQixJQUFJUSxzQkFBc0JSLG1CQUFPQSxDQUFDO0FBQ2xDLElBQUlTLG9CQUFvQlYsTUFBTVUsaUJBQWlCO0FBRS9DLElBQUlDLHFCQUFxQjtJQUNyQjtJQUFLO0lBQUs7SUFBSztJQUFLO0lBQ3BCO0lBQUs7SUFBSztJQUFLO0lBQU07SUFDckI7SUFBSztJQUFLO0lBQUs7SUFBSztJQUNwQjtJQUFLO0lBQUs7SUFBS0MsT0FBT0MsWUFBWSxDQUFDO0NBQ3RDO0FBRUQsSUFBSUMscUJBQXFCO0lBQUM7SUFBVztJQUFPO0lBQVM7SUFBTztDQUFVO0FBRXRFLFNBQVNDLGdCQUFnQkMsTUFBTTtJQUMzQix5QkFBeUI7SUFDekJaLGFBQWFhLElBQUksQ0FBQyxJQUFJO0lBRXRCLDZCQUE2QjtJQUU3QixJQUFJLENBQUNELE1BQU0sR0FBRztRQUNWLHVCQUF1QjtRQUN2QkUsc0JBQXNCO1FBRXRCLDRDQUE0QztRQUM1Qyw0QkFBNEI7UUFDNUJDLHdCQUF3QjtRQUV4QiwrREFBK0Q7UUFDL0QsaUNBQWlDO1FBQ2pDQywwQkFBMEI7UUFFMUIsZ0VBQWdFO1FBQ2hFLG1CQUFtQjtRQUNuQkMsd0JBQXdCO1FBRXhCLCtEQUErRDtRQUMvRCxvRUFBb0U7UUFDcEUsMERBQTBEO1FBQzFELHdDQUF3QztRQUN4Qyw2REFBNkQ7UUFDN0RDLGtCQUFrQjtRQUVsQiwrREFBK0Q7UUFDL0QsOERBQThEO1FBQzlELCtEQUErRDtRQUMvRCwrREFBK0Q7UUFDL0Qsa0VBQWtFO1FBQ2xFLDBDQUEwQztRQUMxQyxtREFBbUQ7UUFDbkRDLG1CQUFtQjtRQUVuQixvRUFBb0U7UUFDcEUsb0VBQW9FO1FBQ3BFLGtFQUFrRTtRQUNsRSxtRUFBbUU7UUFDbkUscUVBQXFFO1FBQ3JFLHlEQUF5RDtRQUN6REMsdUJBQXVCO1FBRXZCLGlFQUFpRTtRQUNqRSxnRUFBZ0U7UUFDaEUsc0JBQXNCO1FBQ3RCQyxjQUFjO1FBRWQseURBQXlEO1FBQ3pEQyxZQUFZLENBQUM7SUFDakI7SUFFQSxJQUFJVixRQUFRO1FBQ1IsSUFBSVU7UUFDSixJQUFJVixPQUFPVSxVQUFVLEVBQUU7WUFDckJBLGFBQWFWLE9BQU9VLFVBQVU7WUFDOUIsT0FBT1YsT0FBT1UsVUFBVTtRQUMxQixPQUNLO1lBQ0hBLGFBQWEsQ0FBQztRQUNoQjtRQUNBeEIsT0FBTyxJQUFJLENBQUNjLE1BQU0sRUFBRUE7UUFDcEJkLE9BQU8sSUFBSSxDQUFDYyxNQUFNLENBQUNVLFVBQVUsRUFBRUE7SUFDbkM7SUFFQSxJQUFJLENBQUNDLElBQUksR0FBRztJQUVaLE9BQVEsSUFBSSxDQUFDWCxNQUFNLENBQUNNLGdCQUFnQjtRQUNoQyxLQUFLO1FBQ0wsS0FBSztZQUNEO1FBQ0o7WUFDSSxNQUFNLElBQUlNLE1BQU07SUFDeEI7QUFDSjtBQUVBekIsS0FBSzBCLFFBQVEsQ0FBQ2QsaUJBQWlCWDtBQUUvQlcsZ0JBQWdCZSxTQUFTLENBQUNDLE9BQU8sR0FBRyxTQUFTQyxVQUFVLEVBQUVDLFNBQVMsRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLG1CQUFtQjtJQUNwRyxJQUFJQyxPQUFPLElBQUk7SUFFZixJQUFJLE9BQU9KLGNBQWUsVUFBVTtRQUNoQyxJQUFJQSxVQUFVSyxNQUFNLEdBQUcsR0FBRztZQUN0QkwsWUFBWTtnQkFBQ0E7YUFBVTtRQUMzQixPQUNLO1lBQ0RBLFlBQVksRUFBRTtRQUNsQjtJQUNKO0lBQ0EsSUFBSSxDQUFFQSxDQUFBQSxxQkFBcUJNLEtBQUksR0FBSTtRQUMvQk4sWUFBWSxFQUFFO0lBQ2xCO0lBQ0EsSUFBSSxDQUFDQSxTQUFTLEdBQUdBO0lBQ2pCLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtJQUVkLElBQUksT0FBT0YsZUFBZ0IsVUFBVTtRQUNqQyxJQUFJLENBQUN6QixHQUFHLEdBQUdBLElBQUlpQyxLQUFLLENBQUNSO0lBQ3pCLE9BQ0s7UUFDRCxJQUFJLENBQUN6QixHQUFHLEdBQUd5QixZQUFZLDhDQUE4QztJQUN6RTtJQUNBLElBQUksQ0FBQyxJQUFJLENBQUN6QixHQUFHLENBQUNrQyxRQUFRLEVBQUU7UUFDcEIsTUFBTSxJQUFJYixNQUFNO0lBQ3BCO0lBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ3JCLEdBQUcsQ0FBQ21DLElBQUksRUFBRTtRQUNoQixNQUFNLElBQUlkLE1BQU07SUFDcEI7SUFFQSxJQUFJLENBQUNlLE1BQU0sR0FBSSxJQUFJLENBQUNwQyxHQUFHLENBQUNrQyxRQUFRLEtBQUs7SUFFckMsZ0NBQWdDO0lBQ2hDLElBQUksQ0FBQ1IsU0FBUyxDQUFDVyxPQUFPLENBQUMsU0FBU0gsUUFBUTtRQUNwQyxJQUFLLElBQUlJLElBQUUsR0FBR0EsSUFBSUosU0FBU0gsTUFBTSxFQUFFTyxJQUFNO1lBQ3JDLElBQUlDLFdBQVdMLFNBQVNNLFVBQVUsQ0FBQ0Y7WUFDbkMsSUFBSUcsWUFBWVAsU0FBU1EsTUFBTSxDQUFDSjtZQUNoQyxJQUFJQyxXQUFXLFVBQVVBLFdBQVcsVUFBVW5DLG1CQUFtQnVDLE9BQU8sQ0FBQ0YsZUFBZSxDQUFDLEdBQUc7Z0JBQ3hGLE1BQU0sSUFBSXBCLE1BQU0sK0NBQStDaEIsT0FBT0MsWUFBWSxDQUFDaUMsWUFBWTtZQUNuRztRQUNKO0lBQ0o7SUFFQSxJQUFJSyxlQUFlO1FBQ2YsT0FBTztRQUNQLFFBQVE7SUFDWjtJQUVBLElBQUksQ0FBQyxJQUFJLENBQUM1QyxHQUFHLENBQUM2QyxJQUFJLEVBQUU7UUFDaEIsSUFBSSxDQUFDN0MsR0FBRyxDQUFDNkMsSUFBSSxHQUFHRCxZQUFZLENBQUMsSUFBSSxDQUFDNUMsR0FBRyxDQUFDa0MsUUFBUSxDQUFDO0lBQ25EO0lBRUEsSUFBSVksUUFBUTNDLGtCQUFrQjtJQUM5QixJQUFLLElBQUltQyxJQUFFLEdBQUdBLElBQUksSUFBSUEsSUFBSztRQUN2QlEsS0FBSyxDQUFDUixFQUFFLEdBQUdTLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFHO0lBQ3hDO0lBQ0EsSUFBSSxDQUFDQyxXQUFXLEdBQUdKLE1BQU1LLFFBQVEsQ0FBQztJQUVsQyxJQUFJQyxrQkFBa0IsSUFBSSxDQUFDcEQsR0FBRyxDQUFDcUQsUUFBUTtJQUN2QyxJQUFJLElBQUssQ0FBQ3JELEdBQUcsQ0FBQ2tDLFFBQVEsS0FBSyxTQUFTLElBQUksQ0FBQ2xDLEdBQUcsQ0FBQzZDLElBQUksS0FBSyxRQUNqRCxJQUFJLENBQUM3QyxHQUFHLENBQUNrQyxRQUFRLEtBQUssVUFBVSxJQUFJLENBQUNsQyxHQUFHLENBQUM2QyxJQUFJLEtBQUssT0FBUztRQUM1RE8sbUJBQW9CLE1BQU0sSUFBSSxDQUFDcEQsR0FBRyxDQUFDNkMsSUFBSTtJQUMzQztJQUVBLElBQUlTLGFBQWEsQ0FBQztJQUNsQixJQUFJLElBQUksQ0FBQ2xCLE1BQU0sSUFBSSxJQUFJLENBQUMzQixNQUFNLENBQUNVLFVBQVUsQ0FBQ29DLGNBQWMsQ0FBQyxZQUFZO1FBQ25FLHdFQUF3RTtRQUN4RTVELE9BQU8yRCxZQUFZLElBQUksQ0FBQzdDLE1BQU0sQ0FBQ1UsVUFBVSxDQUFDUyxPQUFPO0lBQ25EO0lBQ0EsSUFBSUEsU0FBUztRQUNYLHFFQUFxRTtRQUNyRWpDLE9BQU8yRCxZQUFZMUI7SUFDckI7SUFDQWpDLE9BQU8yRCxZQUFZO1FBQ2YsV0FBVztRQUNYLGNBQWM7UUFDZCx5QkFBeUIsSUFBSSxDQUFDN0MsTUFBTSxDQUFDTSxnQkFBZ0IsQ0FBQ29DLFFBQVEsQ0FBQztRQUMvRCxxQkFBcUIsSUFBSSxDQUFDRCxXQUFXO1FBQ3JDLFFBQVFJLFdBQVdFLElBQUksSUFBSUo7SUFDL0I7SUFFQSxJQUFJLElBQUksQ0FBQzFCLFNBQVMsQ0FBQ0ssTUFBTSxHQUFHLEdBQUc7UUFDM0J1QixVQUFVLENBQUMseUJBQXlCLEdBQUcsSUFBSSxDQUFDNUIsU0FBUyxDQUFDK0IsSUFBSSxDQUFDO0lBQy9EO0lBQ0EsSUFBSSxJQUFJLENBQUM5QixNQUFNLEVBQUU7UUFDYixJQUFJLElBQUksQ0FBQ2xCLE1BQU0sQ0FBQ00sZ0JBQWdCLEtBQUssSUFBSTtZQUNyQ3VDLFVBQVUsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDM0IsTUFBTTtRQUN0QyxPQUNLLElBQUksSUFBSSxDQUFDbEIsTUFBTSxDQUFDTSxnQkFBZ0IsS0FBSyxHQUFHO1lBQ3pDdUMsVUFBVSxDQUFDLHVCQUF1QixHQUFHLElBQUksQ0FBQzNCLE1BQU07UUFDcEQ7SUFDSjtJQUVBLDZCQUE2QjtJQUU3QixJQUFJK0I7SUFDSiw2QkFBNkI7SUFDN0IsSUFBSSxJQUFJLENBQUMxRCxHQUFHLENBQUMyRCxRQUFRLEVBQUU7UUFDbkJELGVBQWUsSUFBSSxDQUFDMUQsR0FBRyxDQUFDNEQsSUFBSTtJQUNoQyxPQUNLLElBQUksSUFBSSxDQUFDNUQsR0FBRyxDQUFDNEQsSUFBSSxFQUFFO1FBQ3BCRixlQUFlLE1BQU0sSUFBSSxDQUFDMUQsR0FBRyxDQUFDNEQsSUFBSTtJQUN0QyxPQUNLO1FBQ0RGLGVBQWU7SUFDbkI7SUFFQSxTQUFTRyxtQkFBbUJDLEtBQUs7UUFDN0JoQyxLQUFLVixJQUFJLEdBQUc7UUFDWlUsS0FBS2lDLElBQUksQ0FBQyxpQkFBaUJEO0lBQy9CO0lBRUEsSUFBSUUsaUJBQWlCO1FBQ2pCQyxPQUFPO0lBQ1g7SUFDQSxJQUFJcEMscUJBQXFCO1FBQ3JCbEMsT0FBT3FFLGdCQUFnQm5DO0lBQzNCO0lBQ0EsdUVBQXVFO0lBQ3ZFLHFDQUFxQztJQUNyQ2xDLE9BQU9xRSxnQkFBZ0I7UUFDbkJYLFVBQVUsSUFBSSxDQUFDckQsR0FBRyxDQUFDcUQsUUFBUTtRQUMzQlIsTUFBTSxJQUFJLENBQUM3QyxHQUFHLENBQUM2QyxJQUFJO1FBQ25CcUIsUUFBUTtRQUNSTixNQUFNRjtRQUNOOUIsU0FBUzBCO0lBQ2I7SUFDQSxJQUFJLElBQUksQ0FBQ2xCLE1BQU0sRUFBRTtRQUNiLElBQUlqQixhQUFhLElBQUksQ0FBQ1YsTUFBTSxDQUFDVSxVQUFVO1FBQ3ZDLElBQUssSUFBSWdELE9BQU9oRCxXQUFZO1lBQ3hCLElBQUlBLFdBQVdvQyxjQUFjLENBQUNZLFFBQVE1RCxtQkFBbUJvQyxPQUFPLENBQUN3QixTQUFTLENBQUMsR0FBRztnQkFDMUVILGNBQWMsQ0FBQ0csSUFBSSxHQUFHaEQsVUFBVSxDQUFDZ0QsSUFBSTtZQUN6QztRQUNKO0lBQ0o7SUFFQSxJQUFJQyxNQUFNLElBQUksQ0FBQ2hELElBQUksR0FBRyxDQUFDLElBQUksQ0FBQ2dCLE1BQU0sR0FBR3JDLFFBQVFELElBQUcsRUFBR3VFLE9BQU8sQ0FBQ0w7SUFDM0RJLElBQUlFLEVBQUUsQ0FBQyxXQUFXLFNBQVNDLHFCQUFxQkMsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLElBQUk7UUFDbEU1QyxLQUFLVixJQUFJLEdBQUc7UUFDWmdELElBQUlPLGNBQWMsQ0FBQyxTQUFTZDtRQUM1Qi9CLEtBQUsyQyxNQUFNLEdBQUdBO1FBQ2QzQyxLQUFLMEMsUUFBUSxHQUFHQTtRQUNoQjFDLEtBQUs4QyxjQUFjLEdBQUdGO1FBQ3RCNUMsS0FBSytDLGlCQUFpQjtJQUMxQjtJQUNBVCxJQUFJRSxFQUFFLENBQUMsU0FBU1Q7SUFFaEJPLElBQUlFLEVBQUUsQ0FBQyxZQUFZLFNBQVNFLFFBQVE7UUFDaEMxQyxLQUFLVixJQUFJLEdBQUc7UUFDWixJQUFJM0IsTUFBTXFGLHlCQUF5QixDQUFDaEQsTUFBTSxrQkFBa0IsR0FBRztZQUMzREEsS0FBS2lDLElBQUksQ0FBQyxnQkFBZ0JTLFVBQVUxQztZQUNwQyxJQUFJMEMsU0FBU0MsTUFBTSxFQUFFO2dCQUNqQkQsU0FBU0MsTUFBTSxDQUFDTSxHQUFHO1lBQ3ZCO1FBQ0osT0FDSztZQUNELElBQUlDLGtCQUFrQixFQUFFO1lBQ3hCLElBQUssSUFBSUMsY0FBY1QsU0FBUzVDLE9BQU8sQ0FBRTtnQkFDckNvRCxnQkFBZ0JFLElBQUksQ0FBQ0QsYUFBYSxPQUFPVCxTQUFTNUMsT0FBTyxDQUFDcUQsV0FBVztZQUN6RTtZQUNBbkQsS0FBS3FELGFBQWEsQ0FDZCw2Q0FDQVgsU0FBU1ksVUFBVSxHQUFHLE1BQU1aLFNBQVNhLGFBQWEsR0FDbEQsaUNBQ0FMLGdCQUFnQnZCLElBQUksQ0FBQyxRQUFRO1FBRXJDO0lBQ0o7SUFDQVcsSUFBSVcsR0FBRztBQUNYO0FBRUF2RSxnQkFBZ0JlLFNBQVMsQ0FBQ3NELGlCQUFpQixHQUFHO0lBQzFDLElBQUlqRCxVQUFVLElBQUksQ0FBQzRDLFFBQVEsQ0FBQzVDLE9BQU87SUFFbkMsSUFBSSxJQUFJLENBQUNGLFNBQVMsQ0FBQ0ssTUFBTSxHQUFHLEdBQUc7UUFDM0IsSUFBSSxDQUFDRyxRQUFRLEdBQUdOLE9BQU8sQ0FBQyx5QkFBeUI7UUFDakQsSUFBSSxJQUFJLENBQUNNLFFBQVEsRUFBRTtZQUNmLElBQUksSUFBSSxDQUFDUixTQUFTLENBQUNpQixPQUFPLENBQUMsSUFBSSxDQUFDVCxRQUFRLE1BQU0sQ0FBQyxHQUFHO2dCQUM5QyxJQUFJLENBQUNpRCxhQUFhLENBQUM7Z0JBQ25CO1lBQ0o7UUFDSixPQUNLO1lBQ0QsSUFBSSxDQUFDQSxhQUFhLENBQUM7WUFDbkI7UUFDSjtJQUNKO0lBRUEsSUFBSSxDQUFFdkQsQ0FBQUEsT0FBTyxDQUFDLGFBQWEsSUFBSUEsT0FBTyxDQUFDLGFBQWEsQ0FBQzBELGlCQUFpQixPQUFPLFNBQVEsR0FBSTtRQUNyRixJQUFJLENBQUNILGFBQWEsQ0FBQztRQUNuQjtJQUNKO0lBRUEsSUFBSSxDQUFFdkQsQ0FBQUEsT0FBTyxDQUFDLFVBQVUsSUFBSUEsT0FBTyxDQUFDLFVBQVUsQ0FBQzBELGlCQUFpQixPQUFPLFdBQVUsR0FBSTtRQUNqRixJQUFJLENBQUNILGFBQWEsQ0FBQztRQUNuQjtJQUNKO0lBRUEsSUFBSUksT0FBT3RGLE9BQU91RixVQUFVLENBQUM7SUFDN0JELEtBQUtFLE1BQU0sQ0FBQyxJQUFJLENBQUN2QyxXQUFXLEdBQUc7SUFDL0IsSUFBSXdDLGNBQWNILEtBQUtJLE1BQU0sQ0FBQztJQUU5QixJQUFJLENBQUMvRCxPQUFPLENBQUMsdUJBQXVCLEVBQUU7UUFDbEMsSUFBSSxDQUFDdUQsYUFBYSxDQUFDO1FBQ25CO0lBQ0o7SUFFQSxJQUFJdkQsT0FBTyxDQUFDLHVCQUF1QixLQUFLOEQsYUFBYTtRQUNqRCxJQUFJLENBQUNQLGFBQWEsQ0FBQyw0RUFBNkVPO1FBQ2hHO0lBQ0o7SUFFQSwyQkFBMkI7SUFFM0IsSUFBSSxDQUFDRSxnQkFBZ0I7QUFDekI7QUFFQXBGLGdCQUFnQmUsU0FBUyxDQUFDNEQsYUFBYSxHQUFHLFNBQVNVLGdCQUFnQjtJQUMvRCxJQUFJLElBQUksQ0FBQ3BCLE1BQU0sSUFBSSxJQUFJLENBQUNBLE1BQU0sQ0FBQ3FCLFFBQVEsRUFBRTtRQUNyQyxJQUFJLENBQUNyQixNQUFNLENBQUNNLEdBQUc7SUFDbkI7SUFDQSxJQUFJLENBQUNoQixJQUFJLENBQUMsaUJBQWlCLElBQUkxQyxNQUFNd0U7QUFDekM7QUFFQXJGLGdCQUFnQmUsU0FBUyxDQUFDcUUsZ0JBQWdCLEdBQUc7SUFDekMsSUFBSUcsYUFBYSxJQUFJN0Ysb0JBQW9CLElBQUksQ0FBQ3VFLE1BQU0sRUFBRSxFQUFFLEVBQUUsSUFBSSxDQUFDdkMsUUFBUSxFQUFFLE1BQU0sSUFBSSxDQUFDekIsTUFBTTtJQUUxRnNGLFdBQVdoRixnQkFBZ0IsR0FBRyxJQUFJLENBQUNOLE1BQU0sQ0FBQ00sZ0JBQWdCO0lBQzFEZ0YsV0FBV0Msd0JBQXdCO0lBRW5DLElBQUksQ0FBQ2pDLElBQUksQ0FBQyxXQUFXZ0M7SUFDckIsSUFBSSxJQUFJLENBQUNuQixjQUFjLENBQUM3QyxNQUFNLEdBQUcsR0FBRztRQUNoQ2dFLFdBQVdFLGdCQUFnQixDQUFDLElBQUksQ0FBQ3JCLGNBQWM7SUFDbkQ7SUFDQSxJQUFJLENBQUNBLGNBQWMsR0FBRztBQUMxQjtBQUVBcEUsZ0JBQWdCZSxTQUFTLENBQUMyRSxLQUFLLEdBQUc7SUFDOUIsSUFBSSxJQUFJLENBQUM5RSxJQUFJLEVBQUU7UUFDWCxJQUFJLENBQUNBLElBQUksQ0FBQzhFLEtBQUs7SUFDbkI7QUFDSjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc1RiIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRDbGllbnQuanM/M2IwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQ29weXJpZ2h0IDIwMTAtMjAxNSBCcmlhbiBNY0tlbHZleS5cbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBleHRlbmQgPSB1dGlscy5leHRlbmQ7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbnZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG52YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG52YXIgV2ViU29ja2V0Q29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vV2ViU29ja2V0Q29ubmVjdGlvbicpO1xudmFyIGJ1ZmZlckFsbG9jVW5zYWZlID0gdXRpbHMuYnVmZmVyQWxsb2NVbnNhZmU7XG5cbnZhciBwcm90b2NvbFNlcGFyYXRvcnMgPSBbXG4gICAgJygnLCAnKScsICc8JywgJz4nLCAnQCcsXG4gICAgJywnLCAnOycsICc6JywgJ1xcXFwnLCAnXFxcIicsXG4gICAgJy8nLCAnWycsICddJywgJz8nLCAnPScsXG4gICAgJ3snLCAnfScsICcgJywgU3RyaW5nLmZyb21DaGFyQ29kZSg5KVxuXTtcblxudmFyIGV4Y2x1ZGVkVGxzT3B0aW9ucyA9IFsnaG9zdG5hbWUnLCdwb3J0JywnbWV0aG9kJywncGF0aCcsJ2hlYWRlcnMnXTtcblxuZnVuY3Rpb24gV2ViU29ja2V0Q2xpZW50KGNvbmZpZykge1xuICAgIC8vIFN1cGVyY2xhc3MgQ29uc3RydWN0b3JcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIC8vIFRPRE86IEltcGxlbWVudCBleHRlbnNpb25zXG5cbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgLy8gMU1pQiBtYXggZnJhbWUgc2l6ZS5cbiAgICAgICAgbWF4UmVjZWl2ZWRGcmFtZVNpemU6IDB4MTAwMDAwLFxuXG4gICAgICAgIC8vIDhNaUIgbWF4IG1lc3NhZ2Ugc2l6ZSwgb25seSBhcHBsaWNhYmxlIGlmXG4gICAgICAgIC8vIGFzc2VtYmxlRnJhZ21lbnRzIGlzIHRydWVcbiAgICAgICAgbWF4UmVjZWl2ZWRNZXNzYWdlU2l6ZTogMHg4MDAwMDAsXG5cbiAgICAgICAgLy8gT3V0Z29pbmcgbWVzc2FnZXMgbGFyZ2VyIHRoYW4gZnJhZ21lbnRhdGlvblRocmVzaG9sZCB3aWxsIGJlXG4gICAgICAgIC8vIHNwbGl0IGludG8gbXVsdGlwbGUgZnJhZ21lbnRzLlxuICAgICAgICBmcmFnbWVudE91dGdvaW5nTWVzc2FnZXM6IHRydWUsXG5cbiAgICAgICAgLy8gT3V0Z29pbmcgZnJhbWVzIGFyZSBmcmFnbWVudGVkIGlmIHRoZXkgZXhjZWVkIHRoaXMgdGhyZXNob2xkLlxuICAgICAgICAvLyBEZWZhdWx0IGlzIDE2S2lCXG4gICAgICAgIGZyYWdtZW50YXRpb25UaHJlc2hvbGQ6IDB4NDAwMCxcblxuICAgICAgICAvLyBXaGljaCB2ZXJzaW9uIG9mIHRoZSBwcm90b2NvbCB0byB1c2UgZm9yIHRoaXMgc2Vzc2lvbi4gIFRoaXNcbiAgICAgICAgLy8gb3B0aW9uIHdpbGwgYmUgcmVtb3ZlZCBvbmNlIHRoZSBwcm90b2NvbCBpcyBmaW5hbGl6ZWQgYnkgdGhlIElFVEZcbiAgICAgICAgLy8gSXQgaXMgb25seSBhdmFpbGFibGUgdG8gZWFzZSB0aGUgdHJhbnNpdGlvbiB0aHJvdWdoIHRoZVxuICAgICAgICAvLyBpbnRlcm1lZGlhdGUgZHJhZnQgcHJvdG9jb2wgdmVyc2lvbnMuXG4gICAgICAgIC8vIEF0IHByZXNlbnQsIGl0IG9ubHkgYWZmZWN0cyB0aGUgbmFtZSBvZiB0aGUgT3JpZ2luIGhlYWRlci5cbiAgICAgICAgd2ViU29ja2V0VmVyc2lvbjogMTMsXG5cbiAgICAgICAgLy8gSWYgdHJ1ZSwgZnJhZ21lbnRlZCBtZXNzYWdlcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYXNzZW1ibGVkXG4gICAgICAgIC8vIGFuZCB0aGUgZnVsbCBtZXNzYWdlIHdpbGwgYmUgZW1pdHRlZCB2aWEgYSAnbWVzc2FnZScgZXZlbnQuXG4gICAgICAgIC8vIElmIGZhbHNlLCBlYWNoIGZyYW1lIHdpbGwgYmUgZW1pdHRlZCB2aWEgYSAnZnJhbWUnIGV2ZW50IGFuZFxuICAgICAgICAvLyB0aGUgYXBwbGljYXRpb24gd2lsbCBiZSByZXNwb25zaWJsZSBmb3IgYWdncmVnYXRpbmcgbXVsdGlwbGVcbiAgICAgICAgLy8gZnJhZ21lbnRlZCBmcmFtZXMuICBTaW5nbGUtZnJhbWUgbWVzc2FnZXMgd2lsbCBlbWl0IGEgJ21lc3NhZ2UnXG4gICAgICAgIC8vIGV2ZW50IGluIGFkZGl0aW9uIHRvIHRoZSAnZnJhbWUnIGV2ZW50LlxuICAgICAgICAvLyBNb3N0IHVzZXJzIHdpbGwgd2FudCB0byBsZWF2ZSB0aGlzIHNldCB0byAndHJ1ZSdcbiAgICAgICAgYXNzZW1ibGVGcmFnbWVudHM6IHRydWUsXG5cbiAgICAgICAgLy8gVGhlIE5hZ2xlIEFsZ29yaXRobSBtYWtlcyBtb3JlIGVmZmljaWVudCB1c2Ugb2YgbmV0d29yayByZXNvdXJjZXNcbiAgICAgICAgLy8gYnkgaW50cm9kdWNpbmcgYSBzbWFsbCBkZWxheSBiZWZvcmUgc2VuZGluZyBzbWFsbCBwYWNrZXRzIHNvIHRoYXRcbiAgICAgICAgLy8gbXVsdGlwbGUgbWVzc2FnZXMgY2FuIGJlIGJhdGNoZWQgdG9nZXRoZXIgYmVmb3JlIGdvaW5nIG9udG8gdGhlXG4gICAgICAgIC8vIHdpcmUuICBUaGlzIGhvd2V2ZXIgY29tZXMgYXQgdGhlIGNvc3Qgb2YgbGF0ZW5jeSwgc28gdGhlIGRlZmF1bHRcbiAgICAgICAgLy8gaXMgdG8gZGlzYWJsZSBpdC4gIElmIHlvdSBkb24ndCBuZWVkIGxvdyBsYXRlbmN5IGFuZCBhcmUgc3RyZWFtaW5nXG4gICAgICAgIC8vIGxvdHMgb2Ygc21hbGwgbWVzc2FnZXMsIHlvdSBjYW4gY2hhbmdlIHRoaXMgdG8gJ2ZhbHNlJ1xuICAgICAgICBkaXNhYmxlTmFnbGVBbGdvcml0aG06IHRydWUsXG5cbiAgICAgICAgLy8gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBhZnRlciBzZW5kaW5nIGEgY2xvc2UgZnJhbWVcbiAgICAgICAgLy8gZm9yIGFuIGFja25vd2xlZGdlbWVudCB0byBjb21lIGJhY2sgYmVmb3JlIGdpdmluZyB1cCBhbmQganVzdFxuICAgICAgICAvLyBjbG9zaW5nIHRoZSBzb2NrZXQuXG4gICAgICAgIGNsb3NlVGltZW91dDogNTAwMCxcblxuICAgICAgICAvLyBPcHRpb25zIHRvIHBhc3MgdG8gaHR0cHMuY29ubmVjdCBpZiBjb25uZWN0aW5nIHZpYSBUTFNcbiAgICAgICAgdGxzT3B0aW9uczoge31cbiAgICB9O1xuXG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgICB2YXIgdGxzT3B0aW9ucztcbiAgICAgICAgaWYgKGNvbmZpZy50bHNPcHRpb25zKSB7XG4gICAgICAgICAgdGxzT3B0aW9ucyA9IGNvbmZpZy50bHNPcHRpb25zO1xuICAgICAgICAgIGRlbGV0ZSBjb25maWcudGxzT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0bHNPcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZXh0ZW5kKHRoaXMuY29uZmlnLCBjb25maWcpO1xuICAgICAgICBleHRlbmQodGhpcy5jb25maWcudGxzT3B0aW9ucywgdGxzT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVxID0gbnVsbDtcbiAgICBcbiAgICBzd2l0Y2ggKHRoaXMuY29uZmlnLndlYlNvY2tldFZlcnNpb24pIHtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3RlZCB3ZWJTb2NrZXRWZXJzaW9uIGlzIG5vdCBzdXBwb3J0ZWQuIEFsbG93ZWQgdmFsdWVzIGFyZSA4IGFuZCAxMy4nKTtcbiAgICB9XG59XG5cbnV0aWwuaW5oZXJpdHMoV2ViU29ja2V0Q2xpZW50LCBFdmVudEVtaXR0ZXIpO1xuXG5XZWJTb2NrZXRDbGllbnQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbihyZXF1ZXN0VXJsLCBwcm90b2NvbHMsIG9yaWdpbiwgaGVhZGVycywgZXh0cmFSZXF1ZXN0T3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBcbiAgICBpZiAodHlwZW9mKHByb3RvY29scykgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChwcm90b2NvbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcm90b2NvbHMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIShwcm90b2NvbHMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgfVxuICAgIHRoaXMucHJvdG9jb2xzID0gcHJvdG9jb2xzO1xuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luO1xuXG4gICAgaWYgKHR5cGVvZihyZXF1ZXN0VXJsKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmwucGFyc2UocmVxdWVzdFVybCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnVybCA9IHJlcXVlc3RVcmw7IC8vIGluIGNhc2UgYW4gYWxyZWFkeSBwYXJzZWQgdXJsIGlzIHBhc3NlZCBpbi5cbiAgICB9XG4gICAgaWYgKCF0aGlzLnVybC5wcm90b2NvbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHNwZWNpZnkgYSBmdWxsIFdlYlNvY2tldCBVUkwsIGluY2x1ZGluZyBwcm90b2NvbC4nKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnVybC5ob3N0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBhIGZ1bGwgV2ViU29ja2V0IFVSTCwgaW5jbHVkaW5nIGhvc3RuYW1lLiBSZWxhdGl2ZSBVUkxzIGFyZSBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cblxuICAgIHRoaXMuc2VjdXJlID0gKHRoaXMudXJsLnByb3RvY29sID09PSAnd3NzOicpO1xuXG4gICAgLy8gdmFsaWRhdGUgcHJvdG9jb2wgY2hhcmFjdGVyczpcbiAgICB0aGlzLnByb3RvY29scy5mb3JFYWNoKGZ1bmN0aW9uKHByb3RvY29sKSB7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaSA8IHByb3RvY29sLmxlbmd0aDsgaSArKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gcHJvdG9jb2wuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIHZhciBjaGFyYWN0ZXIgPSBwcm90b2NvbC5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAweDAwMjEgfHwgY2hhckNvZGUgPiAweDAwN0UgfHwgcHJvdG9jb2xTZXBhcmF0b3JzLmluZGV4T2YoY2hhcmFjdGVyKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3RvY29sIGxpc3QgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXIgXCInICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSkgKyAnXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGRlZmF1bHRQb3J0cyA9IHtcbiAgICAgICAgJ3dzOic6ICc4MCcsXG4gICAgICAgICd3c3M6JzogJzQ0MydcbiAgICB9O1xuXG4gICAgaWYgKCF0aGlzLnVybC5wb3J0KSB7XG4gICAgICAgIHRoaXMudXJsLnBvcnQgPSBkZWZhdWx0UG9ydHNbdGhpcy51cmwucHJvdG9jb2xdO1xuICAgIH1cblxuICAgIHZhciBub25jZSA9IGJ1ZmZlckFsbG9jVW5zYWZlKDE2KTtcbiAgICBmb3IgKHZhciBpPTA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgIG5vbmNlW2ldID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpKjB4RkYpO1xuICAgIH1cbiAgICB0aGlzLmJhc2U2NG5vbmNlID0gbm9uY2UudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuXG4gICAgdmFyIGhvc3RIZWFkZXJWYWx1ZSA9IHRoaXMudXJsLmhvc3RuYW1lO1xuICAgIGlmICgodGhpcy51cmwucHJvdG9jb2wgPT09ICd3czonICYmIHRoaXMudXJsLnBvcnQgIT09ICc4MCcpIHx8XG4gICAgICAgICh0aGlzLnVybC5wcm90b2NvbCA9PT0gJ3dzczonICYmIHRoaXMudXJsLnBvcnQgIT09ICc0NDMnKSkgIHtcbiAgICAgICAgaG9zdEhlYWRlclZhbHVlICs9ICgnOicgKyB0aGlzLnVybC5wb3J0KTtcbiAgICB9XG5cbiAgICB2YXIgcmVxSGVhZGVycyA9IHt9O1xuICAgIGlmICh0aGlzLnNlY3VyZSAmJiB0aGlzLmNvbmZpZy50bHNPcHRpb25zLmhhc093blByb3BlcnR5KCdoZWFkZXJzJykpIHtcbiAgICAgIC8vIEFsbG93IGZvciBhZGRpdGlvbmFsIGhlYWRlcnMgdG8gYmUgcHJvdmlkZWQgd2hlbiBjb25uZWN0aW5nIHZpYSBIVFRQU1xuICAgICAgZXh0ZW5kKHJlcUhlYWRlcnMsIHRoaXMuY29uZmlnLnRsc09wdGlvbnMuaGVhZGVycyk7XG4gICAgfVxuICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAvLyBFeHBsaWNpdGx5IHByb3ZpZGVkIGhlYWRlcnMgdGFrZSBwcmlvcml0eSBvdmVyIGFueSBmcm9tIHRsc09wdGlvbnNcbiAgICAgIGV4dGVuZChyZXFIZWFkZXJzLCBoZWFkZXJzKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcUhlYWRlcnMsIHtcbiAgICAgICAgJ1VwZ3JhZGUnOiAnd2Vic29ja2V0JyxcbiAgICAgICAgJ0Nvbm5lY3Rpb24nOiAnVXBncmFkZScsXG4gICAgICAgICdTZWMtV2ViU29ja2V0LVZlcnNpb24nOiB0aGlzLmNvbmZpZy53ZWJTb2NrZXRWZXJzaW9uLnRvU3RyaW5nKDEwKSxcbiAgICAgICAgJ1NlYy1XZWJTb2NrZXQtS2V5JzogdGhpcy5iYXNlNjRub25jZSxcbiAgICAgICAgJ0hvc3QnOiByZXFIZWFkZXJzLkhvc3QgfHwgaG9zdEhlYWRlclZhbHVlXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5wcm90b2NvbHMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXFIZWFkZXJzWydTZWMtV2ViU29ja2V0LVByb3RvY29sJ10gPSB0aGlzLnByb3RvY29scy5qb2luKCcsICcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcmlnaW4pIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLndlYlNvY2tldFZlcnNpb24gPT09IDEzKSB7XG4gICAgICAgICAgICByZXFIZWFkZXJzWydPcmlnaW4nXSA9IHRoaXMub3JpZ2luO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29uZmlnLndlYlNvY2tldFZlcnNpb24gPT09IDgpIHtcbiAgICAgICAgICAgIHJlcUhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtT3JpZ2luJ10gPSB0aGlzLm9yaWdpbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IEltcGxlbWVudCBleHRlbnNpb25zXG5cbiAgICB2YXIgcGF0aEFuZFF1ZXJ5O1xuICAgIC8vIEVuc3VyZSBpdCBiZWdpbnMgd2l0aCAnLycuXG4gICAgaWYgKHRoaXMudXJsLnBhdGhuYW1lKSB7XG4gICAgICAgIHBhdGhBbmRRdWVyeSA9IHRoaXMudXJsLnBhdGg7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMudXJsLnBhdGgpIHtcbiAgICAgICAgcGF0aEFuZFF1ZXJ5ID0gJy8nICsgdGhpcy51cmwucGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhdGhBbmRRdWVyeSA9ICcvJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVSZXF1ZXN0RXJyb3IoZXJyb3IpIHtcbiAgICAgICAgc2VsZi5fcmVxID0gbnVsbDtcbiAgICAgICAgc2VsZi5lbWl0KCdjb25uZWN0RmFpbGVkJywgZXJyb3IpO1xuICAgIH1cblxuICAgIHZhciByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgYWdlbnQ6IGZhbHNlXG4gICAgfTtcbiAgICBpZiAoZXh0cmFSZXF1ZXN0T3B0aW9ucykge1xuICAgICAgICBleHRlbmQocmVxdWVzdE9wdGlvbnMsIGV4dHJhUmVxdWVzdE9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBUaGVzZSBvcHRpb25zIGFyZSBhbHdheXMgb3ZlcnJpZGRlbiBieSB0aGUgbGlicmFyeS4gIFRoZSB1c2VyIGlzIG5vdFxuICAgIC8vIGFsbG93ZWQgdG8gc3BlY2lmeSB0aGVzZSBkaXJlY3RseS5cbiAgICBleHRlbmQocmVxdWVzdE9wdGlvbnMsIHtcbiAgICAgICAgaG9zdG5hbWU6IHRoaXMudXJsLmhvc3RuYW1lLFxuICAgICAgICBwb3J0OiB0aGlzLnVybC5wb3J0LFxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBwYXRoOiBwYXRoQW5kUXVlcnksXG4gICAgICAgIGhlYWRlcnM6IHJlcUhlYWRlcnNcbiAgICB9KTtcbiAgICBpZiAodGhpcy5zZWN1cmUpIHtcbiAgICAgICAgdmFyIHRsc09wdGlvbnMgPSB0aGlzLmNvbmZpZy50bHNPcHRpb25zO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGxzT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRsc09wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBleGNsdWRlZFRsc09wdGlvbnMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zW2tleV0gPSB0bHNPcHRpb25zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVxID0gdGhpcy5fcmVxID0gKHRoaXMuc2VjdXJlID8gaHR0cHMgOiBodHRwKS5yZXF1ZXN0KHJlcXVlc3RPcHRpb25zKTtcbiAgICByZXEub24oJ3VwZ3JhZGUnLCBmdW5jdGlvbiBoYW5kbGVSZXF1ZXN0VXBncmFkZShyZXNwb25zZSwgc29ja2V0LCBoZWFkKSB7XG4gICAgICAgIHNlbGYuX3JlcSA9IG51bGw7XG4gICAgICAgIHJlcS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVSZXF1ZXN0RXJyb3IpO1xuICAgICAgICBzZWxmLnNvY2tldCA9IHNvY2tldDtcbiAgICAgICAgc2VsZi5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICBzZWxmLmZpcnN0RGF0YUNodW5rID0gaGVhZDtcbiAgICAgICAgc2VsZi52YWxpZGF0ZUhhbmRzaGFrZSgpO1xuICAgIH0pO1xuICAgIHJlcS5vbignZXJyb3InLCBoYW5kbGVSZXF1ZXN0RXJyb3IpO1xuXG4gICAgcmVxLm9uKCdyZXNwb25zZScsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIHNlbGYuX3JlcSA9IG51bGw7XG4gICAgICAgIGlmICh1dGlscy5ldmVudEVtaXR0ZXJMaXN0ZW5lckNvdW50KHNlbGYsICdodHRwUmVzcG9uc2UnKSA+IDApIHtcbiAgICAgICAgICAgIHNlbGYuZW1pdCgnaHR0cFJlc3BvbnNlJywgcmVzcG9uc2UsIHNlbGYpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnNvY2tldCkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNvY2tldC5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXJEdW1wUGFydHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGhlYWRlck5hbWUgaW4gcmVzcG9uc2UuaGVhZGVycykge1xuICAgICAgICAgICAgICAgIGhlYWRlckR1bXBQYXJ0cy5wdXNoKGhlYWRlck5hbWUgKyAnOiAnICsgcmVzcG9uc2UuaGVhZGVyc1toZWFkZXJOYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmZhaWxIYW5kc2hha2UoXG4gICAgICAgICAgICAgICAgJ1NlcnZlciByZXNwb25kZWQgd2l0aCBhIG5vbi0xMDEgc3RhdHVzOiAnICtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5zdGF0dXNDb2RlICsgJyAnICsgcmVzcG9uc2Uuc3RhdHVzTWVzc2FnZSArXG4gICAgICAgICAgICAgICAgJ1xcblJlc3BvbnNlIEhlYWRlcnMgRm9sbG93OlxcbicgK1xuICAgICAgICAgICAgICAgIGhlYWRlckR1bXBQYXJ0cy5qb2luKCdcXG4nKSArICdcXG4nXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmVxLmVuZCgpO1xufTtcblxuV2ViU29ja2V0Q2xpZW50LnByb3RvdHlwZS52YWxpZGF0ZUhhbmRzaGFrZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoZWFkZXJzID0gdGhpcy5yZXNwb25zZS5oZWFkZXJzO1xuXG4gICAgaWYgKHRoaXMucHJvdG9jb2xzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5wcm90b2NvbCA9IGhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXTtcbiAgICAgICAgaWYgKHRoaXMucHJvdG9jb2wpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3RvY29scy5pbmRleE9mKHRoaXMucHJvdG9jb2wpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmFpbEhhbmRzaGFrZSgnU2VydmVyIGRpZCBub3QgcmVzcG9uZCB3aXRoIGEgcmVxdWVzdGVkIHByb3RvY29sLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmFpbEhhbmRzaGFrZSgnRXhwZWN0ZWQgYSBTZWMtV2ViU29ja2V0LVByb3RvY29sIGhlYWRlci4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKGhlYWRlcnNbJ2Nvbm5lY3Rpb24nXSAmJiBoZWFkZXJzWydjb25uZWN0aW9uJ10udG9Mb2NhbGVMb3dlckNhc2UoKSA9PT0gJ3VwZ3JhZGUnKSkge1xuICAgICAgICB0aGlzLmZhaWxIYW5kc2hha2UoJ0V4cGVjdGVkIGEgQ29ubmVjdGlvbjogVXBncmFkZSBoZWFkZXIgZnJvbSB0aGUgc2VydmVyJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIShoZWFkZXJzWyd1cGdyYWRlJ10gJiYgaGVhZGVyc1sndXBncmFkZSddLnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09ICd3ZWJzb2NrZXQnKSkge1xuICAgICAgICB0aGlzLmZhaWxIYW5kc2hha2UoJ0V4cGVjdGVkIGFuIFVwZ3JhZGU6IHdlYnNvY2tldCBoZWFkZXIgZnJvbSB0aGUgc2VydmVyJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2hhMSA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJyk7XG4gICAgc2hhMS51cGRhdGUodGhpcy5iYXNlNjRub25jZSArICcyNThFQUZBNS1FOTE0LTQ3REEtOTVDQS1DNUFCMERDODVCMTEnKTtcbiAgICB2YXIgZXhwZWN0ZWRLZXkgPSBzaGExLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgICBpZiAoIWhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtYWNjZXB0J10pIHtcbiAgICAgICAgdGhpcy5mYWlsSGFuZHNoYWtlKCdFeHBlY3RlZCBTZWMtV2ViU29ja2V0LUFjY2VwdCBoZWFkZXIgZnJvbSBzZXJ2ZXInKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChoZWFkZXJzWydzZWMtd2Vic29ja2V0LWFjY2VwdCddICE9PSBleHBlY3RlZEtleSkge1xuICAgICAgICB0aGlzLmZhaWxIYW5kc2hha2UoJ1NlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlciBmcm9tIHNlcnZlciBkaWRuXFwndCBtYXRjaCBleHBlY3RlZCB2YWx1ZSBvZiAnICsgZXhwZWN0ZWRLZXkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVE9ETzogU3VwcG9ydCBleHRlbnNpb25zXG5cbiAgICB0aGlzLnN1Y2NlZWRIYW5kc2hha2UoKTtcbn07XG5cbldlYlNvY2tldENsaWVudC5wcm90b3R5cGUuZmFpbEhhbmRzaGFrZSA9IGZ1bmN0aW9uKGVycm9yRGVzY3JpcHRpb24pIHtcbiAgICBpZiAodGhpcy5zb2NrZXQgJiYgdGhpcy5zb2NrZXQud3JpdGFibGUpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuZW5kKCk7XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnY29ubmVjdEZhaWxlZCcsIG5ldyBFcnJvcihlcnJvckRlc2NyaXB0aW9uKSk7XG59O1xuXG5XZWJTb2NrZXRDbGllbnQucHJvdG90eXBlLnN1Y2NlZWRIYW5kc2hha2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29ubmVjdGlvbiA9IG5ldyBXZWJTb2NrZXRDb25uZWN0aW9uKHRoaXMuc29ja2V0LCBbXSwgdGhpcy5wcm90b2NvbCwgdHJ1ZSwgdGhpcy5jb25maWcpO1xuXG4gICAgY29ubmVjdGlvbi53ZWJTb2NrZXRWZXJzaW9uID0gdGhpcy5jb25maWcud2ViU29ja2V0VmVyc2lvbjtcbiAgICBjb25uZWN0aW9uLl9hZGRTb2NrZXRFdmVudExpc3RlbmVycygpO1xuXG4gICAgdGhpcy5lbWl0KCdjb25uZWN0JywgY29ubmVjdGlvbik7XG4gICAgaWYgKHRoaXMuZmlyc3REYXRhQ2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25uZWN0aW9uLmhhbmRsZVNvY2tldERhdGEodGhpcy5maXJzdERhdGFDaHVuayk7XG4gICAgfVxuICAgIHRoaXMuZmlyc3REYXRhQ2h1bmsgPSBudWxsO1xufTtcblxuV2ViU29ja2V0Q2xpZW50LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9yZXEpIHtcbiAgICAgICAgdGhpcy5fcmVxLmFib3J0KCk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRDbGllbnQ7XG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwiZXh0ZW5kIiwidXRpbCIsIkV2ZW50RW1pdHRlciIsImh0dHAiLCJodHRwcyIsInVybCIsImNyeXB0byIsIldlYlNvY2tldENvbm5lY3Rpb24iLCJidWZmZXJBbGxvY1Vuc2FmZSIsInByb3RvY29sU2VwYXJhdG9ycyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImV4Y2x1ZGVkVGxzT3B0aW9ucyIsIldlYlNvY2tldENsaWVudCIsImNvbmZpZyIsImNhbGwiLCJtYXhSZWNlaXZlZEZyYW1lU2l6ZSIsIm1heFJlY2VpdmVkTWVzc2FnZVNpemUiLCJmcmFnbWVudE91dGdvaW5nTWVzc2FnZXMiLCJmcmFnbWVudGF0aW9uVGhyZXNob2xkIiwid2ViU29ja2V0VmVyc2lvbiIsImFzc2VtYmxlRnJhZ21lbnRzIiwiZGlzYWJsZU5hZ2xlQWxnb3JpdGhtIiwiY2xvc2VUaW1lb3V0IiwidGxzT3B0aW9ucyIsIl9yZXEiLCJFcnJvciIsImluaGVyaXRzIiwicHJvdG90eXBlIiwiY29ubmVjdCIsInJlcXVlc3RVcmwiLCJwcm90b2NvbHMiLCJvcmlnaW4iLCJoZWFkZXJzIiwiZXh0cmFSZXF1ZXN0T3B0aW9ucyIsInNlbGYiLCJsZW5ndGgiLCJBcnJheSIsInBhcnNlIiwicHJvdG9jb2wiLCJob3N0Iiwic2VjdXJlIiwiZm9yRWFjaCIsImkiLCJjaGFyQ29kZSIsImNoYXJDb2RlQXQiLCJjaGFyYWN0ZXIiLCJjaGFyQXQiLCJpbmRleE9mIiwiZGVmYXVsdFBvcnRzIiwicG9ydCIsIm5vbmNlIiwiTWF0aCIsInJvdW5kIiwicmFuZG9tIiwiYmFzZTY0bm9uY2UiLCJ0b1N0cmluZyIsImhvc3RIZWFkZXJWYWx1ZSIsImhvc3RuYW1lIiwicmVxSGVhZGVycyIsImhhc093blByb3BlcnR5IiwiSG9zdCIsImpvaW4iLCJwYXRoQW5kUXVlcnkiLCJwYXRobmFtZSIsInBhdGgiLCJoYW5kbGVSZXF1ZXN0RXJyb3IiLCJlcnJvciIsImVtaXQiLCJyZXF1ZXN0T3B0aW9ucyIsImFnZW50IiwibWV0aG9kIiwia2V5IiwicmVxIiwicmVxdWVzdCIsIm9uIiwiaGFuZGxlUmVxdWVzdFVwZ3JhZGUiLCJyZXNwb25zZSIsInNvY2tldCIsImhlYWQiLCJyZW1vdmVMaXN0ZW5lciIsImZpcnN0RGF0YUNodW5rIiwidmFsaWRhdGVIYW5kc2hha2UiLCJldmVudEVtaXR0ZXJMaXN0ZW5lckNvdW50IiwiZW5kIiwiaGVhZGVyRHVtcFBhcnRzIiwiaGVhZGVyTmFtZSIsInB1c2giLCJmYWlsSGFuZHNoYWtlIiwic3RhdHVzQ29kZSIsInN0YXR1c01lc3NhZ2UiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsInNoYTEiLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiZXhwZWN0ZWRLZXkiLCJkaWdlc3QiLCJzdWNjZWVkSGFuZHNoYWtlIiwiZXJyb3JEZXNjcmlwdGlvbiIsIndyaXRhYmxlIiwiY29ubmVjdGlvbiIsIl9hZGRTb2NrZXRFdmVudExpc3RlbmVycyIsImhhbmRsZVNvY2tldERhdGEiLCJhYm9ydCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/WebSocketClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/WebSocketConnection.js":
/*!***********************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketConnection.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ var util = __webpack_require__(/*! util */ \"util\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/websocket/lib/utils.js\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar WebSocketFrame = __webpack_require__(/*! ./WebSocketFrame */ \"(ssr)/./node_modules/websocket/lib/WebSocketFrame.js\");\nvar BufferList = __webpack_require__(/*! ../vendor/FastBufferList */ \"(ssr)/./node_modules/websocket/vendor/FastBufferList.js\");\nvar isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"(ssr)/./node_modules/utf-8-validate/index.js\");\nvar bufferAllocUnsafe = utils.bufferAllocUnsafe;\nvar bufferFromString = utils.bufferFromString;\n// Connected, fully-open, ready to send and receive frames\nconst STATE_OPEN = \"open\";\n// Received a close frame from the remote peer\nconst STATE_PEER_REQUESTED_CLOSE = \"peer_requested_close\";\n// Sent close frame to remote peer.  No further data can be sent.\nconst STATE_ENDING = \"ending\";\n// Connection is fully closed.  No further data can be sent or received.\nconst STATE_CLOSED = \"closed\";\nvar setImmediateImpl = \"setImmediate\" in global ? global.setImmediate.bind(global) : process.nextTick.bind(process);\nvar idCounter = 0;\nfunction WebSocketConnection(socket, extensions, protocol, maskOutgoingPackets, config) {\n    this._debug = utils.BufferingLogger(\"websocket:connection\", ++idCounter);\n    this._debug(\"constructor\");\n    if (this._debug.enabled) {\n        instrumentSocketForDebugging(this, socket);\n    }\n    // Superclass Constructor\n    EventEmitter.call(this);\n    this._pingListenerCount = 0;\n    this.on(\"newListener\", function(ev) {\n        if (ev === \"ping\") {\n            this._pingListenerCount++;\n        }\n    }).on(\"removeListener\", function(ev) {\n        if (ev === \"ping\") {\n            this._pingListenerCount--;\n        }\n    });\n    this.config = config;\n    this.socket = socket;\n    this.protocol = protocol;\n    this.extensions = extensions;\n    this.remoteAddress = socket.remoteAddress;\n    this.closeReasonCode = -1;\n    this.closeDescription = null;\n    this.closeEventEmitted = false;\n    // We have to mask outgoing packets if we're acting as a WebSocket client.\n    this.maskOutgoingPackets = maskOutgoingPackets;\n    // We re-use the same buffers for the mask and frame header for all frames\n    // received on each connection to avoid a small memory allocation for each\n    // frame.\n    this.maskBytes = bufferAllocUnsafe(4);\n    this.frameHeader = bufferAllocUnsafe(10);\n    // the BufferList will handle the data streaming in\n    this.bufferList = new BufferList();\n    // Prepare for receiving first frame\n    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    this.fragmentationSize = 0; // data received so far...\n    this.frameQueue = [];\n    // Various bits of connection state\n    this.connected = true;\n    this.state = STATE_OPEN;\n    this.waitingForCloseResponse = false;\n    // Received TCP FIN, socket's readable stream is finished.\n    this.receivedEnd = false;\n    this.closeTimeout = this.config.closeTimeout;\n    this.assembleFragments = this.config.assembleFragments;\n    this.maxReceivedMessageSize = this.config.maxReceivedMessageSize;\n    this.outputBufferFull = false;\n    this.inputPaused = false;\n    this.receivedDataHandler = this.processReceivedData.bind(this);\n    this._closeTimerHandler = this.handleCloseTimer.bind(this);\n    // Disable nagle algorithm?\n    this.socket.setNoDelay(this.config.disableNagleAlgorithm);\n    // Make sure there is no socket inactivity timeout\n    this.socket.setTimeout(0);\n    if (this.config.keepalive && !this.config.useNativeKeepalive) {\n        if (typeof this.config.keepaliveInterval !== \"number\") {\n            throw new Error(\"keepaliveInterval must be specified and numeric \" + \"if keepalive is true.\");\n        }\n        this._keepaliveTimerHandler = this.handleKeepaliveTimer.bind(this);\n        this.setKeepaliveTimer();\n        if (this.config.dropConnectionOnKeepaliveTimeout) {\n            if (typeof this.config.keepaliveGracePeriod !== \"number\") {\n                throw new Error(\"keepaliveGracePeriod  must be specified and \" + \"numeric if dropConnectionOnKeepaliveTimeout \" + \"is true.\");\n            }\n            this._gracePeriodTimerHandler = this.handleGracePeriodTimer.bind(this);\n        }\n    } else if (this.config.keepalive && this.config.useNativeKeepalive) {\n        if (!(\"setKeepAlive\" in this.socket)) {\n            throw new Error(\"Unable to use native keepalive: unsupported by \" + \"this version of Node.\");\n        }\n        this.socket.setKeepAlive(true, this.config.keepaliveInterval);\n    }\n    // The HTTP Client seems to subscribe to socket error events\n    // and re-dispatch them in such a way that doesn't make sense\n    // for users of our client, so we want to make sure nobody\n    // else is listening for error events on the socket besides us.\n    this.socket.removeAllListeners(\"error\");\n}\nWebSocketConnection.CLOSE_REASON_NORMAL = 1000;\nWebSocketConnection.CLOSE_REASON_GOING_AWAY = 1001;\nWebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR = 1002;\nWebSocketConnection.CLOSE_REASON_UNPROCESSABLE_INPUT = 1003;\nWebSocketConnection.CLOSE_REASON_RESERVED = 1004; // Reserved value.  Undefined meaning.\nWebSocketConnection.CLOSE_REASON_NOT_PROVIDED = 1005; // Not to be used on the wire\nWebSocketConnection.CLOSE_REASON_ABNORMAL = 1006; // Not to be used on the wire\nWebSocketConnection.CLOSE_REASON_INVALID_DATA = 1007;\nWebSocketConnection.CLOSE_REASON_POLICY_VIOLATION = 1008;\nWebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG = 1009;\nWebSocketConnection.CLOSE_REASON_EXTENSION_REQUIRED = 1010;\nWebSocketConnection.CLOSE_REASON_INTERNAL_SERVER_ERROR = 1011;\nWebSocketConnection.CLOSE_REASON_TLS_HANDSHAKE_FAILED = 1015; // Not to be used on the wire\nWebSocketConnection.CLOSE_DESCRIPTIONS = {\n    1000: \"Normal connection closure\",\n    1001: \"Remote peer is going away\",\n    1002: \"Protocol error\",\n    1003: \"Unprocessable input\",\n    1004: \"Reserved\",\n    1005: \"Reason not provided\",\n    1006: \"Abnormal closure, no further detail available\",\n    1007: \"Invalid data received\",\n    1008: \"Policy violation\",\n    1009: \"Message too big\",\n    1010: \"Extension requested by client is required\",\n    1011: \"Internal Server Error\",\n    1015: \"TLS Handshake Failed\"\n};\nfunction validateCloseReason(code) {\n    if (code < 1000) {\n        // Status codes in the range 0-999 are not used\n        return false;\n    }\n    if (code >= 1000 && code <= 2999) {\n        // Codes from 1000 - 2999 are reserved for use by the protocol.  Only\n        // a few codes are defined, all others are currently illegal.\n        return [\n            1000,\n            1001,\n            1002,\n            1003,\n            1007,\n            1008,\n            1009,\n            1010,\n            1011,\n            1012,\n            1013,\n            1014,\n            1015\n        ].indexOf(code) !== -1;\n    }\n    if (code >= 3000 && code <= 3999) {\n        // Reserved for use by libraries, frameworks, and applications.\n        // Should be registered with IANA.  Interpretation of these codes is\n        // undefined by the WebSocket protocol.\n        return true;\n    }\n    if (code >= 4000 && code <= 4999) {\n        // Reserved for private use.  Interpretation of these codes is\n        // undefined by the WebSocket protocol.\n        return true;\n    }\n    if (code >= 5000) {\n        return false;\n    }\n}\nutil.inherits(WebSocketConnection, EventEmitter);\nWebSocketConnection.prototype._addSocketEventListeners = function() {\n    this.socket.on(\"error\", this.handleSocketError.bind(this));\n    this.socket.on(\"end\", this.handleSocketEnd.bind(this));\n    this.socket.on(\"close\", this.handleSocketClose.bind(this));\n    this.socket.on(\"drain\", this.handleSocketDrain.bind(this));\n    this.socket.on(\"pause\", this.handleSocketPause.bind(this));\n    this.socket.on(\"resume\", this.handleSocketResume.bind(this));\n    this.socket.on(\"data\", this.handleSocketData.bind(this));\n};\n// set or reset the keepalive timer when data is received.\nWebSocketConnection.prototype.setKeepaliveTimer = function() {\n    this._debug(\"setKeepaliveTimer\");\n    if (!this.config.keepalive || this.config.useNativeKeepalive) {\n        return;\n    }\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n    this._keepaliveTimeoutID = setTimeout(this._keepaliveTimerHandler, this.config.keepaliveInterval);\n};\nWebSocketConnection.prototype.clearKeepaliveTimer = function() {\n    if (this._keepaliveTimeoutID) {\n        clearTimeout(this._keepaliveTimeoutID);\n    }\n};\n// No data has been received within config.keepaliveTimeout ms.\nWebSocketConnection.prototype.handleKeepaliveTimer = function() {\n    this._debug(\"handleKeepaliveTimer\");\n    this._keepaliveTimeoutID = null;\n    this.ping();\n    // If we are configured to drop connections if the client doesn't respond\n    // then set the grace period timer.\n    if (this.config.dropConnectionOnKeepaliveTimeout) {\n        this.setGracePeriodTimer();\n    } else {\n        // Otherwise reset the keepalive timer to send the next ping.\n        this.setKeepaliveTimer();\n    }\n};\nWebSocketConnection.prototype.setGracePeriodTimer = function() {\n    this._debug(\"setGracePeriodTimer\");\n    this.clearGracePeriodTimer();\n    this._gracePeriodTimeoutID = setTimeout(this._gracePeriodTimerHandler, this.config.keepaliveGracePeriod);\n};\nWebSocketConnection.prototype.clearGracePeriodTimer = function() {\n    if (this._gracePeriodTimeoutID) {\n        clearTimeout(this._gracePeriodTimeoutID);\n    }\n};\nWebSocketConnection.prototype.handleGracePeriodTimer = function() {\n    this._debug(\"handleGracePeriodTimer\");\n    // If this is called, the client has not responded and is assumed dead.\n    this._gracePeriodTimeoutID = null;\n    this.drop(WebSocketConnection.CLOSE_REASON_ABNORMAL, \"Peer not responding.\", true);\n};\nWebSocketConnection.prototype.handleSocketData = function(data) {\n    this._debug(\"handleSocketData\");\n    // Reset the keepalive timer when receiving data of any kind.\n    this.setKeepaliveTimer();\n    // Add received data to our bufferList, which efficiently holds received\n    // data chunks in a linked list of Buffer objects.\n    this.bufferList.write(data);\n    this.processReceivedData();\n};\nWebSocketConnection.prototype.processReceivedData = function() {\n    this._debug(\"processReceivedData\");\n    // If we're not connected, we should ignore any data remaining on the buffer.\n    if (!this.connected) {\n        return;\n    }\n    // Receiving/parsing is expected to be halted when paused.\n    if (this.inputPaused) {\n        return;\n    }\n    var frame = this.currentFrame;\n    // WebSocketFrame.prototype.addData returns true if all data necessary to\n    // parse the frame was available.  It returns false if we are waiting for\n    // more data to come in on the wire.\n    if (!frame.addData(this.bufferList)) {\n        this._debug(\"-- insufficient data for frame\");\n        return;\n    }\n    var self = this;\n    // Handle possible parsing errors\n    if (frame.protocolError) {\n        // Something bad happened.. get rid of this client.\n        this._debug(\"-- protocol error\");\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, frame.dropReason);\n        });\n        return;\n    } else if (frame.frameTooLarge) {\n        this._debug(\"-- frame too large\");\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, frame.dropReason);\n        });\n        return;\n    }\n    // For now since we don't support extensions, all RSV bits are illegal\n    if (frame.rsv1 || frame.rsv2 || frame.rsv3) {\n        this._debug(\"-- illegal rsv flag\");\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, \"Unsupported usage of rsv bits without negotiated extension.\");\n        });\n        return;\n    }\n    if (!this.assembleFragments) {\n        this._debug(\"-- emitting frame\");\n        process.nextTick(function() {\n            self.emit(\"frame\", frame);\n        });\n    }\n    process.nextTick(function() {\n        self.processFrame(frame);\n    });\n    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    // If there's data remaining, schedule additional processing, but yield\n    // for now so that other connections have a chance to have their data\n    // processed.  We use setImmediate here instead of process.nextTick to\n    // explicitly indicate that we wish for other I/O to be handled first.\n    if (this.bufferList.length > 0) {\n        setImmediateImpl(this.receivedDataHandler);\n    }\n};\nWebSocketConnection.prototype.handleSocketError = function(error) {\n    this._debug(\"handleSocketError: %j\", error);\n    if (this.state === STATE_CLOSED) {\n        // See https://github.com/theturtle32/WebSocket-Node/issues/288\n        this._debug(\"  --- Socket 'error' after 'close'\");\n        return;\n    }\n    this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;\n    this.closeDescription = \"Socket Error: \" + error.syscall + \" \" + error.code;\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    this.fragmentationSize = 0;\n    if (utils.eventEmitterListenerCount(this, \"error\") > 0) {\n        this.emit(\"error\", error);\n    }\n    this.socket.destroy();\n    this._debug.printOutput();\n};\nWebSocketConnection.prototype.handleSocketEnd = function() {\n    this._debug(\"handleSocketEnd: received socket end.  state = %s\", this.state);\n    this.receivedEnd = true;\n    if (this.state === STATE_CLOSED) {\n        // When using the TLS module, sometimes the socket will emit 'end'\n        // after it emits 'close'.  I don't think that's correct behavior,\n        // but we should deal with it gracefully by ignoring it.\n        this._debug(\"  --- Socket 'end' after 'close'\");\n        return;\n    }\n    if (this.state !== STATE_PEER_REQUESTED_CLOSE && this.state !== STATE_ENDING) {\n        this._debug(\"  --- UNEXPECTED socket end.\");\n        this.socket.end();\n    }\n};\nWebSocketConnection.prototype.handleSocketClose = function(hadError) {\n    this._debug(\"handleSocketClose: received socket close\");\n    this.socketHadError = hadError;\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    // If closeReasonCode is still set to -1 at this point then we must\n    // not have received a close frame!!\n    if (this.closeReasonCode === -1) {\n        this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;\n        this.closeDescription = \"Connection dropped by remote peer.\";\n    }\n    this.clearCloseTimer();\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n    if (!this.closeEventEmitted) {\n        this.closeEventEmitted = true;\n        this._debug(\"-- Emitting WebSocketConnection close event\");\n        this.emit(\"close\", this.closeReasonCode, this.closeDescription);\n    }\n};\nWebSocketConnection.prototype.handleSocketDrain = function() {\n    this._debug(\"handleSocketDrain: socket drain event\");\n    this.outputBufferFull = false;\n    this.emit(\"drain\");\n};\nWebSocketConnection.prototype.handleSocketPause = function() {\n    this._debug(\"handleSocketPause: socket pause event\");\n    this.inputPaused = true;\n    this.emit(\"pause\");\n};\nWebSocketConnection.prototype.handleSocketResume = function() {\n    this._debug(\"handleSocketResume: socket resume event\");\n    this.inputPaused = false;\n    this.emit(\"resume\");\n    this.processReceivedData();\n};\nWebSocketConnection.prototype.pause = function() {\n    this._debug(\"pause: pause requested\");\n    this.socket.pause();\n};\nWebSocketConnection.prototype.resume = function() {\n    this._debug(\"resume: resume requested\");\n    this.socket.resume();\n};\nWebSocketConnection.prototype.close = function(reasonCode, description) {\n    if (this.connected) {\n        this._debug(\"close: Initating clean WebSocket close sequence.\");\n        if (\"number\" !== typeof reasonCode) {\n            reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n        }\n        if (!validateCloseReason(reasonCode)) {\n            throw new Error(\"Close code \" + reasonCode + \" is not valid.\");\n        }\n        if (\"string\" !== typeof description) {\n            description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];\n        }\n        this.closeReasonCode = reasonCode;\n        this.closeDescription = description;\n        this.setCloseTimer();\n        this.sendCloseFrame(this.closeReasonCode, this.closeDescription);\n        this.state = STATE_ENDING;\n        this.connected = false;\n    }\n};\nWebSocketConnection.prototype.drop = function(reasonCode, description, skipCloseFrame) {\n    this._debug(\"drop\");\n    if (typeof reasonCode !== \"number\") {\n        reasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n    }\n    if (typeof description !== \"string\") {\n        // If no description is provided, try to look one up based on the\n        // specified reasonCode.\n        description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];\n    }\n    this._debug(\"Forcefully dropping connection. skipCloseFrame: %s, code: %d, description: %s\", skipCloseFrame, reasonCode, description);\n    this.closeReasonCode = reasonCode;\n    this.closeDescription = description;\n    this.frameQueue = [];\n    this.fragmentationSize = 0;\n    if (!skipCloseFrame) {\n        this.sendCloseFrame(reasonCode, description);\n    }\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    this.clearCloseTimer();\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n    if (!this.closeEventEmitted) {\n        this.closeEventEmitted = true;\n        this._debug(\"Emitting WebSocketConnection close event\");\n        this.emit(\"close\", this.closeReasonCode, this.closeDescription);\n    }\n    this._debug(\"Drop: destroying socket\");\n    this.socket.destroy();\n};\nWebSocketConnection.prototype.setCloseTimer = function() {\n    this._debug(\"setCloseTimer\");\n    this.clearCloseTimer();\n    this._debug(\"Setting close timer\");\n    this.waitingForCloseResponse = true;\n    this.closeTimer = setTimeout(this._closeTimerHandler, this.closeTimeout);\n};\nWebSocketConnection.prototype.clearCloseTimer = function() {\n    this._debug(\"clearCloseTimer\");\n    if (this.closeTimer) {\n        this._debug(\"Clearing close timer\");\n        clearTimeout(this.closeTimer);\n        this.waitingForCloseResponse = false;\n        this.closeTimer = null;\n    }\n};\nWebSocketConnection.prototype.handleCloseTimer = function() {\n    this._debug(\"handleCloseTimer\");\n    this.closeTimer = null;\n    if (this.waitingForCloseResponse) {\n        this._debug(\"Close response not received from client.  Forcing socket end.\");\n        this.waitingForCloseResponse = false;\n        this.state = STATE_CLOSED;\n        this.socket.end();\n    }\n};\nWebSocketConnection.prototype.processFrame = function(frame) {\n    this._debug(\"processFrame\");\n    this._debug(\" -- frame: %s\", frame);\n    // Any non-control opcode besides 0x00 (continuation) received in the\n    // middle of a fragmented message is illegal.\n    if (this.frameQueue.length !== 0 && frame.opcode > 0x00 && frame.opcode < 0x08) {\n        this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, \"Illegal frame opcode 0x\" + frame.opcode.toString(16) + \" \" + \"received in middle of fragmented message.\");\n        return;\n    }\n    switch(frame.opcode){\n        case 0x02:\n            this._debug(\"-- Binary Frame\");\n            if (this.assembleFragments) {\n                if (frame.fin) {\n                    // Complete single-frame message received\n                    this._debug(\"---- Emitting 'message' event\");\n                    this.emit(\"message\", {\n                        type: \"binary\",\n                        binaryData: frame.binaryPayload\n                    });\n                } else {\n                    // beginning of a fragmented message\n                    this.frameQueue.push(frame);\n                    this.fragmentationSize = frame.length;\n                }\n            }\n            break;\n        case 0x01:\n            this._debug(\"-- Text Frame\");\n            if (this.assembleFragments) {\n                if (frame.fin) {\n                    if (!isValidUTF8(frame.binaryPayload)) {\n                        this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA, \"Invalid UTF-8 Data Received\");\n                        return;\n                    }\n                    // Complete single-frame message received\n                    this._debug(\"---- Emitting 'message' event\");\n                    this.emit(\"message\", {\n                        type: \"utf8\",\n                        utf8Data: frame.binaryPayload.toString(\"utf8\")\n                    });\n                } else {\n                    // beginning of a fragmented message\n                    this.frameQueue.push(frame);\n                    this.fragmentationSize = frame.length;\n                }\n            }\n            break;\n        case 0x00:\n            this._debug(\"-- Continuation Frame\");\n            if (this.assembleFragments) {\n                if (this.frameQueue.length === 0) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, \"Unexpected Continuation Frame\");\n                    return;\n                }\n                this.fragmentationSize += frame.length;\n                if (this.fragmentationSize > this.maxReceivedMessageSize) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, \"Maximum message size exceeded.\");\n                    return;\n                }\n                this.frameQueue.push(frame);\n                if (frame.fin) {\n                    // end of fragmented message, so we process the whole\n                    // message now.  We also have to decode the utf-8 data\n                    // for text frames after combining all the fragments.\n                    var bytesCopied = 0;\n                    var binaryPayload = bufferAllocUnsafe(this.fragmentationSize);\n                    var opcode = this.frameQueue[0].opcode;\n                    this.frameQueue.forEach(function(currentFrame) {\n                        currentFrame.binaryPayload.copy(binaryPayload, bytesCopied);\n                        bytesCopied += currentFrame.binaryPayload.length;\n                    });\n                    this.frameQueue = [];\n                    this.fragmentationSize = 0;\n                    switch(opcode){\n                        case 0x02:\n                            this.emit(\"message\", {\n                                type: \"binary\",\n                                binaryData: binaryPayload\n                            });\n                            break;\n                        case 0x01:\n                            if (!isValidUTF8(binaryPayload)) {\n                                this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA, \"Invalid UTF-8 Data Received\");\n                                return;\n                            }\n                            this.emit(\"message\", {\n                                type: \"utf8\",\n                                utf8Data: binaryPayload.toString(\"utf8\")\n                            });\n                            break;\n                        default:\n                            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, \"Unexpected first opcode in fragmentation sequence: 0x\" + opcode.toString(16));\n                            return;\n                    }\n                }\n            }\n            break;\n        case 0x09:\n            this._debug(\"-- Ping Frame\");\n            if (this._pingListenerCount > 0) {\n                // logic to emit the ping frame: this is only done when a listener is known to exist\n                // Expose a function allowing the user to override the default ping() behavior\n                var cancelled = false;\n                var cancel = function() {\n                    cancelled = true;\n                };\n                this.emit(\"ping\", cancel, frame.binaryPayload);\n                // Only send a pong if the client did not indicate that he would like to cancel\n                if (!cancelled) {\n                    this.pong(frame.binaryPayload);\n                }\n            } else {\n                this.pong(frame.binaryPayload);\n            }\n            break;\n        case 0x0A:\n            this._debug(\"-- Pong Frame\");\n            this.emit(\"pong\", frame.binaryPayload);\n            break;\n        case 0x08:\n            this._debug(\"-- Close Frame\");\n            if (this.waitingForCloseResponse) {\n                // Got response to our request to close the connection.\n                // Close is complete, so we just hang up.\n                this._debug(\"---- Got close response from peer.  Completing closing handshake.\");\n                this.clearCloseTimer();\n                this.waitingForCloseResponse = false;\n                this.state = STATE_CLOSED;\n                this.socket.end();\n                return;\n            }\n            this._debug(\"---- Closing handshake initiated by peer.\");\n            // Got request from other party to close connection.\n            // Send back acknowledgement and then hang up.\n            this.state = STATE_PEER_REQUESTED_CLOSE;\n            var respondCloseReasonCode;\n            // Make sure the close reason provided is legal according to\n            // the protocol spec.  Providing no close status is legal.\n            // WebSocketFrame sets closeStatus to -1 by default, so if it\n            // is still -1, then no status was provided.\n            if (frame.invalidCloseFrameLength) {\n                this.closeReasonCode = 1005; // 1005 = No reason provided.\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n            } else if (frame.closeStatus === -1 || validateCloseReason(frame.closeStatus)) {\n                this.closeReasonCode = frame.closeStatus;\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n            } else {\n                this.closeReasonCode = frame.closeStatus;\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n            }\n            // If there is a textual description in the close frame, extract it.\n            if (frame.binaryPayload.length > 1) {\n                if (!isValidUTF8(frame.binaryPayload)) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA, \"Invalid UTF-8 Data Received\");\n                    return;\n                }\n                this.closeDescription = frame.binaryPayload.toString(\"utf8\");\n            } else {\n                this.closeDescription = WebSocketConnection.CLOSE_DESCRIPTIONS[this.closeReasonCode];\n            }\n            this._debug(\"------ Remote peer %s - code: %d - %s - close frame payload length: %d\", this.remoteAddress, this.closeReasonCode, this.closeDescription, frame.length);\n            this._debug(\"------ responding to remote peer's close request.\");\n            this.sendCloseFrame(respondCloseReasonCode, null);\n            this.connected = false;\n            break;\n        default:\n            this._debug(\"-- Unrecognized Opcode %d\", frame.opcode);\n            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, \"Unrecognized Opcode: 0x\" + frame.opcode.toString(16));\n            break;\n    }\n};\nWebSocketConnection.prototype.send = function(data, cb) {\n    this._debug(\"send\");\n    if (Buffer.isBuffer(data)) {\n        this.sendBytes(data, cb);\n    } else if (typeof data[\"toString\"] === \"function\") {\n        this.sendUTF(data, cb);\n    } else {\n        throw new Error(\"Data provided must either be a Node Buffer or implement toString()\");\n    }\n};\nWebSocketConnection.prototype.sendUTF = function(data, cb) {\n    data = bufferFromString(data.toString(), \"utf8\");\n    this._debug(\"sendUTF: %d bytes\", data.length);\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x01; // WebSocketOpcode.TEXT_FRAME\n    frame.binaryPayload = data;\n    this.fragmentAndSend(frame, cb);\n};\nWebSocketConnection.prototype.sendBytes = function(data, cb) {\n    this._debug(\"sendBytes\");\n    if (!Buffer.isBuffer(data)) {\n        throw new Error(\"You must pass a Node Buffer object to WebSocketConnection.prototype.sendBytes()\");\n    }\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x02; // WebSocketOpcode.BINARY_FRAME\n    frame.binaryPayload = data;\n    this.fragmentAndSend(frame, cb);\n};\nWebSocketConnection.prototype.ping = function(data) {\n    this._debug(\"ping\");\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x09; // WebSocketOpcode.PING\n    frame.fin = true;\n    if (data) {\n        if (!Buffer.isBuffer(data)) {\n            data = bufferFromString(data.toString(), \"utf8\");\n        }\n        if (data.length > 125) {\n            this._debug(\"WebSocket: Data for ping is longer than 125 bytes.  Truncating.\");\n            data = data.slice(0, 124);\n        }\n        frame.binaryPayload = data;\n    }\n    this.sendFrame(frame);\n};\n// Pong frames have to echo back the contents of the data portion of the\n// ping frame exactly, byte for byte.\nWebSocketConnection.prototype.pong = function(binaryPayload) {\n    this._debug(\"pong\");\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x0A; // WebSocketOpcode.PONG\n    if (Buffer.isBuffer(binaryPayload) && binaryPayload.length > 125) {\n        this._debug(\"WebSocket: Data for pong is longer than 125 bytes.  Truncating.\");\n        binaryPayload = binaryPayload.slice(0, 124);\n    }\n    frame.binaryPayload = binaryPayload;\n    frame.fin = true;\n    this.sendFrame(frame);\n};\nWebSocketConnection.prototype.fragmentAndSend = function(frame, cb) {\n    this._debug(\"fragmentAndSend\");\n    if (frame.opcode > 0x07) {\n        throw new Error(\"You cannot fragment control frames.\");\n    }\n    var threshold = this.config.fragmentationThreshold;\n    var length = frame.binaryPayload.length;\n    // Send immediately if fragmentation is disabled or the message is not\n    // larger than the fragmentation threshold.\n    if (!this.config.fragmentOutgoingMessages || frame.binaryPayload && length <= threshold) {\n        frame.fin = true;\n        this.sendFrame(frame, cb);\n        return;\n    }\n    var numFragments = Math.ceil(length / threshold);\n    var sentFragments = 0;\n    var sentCallback = function fragmentSentCallback(err) {\n        if (err) {\n            if (typeof cb === \"function\") {\n                // pass only the first error\n                cb(err);\n                cb = null;\n            }\n            return;\n        }\n        ++sentFragments;\n        if (sentFragments === numFragments && typeof cb === \"function\") {\n            cb();\n        }\n    };\n    for(var i = 1; i <= numFragments; i++){\n        var currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n        // continuation opcode except for first frame.\n        currentFrame.opcode = i === 1 ? frame.opcode : 0x00;\n        // fin set on last frame only\n        currentFrame.fin = i === numFragments;\n        // length is likely to be shorter on the last fragment\n        var currentLength = i === numFragments ? length - threshold * (i - 1) : threshold;\n        var sliceStart = threshold * (i - 1);\n        // Slice the right portion of the original payload\n        currentFrame.binaryPayload = frame.binaryPayload.slice(sliceStart, sliceStart + currentLength);\n        this.sendFrame(currentFrame, sentCallback);\n    }\n};\nWebSocketConnection.prototype.sendCloseFrame = function(reasonCode, description, cb) {\n    if (typeof reasonCode !== \"number\") {\n        reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n    }\n    this._debug(\"sendCloseFrame state: %s, reasonCode: %d, description: %s\", this.state, reasonCode, description);\n    if (this.state !== STATE_OPEN && this.state !== STATE_PEER_REQUESTED_CLOSE) {\n        return;\n    }\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.fin = true;\n    frame.opcode = 0x08; // WebSocketOpcode.CONNECTION_CLOSE\n    frame.closeStatus = reasonCode;\n    if (typeof description === \"string\") {\n        frame.binaryPayload = bufferFromString(description, \"utf8\");\n    }\n    this.sendFrame(frame, cb);\n    this.socket.end();\n};\nWebSocketConnection.prototype.sendFrame = function(frame, cb) {\n    this._debug(\"sendFrame\");\n    frame.mask = this.maskOutgoingPackets;\n    var flushed = this.socket.write(frame.toBuffer(), cb);\n    this.outputBufferFull = !flushed;\n    return flushed;\n};\nmodule.exports = WebSocketConnection;\nfunction instrumentSocketForDebugging(connection, socket) {\n    /* jshint loopfunc: true */ if (!connection._debug.enabled) {\n        return;\n    }\n    var originalSocketEmit = socket.emit;\n    socket.emit = function(event) {\n        connection._debug(\"||| Socket Event  '%s'\", event);\n        originalSocketEmit.apply(this, arguments);\n    };\n    for(var key in socket){\n        if (\"function\" !== typeof socket[key]) {\n            continue;\n        }\n        if ([\n            \"emit\"\n        ].indexOf(key) !== -1) {\n            continue;\n        }\n        (function(key) {\n            var original = socket[key];\n            if (key === \"on\") {\n                socket[key] = function proxyMethod__EventEmitter__On() {\n                    connection._debug(\"||| Socket method called:  %s (%s)\", key, arguments[0]);\n                    return original.apply(this, arguments);\n                };\n                return;\n            }\n            socket[key] = function proxyMethod() {\n                connection._debug(\"||| Socket method called:  %s\", key);\n                return original.apply(this, arguments);\n            };\n        })(key);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRDb25uZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozt1RUFjdUUsR0FFdkUsSUFBSUEsT0FBT0MsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUUsZUFBZUYsMERBQThCO0FBQ2pELElBQUlHLGlCQUFpQkgsbUJBQU9BLENBQUM7QUFDN0IsSUFBSUksYUFBYUosbUJBQU9BLENBQUM7QUFDekIsSUFBSUssY0FBY0wsbUJBQU9BLENBQUM7QUFDMUIsSUFBSU0sb0JBQW9CTCxNQUFNSyxpQkFBaUI7QUFDL0MsSUFBSUMsbUJBQW1CTixNQUFNTSxnQkFBZ0I7QUFFN0MsMERBQTBEO0FBQzFELE1BQU1DLGFBQWE7QUFDbkIsOENBQThDO0FBQzlDLE1BQU1DLDZCQUE2QjtBQUNuQyxpRUFBaUU7QUFDakUsTUFBTUMsZUFBZTtBQUNyQix3RUFBd0U7QUFDeEUsTUFBTUMsZUFBZTtBQUVyQixJQUFJQyxtQkFBbUIsa0JBQW1CQyxTQUNkQSxPQUFPQyxZQUFZLENBQUNDLElBQUksQ0FBQ0YsVUFDekJHLFFBQVFDLFFBQVEsQ0FBQ0YsSUFBSSxDQUFDQztBQUVsRCxJQUFJRSxZQUFZO0FBRWhCLFNBQVNDLG9CQUFvQkMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLFFBQVEsRUFBRUMsbUJBQW1CLEVBQUVDLE1BQU07SUFDbEYsSUFBSSxDQUFDQyxNQUFNLEdBQUd4QixNQUFNeUIsZUFBZSxDQUFDLHdCQUF3QixFQUFFUjtJQUM5RCxJQUFJLENBQUNPLE1BQU0sQ0FBQztJQUVaLElBQUksSUFBSSxDQUFDQSxNQUFNLENBQUNFLE9BQU8sRUFBRTtRQUNyQkMsNkJBQTZCLElBQUksRUFBRVI7SUFDdkM7SUFFQSx5QkFBeUI7SUFDekJsQixhQUFhMkIsSUFBSSxDQUFDLElBQUk7SUFFdEIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztJQUMx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LE9BQU9FLFNBQVNILEtBQUssQ0FBQyxJQUFJLEVBQUVDO2dCQUNoQztnQkFDQTtZQUNKO1lBQ0F2SyxNQUFNLENBQUN3SyxJQUFJLEdBQUcsU0FBU0c7Z0JBQ25CUixXQUFXOUosTUFBTSxDQUFDLGlDQUFpQ21LO2dCQUNuRCxPQUFPQyxTQUFTSCxLQUFLLENBQUMsSUFBSSxFQUFFQztZQUNoQztRQUNKLEdBQUdDO0lBQ1A7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRDb25uZWN0aW9uLmpzPzRlNDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIENvcHlyaWdodCAyMDEwLTIwMTUgQnJpYW4gTWNLZWx2ZXkuXG4gKlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgV2ViU29ja2V0RnJhbWUgPSByZXF1aXJlKCcuL1dlYlNvY2tldEZyYW1lJyk7XG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4uL3ZlbmRvci9GYXN0QnVmZmVyTGlzdCcpO1xudmFyIGlzVmFsaWRVVEY4ID0gcmVxdWlyZSgndXRmLTgtdmFsaWRhdGUnKTtcbnZhciBidWZmZXJBbGxvY1Vuc2FmZSA9IHV0aWxzLmJ1ZmZlckFsbG9jVW5zYWZlO1xudmFyIGJ1ZmZlckZyb21TdHJpbmcgPSB1dGlscy5idWZmZXJGcm9tU3RyaW5nO1xuXG4vLyBDb25uZWN0ZWQsIGZ1bGx5LW9wZW4sIHJlYWR5IHRvIHNlbmQgYW5kIHJlY2VpdmUgZnJhbWVzXG5jb25zdCBTVEFURV9PUEVOID0gJ29wZW4nO1xuLy8gUmVjZWl2ZWQgYSBjbG9zZSBmcmFtZSBmcm9tIHRoZSByZW1vdGUgcGVlclxuY29uc3QgU1RBVEVfUEVFUl9SRVFVRVNURURfQ0xPU0UgPSAncGVlcl9yZXF1ZXN0ZWRfY2xvc2UnO1xuLy8gU2VudCBjbG9zZSBmcmFtZSB0byByZW1vdGUgcGVlci4gIE5vIGZ1cnRoZXIgZGF0YSBjYW4gYmUgc2VudC5cbmNvbnN0IFNUQVRFX0VORElORyA9ICdlbmRpbmcnO1xuLy8gQ29ubmVjdGlvbiBpcyBmdWxseSBjbG9zZWQuICBObyBmdXJ0aGVyIGRhdGEgY2FuIGJlIHNlbnQgb3IgcmVjZWl2ZWQuXG5jb25zdCBTVEFURV9DTE9TRUQgPSAnY2xvc2VkJztcblxudmFyIHNldEltbWVkaWF0ZUltcGwgPSAoJ3NldEltbWVkaWF0ZScgaW4gZ2xvYmFsKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLnNldEltbWVkaWF0ZS5iaW5kKGdsb2JhbCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2suYmluZChwcm9jZXNzKTtcblxudmFyIGlkQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIFdlYlNvY2tldENvbm5lY3Rpb24oc29ja2V0LCBleHRlbnNpb25zLCBwcm90b2NvbCwgbWFza091dGdvaW5nUGFja2V0cywgY29uZmlnKSB7XG4gICAgdGhpcy5fZGVidWcgPSB1dGlscy5CdWZmZXJpbmdMb2dnZXIoJ3dlYnNvY2tldDpjb25uZWN0aW9uJywgKytpZENvdW50ZXIpO1xuICAgIHRoaXMuX2RlYnVnKCdjb25zdHJ1Y3RvcicpO1xuICAgIFxuICAgIGlmICh0aGlzLl9kZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgIGluc3RydW1lbnRTb2NrZXRGb3JEZWJ1Z2dpbmcodGhpcywgc29ja2V0KTtcbiAgICB9XG4gICAgXG4gICAgLy8gU3VwZXJjbGFzcyBDb25zdHJ1Y3RvclxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fcGluZ0xpc3RlbmVyQ291bnQgPSAwO1xuICAgIHRoaXMub24oJ25ld0xpc3RlbmVyJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKGV2ID09PSAncGluZycpe1xuICAgICAgICAgICAgdGhpcy5fcGluZ0xpc3RlbmVyQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgfSkub24oJ3JlbW92ZUxpc3RlbmVyJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKGV2ID09PSAncGluZycpIHtcbiAgICAgICAgICAgIHRoaXMuX3BpbmdMaXN0ZW5lckNvdW50LS07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgIHRoaXMucHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgIHRoaXMucmVtb3RlQWRkcmVzcyA9IHNvY2tldC5yZW1vdGVBZGRyZXNzO1xuICAgIHRoaXMuY2xvc2VSZWFzb25Db2RlID0gLTE7XG4gICAgdGhpcy5jbG9zZURlc2NyaXB0aW9uID0gbnVsbDtcbiAgICB0aGlzLmNsb3NlRXZlbnRFbWl0dGVkID0gZmFsc2U7XG5cbiAgICAvLyBXZSBoYXZlIHRvIG1hc2sgb3V0Z29pbmcgcGFja2V0cyBpZiB3ZSdyZSBhY3RpbmcgYXMgYSBXZWJTb2NrZXQgY2xpZW50LlxuICAgIHRoaXMubWFza091dGdvaW5nUGFja2V0cyA9IG1hc2tPdXRnb2luZ1BhY2tldHM7XG5cbiAgICAvLyBXZSByZS11c2UgdGhlIHNhbWUgYnVmZmVycyBmb3IgdGhlIG1hc2sgYW5kIGZyYW1lIGhlYWRlciBmb3IgYWxsIGZyYW1lc1xuICAgIC8vIHJlY2VpdmVkIG9uIGVhY2ggY29ubmVjdGlvbiB0byBhdm9pZCBhIHNtYWxsIG1lbW9yeSBhbGxvY2F0aW9uIGZvciBlYWNoXG4gICAgLy8gZnJhbWUuXG4gICAgdGhpcy5tYXNrQnl0ZXMgPSBidWZmZXJBbGxvY1Vuc2FmZSg0KTtcbiAgICB0aGlzLmZyYW1lSGVhZGVyID0gYnVmZmVyQWxsb2NVbnNhZmUoMTApO1xuXG4gICAgLy8gdGhlIEJ1ZmZlckxpc3Qgd2lsbCBoYW5kbGUgdGhlIGRhdGEgc3RyZWFtaW5nIGluXG4gICAgdGhpcy5idWZmZXJMaXN0ID0gbmV3IEJ1ZmZlckxpc3QoKTtcblxuICAgIC8vIFByZXBhcmUgZm9yIHJlY2VpdmluZyBmaXJzdCBmcmFtZVxuICAgIHRoaXMuY3VycmVudEZyYW1lID0gbmV3IFdlYlNvY2tldEZyYW1lKHRoaXMubWFza0J5dGVzLCB0aGlzLmZyYW1lSGVhZGVyLCB0aGlzLmNvbmZpZyk7XG4gICAgdGhpcy5mcmFnbWVudGF0aW9uU2l6ZSA9IDA7IC8vIGRhdGEgcmVjZWl2ZWQgc28gZmFyLi4uXG4gICAgdGhpcy5mcmFtZVF1ZXVlID0gW107XG4gICAgXG4gICAgLy8gVmFyaW91cyBiaXRzIG9mIGNvbm5lY3Rpb24gc3RhdGVcbiAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX09QRU47XG4gICAgdGhpcy53YWl0aW5nRm9yQ2xvc2VSZXNwb25zZSA9IGZhbHNlO1xuICAgIC8vIFJlY2VpdmVkIFRDUCBGSU4sIHNvY2tldCdzIHJlYWRhYmxlIHN0cmVhbSBpcyBmaW5pc2hlZC5cbiAgICB0aGlzLnJlY2VpdmVkRW5kID0gZmFsc2U7XG5cbiAgICB0aGlzLmNsb3NlVGltZW91dCA9IHRoaXMuY29uZmlnLmNsb3NlVGltZW91dDtcbiAgICB0aGlzLmFzc2VtYmxlRnJhZ21lbnRzID0gdGhpcy5jb25maWcuYXNzZW1ibGVGcmFnbWVudHM7XG4gICAgdGhpcy5tYXhSZWNlaXZlZE1lc3NhZ2VTaXplID0gdGhpcy5jb25maWcubWF4UmVjZWl2ZWRNZXNzYWdlU2l6ZTtcblxuICAgIHRoaXMub3V0cHV0QnVmZmVyRnVsbCA9IGZhbHNlO1xuICAgIHRoaXMuaW5wdXRQYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlY2VpdmVkRGF0YUhhbmRsZXIgPSB0aGlzLnByb2Nlc3NSZWNlaXZlZERhdGEuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9jbG9zZVRpbWVySGFuZGxlciA9IHRoaXMuaGFuZGxlQ2xvc2VUaW1lci5iaW5kKHRoaXMpO1xuXG4gICAgLy8gRGlzYWJsZSBuYWdsZSBhbGdvcml0aG0/XG4gICAgdGhpcy5zb2NrZXQuc2V0Tm9EZWxheSh0aGlzLmNvbmZpZy5kaXNhYmxlTmFnbGVBbGdvcml0aG0pO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZXJlIGlzIG5vIHNvY2tldCBpbmFjdGl2aXR5IHRpbWVvdXRcbiAgICB0aGlzLnNvY2tldC5zZXRUaW1lb3V0KDApO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmtlZXBhbGl2ZSAmJiAhdGhpcy5jb25maWcudXNlTmF0aXZlS2VlcGFsaXZlKSB7XG4gICAgICAgIGlmICh0eXBlb2YodGhpcy5jb25maWcua2VlcGFsaXZlSW50ZXJ2YWwpICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZWVwYWxpdmVJbnRlcnZhbCBtdXN0IGJlIHNwZWNpZmllZCBhbmQgbnVtZXJpYyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWYga2VlcGFsaXZlIGlzIHRydWUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fa2VlcGFsaXZlVGltZXJIYW5kbGVyID0gdGhpcy5oYW5kbGVLZWVwYWxpdmVUaW1lci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldEtlZXBhbGl2ZVRpbWVyKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmRyb3BDb25uZWN0aW9uT25LZWVwYWxpdmVUaW1lb3V0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKHRoaXMuY29uZmlnLmtlZXBhbGl2ZUdyYWNlUGVyaW9kKSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tlZXBhbGl2ZUdyYWNlUGVyaW9kICBtdXN0IGJlIHNwZWNpZmllZCBhbmQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdudW1lcmljIGlmIGRyb3BDb25uZWN0aW9uT25LZWVwYWxpdmVUaW1lb3V0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaXMgdHJ1ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2dyYWNlUGVyaW9kVGltZXJIYW5kbGVyID0gdGhpcy5oYW5kbGVHcmFjZVBlcmlvZFRpbWVyLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5jb25maWcua2VlcGFsaXZlICYmIHRoaXMuY29uZmlnLnVzZU5hdGl2ZUtlZXBhbGl2ZSkge1xuICAgICAgICBpZiAoISgnc2V0S2VlcEFsaXZlJyBpbiB0aGlzLnNvY2tldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHVzZSBuYXRpdmUga2VlcGFsaXZlOiB1bnN1cHBvcnRlZCBieSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGhpcyB2ZXJzaW9uIG9mIE5vZGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb2NrZXQuc2V0S2VlcEFsaXZlKHRydWUsIHRoaXMuY29uZmlnLmtlZXBhbGl2ZUludGVydmFsKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVGhlIEhUVFAgQ2xpZW50IHNlZW1zIHRvIHN1YnNjcmliZSB0byBzb2NrZXQgZXJyb3IgZXZlbnRzXG4gICAgLy8gYW5kIHJlLWRpc3BhdGNoIHRoZW0gaW4gc3VjaCBhIHdheSB0aGF0IGRvZXNuJ3QgbWFrZSBzZW5zZVxuICAgIC8vIGZvciB1c2VycyBvZiBvdXIgY2xpZW50LCBzbyB3ZSB3YW50IHRvIG1ha2Ugc3VyZSBub2JvZHlcbiAgICAvLyBlbHNlIGlzIGxpc3RlbmluZyBmb3IgZXJyb3IgZXZlbnRzIG9uIHRoZSBzb2NrZXQgYmVzaWRlcyB1cy5cbiAgICB0aGlzLnNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Vycm9yJyk7XG59XG5cbldlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX05PUk1BTCA9IDEwMDA7XG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9HT0lOR19BV0FZID0gMTAwMTtcbldlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX1BST1RPQ09MX0VSUk9SID0gMTAwMjtcbldlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX1VOUFJPQ0VTU0FCTEVfSU5QVVQgPSAxMDAzO1xuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fUkVTRVJWRUQgPSAxMDA0OyAvLyBSZXNlcnZlZCB2YWx1ZS4gIFVuZGVmaW5lZCBtZWFuaW5nLlxuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fTk9UX1BST1ZJREVEID0gMTAwNTsgLy8gTm90IHRvIGJlIHVzZWQgb24gdGhlIHdpcmVcbldlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX0FCTk9STUFMID0gMTAwNjsgLy8gTm90IHRvIGJlIHVzZWQgb24gdGhlIHdpcmVcbldlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX0lOVkFMSURfREFUQSA9IDEwMDc7XG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9QT0xJQ1lfVklPTEFUSU9OID0gMTAwODtcbldlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX01FU1NBR0VfVE9PX0JJRyA9IDEwMDk7XG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9FWFRFTlNJT05fUkVRVUlSRUQgPSAxMDEwO1xuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fSU5URVJOQUxfU0VSVkVSX0VSUk9SID0gMTAxMTtcbldlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX1RMU19IQU5EU0hBS0VfRkFJTEVEID0gMTAxNTsgLy8gTm90IHRvIGJlIHVzZWQgb24gdGhlIHdpcmVcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9ERVNDUklQVElPTlMgPSB7XG4gICAgMTAwMDogJ05vcm1hbCBjb25uZWN0aW9uIGNsb3N1cmUnLFxuICAgIDEwMDE6ICdSZW1vdGUgcGVlciBpcyBnb2luZyBhd2F5JyxcbiAgICAxMDAyOiAnUHJvdG9jb2wgZXJyb3InLFxuICAgIDEwMDM6ICdVbnByb2Nlc3NhYmxlIGlucHV0JyxcbiAgICAxMDA0OiAnUmVzZXJ2ZWQnLFxuICAgIDEwMDU6ICdSZWFzb24gbm90IHByb3ZpZGVkJyxcbiAgICAxMDA2OiAnQWJub3JtYWwgY2xvc3VyZSwgbm8gZnVydGhlciBkZXRhaWwgYXZhaWxhYmxlJyxcbiAgICAxMDA3OiAnSW52YWxpZCBkYXRhIHJlY2VpdmVkJyxcbiAgICAxMDA4OiAnUG9saWN5IHZpb2xhdGlvbicsXG4gICAgMTAwOTogJ01lc3NhZ2UgdG9vIGJpZycsXG4gICAgMTAxMDogJ0V4dGVuc2lvbiByZXF1ZXN0ZWQgYnkgY2xpZW50IGlzIHJlcXVpcmVkJyxcbiAgICAxMDExOiAnSW50ZXJuYWwgU2VydmVyIEVycm9yJyxcbiAgICAxMDE1OiAnVExTIEhhbmRzaGFrZSBGYWlsZWQnXG59O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUNsb3NlUmVhc29uKGNvZGUpIHtcbiAgICBpZiAoY29kZSA8IDEwMDApIHtcbiAgICAgICAgLy8gU3RhdHVzIGNvZGVzIGluIHRoZSByYW5nZSAwLTk5OSBhcmUgbm90IHVzZWRcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY29kZSA+PSAxMDAwICYmIGNvZGUgPD0gMjk5OSkge1xuICAgICAgICAvLyBDb2RlcyBmcm9tIDEwMDAgLSAyOTk5IGFyZSByZXNlcnZlZCBmb3IgdXNlIGJ5IHRoZSBwcm90b2NvbC4gIE9ubHlcbiAgICAgICAgLy8gYSBmZXcgY29kZXMgYXJlIGRlZmluZWQsIGFsbCBvdGhlcnMgYXJlIGN1cnJlbnRseSBpbGxlZ2FsLlxuICAgICAgICByZXR1cm4gWzEwMDAsIDEwMDEsIDEwMDIsIDEwMDMsIDEwMDcsIDEwMDgsIDEwMDksIDEwMTAsIDEwMTEsIDEwMTIsIDEwMTMsIDEwMTQsIDEwMTVdLmluZGV4T2YoY29kZSkgIT09IC0xO1xuICAgIH1cbiAgICBpZiAoY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gMzk5OSkge1xuICAgICAgICAvLyBSZXNlcnZlZCBmb3IgdXNlIGJ5IGxpYnJhcmllcywgZnJhbWV3b3JrcywgYW5kIGFwcGxpY2F0aW9ucy5cbiAgICAgICAgLy8gU2hvdWxkIGJlIHJlZ2lzdGVyZWQgd2l0aCBJQU5BLiAgSW50ZXJwcmV0YXRpb24gb2YgdGhlc2UgY29kZXMgaXNcbiAgICAgICAgLy8gdW5kZWZpbmVkIGJ5IHRoZSBXZWJTb2NrZXQgcHJvdG9jb2wuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29kZSA+PSA0MDAwICYmIGNvZGUgPD0gNDk5OSkge1xuICAgICAgICAvLyBSZXNlcnZlZCBmb3IgcHJpdmF0ZSB1c2UuICBJbnRlcnByZXRhdGlvbiBvZiB0aGVzZSBjb2RlcyBpc1xuICAgICAgICAvLyB1bmRlZmluZWQgYnkgdGhlIFdlYlNvY2tldCBwcm90b2NvbC5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjb2RlID49IDUwMDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxudXRpbC5pbmhlcml0cyhXZWJTb2NrZXRDb25uZWN0aW9uLCBFdmVudEVtaXR0ZXIpO1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5fYWRkU29ja2V0RXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNvY2tldC5vbignZXJyb3InLCB0aGlzLmhhbmRsZVNvY2tldEVycm9yLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc29ja2V0Lm9uKCdlbmQnLCB0aGlzLmhhbmRsZVNvY2tldEVuZC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnNvY2tldC5vbignY2xvc2UnLCB0aGlzLmhhbmRsZVNvY2tldENsb3NlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc29ja2V0Lm9uKCdkcmFpbicsIHRoaXMuaGFuZGxlU29ja2V0RHJhaW4uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5zb2NrZXQub24oJ3BhdXNlJywgdGhpcy5oYW5kbGVTb2NrZXRQYXVzZS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnNvY2tldC5vbigncmVzdW1lJywgdGhpcy5oYW5kbGVTb2NrZXRSZXN1bWUuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5zb2NrZXQub24oJ2RhdGEnLCB0aGlzLmhhbmRsZVNvY2tldERhdGEuYmluZCh0aGlzKSk7XG59O1xuXG4vLyBzZXQgb3IgcmVzZXQgdGhlIGtlZXBhbGl2ZSB0aW1lciB3aGVuIGRhdGEgaXMgcmVjZWl2ZWQuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRLZWVwYWxpdmVUaW1lciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlYnVnKCdzZXRLZWVwYWxpdmVUaW1lcicpO1xuICAgIGlmICghdGhpcy5jb25maWcua2VlcGFsaXZlICB8fCB0aGlzLmNvbmZpZy51c2VOYXRpdmVLZWVwYWxpdmUpIHsgcmV0dXJuOyB9XG4gICAgdGhpcy5jbGVhcktlZXBhbGl2ZVRpbWVyKCk7XG4gICAgdGhpcy5jbGVhckdyYWNlUGVyaW9kVGltZXIoKTtcbiAgICB0aGlzLl9rZWVwYWxpdmVUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KHRoaXMuX2tlZXBhbGl2ZVRpbWVySGFuZGxlciwgdGhpcy5jb25maWcua2VlcGFsaXZlSW50ZXJ2YWwpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuY2xlYXJLZWVwYWxpdmVUaW1lciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9rZWVwYWxpdmVUaW1lb3V0SUQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2tlZXBhbGl2ZVRpbWVvdXRJRCk7XG4gICAgfVxufTtcblxuLy8gTm8gZGF0YSBoYXMgYmVlbiByZWNlaXZlZCB3aXRoaW4gY29uZmlnLmtlZXBhbGl2ZVRpbWVvdXQgbXMuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVLZWVwYWxpdmVUaW1lciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlYnVnKCdoYW5kbGVLZWVwYWxpdmVUaW1lcicpO1xuICAgIHRoaXMuX2tlZXBhbGl2ZVRpbWVvdXRJRCA9IG51bGw7XG4gICAgdGhpcy5waW5nKCk7XG5cbiAgICAvLyBJZiB3ZSBhcmUgY29uZmlndXJlZCB0byBkcm9wIGNvbm5lY3Rpb25zIGlmIHRoZSBjbGllbnQgZG9lc24ndCByZXNwb25kXG4gICAgLy8gdGhlbiBzZXQgdGhlIGdyYWNlIHBlcmlvZCB0aW1lci5cbiAgICBpZiAodGhpcy5jb25maWcuZHJvcENvbm5lY3Rpb25PbktlZXBhbGl2ZVRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5zZXRHcmFjZVBlcmlvZFRpbWVyKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UgcmVzZXQgdGhlIGtlZXBhbGl2ZSB0aW1lciB0byBzZW5kIHRoZSBuZXh0IHBpbmcuXG4gICAgICAgIHRoaXMuc2V0S2VlcGFsaXZlVGltZXIoKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRHcmFjZVBlcmlvZFRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ3NldEdyYWNlUGVyaW9kVGltZXInKTtcbiAgICB0aGlzLmNsZWFyR3JhY2VQZXJpb2RUaW1lcigpO1xuICAgIHRoaXMuX2dyYWNlUGVyaW9kVGltZW91dElEID0gc2V0VGltZW91dCh0aGlzLl9ncmFjZVBlcmlvZFRpbWVySGFuZGxlciwgdGhpcy5jb25maWcua2VlcGFsaXZlR3JhY2VQZXJpb2QpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuY2xlYXJHcmFjZVBlcmlvZFRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2dyYWNlUGVyaW9kVGltZW91dElEKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9ncmFjZVBlcmlvZFRpbWVvdXRJRCk7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlR3JhY2VQZXJpb2RUaW1lciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlYnVnKCdoYW5kbGVHcmFjZVBlcmlvZFRpbWVyJyk7XG4gICAgLy8gSWYgdGhpcyBpcyBjYWxsZWQsIHRoZSBjbGllbnQgaGFzIG5vdCByZXNwb25kZWQgYW5kIGlzIGFzc3VtZWQgZGVhZC5cbiAgICB0aGlzLl9ncmFjZVBlcmlvZFRpbWVvdXRJRCA9IG51bGw7XG4gICAgdGhpcy5kcm9wKFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX0FCTk9STUFMLCAnUGVlciBub3QgcmVzcG9uZGluZy4nLCB0cnVlKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZVNvY2tldERhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdGhpcy5fZGVidWcoJ2hhbmRsZVNvY2tldERhdGEnKTtcbiAgICAvLyBSZXNldCB0aGUga2VlcGFsaXZlIHRpbWVyIHdoZW4gcmVjZWl2aW5nIGRhdGEgb2YgYW55IGtpbmQuXG4gICAgdGhpcy5zZXRLZWVwYWxpdmVUaW1lcigpO1xuXG4gICAgLy8gQWRkIHJlY2VpdmVkIGRhdGEgdG8gb3VyIGJ1ZmZlckxpc3QsIHdoaWNoIGVmZmljaWVudGx5IGhvbGRzIHJlY2VpdmVkXG4gICAgLy8gZGF0YSBjaHVua3MgaW4gYSBsaW5rZWQgbGlzdCBvZiBCdWZmZXIgb2JqZWN0cy5cbiAgICB0aGlzLmJ1ZmZlckxpc3Qud3JpdGUoZGF0YSk7XG5cbiAgICB0aGlzLnByb2Nlc3NSZWNlaXZlZERhdGEoKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnByb2Nlc3NSZWNlaXZlZERhdGEgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1ZygncHJvY2Vzc1JlY2VpdmVkRGF0YScpO1xuICAgIC8vIElmIHdlJ3JlIG5vdCBjb25uZWN0ZWQsIHdlIHNob3VsZCBpZ25vcmUgYW55IGRhdGEgcmVtYWluaW5nIG9uIHRoZSBidWZmZXIuXG4gICAgaWYgKCF0aGlzLmNvbm5lY3RlZCkgeyByZXR1cm47IH1cblxuICAgIC8vIFJlY2VpdmluZy9wYXJzaW5nIGlzIGV4cGVjdGVkIHRvIGJlIGhhbHRlZCB3aGVuIHBhdXNlZC5cbiAgICBpZiAodGhpcy5pbnB1dFBhdXNlZCkgeyByZXR1cm47IH1cblxuICAgIHZhciBmcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuXG4gICAgLy8gV2ViU29ja2V0RnJhbWUucHJvdG90eXBlLmFkZERhdGEgcmV0dXJucyB0cnVlIGlmIGFsbCBkYXRhIG5lY2Vzc2FyeSB0b1xuICAgIC8vIHBhcnNlIHRoZSBmcmFtZSB3YXMgYXZhaWxhYmxlLiAgSXQgcmV0dXJucyBmYWxzZSBpZiB3ZSBhcmUgd2FpdGluZyBmb3JcbiAgICAvLyBtb3JlIGRhdGEgdG8gY29tZSBpbiBvbiB0aGUgd2lyZS5cbiAgICBpZiAoIWZyYW1lLmFkZERhdGEodGhpcy5idWZmZXJMaXN0KSkgeyB0aGlzLl9kZWJ1ZygnLS0gaW5zdWZmaWNpZW50IGRhdGEgZm9yIGZyYW1lJyk7IHJldHVybjsgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gSGFuZGxlIHBvc3NpYmxlIHBhcnNpbmcgZXJyb3JzXG4gICAgaWYgKGZyYW1lLnByb3RvY29sRXJyb3IpIHtcbiAgICAgICAgLy8gU29tZXRoaW5nIGJhZCBoYXBwZW5lZC4uIGdldCByaWQgb2YgdGhpcyBjbGllbnQuXG4gICAgICAgIHRoaXMuX2RlYnVnKCctLSBwcm90b2NvbCBlcnJvcicpO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5kcm9wKFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX1BST1RPQ09MX0VSUk9SLCBmcmFtZS5kcm9wUmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoZnJhbWUuZnJhbWVUb29MYXJnZSkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnLS0gZnJhbWUgdG9vIGxhcmdlJyk7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmRyb3AoV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fTUVTU0FHRV9UT09fQklHLCBmcmFtZS5kcm9wUmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGb3Igbm93IHNpbmNlIHdlIGRvbid0IHN1cHBvcnQgZXh0ZW5zaW9ucywgYWxsIFJTViBiaXRzIGFyZSBpbGxlZ2FsXG4gICAgaWYgKGZyYW1lLnJzdjEgfHwgZnJhbWUucnN2MiB8fCBmcmFtZS5yc3YzKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCctLSBpbGxlZ2FsIHJzdiBmbGFnJyk7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmRyb3AoV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fUFJPVE9DT0xfRVJST1IsXG4gICAgICAgICAgICAgICdVbnN1cHBvcnRlZCB1c2FnZSBvZiByc3YgYml0cyB3aXRob3V0IG5lZ290aWF0ZWQgZXh0ZW5zaW9uLicpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5hc3NlbWJsZUZyYWdtZW50cykge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnLS0gZW1pdHRpbmcgZnJhbWUnKTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHsgc2VsZi5lbWl0KCdmcmFtZScsIGZyYW1lKTsgfSk7XG4gICAgfVxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHsgc2VsZi5wcm9jZXNzRnJhbWUoZnJhbWUpOyB9KTtcbiAgICBcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IG5ldyBXZWJTb2NrZXRGcmFtZSh0aGlzLm1hc2tCeXRlcywgdGhpcy5mcmFtZUhlYWRlciwgdGhpcy5jb25maWcpO1xuXG4gICAgLy8gSWYgdGhlcmUncyBkYXRhIHJlbWFpbmluZywgc2NoZWR1bGUgYWRkaXRpb25hbCBwcm9jZXNzaW5nLCBidXQgeWllbGRcbiAgICAvLyBmb3Igbm93IHNvIHRoYXQgb3RoZXIgY29ubmVjdGlvbnMgaGF2ZSBhIGNoYW5jZSB0byBoYXZlIHRoZWlyIGRhdGFcbiAgICAvLyBwcm9jZXNzZWQuICBXZSB1c2Ugc2V0SW1tZWRpYXRlIGhlcmUgaW5zdGVhZCBvZiBwcm9jZXNzLm5leHRUaWNrIHRvXG4gICAgLy8gZXhwbGljaXRseSBpbmRpY2F0ZSB0aGF0IHdlIHdpc2ggZm9yIG90aGVyIEkvTyB0byBiZSBoYW5kbGVkIGZpcnN0LlxuICAgIGlmICh0aGlzLmJ1ZmZlckxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICBzZXRJbW1lZGlhdGVJbXBsKHRoaXMucmVjZWl2ZWREYXRhSGFuZGxlcik7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlU29ja2V0RXJyb3IgPSBmdW5jdGlvbihlcnJvcikge1xuICAgIHRoaXMuX2RlYnVnKCdoYW5kbGVTb2NrZXRFcnJvcjogJWonLCBlcnJvcik7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFNUQVRFX0NMT1NFRCkge1xuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdGhldHVydGxlMzIvV2ViU29ja2V0LU5vZGUvaXNzdWVzLzI4OFxuICAgICAgICB0aGlzLl9kZWJ1ZygnICAtLS0gU29ja2V0IFxcJ2Vycm9yXFwnIGFmdGVyIFxcJ2Nsb3NlXFwnJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jbG9zZVJlYXNvbkNvZGUgPSBXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9BQk5PUk1BTDtcbiAgICB0aGlzLmNsb3NlRGVzY3JpcHRpb24gPSAnU29ja2V0IEVycm9yOiAnICsgZXJyb3Iuc3lzY2FsbCArICcgJyArIGVycm9yLmNvZGU7XG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfQ0xPU0VEO1xuICAgIHRoaXMuZnJhZ21lbnRhdGlvblNpemUgPSAwO1xuICAgIGlmICh1dGlscy5ldmVudEVtaXR0ZXJMaXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID4gMCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLnNvY2tldC5kZXN0cm95KCk7XG4gICAgdGhpcy5fZGVidWcucHJpbnRPdXRwdXQoKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZVNvY2tldEVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlYnVnKCdoYW5kbGVTb2NrZXRFbmQ6IHJlY2VpdmVkIHNvY2tldCBlbmQuICBzdGF0ZSA9ICVzJywgdGhpcy5zdGF0ZSk7XG4gICAgdGhpcy5yZWNlaXZlZEVuZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFNUQVRFX0NMT1NFRCkge1xuICAgICAgICAvLyBXaGVuIHVzaW5nIHRoZSBUTFMgbW9kdWxlLCBzb21ldGltZXMgdGhlIHNvY2tldCB3aWxsIGVtaXQgJ2VuZCdcbiAgICAgICAgLy8gYWZ0ZXIgaXQgZW1pdHMgJ2Nsb3NlJy4gIEkgZG9uJ3QgdGhpbmsgdGhhdCdzIGNvcnJlY3QgYmVoYXZpb3IsXG4gICAgICAgIC8vIGJ1dCB3ZSBzaG91bGQgZGVhbCB3aXRoIGl0IGdyYWNlZnVsbHkgYnkgaWdub3JpbmcgaXQuXG4gICAgICAgIHRoaXMuX2RlYnVnKCcgIC0tLSBTb2NrZXQgXFwnZW5kXFwnIGFmdGVyIFxcJ2Nsb3NlXFwnJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX1BFRVJfUkVRVUVTVEVEX0NMT1NFICYmXG4gICAgICAgIHRoaXMuc3RhdGUgIT09IFNUQVRFX0VORElORykge1xuICAgICAgdGhpcy5fZGVidWcoJyAgLS0tIFVORVhQRUNURUQgc29ja2V0IGVuZC4nKTtcbiAgICAgIHRoaXMuc29ja2V0LmVuZCgpO1xuICAgIH1cbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZVNvY2tldENsb3NlID0gZnVuY3Rpb24oaGFkRXJyb3IpIHtcbiAgICB0aGlzLl9kZWJ1ZygnaGFuZGxlU29ja2V0Q2xvc2U6IHJlY2VpdmVkIHNvY2tldCBjbG9zZScpO1xuICAgIHRoaXMuc29ja2V0SGFkRXJyb3IgPSBoYWRFcnJvcjtcbiAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9DTE9TRUQ7XG4gICAgLy8gSWYgY2xvc2VSZWFzb25Db2RlIGlzIHN0aWxsIHNldCB0byAtMSBhdCB0aGlzIHBvaW50IHRoZW4gd2UgbXVzdFxuICAgIC8vIG5vdCBoYXZlIHJlY2VpdmVkIGEgY2xvc2UgZnJhbWUhIVxuICAgIGlmICh0aGlzLmNsb3NlUmVhc29uQ29kZSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5jbG9zZVJlYXNvbkNvZGUgPSBXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9BQk5PUk1BTDtcbiAgICAgICAgdGhpcy5jbG9zZURlc2NyaXB0aW9uID0gJ0Nvbm5lY3Rpb24gZHJvcHBlZCBieSByZW1vdGUgcGVlci4nO1xuICAgIH1cbiAgICB0aGlzLmNsZWFyQ2xvc2VUaW1lcigpO1xuICAgIHRoaXMuY2xlYXJLZWVwYWxpdmVUaW1lcigpO1xuICAgIHRoaXMuY2xlYXJHcmFjZVBlcmlvZFRpbWVyKCk7XG4gICAgaWYgKCF0aGlzLmNsb3NlRXZlbnRFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFdmVudEVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kZWJ1ZygnLS0gRW1pdHRpbmcgV2ViU29ja2V0Q29ubmVjdGlvbiBjbG9zZSBldmVudCcpO1xuICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgdGhpcy5jbG9zZVJlYXNvbkNvZGUsIHRoaXMuY2xvc2VEZXNjcmlwdGlvbik7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlU29ja2V0RHJhaW4gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1ZygnaGFuZGxlU29ja2V0RHJhaW46IHNvY2tldCBkcmFpbiBldmVudCcpO1xuICAgIHRoaXMub3V0cHV0QnVmZmVyRnVsbCA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZVNvY2tldFBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ2hhbmRsZVNvY2tldFBhdXNlOiBzb2NrZXQgcGF1c2UgZXZlbnQnKTtcbiAgICB0aGlzLmlucHV0UGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVTb2NrZXRSZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1ZygnaGFuZGxlU29ja2V0UmVzdW1lOiBzb2NrZXQgcmVzdW1lIGV2ZW50Jyk7XG4gICAgdGhpcy5pbnB1dFBhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncmVzdW1lJyk7XG4gICAgdGhpcy5wcm9jZXNzUmVjZWl2ZWREYXRhKCk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlYnVnKCdwYXVzZTogcGF1c2UgcmVxdWVzdGVkJyk7XG4gICAgdGhpcy5zb2NrZXQucGF1c2UoKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlYnVnKCdyZXN1bWU6IHJlc3VtZSByZXF1ZXN0ZWQnKTtcbiAgICB0aGlzLnNvY2tldC5yZXN1bWUoKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24ocmVhc29uQ29kZSwgZGVzY3JpcHRpb24pIHtcbiAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ2Nsb3NlOiBJbml0YXRpbmcgY2xlYW4gV2ViU29ja2V0IGNsb3NlIHNlcXVlbmNlLicpO1xuICAgICAgICBpZiAoJ251bWJlcicgIT09IHR5cGVvZiByZWFzb25Db2RlKSB7XG4gICAgICAgICAgICByZWFzb25Db2RlID0gV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fTk9STUFMO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsaWRhdGVDbG9zZVJlYXNvbihyZWFzb25Db2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbG9zZSBjb2RlICcgKyByZWFzb25Db2RlICsgJyBpcyBub3QgdmFsaWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9ERVNDUklQVElPTlNbcmVhc29uQ29kZV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZVJlYXNvbkNvZGUgPSByZWFzb25Db2RlO1xuICAgICAgICB0aGlzLmNsb3NlRGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5zZXRDbG9zZVRpbWVyKCk7XG4gICAgICAgIHRoaXMuc2VuZENsb3NlRnJhbWUodGhpcy5jbG9zZVJlYXNvbkNvZGUsIHRoaXMuY2xvc2VEZXNjcmlwdGlvbik7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9FTkRJTkc7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuZHJvcCA9IGZ1bmN0aW9uKHJlYXNvbkNvZGUsIGRlc2NyaXB0aW9uLCBza2lwQ2xvc2VGcmFtZSkge1xuICAgIHRoaXMuX2RlYnVnKCdkcm9wJyk7XG4gICAgaWYgKHR5cGVvZihyZWFzb25Db2RlKSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmVhc29uQ29kZSA9IFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX1BST1RPQ09MX0VSUk9SO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YoZGVzY3JpcHRpb24pICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBJZiBubyBkZXNjcmlwdGlvbiBpcyBwcm92aWRlZCwgdHJ5IHRvIGxvb2sgb25lIHVwIGJhc2VkIG9uIHRoZVxuICAgICAgICAvLyBzcGVjaWZpZWQgcmVhc29uQ29kZS5cbiAgICAgICAgZGVzY3JpcHRpb24gPSBXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX0RFU0NSSVBUSU9OU1tyZWFzb25Db2RlXTtcbiAgICB9XG5cbiAgICB0aGlzLl9kZWJ1ZygnRm9yY2VmdWxseSBkcm9wcGluZyBjb25uZWN0aW9uLiBza2lwQ2xvc2VGcmFtZTogJXMsIGNvZGU6ICVkLCBkZXNjcmlwdGlvbjogJXMnLFxuICAgICAgICBza2lwQ2xvc2VGcmFtZSwgcmVhc29uQ29kZSwgZGVzY3JpcHRpb25cbiAgICApO1xuXG4gICAgdGhpcy5jbG9zZVJlYXNvbkNvZGUgPSByZWFzb25Db2RlO1xuICAgIHRoaXMuY2xvc2VEZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgIHRoaXMuZnJhbWVRdWV1ZSA9IFtdO1xuICAgIHRoaXMuZnJhZ21lbnRhdGlvblNpemUgPSAwO1xuICAgIGlmICghc2tpcENsb3NlRnJhbWUpIHtcbiAgICAgICAgdGhpcy5zZW5kQ2xvc2VGcmFtZShyZWFzb25Db2RlLCBkZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0NMT1NFRDtcbiAgICB0aGlzLmNsZWFyQ2xvc2VUaW1lcigpO1xuICAgIHRoaXMuY2xlYXJLZWVwYWxpdmVUaW1lcigpO1xuICAgIHRoaXMuY2xlYXJHcmFjZVBlcmlvZFRpbWVyKCk7XG5cbiAgICBpZiAoIXRoaXMuY2xvc2VFdmVudEVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5jbG9zZUV2ZW50RW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdFbWl0dGluZyBXZWJTb2NrZXRDb25uZWN0aW9uIGNsb3NlIGV2ZW50Jyk7XG4gICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCB0aGlzLmNsb3NlUmVhc29uQ29kZSwgdGhpcy5jbG9zZURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5fZGVidWcoJ0Ryb3A6IGRlc3Ryb3lpbmcgc29ja2V0Jyk7XG4gICAgdGhpcy5zb2NrZXQuZGVzdHJveSgpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2V0Q2xvc2VUaW1lciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlYnVnKCdzZXRDbG9zZVRpbWVyJyk7XG4gICAgdGhpcy5jbGVhckNsb3NlVGltZXIoKTtcbiAgICB0aGlzLl9kZWJ1ZygnU2V0dGluZyBjbG9zZSB0aW1lcicpO1xuICAgIHRoaXMud2FpdGluZ0ZvckNsb3NlUmVzcG9uc2UgPSB0cnVlO1xuICAgIHRoaXMuY2xvc2VUaW1lciA9IHNldFRpbWVvdXQodGhpcy5fY2xvc2VUaW1lckhhbmRsZXIsIHRoaXMuY2xvc2VUaW1lb3V0KTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmNsZWFyQ2xvc2VUaW1lciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlYnVnKCdjbGVhckNsb3NlVGltZXInKTtcbiAgICBpZiAodGhpcy5jbG9zZVRpbWVyKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdDbGVhcmluZyBjbG9zZSB0aW1lcicpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jbG9zZVRpbWVyKTtcbiAgICAgICAgdGhpcy53YWl0aW5nRm9yQ2xvc2VSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNsb3NlVGltZXIgPSBudWxsO1xuICAgIH1cbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZUNsb3NlVGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1ZygnaGFuZGxlQ2xvc2VUaW1lcicpO1xuICAgIHRoaXMuY2xvc2VUaW1lciA9IG51bGw7XG4gICAgaWYgKHRoaXMud2FpdGluZ0ZvckNsb3NlUmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ0Nsb3NlIHJlc3BvbnNlIG5vdCByZWNlaXZlZCBmcm9tIGNsaWVudC4gIEZvcmNpbmcgc29ja2V0IGVuZC4nKTtcbiAgICAgICAgdGhpcy53YWl0aW5nRm9yQ2xvc2VSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfQ0xPU0VEO1xuICAgICAgICB0aGlzLnNvY2tldC5lbmQoKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5wcm9jZXNzRnJhbWUgPSBmdW5jdGlvbihmcmFtZSkge1xuICAgIHRoaXMuX2RlYnVnKCdwcm9jZXNzRnJhbWUnKTtcbiAgICB0aGlzLl9kZWJ1ZygnIC0tIGZyYW1lOiAlcycsIGZyYW1lKTtcbiAgICBcbiAgICAvLyBBbnkgbm9uLWNvbnRyb2wgb3Bjb2RlIGJlc2lkZXMgMHgwMCAoY29udGludWF0aW9uKSByZWNlaXZlZCBpbiB0aGVcbiAgICAvLyBtaWRkbGUgb2YgYSBmcmFnbWVudGVkIG1lc3NhZ2UgaXMgaWxsZWdhbC5cbiAgICBpZiAodGhpcy5mcmFtZVF1ZXVlLmxlbmd0aCAhPT0gMCAmJiAoZnJhbWUub3Bjb2RlID4gMHgwMCAmJiBmcmFtZS5vcGNvZGUgPCAweDA4KSkge1xuICAgICAgICB0aGlzLmRyb3AoV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fUFJPVE9DT0xfRVJST1IsXG4gICAgICAgICAgJ0lsbGVnYWwgZnJhbWUgb3Bjb2RlIDB4JyArIGZyYW1lLm9wY29kZS50b1N0cmluZygxNikgKyAnICcgK1xuICAgICAgICAgICdyZWNlaXZlZCBpbiBtaWRkbGUgb2YgZnJhZ21lbnRlZCBtZXNzYWdlLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3dpdGNoKGZyYW1lLm9wY29kZSkge1xuICAgICAgICBjYXNlIDB4MDI6IC8vIFdlYlNvY2tldEZyYW1lLkJJTkFSWV9GUkFNRVxuICAgICAgICAgICAgdGhpcy5fZGVidWcoJy0tIEJpbmFyeSBGcmFtZScpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXNzZW1ibGVGcmFnbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUuZmluKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXBsZXRlIHNpbmdsZS1mcmFtZSBtZXNzYWdlIHJlY2VpdmVkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCctLS0tIEVtaXR0aW5nIFxcJ21lc3NhZ2VcXCcgZXZlbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2JpbmFyeScsXG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnlEYXRhOiBmcmFtZS5iaW5hcnlQYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVnaW5uaW5nIG9mIGEgZnJhZ21lbnRlZCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVRdWV1ZS5wdXNoKGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudGF0aW9uU2l6ZSA9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDAxOiAvLyBXZWJTb2NrZXRGcmFtZS5URVhUX0ZSQU1FXG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnLS0gVGV4dCBGcmFtZScpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXNzZW1ibGVGcmFnbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUuZmluKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZFVURjgoZnJhbWUuYmluYXJ5UGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9JTlZBTElEX0RBVEEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdJbnZhbGlkIFVURi04IERhdGEgUmVjZWl2ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDb21wbGV0ZSBzaW5nbGUtZnJhbWUgbWVzc2FnZSByZWNlaXZlZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnLS0tLSBFbWl0dGluZyBcXCdtZXNzYWdlXFwnIGV2ZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1dGY4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhEYXRhOiBmcmFtZS5iaW5hcnlQYXlsb2FkLnRvU3RyaW5nKCd1dGY4JylcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBiZWdpbm5pbmcgb2YgYSBmcmFnbWVudGVkIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFtZVF1ZXVlLnB1c2goZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50YXRpb25TaXplID0gZnJhbWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MDA6IC8vIFdlYlNvY2tldEZyYW1lLkNPTlRJTlVBVElPTlxuICAgICAgICAgICAgdGhpcy5fZGVidWcoJy0tIENvbnRpbnVhdGlvbiBGcmFtZScpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXNzZW1ibGVGcmFnbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mcmFtZVF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AoV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fUFJPVE9DT0xfRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgJ1VuZXhwZWN0ZWQgQ29udGludWF0aW9uIEZyYW1lJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50YXRpb25TaXplICs9IGZyYW1lLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZyYWdtZW50YXRpb25TaXplID4gdGhpcy5tYXhSZWNlaXZlZE1lc3NhZ2VTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9NRVNTQUdFX1RPT19CSUcsXG4gICAgICAgICAgICAgICAgICAgICAgJ01heGltdW0gbWVzc2FnZSBzaXplIGV4Y2VlZGVkLicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZVF1ZXVlLnB1c2goZnJhbWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lLmZpbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbmQgb2YgZnJhZ21lbnRlZCBtZXNzYWdlLCBzbyB3ZSBwcm9jZXNzIHRoZSB3aG9sZVxuICAgICAgICAgICAgICAgICAgICAvLyBtZXNzYWdlIG5vdy4gIFdlIGFsc28gaGF2ZSB0byBkZWNvZGUgdGhlIHV0Zi04IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHRleHQgZnJhbWVzIGFmdGVyIGNvbWJpbmluZyBhbGwgdGhlIGZyYWdtZW50cy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ5dGVzQ29waWVkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpbmFyeVBheWxvYWQgPSBidWZmZXJBbGxvY1Vuc2FmZSh0aGlzLmZyYWdtZW50YXRpb25TaXplKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wY29kZSA9IHRoaXMuZnJhbWVRdWV1ZVswXS5vcGNvZGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChjdXJyZW50RnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGcmFtZS5iaW5hcnlQYXlsb2FkLmNvcHkoYmluYXJ5UGF5bG9hZCwgYnl0ZXNDb3BpZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNDb3BpZWQgKz0gY3VycmVudEZyYW1lLmJpbmFyeVBheWxvYWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFtZVF1ZXVlID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRhdGlvblNpemUgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAob3Bjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MDI6IC8vIFdlYlNvY2tldE9wY29kZS5CSU5BUllfRlJBTUVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdiaW5hcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnlEYXRhOiBiaW5hcnlQYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MDE6IC8vIFdlYlNvY2tldE9wY29kZS5URVhUX0ZSQU1FXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkVVRGOChiaW5hcnlQYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AoV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fSU5WQUxJRF9EQVRBLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdJbnZhbGlkIFVURi04IERhdGEgUmVjZWl2ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1dGY4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmOERhdGE6IGJpbmFyeVBheWxvYWQudG9TdHJpbmcoJ3V0ZjgnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AoV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fUFJPVE9DT0xfRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVW5leHBlY3RlZCBmaXJzdCBvcGNvZGUgaW4gZnJhZ21lbnRhdGlvbiBzZXF1ZW5jZTogMHgnICsgb3Bjb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwOTogLy8gV2ViU29ja2V0RnJhbWUuUElOR1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJy0tIFBpbmcgRnJhbWUnKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3BpbmdMaXN0ZW5lckNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIGxvZ2ljIHRvIGVtaXQgdGhlIHBpbmcgZnJhbWU6IHRoaXMgaXMgb25seSBkb25lIHdoZW4gYSBsaXN0ZW5lciBpcyBrbm93biB0byBleGlzdFxuICAgICAgICAgICAgICAgIC8vIEV4cG9zZSBhIGZ1bmN0aW9uIGFsbG93aW5nIHRoZSB1c2VyIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHBpbmcoKSBiZWhhdmlvclxuICAgICAgICAgICAgICAgIHZhciBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgY2FuY2VsID0gZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTsgXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3BpbmcnLCBjYW5jZWwsIGZyYW1lLmJpbmFyeVBheWxvYWQpO1xuXG4gICAgICAgICAgICAgICAgLy8gT25seSBzZW5kIGEgcG9uZyBpZiB0aGUgY2xpZW50IGRpZCBub3QgaW5kaWNhdGUgdGhhdCBoZSB3b3VsZCBsaWtlIHRvIGNhbmNlbFxuICAgICAgICAgICAgICAgIGlmICghY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9uZyhmcmFtZS5iaW5hcnlQYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvbmcoZnJhbWUuYmluYXJ5UGF5bG9hZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MEE6IC8vIFdlYlNvY2tldEZyYW1lLlBPTkdcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCctLSBQb25nIEZyYW1lJyk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3BvbmcnLCBmcmFtZS5iaW5hcnlQYXlsb2FkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MDg6IC8vIFdlYlNvY2tldEZyYW1lLkNPTk5FQ1RJT05fQ0xPU0VcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCctLSBDbG9zZSBGcmFtZScpO1xuICAgICAgICAgICAgaWYgKHRoaXMud2FpdGluZ0ZvckNsb3NlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBHb3QgcmVzcG9uc2UgdG8gb3VyIHJlcXVlc3QgdG8gY2xvc2UgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAgICAgLy8gQ2xvc2UgaXMgY29tcGxldGUsIHNvIHdlIGp1c3QgaGFuZyB1cC5cbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnLS0tLSBHb3QgY2xvc2UgcmVzcG9uc2UgZnJvbSBwZWVyLiAgQ29tcGxldGluZyBjbG9zaW5nIGhhbmRzaGFrZS4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyQ2xvc2VUaW1lcigpO1xuICAgICAgICAgICAgICAgIHRoaXMud2FpdGluZ0ZvckNsb3NlUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfQ0xPU0VEO1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5fZGVidWcoJy0tLS0gQ2xvc2luZyBoYW5kc2hha2UgaW5pdGlhdGVkIGJ5IHBlZXIuJyk7XG4gICAgICAgICAgICAvLyBHb3QgcmVxdWVzdCBmcm9tIG90aGVyIHBhcnR5IHRvIGNsb3NlIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAvLyBTZW5kIGJhY2sgYWNrbm93bGVkZ2VtZW50IGFuZCB0aGVuIGhhbmcgdXAuXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUEVFUl9SRVFVRVNURURfQ0xPU0U7XG4gICAgICAgICAgICB2YXIgcmVzcG9uZENsb3NlUmVhc29uQ29kZTtcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBjbG9zZSByZWFzb24gcHJvdmlkZWQgaXMgbGVnYWwgYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyB0aGUgcHJvdG9jb2wgc3BlYy4gIFByb3ZpZGluZyBubyBjbG9zZSBzdGF0dXMgaXMgbGVnYWwuXG4gICAgICAgICAgICAvLyBXZWJTb2NrZXRGcmFtZSBzZXRzIGNsb3NlU3RhdHVzIHRvIC0xIGJ5IGRlZmF1bHQsIHNvIGlmIGl0XG4gICAgICAgICAgICAvLyBpcyBzdGlsbCAtMSwgdGhlbiBubyBzdGF0dXMgd2FzIHByb3ZpZGVkLlxuICAgICAgICAgICAgaWYgKGZyYW1lLmludmFsaWRDbG9zZUZyYW1lTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVJlYXNvbkNvZGUgPSAxMDA1OyAvLyAxMDA1ID0gTm8gcmVhc29uIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAgIHJlc3BvbmRDbG9zZVJlYXNvbkNvZGUgPSBXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9QUk9UT0NPTF9FUlJPUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZyYW1lLmNsb3NlU3RhdHVzID09PSAtMSB8fCB2YWxpZGF0ZUNsb3NlUmVhc29uKGZyYW1lLmNsb3NlU3RhdHVzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VSZWFzb25Db2RlID0gZnJhbWUuY2xvc2VTdGF0dXM7XG4gICAgICAgICAgICAgICAgcmVzcG9uZENsb3NlUmVhc29uQ29kZSA9IFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX05PUk1BTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VSZWFzb25Db2RlID0gZnJhbWUuY2xvc2VTdGF0dXM7XG4gICAgICAgICAgICAgICAgcmVzcG9uZENsb3NlUmVhc29uQ29kZSA9IFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX1BST1RPQ09MX0VSUk9SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHRleHR1YWwgZGVzY3JpcHRpb24gaW4gdGhlIGNsb3NlIGZyYW1lLCBleHRyYWN0IGl0LlxuICAgICAgICAgICAgaWYgKGZyYW1lLmJpbmFyeVBheWxvYWQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZFVURjgoZnJhbWUuYmluYXJ5UGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wKFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX0lOVkFMSURfREFUQSxcbiAgICAgICAgICAgICAgICAgICAgICAnSW52YWxpZCBVVEYtOCBEYXRhIFJlY2VpdmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZURlc2NyaXB0aW9uID0gZnJhbWUuYmluYXJ5UGF5bG9hZC50b1N0cmluZygndXRmOCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZURlc2NyaXB0aW9uID0gV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9ERVNDUklQVElPTlNbdGhpcy5jbG9zZVJlYXNvbkNvZGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGVidWcoXG4gICAgICAgICAgICAgICAgJy0tLS0tLSBSZW1vdGUgcGVlciAlcyAtIGNvZGU6ICVkIC0gJXMgLSBjbG9zZSBmcmFtZSBwYXlsb2FkIGxlbmd0aDogJWQnLFxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3RlQWRkcmVzcywgdGhpcy5jbG9zZVJlYXNvbkNvZGUsXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZURlc2NyaXB0aW9uLCBmcmFtZS5sZW5ndGhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnLS0tLS0tIHJlc3BvbmRpbmcgdG8gcmVtb3RlIHBlZXJcXCdzIGNsb3NlIHJlcXVlc3QuJyk7XG4gICAgICAgICAgICB0aGlzLnNlbmRDbG9zZUZyYW1lKHJlc3BvbmRDbG9zZVJlYXNvbkNvZGUsIG51bGwpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5fZGVidWcoJy0tIFVucmVjb2duaXplZCBPcGNvZGUgJWQnLCBmcmFtZS5vcGNvZGUpO1xuICAgICAgICAgICAgdGhpcy5kcm9wKFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX1BST1RPQ09MX0VSUk9SLFxuICAgICAgICAgICAgICAnVW5yZWNvZ25pemVkIE9wY29kZTogMHgnICsgZnJhbWUub3Bjb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSwgY2IpIHtcbiAgICB0aGlzLl9kZWJ1Zygnc2VuZCcpO1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgdGhpcy5zZW5kQnl0ZXMoZGF0YSwgY2IpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YoZGF0YVsndG9TdHJpbmcnXSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5zZW5kVVRGKGRhdGEsIGNiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBwcm92aWRlZCBtdXN0IGVpdGhlciBiZSBhIE5vZGUgQnVmZmVyIG9yIGltcGxlbWVudCB0b1N0cmluZygpJyk7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZFVURiA9IGZ1bmN0aW9uKGRhdGEsIGNiKSB7XG4gICAgZGF0YSA9IGJ1ZmZlckZyb21TdHJpbmcoZGF0YS50b1N0cmluZygpLCAndXRmOCcpO1xuICAgIHRoaXMuX2RlYnVnKCdzZW5kVVRGOiAlZCBieXRlcycsIGRhdGEubGVuZ3RoKTtcbiAgICB2YXIgZnJhbWUgPSBuZXcgV2ViU29ja2V0RnJhbWUodGhpcy5tYXNrQnl0ZXMsIHRoaXMuZnJhbWVIZWFkZXIsIHRoaXMuY29uZmlnKTtcbiAgICBmcmFtZS5vcGNvZGUgPSAweDAxOyAvLyBXZWJTb2NrZXRPcGNvZGUuVEVYVF9GUkFNRVxuICAgIGZyYW1lLmJpbmFyeVBheWxvYWQgPSBkYXRhO1xuICAgIHRoaXMuZnJhZ21lbnRBbmRTZW5kKGZyYW1lLCBjYik7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kQnl0ZXMgPSBmdW5jdGlvbihkYXRhLCBjYikge1xuICAgIHRoaXMuX2RlYnVnKCdzZW5kQnl0ZXMnKTtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSBOb2RlIEJ1ZmZlciBvYmplY3QgdG8gV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZEJ5dGVzKCknKTtcbiAgICB9XG4gICAgdmFyIGZyYW1lID0gbmV3IFdlYlNvY2tldEZyYW1lKHRoaXMubWFza0J5dGVzLCB0aGlzLmZyYW1lSGVhZGVyLCB0aGlzLmNvbmZpZyk7XG4gICAgZnJhbWUub3Bjb2RlID0gMHgwMjsgLy8gV2ViU29ja2V0T3Bjb2RlLkJJTkFSWV9GUkFNRVxuICAgIGZyYW1lLmJpbmFyeVBheWxvYWQgPSBkYXRhO1xuICAgIHRoaXMuZnJhZ21lbnRBbmRTZW5kKGZyYW1lLCBjYik7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHRoaXMuX2RlYnVnKCdwaW5nJyk7XG4gICAgdmFyIGZyYW1lID0gbmV3IFdlYlNvY2tldEZyYW1lKHRoaXMubWFza0J5dGVzLCB0aGlzLmZyYW1lSGVhZGVyLCB0aGlzLmNvbmZpZyk7XG4gICAgZnJhbWUub3Bjb2RlID0gMHgwOTsgLy8gV2ViU29ja2V0T3Bjb2RlLlBJTkdcbiAgICBmcmFtZS5maW4gPSB0cnVlO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgICBkYXRhID0gYnVmZmVyRnJvbVN0cmluZyhkYXRhLnRvU3RyaW5nKCksICd1dGY4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMTI1KSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnV2ViU29ja2V0OiBEYXRhIGZvciBwaW5nIGlzIGxvbmdlciB0aGFuIDEyNSBieXRlcy4gIFRydW5jYXRpbmcuJyk7XG4gICAgICAgICAgICBkYXRhID0gZGF0YS5zbGljZSgwLDEyNCk7XG4gICAgICAgIH1cbiAgICAgICAgZnJhbWUuYmluYXJ5UGF5bG9hZCA9IGRhdGE7XG4gICAgfVxuICAgIHRoaXMuc2VuZEZyYW1lKGZyYW1lKTtcbn07XG5cbi8vIFBvbmcgZnJhbWVzIGhhdmUgdG8gZWNobyBiYWNrIHRoZSBjb250ZW50cyBvZiB0aGUgZGF0YSBwb3J0aW9uIG9mIHRoZVxuLy8gcGluZyBmcmFtZSBleGFjdGx5LCBieXRlIGZvciBieXRlLlxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUucG9uZyA9IGZ1bmN0aW9uKGJpbmFyeVBheWxvYWQpIHtcbiAgICB0aGlzLl9kZWJ1ZygncG9uZycpO1xuICAgIHZhciBmcmFtZSA9IG5ldyBXZWJTb2NrZXRGcmFtZSh0aGlzLm1hc2tCeXRlcywgdGhpcy5mcmFtZUhlYWRlciwgdGhpcy5jb25maWcpO1xuICAgIGZyYW1lLm9wY29kZSA9IDB4MEE7IC8vIFdlYlNvY2tldE9wY29kZS5QT05HXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiaW5hcnlQYXlsb2FkKSAmJiBiaW5hcnlQYXlsb2FkLmxlbmd0aCA+IDEyNSkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnV2ViU29ja2V0OiBEYXRhIGZvciBwb25nIGlzIGxvbmdlciB0aGFuIDEyNSBieXRlcy4gIFRydW5jYXRpbmcuJyk7XG4gICAgICAgIGJpbmFyeVBheWxvYWQgPSBiaW5hcnlQYXlsb2FkLnNsaWNlKDAsMTI0KTtcbiAgICB9XG4gICAgZnJhbWUuYmluYXJ5UGF5bG9hZCA9IGJpbmFyeVBheWxvYWQ7XG4gICAgZnJhbWUuZmluID0gdHJ1ZTtcbiAgICB0aGlzLnNlbmRGcmFtZShmcmFtZSk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5mcmFnbWVudEFuZFNlbmQgPSBmdW5jdGlvbihmcmFtZSwgY2IpIHtcbiAgICB0aGlzLl9kZWJ1ZygnZnJhZ21lbnRBbmRTZW5kJyk7XG4gICAgaWYgKGZyYW1lLm9wY29kZSA+IDB4MDcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IGZyYWdtZW50IGNvbnRyb2wgZnJhbWVzLicpO1xuICAgIH1cblxuICAgIHZhciB0aHJlc2hvbGQgPSB0aGlzLmNvbmZpZy5mcmFnbWVudGF0aW9uVGhyZXNob2xkO1xuICAgIHZhciBsZW5ndGggPSBmcmFtZS5iaW5hcnlQYXlsb2FkLmxlbmd0aDtcblxuICAgIC8vIFNlbmQgaW1tZWRpYXRlbHkgaWYgZnJhZ21lbnRhdGlvbiBpcyBkaXNhYmxlZCBvciB0aGUgbWVzc2FnZSBpcyBub3RcbiAgICAvLyBsYXJnZXIgdGhhbiB0aGUgZnJhZ21lbnRhdGlvbiB0aHJlc2hvbGQuXG4gICAgaWYgKCF0aGlzLmNvbmZpZy5mcmFnbWVudE91dGdvaW5nTWVzc2FnZXMgfHwgKGZyYW1lLmJpbmFyeVBheWxvYWQgJiYgbGVuZ3RoIDw9IHRocmVzaG9sZCkpIHtcbiAgICAgICAgZnJhbWUuZmluID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZW5kRnJhbWUoZnJhbWUsIGNiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB2YXIgbnVtRnJhZ21lbnRzID0gTWF0aC5jZWlsKGxlbmd0aCAvIHRocmVzaG9sZCk7XG4gICAgdmFyIHNlbnRGcmFnbWVudHMgPSAwO1xuICAgIHZhciBzZW50Q2FsbGJhY2sgPSBmdW5jdGlvbiBmcmFnbWVudFNlbnRDYWxsYmFjayhlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIHBhc3Mgb25seSB0aGUgZmlyc3QgZXJyb3JcbiAgICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgICAgIGNiID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICArK3NlbnRGcmFnbWVudHM7XG4gICAgICAgIGlmICgoc2VudEZyYWdtZW50cyA9PT0gbnVtRnJhZ21lbnRzKSAmJiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yICh2YXIgaT0xOyBpIDw9IG51bUZyYWdtZW50czsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyZW50RnJhbWUgPSBuZXcgV2ViU29ja2V0RnJhbWUodGhpcy5tYXNrQnl0ZXMsIHRoaXMuZnJhbWVIZWFkZXIsIHRoaXMuY29uZmlnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIGNvbnRpbnVhdGlvbiBvcGNvZGUgZXhjZXB0IGZvciBmaXJzdCBmcmFtZS5cbiAgICAgICAgY3VycmVudEZyYW1lLm9wY29kZSA9IChpID09PSAxKSA/IGZyYW1lLm9wY29kZSA6IDB4MDA7XG4gICAgICAgIFxuICAgICAgICAvLyBmaW4gc2V0IG9uIGxhc3QgZnJhbWUgb25seVxuICAgICAgICBjdXJyZW50RnJhbWUuZmluID0gKGkgPT09IG51bUZyYWdtZW50cyk7XG4gICAgICAgIFxuICAgICAgICAvLyBsZW5ndGggaXMgbGlrZWx5IHRvIGJlIHNob3J0ZXIgb24gdGhlIGxhc3QgZnJhZ21lbnRcbiAgICAgICAgdmFyIGN1cnJlbnRMZW5ndGggPSAoaSA9PT0gbnVtRnJhZ21lbnRzKSA/IGxlbmd0aCAtICh0aHJlc2hvbGQgKiAoaS0xKSkgOiB0aHJlc2hvbGQ7XG4gICAgICAgIHZhciBzbGljZVN0YXJ0ID0gdGhyZXNob2xkICogKGktMSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTbGljZSB0aGUgcmlnaHQgcG9ydGlvbiBvZiB0aGUgb3JpZ2luYWwgcGF5bG9hZFxuICAgICAgICBjdXJyZW50RnJhbWUuYmluYXJ5UGF5bG9hZCA9IGZyYW1lLmJpbmFyeVBheWxvYWQuc2xpY2Uoc2xpY2VTdGFydCwgc2xpY2VTdGFydCArIGN1cnJlbnRMZW5ndGgpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5zZW5kRnJhbWUoY3VycmVudEZyYW1lLCBzZW50Q2FsbGJhY2spO1xuICAgIH1cbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRDbG9zZUZyYW1lID0gZnVuY3Rpb24ocmVhc29uQ29kZSwgZGVzY3JpcHRpb24sIGNiKSB7XG4gICAgaWYgKHR5cGVvZihyZWFzb25Db2RlKSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmVhc29uQ29kZSA9IFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX05PUk1BTDtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5fZGVidWcoJ3NlbmRDbG9zZUZyYW1lIHN0YXRlOiAlcywgcmVhc29uQ29kZTogJWQsIGRlc2NyaXB0aW9uOiAlcycsIHRoaXMuc3RhdGUsIHJlYXNvbkNvZGUsIGRlc2NyaXB0aW9uKTtcbiAgICBcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfT1BFTiAmJiB0aGlzLnN0YXRlICE9PSBTVEFURV9QRUVSX1JFUVVFU1RFRF9DTE9TRSkgeyByZXR1cm47IH1cbiAgICBcbiAgICB2YXIgZnJhbWUgPSBuZXcgV2ViU29ja2V0RnJhbWUodGhpcy5tYXNrQnl0ZXMsIHRoaXMuZnJhbWVIZWFkZXIsIHRoaXMuY29uZmlnKTtcbiAgICBmcmFtZS5maW4gPSB0cnVlO1xuICAgIGZyYW1lLm9wY29kZSA9IDB4MDg7IC8vIFdlYlNvY2tldE9wY29kZS5DT05ORUNUSU9OX0NMT1NFXG4gICAgZnJhbWUuY2xvc2VTdGF0dXMgPSByZWFzb25Db2RlO1xuICAgIGlmICh0eXBlb2YoZGVzY3JpcHRpb24pID09PSAnc3RyaW5nJykge1xuICAgICAgICBmcmFtZS5iaW5hcnlQYXlsb2FkID0gYnVmZmVyRnJvbVN0cmluZyhkZXNjcmlwdGlvbiwgJ3V0ZjgnKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5zZW5kRnJhbWUoZnJhbWUsIGNiKTtcbiAgICB0aGlzLnNvY2tldC5lbmQoKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRGcmFtZSA9IGZ1bmN0aW9uKGZyYW1lLCBjYikge1xuICAgIHRoaXMuX2RlYnVnKCdzZW5kRnJhbWUnKTtcbiAgICBmcmFtZS5tYXNrID0gdGhpcy5tYXNrT3V0Z29pbmdQYWNrZXRzO1xuICAgIHZhciBmbHVzaGVkID0gdGhpcy5zb2NrZXQud3JpdGUoZnJhbWUudG9CdWZmZXIoKSwgY2IpO1xuICAgIHRoaXMub3V0cHV0QnVmZmVyRnVsbCA9ICFmbHVzaGVkO1xuICAgIHJldHVybiBmbHVzaGVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRDb25uZWN0aW9uO1xuXG5cblxuZnVuY3Rpb24gaW5zdHJ1bWVudFNvY2tldEZvckRlYnVnZ2luZyhjb25uZWN0aW9uLCBzb2NrZXQpIHtcbiAgICAvKiBqc2hpbnQgbG9vcGZ1bmM6IHRydWUgKi9cbiAgICBpZiAoIWNvbm5lY3Rpb24uX2RlYnVnLmVuYWJsZWQpIHsgcmV0dXJuOyB9XG4gICAgXG4gICAgdmFyIG9yaWdpbmFsU29ja2V0RW1pdCA9IHNvY2tldC5lbWl0O1xuICAgIHNvY2tldC5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgY29ubmVjdGlvbi5fZGVidWcoJ3x8fCBTb2NrZXQgRXZlbnQgIFxcJyVzXFwnJywgZXZlbnQpO1xuICAgICAgICBvcmlnaW5hbFNvY2tldEVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIFxuICAgIGZvciAodmFyIGtleSBpbiBzb2NrZXQpIHtcbiAgICAgICAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZihzb2NrZXRba2V5XSkpIHsgY29udGludWU7IH1cbiAgICAgICAgaWYgKFsnZW1pdCddLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHsgY29udGludWU7IH1cbiAgICAgICAgKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gc29ja2V0W2tleV07XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnb24nKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0W2tleV0gPSBmdW5jdGlvbiBwcm94eU1ldGhvZF9fRXZlbnRFbWl0dGVyX19PbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5fZGVidWcoJ3x8fCBTb2NrZXQgbWV0aG9kIGNhbGxlZDogICVzICglcyknLCBrZXksIGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc29ja2V0W2tleV0gPSBmdW5jdGlvbiBwcm94eU1ldGhvZCgpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLl9kZWJ1ZygnfHx8IFNvY2tldCBtZXRob2QgY2FsbGVkOiAgJXMnLCBrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoa2V5KTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsidXRpbCIsInJlcXVpcmUiLCJ1dGlscyIsIkV2ZW50RW1pdHRlciIsIldlYlNvY2tldEZyYW1lIiwiQnVmZmVyTGlzdCIsImlzVmFsaWRVVEY4IiwiYnVmZmVyQWxsb2NVbnNhZmUiLCJidWZmZXJGcm9tU3RyaW5nIiwiU1RBVEVfT1BFTiIsIlNUQVRFX1BFRVJfUkVRVUVTVEVEX0NMT1NFIiwiU1RBVEVfRU5ESU5HIiwiU1RBVEVfQ0xPU0VEIiwic2V0SW1tZWRpYXRlSW1wbCIsImdsb2JhbCIsInNldEltbWVkaWF0ZSIsImJpbmQiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJpZENvdW50ZXIiLCJXZWJTb2NrZXRDb25uZWN0aW9uIiwic29ja2V0IiwiZXh0ZW5zaW9ucyIsInByb3RvY29sIiwibWFza091dGdvaW5nUGFja2V0cyIsImNvbmZpZyIsIl9kZWJ1ZyIsIkJ1ZmZlcmluZ0xvZ2dlciIsImVuYWJsZWQiLCJpbnN0cnVtZW50U29ja2V0Rm9yRGVidWdnaW5nIiwiY2FsbCIsIl9waW5nTGlzdGVuZXJDb3VudCIsIm9uIiwiZXYiLCJyZW1vdGVBZGRyZXNzIiwiY2xvc2VSZWFzb25Db2RlIiwiY2xvc2VEZXNjcmlwdGlvbiIsImNsb3NlRXZlbnRFbWl0dGVkIiwibWFza0J5dGVzIiwiZnJhbWVIZWFkZXIiLCJidWZmZXJMaXN0IiwiY3VycmVudEZyYW1lIiwiZnJhZ21lbnRhdGlvblNpemUiLCJmcmFtZVF1ZXVlIiwiY29ubmVjdGVkIiwic3RhdGUiLCJ3YWl0aW5nRm9yQ2xvc2VSZXNwb25zZSIsInJlY2VpdmVkRW5kIiwiY2xvc2VUaW1lb3V0IiwiYXNzZW1ibGVGcmFnbWVudHMiLCJtYXhSZWNlaXZlZE1lc3NhZ2VTaXplIiwib3V0cHV0QnVmZmVyRnVsbCIsImlucHV0UGF1c2VkIiwicmVjZWl2ZWREYXRhSGFuZGxlciIsInByb2Nlc3NSZWNlaXZlZERhdGEiLCJfY2xvc2VUaW1lckhhbmRsZXIiLCJoYW5kbGVDbG9zZVRpbWVyIiwic2V0Tm9EZWxheSIsImRpc2FibGVOYWdsZUFsZ29yaXRobSIsInNldFRpbWVvdXQiLCJrZWVwYWxpdmUiLCJ1c2VOYXRpdmVLZWVwYWxpdmUiLCJrZWVwYWxpdmVJbnRlcnZhbCIsIkVycm9yIiwiX2tlZXBhbGl2ZVRpbWVySGFuZGxlciIsImhhbmRsZUtlZXBhbGl2ZVRpbWVyIiwic2V0S2VlcGFsaXZlVGltZXIiLCJkcm9wQ29ubmVjdGlvbk9uS2VlcGFsaXZlVGltZW91dCIsImtlZXBhbGl2ZUdyYWNlUGVyaW9kIiwiX2dyYWNlUGVyaW9kVGltZXJIYW5kbGVyIiwiaGFuZGxlR3JhY2VQZXJpb2RUaW1lciIsInNldEtlZXBBbGl2ZSIsInJlbW92ZUFsbExpc3RlbmVycyIsIkNMT1NFX1JFQVNPTl9OT1JNQUwiLCJDTE9TRV9SRUFTT05fR09JTkdfQVdBWSIsIkNMT1NFX1JFQVNPTl9QUk9UT0NPTF9FUlJPUiIsIkNMT1NFX1JFQVNPTl9VTlBST0NFU1NBQkxFX0lOUFVUIiwiQ0xPU0VfUkVBU09OX1JFU0VSVkVEIiwiQ0xPU0VfUkVBU09OX05PVF9QUk9WSURFRCIsIkNMT1NFX1JFQVNPTl9BQk5PUk1BTCIsIkNMT1NFX1JFQVNPTl9JTlZBTElEX0RBVEEiLCJDTE9TRV9SRUFTT05fUE9MSUNZX1ZJT0xBVElPTiIsIkNMT1NFX1JFQVNPTl9NRVNTQUdFX1RPT19CSUciLCJDTE9TRV9SRUFTT05fRVhURU5TSU9OX1JFUVVJUkVEIiwiQ0xPU0VfUkVBU09OX0lOVEVSTkFMX1NFUlZFUl9FUlJPUiIsIkNMT1NFX1JFQVNPTl9UTFNfSEFORFNIQUtFX0ZBSUxFRCIsIkNMT1NFX0RFU0NSSVBUSU9OUyIsInZhbGlkYXRlQ2xvc2VSZWFzb24iLCJjb2RlIiwiaW5kZXhPZiIsImluaGVyaXRzIiwicHJvdG90eXBlIiwiX2FkZFNvY2tldEV2ZW50TGlzdGVuZXJzIiwiaGFuZGxlU29ja2V0RXJyb3IiLCJoYW5kbGVTb2NrZXRFbmQiLCJoYW5kbGVTb2NrZXRDbG9zZSIsImhhbmRsZVNvY2tldERyYWluIiwiaGFuZGxlU29ja2V0UGF1c2UiLCJoYW5kbGVTb2NrZXRSZXN1bWUiLCJoYW5kbGVTb2NrZXREYXRhIiwiY2xlYXJLZWVwYWxpdmVUaW1lciIsImNsZWFyR3JhY2VQZXJpb2RUaW1lciIsIl9rZWVwYWxpdmVUaW1lb3V0SUQiLCJjbGVhclRpbWVvdXQiLCJwaW5nIiwic2V0R3JhY2VQZXJpb2RUaW1lciIsIl9ncmFjZVBlcmlvZFRpbWVvdXRJRCIsImRyb3AiLCJkYXRhIiwid3JpdGUiLCJmcmFtZSIsImFkZERhdGEiLCJzZWxmIiwicHJvdG9jb2xFcnJvciIsImRyb3BSZWFzb24iLCJmcmFtZVRvb0xhcmdlIiwicnN2MSIsInJzdjIiLCJyc3YzIiwiZW1pdCIsInByb2Nlc3NGcmFtZSIsImxlbmd0aCIsImVycm9yIiwic3lzY2FsbCIsImV2ZW50RW1pdHRlckxpc3RlbmVyQ291bnQiLCJkZXN0cm95IiwicHJpbnRPdXRwdXQiLCJlbmQiLCJoYWRFcnJvciIsInNvY2tldEhhZEVycm9yIiwiY2xlYXJDbG9zZVRpbWVyIiwicGF1c2UiLCJyZXN1bWUiLCJjbG9zZSIsInJlYXNvbkNvZGUiLCJkZXNjcmlwdGlvbiIsInNldENsb3NlVGltZXIiLCJzZW5kQ2xvc2VGcmFtZSIsInNraXBDbG9zZUZyYW1lIiwiY2xvc2VUaW1lciIsIm9wY29kZSIsInRvU3RyaW5nIiwiZmluIiwidHlwZSIsImJpbmFyeURhdGEiLCJiaW5hcnlQYXlsb2FkIiwicHVzaCIsInV0ZjhEYXRhIiwiYnl0ZXNDb3BpZWQiLCJmb3JFYWNoIiwiY29weSIsImNhbmNlbGxlZCIsImNhbmNlbCIsInBvbmciLCJyZXNwb25kQ2xvc2VSZWFzb25Db2RlIiwiaW52YWxpZENsb3NlRnJhbWVMZW5ndGgiLCJjbG9zZVN0YXR1cyIsInNlbmQiLCJjYiIsIkJ1ZmZlciIsImlzQnVmZmVyIiwic2VuZEJ5dGVzIiwic2VuZFVURiIsImZyYWdtZW50QW5kU2VuZCIsInNsaWNlIiwic2VuZEZyYW1lIiwidGhyZXNob2xkIiwiZnJhZ21lbnRhdGlvblRocmVzaG9sZCIsImZyYWdtZW50T3V0Z29pbmdNZXNzYWdlcyIsIm51bUZyYWdtZW50cyIsIk1hdGgiLCJjZWlsIiwic2VudEZyYWdtZW50cyIsInNlbnRDYWxsYmFjayIsImZyYWdtZW50U2VudENhbGxiYWNrIiwiZXJyIiwiaSIsImN1cnJlbnRMZW5ndGgiLCJzbGljZVN0YXJ0IiwibWFzayIsImZsdXNoZWQiLCJ0b0J1ZmZlciIsIm1vZHVsZSIsImV4cG9ydHMiLCJjb25uZWN0aW9uIiwib3JpZ2luYWxTb2NrZXRFbWl0IiwiZXZlbnQiLCJhcHBseSIsImFyZ3VtZW50cyIsImtleSIsIm9yaWdpbmFsIiwicHJveHlNZXRob2RfX0V2ZW50RW1pdHRlcl9fT24iLCJwcm94eU1ldGhvZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/WebSocketConnection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/WebSocketFrame.js":
/*!******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketFrame.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ var bufferUtil = __webpack_require__(/*! bufferutil */ \"(ssr)/./node_modules/bufferutil/index.js\");\nvar bufferAllocUnsafe = (__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/websocket/lib/utils.js\").bufferAllocUnsafe);\nconst DECODE_HEADER = 1;\nconst WAITING_FOR_16_BIT_LENGTH = 2;\nconst WAITING_FOR_64_BIT_LENGTH = 3;\nconst WAITING_FOR_MASK_KEY = 4;\nconst WAITING_FOR_PAYLOAD = 5;\nconst COMPLETE = 6;\n// WebSocketConnection will pass shared buffer objects for maskBytes and\n// frameHeader into the constructor to avoid tons of small memory allocations\n// for each frame we have to parse.  This is only used for parsing frames\n// we receive off the wire.\nfunction WebSocketFrame(maskBytes, frameHeader, config) {\n    this.maskBytes = maskBytes;\n    this.frameHeader = frameHeader;\n    this.config = config;\n    this.maxReceivedFrameSize = config.maxReceivedFrameSize;\n    this.protocolError = false;\n    this.frameTooLarge = false;\n    this.invalidCloseFrameLength = false;\n    this.parseState = DECODE_HEADER;\n    this.closeStatus = -1;\n}\nWebSocketFrame.prototype.addData = function(bufferList) {\n    if (this.parseState === DECODE_HEADER) {\n        if (bufferList.length >= 2) {\n            bufferList.joinInto(this.frameHeader, 0, 0, 2);\n            bufferList.advance(2);\n            var firstByte = this.frameHeader[0];\n            var secondByte = this.frameHeader[1];\n            this.fin = Boolean(firstByte & 0x80);\n            this.rsv1 = Boolean(firstByte & 0x40);\n            this.rsv2 = Boolean(firstByte & 0x20);\n            this.rsv3 = Boolean(firstByte & 0x10);\n            this.mask = Boolean(secondByte & 0x80);\n            this.opcode = firstByte & 0x0F;\n            this.length = secondByte & 0x7F;\n            // Control frame sanity check\n            if (this.opcode >= 0x08) {\n                if (this.length > 125) {\n                    this.protocolError = true;\n                    this.dropReason = \"Illegal control frame longer than 125 bytes.\";\n                    return true;\n                }\n                if (!this.fin) {\n                    this.protocolError = true;\n                    this.dropReason = \"Control frames must not be fragmented.\";\n                    return true;\n                }\n            }\n            if (this.length === 126) {\n                this.parseState = WAITING_FOR_16_BIT_LENGTH;\n            } else if (this.length === 127) {\n                this.parseState = WAITING_FOR_64_BIT_LENGTH;\n            } else {\n                this.parseState = WAITING_FOR_MASK_KEY;\n            }\n        }\n    }\n    if (this.parseState === WAITING_FOR_16_BIT_LENGTH) {\n        if (bufferList.length >= 2) {\n            bufferList.joinInto(this.frameHeader, 2, 0, 2);\n            bufferList.advance(2);\n            this.length = this.frameHeader.readUInt16BE(2);\n            this.parseState = WAITING_FOR_MASK_KEY;\n        }\n    } else if (this.parseState === WAITING_FOR_64_BIT_LENGTH) {\n        if (bufferList.length >= 8) {\n            bufferList.joinInto(this.frameHeader, 2, 0, 8);\n            bufferList.advance(8);\n            var lengthPair = [\n                this.frameHeader.readUInt32BE(2),\n                this.frameHeader.readUInt32BE(2 + 4)\n            ];\n            if (lengthPair[0] !== 0) {\n                this.protocolError = true;\n                this.dropReason = \"Unsupported 64-bit length frame received\";\n                return true;\n            }\n            this.length = lengthPair[1];\n            this.parseState = WAITING_FOR_MASK_KEY;\n        }\n    }\n    if (this.parseState === WAITING_FOR_MASK_KEY) {\n        if (this.mask) {\n            if (bufferList.length >= 4) {\n                bufferList.joinInto(this.maskBytes, 0, 0, 4);\n                bufferList.advance(4);\n                this.parseState = WAITING_FOR_PAYLOAD;\n            }\n        } else {\n            this.parseState = WAITING_FOR_PAYLOAD;\n        }\n    }\n    if (this.parseState === WAITING_FOR_PAYLOAD) {\n        if (this.length > this.maxReceivedFrameSize) {\n            this.frameTooLarge = true;\n            this.dropReason = \"Frame size of \" + this.length.toString(10) + \" bytes exceeds maximum accepted frame size\";\n            return true;\n        }\n        if (this.length === 0) {\n            this.binaryPayload = bufferAllocUnsafe(0);\n            this.parseState = COMPLETE;\n            return true;\n        }\n        if (bufferList.length >= this.length) {\n            this.binaryPayload = bufferList.take(this.length);\n            bufferList.advance(this.length);\n            if (this.mask) {\n                bufferUtil.unmask(this.binaryPayload, this.maskBytes);\n            // xor(this.binaryPayload, this.maskBytes, 0);\n            }\n            if (this.opcode === 0x08) {\n                if (this.length === 1) {\n                    // Invalid length for a close frame.  Must be zero or at least two.\n                    this.binaryPayload = bufferAllocUnsafe(0);\n                    this.invalidCloseFrameLength = true;\n                }\n                if (this.length >= 2) {\n                    this.closeStatus = this.binaryPayload.readUInt16BE(0);\n                    this.binaryPayload = this.binaryPayload.slice(2);\n                }\n            }\n            this.parseState = COMPLETE;\n            return true;\n        }\n    }\n    return false;\n};\nWebSocketFrame.prototype.throwAwayPayload = function(bufferList) {\n    if (bufferList.length >= this.length) {\n        bufferList.advance(this.length);\n        this.parseState = COMPLETE;\n        return true;\n    }\n    return false;\n};\nWebSocketFrame.prototype.toBuffer = function(nullMask) {\n    var maskKey;\n    var headerLength = 2;\n    var data;\n    var outputPos;\n    var firstByte = 0x00;\n    var secondByte = 0x00;\n    if (this.fin) {\n        firstByte |= 0x80;\n    }\n    if (this.rsv1) {\n        firstByte |= 0x40;\n    }\n    if (this.rsv2) {\n        firstByte |= 0x20;\n    }\n    if (this.rsv3) {\n        firstByte |= 0x10;\n    }\n    if (this.mask) {\n        secondByte |= 0x80;\n    }\n    firstByte |= this.opcode & 0x0F;\n    // the close frame is a special case because the close reason is\n    // prepended to the payload data.\n    if (this.opcode === 0x08) {\n        this.length = 2;\n        if (this.binaryPayload) {\n            this.length += this.binaryPayload.length;\n        }\n        data = bufferAllocUnsafe(this.length);\n        data.writeUInt16BE(this.closeStatus, 0);\n        if (this.length > 2) {\n            this.binaryPayload.copy(data, 2);\n        }\n    } else if (this.binaryPayload) {\n        data = this.binaryPayload;\n        this.length = data.length;\n    } else {\n        this.length = 0;\n    }\n    if (this.length <= 125) {\n        // encode the length directly into the two-byte frame header\n        secondByte |= this.length & 0x7F;\n    } else if (this.length > 125 && this.length <= 0xFFFF) {\n        // Use 16-bit length\n        secondByte |= 126;\n        headerLength += 2;\n    } else if (this.length > 0xFFFF) {\n        // Use 64-bit length\n        secondByte |= 127;\n        headerLength += 8;\n    }\n    var output = bufferAllocUnsafe(this.length + headerLength + (this.mask ? 4 : 0));\n    // write the frame header\n    output[0] = firstByte;\n    output[1] = secondByte;\n    outputPos = 2;\n    if (this.length > 125 && this.length <= 0xFFFF) {\n        // write 16-bit length\n        output.writeUInt16BE(this.length, outputPos);\n        outputPos += 2;\n    } else if (this.length > 0xFFFF) {\n        // write 64-bit length\n        output.writeUInt32BE(0x00000000, outputPos);\n        output.writeUInt32BE(this.length, outputPos + 4);\n        outputPos += 8;\n    }\n    if (this.mask) {\n        maskKey = nullMask ? 0 : Math.random() * 0xFFFFFFFF >>> 0;\n        this.maskBytes.writeUInt32BE(maskKey, 0);\n        // write the mask key\n        this.maskBytes.copy(output, outputPos);\n        outputPos += 4;\n        if (data) {\n            bufferUtil.mask(data, this.maskBytes, output, outputPos, this.length);\n        }\n    } else if (data) {\n        data.copy(output, outputPos);\n    }\n    return output;\n};\nWebSocketFrame.prototype.toString = function() {\n    return \"Opcode: \" + this.opcode + \", fin: \" + this.fin + \", length: \" + this.length + \", hasPayload: \" + Boolean(this.binaryPayload) + \", masked: \" + this.mask;\n};\nmodule.exports = WebSocketFrame;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRGcmFtZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7dUVBY3VFLEdBRXZFLElBQUlBLGFBQWFDLG1CQUFPQSxDQUFDO0FBQ3pCLElBQUlDLG9CQUFvQkQscUdBQW9DO0FBRTVELE1BQU1FLGdCQUFnQjtBQUN0QixNQUFNQyw0QkFBNEI7QUFDbEMsTUFBTUMsNEJBQTRCO0FBQ2xDLE1BQU1DLHVCQUF1QjtBQUM3QixNQUFNQyxzQkFBc0I7QUFDNUIsTUFBTUMsV0FBVztBQUVqQix3RUFBd0U7QUFDeEUsNkVBQTZFO0FBQzdFLHlFQUF5RTtBQUN6RSwyQkFBMkI7QUFDM0IsU0FBU0MsZUFBZUMsU0FBUyxFQUFFQyxXQUFXLEVBQUVDLE1BQU07SUFDbEQsSUFBSSxDQUFDRixTQUFTLEdBQUdBO0lBQ2pCLElBQUksQ0FBQ0MsV0FBVyxHQUFHQTtJQUNuQixJQUFJLENBQUNDLE1BQU0sR0FBR0E7SUFDZCxJQUFJLENBQUNDLG9CQUFvQixHQUFHRCxPQUFPQyxvQkFBb0I7SUFDdkQsSUFBSSxDQUFDQyxhQUFhLEdBQUc7SUFDckIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7SUFDckIsSUFBSSxDQUFDQyx1QkFBdUIsR0FBRztJQUMvQixJQUFJLENBQUNDLFVBQVUsR0FBR2Q7SUFDbEIsSUFBSSxDQUFDZSxXQUFXLEdBQUcsQ0FBQztBQUN4QjtBQUVBVCxlQUFlVSxTQUFTLENBQUNDLE9BQU8sR0FBRyxTQUFTQyxVQUFVO0lBQ2xELElBQUksSUFBSSxDQUFDSixVQUFVLEtBQUtkLGVBQWU7UUFDbkMsSUFBSWtCLFdBQVdDLE1BQU0sSUFBSSxHQUFHO1lBQ3hCRCxXQUFXRSxRQUFRLENBQUMsSUFBSSxDQUFDWixXQUFXLEVBQUUsR0FBRyxHQUFHO1lBQzVDVSxXQUFXRyxPQUFPLENBQUM7WUFDbkIsSUFBSUMsWUFBWSxJQUFJLENBQUNkLFdBQVcsQ0FBQyxFQUFFO1lBQ25DLElBQUllLGFBQWEsSUFBSSxDQUFDZixXQUFXLENBQUMsRUFBRTtZQUVwQyxJQUFJLENBQUNnQixHQUFHLEdBQU9DLFFBQVFILFlBQWE7WUFDcEMsSUFBSSxDQUFDSSxJQUFJLEdBQU1ELFFBQVFILFlBQWE7WUFDcEMsSUFBSSxDQUFDSyxJQUFJLEdBQU1GLFFBQVFILFlBQWE7WUFDcEMsSUFBSSxDQUFDTSxJQUFJLEdBQU1ILFFBQVFILFlBQWE7WUFDcEMsSUFBSSxDQUFDTyxJQUFJLEdBQU1KLFFBQVFGLGFBQWE7WUFFcEMsSUFBSSxDQUFDTyxNQUFNLEdBQUlSLFlBQWE7WUFDNUIsSUFBSSxDQUFDSCxNQUFNLEdBQUdJLGFBQWE7WUFFM0IsNkJBQTZCO1lBQzdCLElBQUksSUFBSSxDQUFDTyxNQUFNLElBQUksTUFBTTtnQkFDckIsSUFBSSxJQUFJLENBQUNYLE1BQU0sR0FBRyxLQUFLO29CQUNuQixJQUFJLENBQUNSLGFBQWEsR0FBRztvQkFDckIsSUFBSSxDQUFDb0IsVUFBVSxHQUFHO29CQUNsQixPQUFPO2dCQUNYO2dCQUNBLElBQUksQ0FBQyxJQUFJLENBQUNQLEdBQUcsRUFBRTtvQkFDWCxJQUFJLENBQUNiLGFBQWEsR0FBRztvQkFDckIsSUFBSSxDQUFDb0IsVUFBVSxHQUFHO29CQUNsQixPQUFPO2dCQUNYO1lBQ0o7WUFFQSxJQUFJLElBQUksQ0FBQ1osTUFBTSxLQUFLLEtBQUs7Z0JBQ3JCLElBQUksQ0FBQ0wsVUFBVSxHQUFHYjtZQUN0QixPQUNLLElBQUksSUFBSSxDQUFDa0IsTUFBTSxLQUFLLEtBQUs7Z0JBQzFCLElBQUksQ0FBQ0wsVUFBVSxHQUFHWjtZQUN0QixPQUNLO2dCQUNELElBQUksQ0FBQ1ksVUFBVSxHQUFHWDtZQUN0QjtRQUNKO0lBQ0o7SUFDQSxJQUFJLElBQUksQ0FBQ1csVUFBVSxLQUFLYiwyQkFBMkI7UUFDL0MsSUFBSWlCLFdBQVdDLE1BQU0sSUFBSSxHQUFHO1lBQ3hCRCxXQUFXRSxRQUFRLENBQUMsSUFBSSxDQUFDWixXQUFXLEVBQUUsR0FBRyxHQUFHO1lBQzVDVSxXQUFXRyxPQUFPLENBQUM7WUFDbkIsSUFBSSxDQUFDRixNQUFNLEdBQUcsSUFBSSxDQUFDWCxXQUFXLENBQUN3QixZQUFZLENBQUM7WUFDNUMsSUFBSSxDQUFDbEIsVUFBVSxHQUFHWDtRQUN0QjtJQUNKLE9BQ0ssSUFBSSxJQUFJLENBQUNXLFVBQVUsS0FBS1osMkJBQTJCO1FBQ3BELElBQUlnQixXQUFXQyxNQUFNLElBQUksR0FBRztZQUN4QkQsV0FBV0UsUUFBUSxDQUFDLElBQUksQ0FBQ1osV0FBVyxFQUFFLEdBQUcsR0FBRztZQUM1Q1UsV0FBV0csT0FBTyxDQUFDO1lBQ25CLElBQUlZLGFBQWE7Z0JBQ2YsSUFBSSxDQUFDekIsV0FBVyxDQUFDMEIsWUFBWSxDQUFDO2dCQUM5QixJQUFJLENBQUMxQixXQUFXLENBQUMwQixZQUFZLENBQUMsSUFBRTthQUNqQztZQUVELElBQUlELFVBQVUsQ0FBQyxFQUFFLEtBQUssR0FBRztnQkFDckIsSUFBSSxDQUFDdEIsYUFBYSxHQUFHO2dCQUNyQixJQUFJLENBQUNvQixVQUFVLEdBQUc7Z0JBQ2xCLE9BQU87WUFDWDtZQUNBLElBQUksQ0FBQ1osTUFBTSxHQUFHYyxVQUFVLENBQUMsRUFBRTtZQUMzQixJQUFJLENBQUNuQixVQUFVLEdBQUdYO1FBQ3RCO0lBQ0o7SUFFQSxJQUFJLElBQUksQ0FBQ1csVUFBVSxLQUFLWCxzQkFBc0I7UUFDMUMsSUFBSSxJQUFJLENBQUMwQixJQUFJLEVBQUU7WUFDWCxJQUFJWCxXQUFXQyxNQUFNLElBQUksR0FBRztnQkFDeEJELFdBQVdFLFFBQVEsQ0FBQyxJQUFJLENBQUNiLFNBQVMsRUFBRSxHQUFHLEdBQUc7Z0JBQzFDVyxXQUFXRyxPQUFPLENBQUM7Z0JBQ25CLElBQUksQ0FBQ1AsVUFBVSxHQUFHVjtZQUN0QjtRQUNKLE9BQ0s7WUFDRCxJQUFJLENBQUNVLFVBQVUsR0FBR1Y7UUFDdEI7SUFDSjtJQUVBLElBQUksSUFBSSxDQUFDVSxVQUFVLEtBQUtWLHFCQUFxQjtRQUN6QyxJQUFJLElBQUksQ0FBQ2UsTUFBTSxHQUFHLElBQUksQ0FBQ1Qsb0JBQW9CLEVBQUU7WUFDekMsSUFBSSxDQUFDRSxhQUFhLEdBQUc7WUFDckIsSUFBSSxDQUFDbUIsVUFBVSxHQUFHLG1CQUFtQixJQUFJLENBQUNaLE1BQU0sQ0FBQ2dCLFFBQVEsQ0FBQyxNQUN4QztZQUNsQixPQUFPO1FBQ1g7UUFFQSxJQUFJLElBQUksQ0FBQ2hCLE1BQU0sS0FBSyxHQUFHO1lBQ25CLElBQUksQ0FBQ2lCLGFBQWEsR0FBR3JDLGtCQUFrQjtZQUN2QyxJQUFJLENBQUNlLFVBQVUsR0FBR1Q7WUFDbEIsT0FBTztRQUNYO1FBQ0EsSUFBSWEsV0FBV0MsTUFBTSxJQUFJLElBQUksQ0FBQ0EsTUFBTSxFQUFFO1lBQ2xDLElBQUksQ0FBQ2lCLGFBQWEsR0FBR2xCLFdBQVdtQixJQUFJLENBQUMsSUFBSSxDQUFDbEIsTUFBTTtZQUNoREQsV0FBV0csT0FBTyxDQUFDLElBQUksQ0FBQ0YsTUFBTTtZQUM5QixJQUFJLElBQUksQ0FBQ1UsSUFBSSxFQUFFO2dCQUNYaEMsV0FBV3lDLE1BQU0sQ0FBQyxJQUFJLENBQUNGLGFBQWEsRUFBRSxJQUFJLENBQUM3QixTQUFTO1lBQ3BELDhDQUE4QztZQUNsRDtZQUVBLElBQUksSUFBSSxDQUFDdUIsTUFBTSxLQUFLLE1BQU07Z0JBQ3RCLElBQUksSUFBSSxDQUFDWCxNQUFNLEtBQUssR0FBRztvQkFDbkIsbUVBQW1FO29CQUNuRSxJQUFJLENBQUNpQixhQUFhLEdBQUdyQyxrQkFBa0I7b0JBQ3ZDLElBQUksQ0FBQ2MsdUJBQXVCLEdBQUc7Z0JBQ25DO2dCQUNBLElBQUksSUFBSSxDQUFDTSxNQUFNLElBQUksR0FBRztvQkFDbEIsSUFBSSxDQUFDSixXQUFXLEdBQUcsSUFBSSxDQUFDcUIsYUFBYSxDQUFDSixZQUFZLENBQUM7b0JBQ25ELElBQUksQ0FBQ0ksYUFBYSxHQUFHLElBQUksQ0FBQ0EsYUFBYSxDQUFDRyxLQUFLLENBQUM7Z0JBQ2xEO1lBQ0o7WUFFQSxJQUFJLENBQUN6QixVQUFVLEdBQUdUO1lBQ2xCLE9BQU87UUFDWDtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBRUFDLGVBQWVVLFNBQVMsQ0FBQ3dCLGdCQUFnQixHQUFHLFNBQVN0QixVQUFVO0lBQzNELElBQUlBLFdBQVdDLE1BQU0sSUFBSSxJQUFJLENBQUNBLE1BQU0sRUFBRTtRQUNsQ0QsV0FBV0csT0FBTyxDQUFDLElBQUksQ0FBQ0YsTUFBTTtRQUM5QixJQUFJLENBQUNMLFVBQVUsR0FBR1Q7UUFDbEIsT0FBTztJQUNYO0lBQ0EsT0FBTztBQUNYO0FBRUFDLGVBQWVVLFNBQVMsQ0FBQ3lCLFFBQVEsR0FBRyxTQUFTQyxRQUFRO0lBQ2pELElBQUlDO0lBQ0osSUFBSUMsZUFBZTtJQUNuQixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSXhCLFlBQVk7SUFDaEIsSUFBSUMsYUFBYTtJQUVqQixJQUFJLElBQUksQ0FBQ0MsR0FBRyxFQUFFO1FBQ1ZGLGFBQWE7SUFDakI7SUFDQSxJQUFJLElBQUksQ0FBQ0ksSUFBSSxFQUFFO1FBQ1hKLGFBQWE7SUFDakI7SUFDQSxJQUFJLElBQUksQ0FBQ0ssSUFBSSxFQUFFO1FBQ1hMLGFBQWE7SUFDakI7SUFDQSxJQUFJLElBQUksQ0FBQ00sSUFBSSxFQUFFO1FBQ1hOLGFBQWE7SUFDakI7SUFDQSxJQUFJLElBQUksQ0FBQ08sSUFBSSxFQUFFO1FBQ1hOLGNBQWM7SUFDbEI7SUFFQUQsYUFBYyxJQUFJLENBQUNRLE1BQU0sR0FBRztJQUU1QixnRUFBZ0U7SUFDaEUsaUNBQWlDO0lBQ2pDLElBQUksSUFBSSxDQUFDQSxNQUFNLEtBQUssTUFBTTtRQUN0QixJQUFJLENBQUNYLE1BQU0sR0FBRztRQUNkLElBQUksSUFBSSxDQUFDaUIsYUFBYSxFQUFFO1lBQ3BCLElBQUksQ0FBQ2pCLE1BQU0sSUFBSSxJQUFJLENBQUNpQixhQUFhLENBQUNqQixNQUFNO1FBQzVDO1FBQ0EwQixPQUFPOUMsa0JBQWtCLElBQUksQ0FBQ29CLE1BQU07UUFDcEMwQixLQUFLRSxhQUFhLENBQUMsSUFBSSxDQUFDaEMsV0FBVyxFQUFFO1FBQ3JDLElBQUksSUFBSSxDQUFDSSxNQUFNLEdBQUcsR0FBRztZQUNqQixJQUFJLENBQUNpQixhQUFhLENBQUNZLElBQUksQ0FBQ0gsTUFBTTtRQUNsQztJQUNKLE9BQ0ssSUFBSSxJQUFJLENBQUNULGFBQWEsRUFBRTtRQUN6QlMsT0FBTyxJQUFJLENBQUNULGFBQWE7UUFDekIsSUFBSSxDQUFDakIsTUFBTSxHQUFHMEIsS0FBSzFCLE1BQU07SUFDN0IsT0FDSztRQUNELElBQUksQ0FBQ0EsTUFBTSxHQUFHO0lBQ2xCO0lBRUEsSUFBSSxJQUFJLENBQUNBLE1BQU0sSUFBSSxLQUFLO1FBQ3BCLDREQUE0RDtRQUM1REksY0FBZSxJQUFJLENBQUNKLE1BQU0sR0FBRztJQUNqQyxPQUNLLElBQUksSUFBSSxDQUFDQSxNQUFNLEdBQUcsT0FBTyxJQUFJLENBQUNBLE1BQU0sSUFBSSxRQUFRO1FBQ2pELG9CQUFvQjtRQUNwQkksY0FBYztRQUNkcUIsZ0JBQWdCO0lBQ3BCLE9BQ0ssSUFBSSxJQUFJLENBQUN6QixNQUFNLEdBQUcsUUFBUTtRQUMzQixvQkFBb0I7UUFDcEJJLGNBQWM7UUFDZHFCLGdCQUFnQjtJQUNwQjtJQUVBLElBQUlLLFNBQVNsRCxrQkFBa0IsSUFBSSxDQUFDb0IsTUFBTSxHQUFHeUIsZUFBZ0IsS0FBSSxDQUFDZixJQUFJLEdBQUcsSUFBSTtJQUU3RSx5QkFBeUI7SUFDekJvQixNQUFNLENBQUMsRUFBRSxHQUFHM0I7SUFDWjJCLE1BQU0sQ0FBQyxFQUFFLEdBQUcxQjtJQUVadUIsWUFBWTtJQUVaLElBQUksSUFBSSxDQUFDM0IsTUFBTSxHQUFHLE9BQU8sSUFBSSxDQUFDQSxNQUFNLElBQUksUUFBUTtRQUM1QyxzQkFBc0I7UUFDdEI4QixPQUFPRixhQUFhLENBQUMsSUFBSSxDQUFDNUIsTUFBTSxFQUFFMkI7UUFDbENBLGFBQWE7SUFDakIsT0FDSyxJQUFJLElBQUksQ0FBQzNCLE1BQU0sR0FBRyxRQUFRO1FBQzNCLHNCQUFzQjtRQUN0QjhCLE9BQU9DLGFBQWEsQ0FBQyxZQUFZSjtRQUNqQ0csT0FBT0MsYUFBYSxDQUFDLElBQUksQ0FBQy9CLE1BQU0sRUFBRTJCLFlBQVk7UUFDOUNBLGFBQWE7SUFDakI7SUFFQSxJQUFJLElBQUksQ0FBQ2pCLElBQUksRUFBRTtRQUNYYyxVQUFVRCxXQUFXLElBQUssS0FBTVUsTUFBTSxLQUFLLGVBQWdCO1FBQzNELElBQUksQ0FBQzdDLFNBQVMsQ0FBQzJDLGFBQWEsQ0FBQ1AsU0FBUztRQUV0QyxxQkFBcUI7UUFDckIsSUFBSSxDQUFDcEMsU0FBUyxDQUFDeUMsSUFBSSxDQUFDQyxRQUFRSDtRQUM1QkEsYUFBYTtRQUViLElBQUlELE1BQU07WUFDUmhELFdBQVdnQyxJQUFJLENBQUNnQixNQUFNLElBQUksQ0FBQ3RDLFNBQVMsRUFBRTBDLFFBQVFILFdBQVcsSUFBSSxDQUFDM0IsTUFBTTtRQUN0RTtJQUNKLE9BQ0ssSUFBSTBCLE1BQU07UUFDWEEsS0FBS0csSUFBSSxDQUFDQyxRQUFRSDtJQUN0QjtJQUVBLE9BQU9HO0FBQ1g7QUFFQTNDLGVBQWVVLFNBQVMsQ0FBQ21CLFFBQVEsR0FBRztJQUNoQyxPQUFPLGFBQWEsSUFBSSxDQUFDTCxNQUFNLEdBQUcsWUFBWSxJQUFJLENBQUNOLEdBQUcsR0FBRyxlQUFlLElBQUksQ0FBQ0wsTUFBTSxHQUFHLG1CQUFtQk0sUUFBUSxJQUFJLENBQUNXLGFBQWEsSUFBSSxlQUFlLElBQUksQ0FBQ1AsSUFBSTtBQUNuSztBQUdBd0IsT0FBT0MsT0FBTyxHQUFHaEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvV2ViU29ja2V0RnJhbWUuanM/YzZmMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQ29weXJpZ2h0IDIwMTAtMjAxNSBCcmlhbiBNY0tlbHZleS5cbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBidWZmZXJVdGlsID0gcmVxdWlyZSgnYnVmZmVydXRpbCcpO1xudmFyIGJ1ZmZlckFsbG9jVW5zYWZlID0gcmVxdWlyZSgnLi91dGlscycpLmJ1ZmZlckFsbG9jVW5zYWZlO1xuXG5jb25zdCBERUNPREVfSEVBREVSID0gMTtcbmNvbnN0IFdBSVRJTkdfRk9SXzE2X0JJVF9MRU5HVEggPSAyO1xuY29uc3QgV0FJVElOR19GT1JfNjRfQklUX0xFTkdUSCA9IDM7XG5jb25zdCBXQUlUSU5HX0ZPUl9NQVNLX0tFWSA9IDQ7XG5jb25zdCBXQUlUSU5HX0ZPUl9QQVlMT0FEID0gNTtcbmNvbnN0IENPTVBMRVRFID0gNjtcblxuLy8gV2ViU29ja2V0Q29ubmVjdGlvbiB3aWxsIHBhc3Mgc2hhcmVkIGJ1ZmZlciBvYmplY3RzIGZvciBtYXNrQnl0ZXMgYW5kXG4vLyBmcmFtZUhlYWRlciBpbnRvIHRoZSBjb25zdHJ1Y3RvciB0byBhdm9pZCB0b25zIG9mIHNtYWxsIG1lbW9yeSBhbGxvY2F0aW9uc1xuLy8gZm9yIGVhY2ggZnJhbWUgd2UgaGF2ZSB0byBwYXJzZS4gIFRoaXMgaXMgb25seSB1c2VkIGZvciBwYXJzaW5nIGZyYW1lc1xuLy8gd2UgcmVjZWl2ZSBvZmYgdGhlIHdpcmUuXG5mdW5jdGlvbiBXZWJTb2NrZXRGcmFtZShtYXNrQnl0ZXMsIGZyYW1lSGVhZGVyLCBjb25maWcpIHtcbiAgICB0aGlzLm1hc2tCeXRlcyA9IG1hc2tCeXRlcztcbiAgICB0aGlzLmZyYW1lSGVhZGVyID0gZnJhbWVIZWFkZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5tYXhSZWNlaXZlZEZyYW1lU2l6ZSA9IGNvbmZpZy5tYXhSZWNlaXZlZEZyYW1lU2l6ZTtcbiAgICB0aGlzLnByb3RvY29sRXJyb3IgPSBmYWxzZTtcbiAgICB0aGlzLmZyYW1lVG9vTGFyZ2UgPSBmYWxzZTtcbiAgICB0aGlzLmludmFsaWRDbG9zZUZyYW1lTGVuZ3RoID0gZmFsc2U7XG4gICAgdGhpcy5wYXJzZVN0YXRlID0gREVDT0RFX0hFQURFUjtcbiAgICB0aGlzLmNsb3NlU3RhdHVzID0gLTE7XG59XG5cbldlYlNvY2tldEZyYW1lLnByb3RvdHlwZS5hZGREYXRhID0gZnVuY3Rpb24oYnVmZmVyTGlzdCkge1xuICAgIGlmICh0aGlzLnBhcnNlU3RhdGUgPT09IERFQ09ERV9IRUFERVIpIHtcbiAgICAgICAgaWYgKGJ1ZmZlckxpc3QubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIGJ1ZmZlckxpc3Quam9pbkludG8odGhpcy5mcmFtZUhlYWRlciwgMCwgMCwgMik7XG4gICAgICAgICAgICBidWZmZXJMaXN0LmFkdmFuY2UoMik7XG4gICAgICAgICAgICB2YXIgZmlyc3RCeXRlID0gdGhpcy5mcmFtZUhlYWRlclswXTtcbiAgICAgICAgICAgIHZhciBzZWNvbmRCeXRlID0gdGhpcy5mcmFtZUhlYWRlclsxXTtcblxuICAgICAgICAgICAgdGhpcy5maW4gICAgID0gQm9vbGVhbihmaXJzdEJ5dGUgICYgMHg4MCk7XG4gICAgICAgICAgICB0aGlzLnJzdjEgICAgPSBCb29sZWFuKGZpcnN0Qnl0ZSAgJiAweDQwKTtcbiAgICAgICAgICAgIHRoaXMucnN2MiAgICA9IEJvb2xlYW4oZmlyc3RCeXRlICAmIDB4MjApO1xuICAgICAgICAgICAgdGhpcy5yc3YzICAgID0gQm9vbGVhbihmaXJzdEJ5dGUgICYgMHgxMCk7XG4gICAgICAgICAgICB0aGlzLm1hc2sgICAgPSBCb29sZWFuKHNlY29uZEJ5dGUgJiAweDgwKTtcblxuICAgICAgICAgICAgdGhpcy5vcGNvZGUgID0gZmlyc3RCeXRlICAmIDB4MEY7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IHNlY29uZEJ5dGUgJiAweDdGO1xuXG4gICAgICAgICAgICAvLyBDb250cm9sIGZyYW1lIHNhbml0eSBjaGVja1xuICAgICAgICAgICAgaWYgKHRoaXMub3Bjb2RlID49IDB4MDgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPiAxMjUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm90b2NvbEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wUmVhc29uID0gJ0lsbGVnYWwgY29udHJvbCBmcmFtZSBsb25nZXIgdGhhbiAxMjUgYnl0ZXMuJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5maW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm90b2NvbEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wUmVhc29uID0gJ0NvbnRyb2wgZnJhbWVzIG11c3Qgbm90IGJlIGZyYWdtZW50ZWQuJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEyNikge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VTdGF0ZSA9IFdBSVRJTkdfRk9SXzE2X0JJVF9MRU5HVEg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxlbmd0aCA9PT0gMTI3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVN0YXRlID0gV0FJVElOR19GT1JfNjRfQklUX0xFTkdUSDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VTdGF0ZSA9IFdBSVRJTkdfRk9SX01BU0tfS0VZO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcnNlU3RhdGUgPT09IFdBSVRJTkdfRk9SXzE2X0JJVF9MRU5HVEgpIHtcbiAgICAgICAgaWYgKGJ1ZmZlckxpc3QubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIGJ1ZmZlckxpc3Quam9pbkludG8odGhpcy5mcmFtZUhlYWRlciwgMiwgMCwgMik7XG4gICAgICAgICAgICBidWZmZXJMaXN0LmFkdmFuY2UoMik7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuZnJhbWVIZWFkZXIucmVhZFVJbnQxNkJFKDIpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZVN0YXRlID0gV0FJVElOR19GT1JfTUFTS19LRVk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5wYXJzZVN0YXRlID09PSBXQUlUSU5HX0ZPUl82NF9CSVRfTEVOR1RIKSB7XG4gICAgICAgIGlmIChidWZmZXJMaXN0Lmxlbmd0aCA+PSA4KSB7XG4gICAgICAgICAgICBidWZmZXJMaXN0LmpvaW5JbnRvKHRoaXMuZnJhbWVIZWFkZXIsIDIsIDAsIDgpO1xuICAgICAgICAgICAgYnVmZmVyTGlzdC5hZHZhbmNlKDgpO1xuICAgICAgICAgICAgdmFyIGxlbmd0aFBhaXIgPSBbXG4gICAgICAgICAgICAgIHRoaXMuZnJhbWVIZWFkZXIucmVhZFVJbnQzMkJFKDIpLFxuICAgICAgICAgICAgICB0aGlzLmZyYW1lSGVhZGVyLnJlYWRVSW50MzJCRSgyKzQpXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBpZiAobGVuZ3RoUGFpclswXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdG9jb2xFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wUmVhc29uID0gJ1Vuc3VwcG9ydGVkIDY0LWJpdCBsZW5ndGggZnJhbWUgcmVjZWl2ZWQnO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGhQYWlyWzFdO1xuICAgICAgICAgICAgdGhpcy5wYXJzZVN0YXRlID0gV0FJVElOR19GT1JfTUFTS19LRVk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXJzZVN0YXRlID09PSBXQUlUSU5HX0ZPUl9NQVNLX0tFWSkge1xuICAgICAgICBpZiAodGhpcy5tYXNrKSB7XG4gICAgICAgICAgICBpZiAoYnVmZmVyTGlzdC5sZW5ndGggPj0gNCkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlckxpc3Quam9pbkludG8odGhpcy5tYXNrQnl0ZXMsIDAsIDAsIDQpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlckxpc3QuYWR2YW5jZSg0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlU3RhdGUgPSBXQUlUSU5HX0ZPUl9QQVlMT0FEO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXJzZVN0YXRlID0gV0FJVElOR19GT1JfUEFZTE9BRDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcnNlU3RhdGUgPT09IFdBSVRJTkdfRk9SX1BBWUxPQUQpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gdGhpcy5tYXhSZWNlaXZlZEZyYW1lU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5mcmFtZVRvb0xhcmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZHJvcFJlYXNvbiA9ICdGcmFtZSBzaXplIG9mICcgKyB0aGlzLmxlbmd0aC50b1N0cmluZygxMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBieXRlcyBleGNlZWRzIG1heGltdW0gYWNjZXB0ZWQgZnJhbWUgc2l6ZSc7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5iaW5hcnlQYXlsb2FkID0gYnVmZmVyQWxsb2NVbnNhZmUoMCk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlU3RhdGUgPSBDT01QTEVURTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZmZXJMaXN0Lmxlbmd0aCA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5iaW5hcnlQYXlsb2FkID0gYnVmZmVyTGlzdC50YWtlKHRoaXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGJ1ZmZlckxpc3QuYWR2YW5jZSh0aGlzLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXNrKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyVXRpbC51bm1hc2sodGhpcy5iaW5hcnlQYXlsb2FkLCB0aGlzLm1hc2tCeXRlcyk7XG4gICAgICAgICAgICAgICAgLy8geG9yKHRoaXMuYmluYXJ5UGF5bG9hZCwgdGhpcy5tYXNrQnl0ZXMsIDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vcGNvZGUgPT09IDB4MDgpIHsgLy8gV2ViU29ja2V0T3Bjb2RlLkNPTk5FQ1RJT05fQ0xPU0VcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBsZW5ndGggZm9yIGEgY2xvc2UgZnJhbWUuICBNdXN0IGJlIHplcm8gb3IgYXQgbGVhc3QgdHdvLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpbmFyeVBheWxvYWQgPSBidWZmZXJBbGxvY1Vuc2FmZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkQ2xvc2VGcmFtZUxlbmd0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VTdGF0dXMgPSB0aGlzLmJpbmFyeVBheWxvYWQucmVhZFVJbnQxNkJFKDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpbmFyeVBheWxvYWQgPSB0aGlzLmJpbmFyeVBheWxvYWQuc2xpY2UoMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnBhcnNlU3RhdGUgPSBDT01QTEVURTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbldlYlNvY2tldEZyYW1lLnByb3RvdHlwZS50aHJvd0F3YXlQYXlsb2FkID0gZnVuY3Rpb24oYnVmZmVyTGlzdCkge1xuICAgIGlmIChidWZmZXJMaXN0Lmxlbmd0aCA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICBidWZmZXJMaXN0LmFkdmFuY2UodGhpcy5sZW5ndGgpO1xuICAgICAgICB0aGlzLnBhcnNlU3RhdGUgPSBDT01QTEVURTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbldlYlNvY2tldEZyYW1lLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKG51bGxNYXNrKSB7XG4gICAgdmFyIG1hc2tLZXk7XG4gICAgdmFyIGhlYWRlckxlbmd0aCA9IDI7XG4gICAgdmFyIGRhdGE7XG4gICAgdmFyIG91dHB1dFBvcztcbiAgICB2YXIgZmlyc3RCeXRlID0gMHgwMDtcbiAgICB2YXIgc2Vjb25kQnl0ZSA9IDB4MDA7XG5cbiAgICBpZiAodGhpcy5maW4pIHtcbiAgICAgICAgZmlyc3RCeXRlIHw9IDB4ODA7XG4gICAgfVxuICAgIGlmICh0aGlzLnJzdjEpIHtcbiAgICAgICAgZmlyc3RCeXRlIHw9IDB4NDA7XG4gICAgfVxuICAgIGlmICh0aGlzLnJzdjIpIHtcbiAgICAgICAgZmlyc3RCeXRlIHw9IDB4MjA7XG4gICAgfVxuICAgIGlmICh0aGlzLnJzdjMpIHtcbiAgICAgICAgZmlyc3RCeXRlIHw9IDB4MTA7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hc2spIHtcbiAgICAgICAgc2Vjb25kQnl0ZSB8PSAweDgwO1xuICAgIH1cblxuICAgIGZpcnN0Qnl0ZSB8PSAodGhpcy5vcGNvZGUgJiAweDBGKTtcblxuICAgIC8vIHRoZSBjbG9zZSBmcmFtZSBpcyBhIHNwZWNpYWwgY2FzZSBiZWNhdXNlIHRoZSBjbG9zZSByZWFzb24gaXNcbiAgICAvLyBwcmVwZW5kZWQgdG8gdGhlIHBheWxvYWQgZGF0YS5cbiAgICBpZiAodGhpcy5vcGNvZGUgPT09IDB4MDgpIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAyO1xuICAgICAgICBpZiAodGhpcy5iaW5hcnlQYXlsb2FkKSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCArPSB0aGlzLmJpbmFyeVBheWxvYWQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSBidWZmZXJBbGxvY1Vuc2FmZSh0aGlzLmxlbmd0aCk7XG4gICAgICAgIGRhdGEud3JpdGVVSW50MTZCRSh0aGlzLmNsb3NlU3RhdHVzLCAwKTtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdGhpcy5iaW5hcnlQYXlsb2FkLmNvcHkoZGF0YSwgMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5iaW5hcnlQYXlsb2FkKSB7XG4gICAgICAgIGRhdGEgPSB0aGlzLmJpbmFyeVBheWxvYWQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IDEyNSkge1xuICAgICAgICAvLyBlbmNvZGUgdGhlIGxlbmd0aCBkaXJlY3RseSBpbnRvIHRoZSB0d28tYnl0ZSBmcmFtZSBoZWFkZXJcbiAgICAgICAgc2Vjb25kQnl0ZSB8PSAodGhpcy5sZW5ndGggJiAweDdGKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5sZW5ndGggPiAxMjUgJiYgdGhpcy5sZW5ndGggPD0gMHhGRkZGKSB7XG4gICAgICAgIC8vIFVzZSAxNi1iaXQgbGVuZ3RoXG4gICAgICAgIHNlY29uZEJ5dGUgfD0gMTI2O1xuICAgICAgICBoZWFkZXJMZW5ndGggKz0gMjtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5sZW5ndGggPiAweEZGRkYpIHtcbiAgICAgICAgLy8gVXNlIDY0LWJpdCBsZW5ndGhcbiAgICAgICAgc2Vjb25kQnl0ZSB8PSAxMjc7XG4gICAgICAgIGhlYWRlckxlbmd0aCArPSA4O1xuICAgIH1cblxuICAgIHZhciBvdXRwdXQgPSBidWZmZXJBbGxvY1Vuc2FmZSh0aGlzLmxlbmd0aCArIGhlYWRlckxlbmd0aCArICh0aGlzLm1hc2sgPyA0IDogMCkpO1xuXG4gICAgLy8gd3JpdGUgdGhlIGZyYW1lIGhlYWRlclxuICAgIG91dHB1dFswXSA9IGZpcnN0Qnl0ZTtcbiAgICBvdXRwdXRbMV0gPSBzZWNvbmRCeXRlO1xuXG4gICAgb3V0cHV0UG9zID0gMjtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IDEyNSAmJiB0aGlzLmxlbmd0aCA8PSAweEZGRkYpIHtcbiAgICAgICAgLy8gd3JpdGUgMTYtYml0IGxlbmd0aFxuICAgICAgICBvdXRwdXQud3JpdGVVSW50MTZCRSh0aGlzLmxlbmd0aCwgb3V0cHV0UG9zKTtcbiAgICAgICAgb3V0cHV0UG9zICs9IDI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gMHhGRkZGKSB7XG4gICAgICAgIC8vIHdyaXRlIDY0LWJpdCBsZW5ndGhcbiAgICAgICAgb3V0cHV0LndyaXRlVUludDMyQkUoMHgwMDAwMDAwMCwgb3V0cHV0UG9zKTtcbiAgICAgICAgb3V0cHV0LndyaXRlVUludDMyQkUodGhpcy5sZW5ndGgsIG91dHB1dFBvcyArIDQpO1xuICAgICAgICBvdXRwdXRQb3MgKz0gODtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXNrKSB7XG4gICAgICAgIG1hc2tLZXkgPSBudWxsTWFzayA/IDAgOiAoKE1hdGgucmFuZG9tKCkgKiAweEZGRkZGRkZGKSA+Pj4gMCk7XG4gICAgICAgIHRoaXMubWFza0J5dGVzLndyaXRlVUludDMyQkUobWFza0tleSwgMCk7XG5cbiAgICAgICAgLy8gd3JpdGUgdGhlIG1hc2sga2V5XG4gICAgICAgIHRoaXMubWFza0J5dGVzLmNvcHkob3V0cHV0LCBvdXRwdXRQb3MpO1xuICAgICAgICBvdXRwdXRQb3MgKz0gNDtcblxuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIGJ1ZmZlclV0aWwubWFzayhkYXRhLCB0aGlzLm1hc2tCeXRlcywgb3V0cHV0LCBvdXRwdXRQb3MsIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhKSB7XG4gICAgICAgIGRhdGEuY29weShvdXRwdXQsIG91dHB1dFBvcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbldlYlNvY2tldEZyYW1lLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnT3Bjb2RlOiAnICsgdGhpcy5vcGNvZGUgKyAnLCBmaW46ICcgKyB0aGlzLmZpbiArICcsIGxlbmd0aDogJyArIHRoaXMubGVuZ3RoICsgJywgaGFzUGF5bG9hZDogJyArIEJvb2xlYW4odGhpcy5iaW5hcnlQYXlsb2FkKSArICcsIG1hc2tlZDogJyArIHRoaXMubWFzaztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRGcmFtZTtcbiJdLCJuYW1lcyI6WyJidWZmZXJVdGlsIiwicmVxdWlyZSIsImJ1ZmZlckFsbG9jVW5zYWZlIiwiREVDT0RFX0hFQURFUiIsIldBSVRJTkdfRk9SXzE2X0JJVF9MRU5HVEgiLCJXQUlUSU5HX0ZPUl82NF9CSVRfTEVOR1RIIiwiV0FJVElOR19GT1JfTUFTS19LRVkiLCJXQUlUSU5HX0ZPUl9QQVlMT0FEIiwiQ09NUExFVEUiLCJXZWJTb2NrZXRGcmFtZSIsIm1hc2tCeXRlcyIsImZyYW1lSGVhZGVyIiwiY29uZmlnIiwibWF4UmVjZWl2ZWRGcmFtZVNpemUiLCJwcm90b2NvbEVycm9yIiwiZnJhbWVUb29MYXJnZSIsImludmFsaWRDbG9zZUZyYW1lTGVuZ3RoIiwicGFyc2VTdGF0ZSIsImNsb3NlU3RhdHVzIiwicHJvdG90eXBlIiwiYWRkRGF0YSIsImJ1ZmZlckxpc3QiLCJsZW5ndGgiLCJqb2luSW50byIsImFkdmFuY2UiLCJmaXJzdEJ5dGUiLCJzZWNvbmRCeXRlIiwiZmluIiwiQm9vbGVhbiIsInJzdjEiLCJyc3YyIiwicnN2MyIsIm1hc2siLCJvcGNvZGUiLCJkcm9wUmVhc29uIiwicmVhZFVJbnQxNkJFIiwibGVuZ3RoUGFpciIsInJlYWRVSW50MzJCRSIsInRvU3RyaW5nIiwiYmluYXJ5UGF5bG9hZCIsInRha2UiLCJ1bm1hc2siLCJzbGljZSIsInRocm93QXdheVBheWxvYWQiLCJ0b0J1ZmZlciIsIm51bGxNYXNrIiwibWFza0tleSIsImhlYWRlckxlbmd0aCIsImRhdGEiLCJvdXRwdXRQb3MiLCJ3cml0ZVVJbnQxNkJFIiwiY29weSIsIm91dHB1dCIsIndyaXRlVUludDMyQkUiLCJNYXRoIiwicmFuZG9tIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/WebSocketFrame.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/WebSocketRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ var crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar url = __webpack_require__(/*! url */ \"url\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar WebSocketConnection = __webpack_require__(/*! ./WebSocketConnection */ \"(ssr)/./node_modules/websocket/lib/WebSocketConnection.js\");\nvar headerValueSplitRegExp = /,\\s*/;\nvar headerParamSplitRegExp = /;\\s*/;\nvar headerSanitizeRegExp = /[\\r\\n]/g;\nvar xForwardedForSeparatorRegExp = /,\\s*/;\nvar separators = [\n    \"(\",\n    \")\",\n    \"<\",\n    \">\",\n    \"@\",\n    \",\",\n    \";\",\n    \":\",\n    \"\\\\\",\n    '\"',\n    \"/\",\n    \"[\",\n    \"]\",\n    \"?\",\n    \"=\",\n    \"{\",\n    \"}\",\n    \" \",\n    String.fromCharCode(9)\n];\nvar controlChars = [\n    String.fromCharCode(127)\n];\nfor(var i = 0; i < 31; i++){\n    /* US-ASCII Control Characters */ controlChars.push(String.fromCharCode(i));\n}\nvar cookieNameValidateRegEx = /([\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2f\\x3a-\\x3f\\x40\\x5b-\\x5e\\x7b\\x7d\\x7f])/;\nvar cookieValueValidateRegEx = /[^\\x21\\x23-\\x2b\\x2d-\\x3a\\x3c-\\x5b\\x5d-\\x7e]/;\nvar cookieValueDQuoteValidateRegEx = /^\"[^\"]*\"$/;\nvar controlCharsAndSemicolonRegEx = /[\\x00-\\x20\\x3b]/g;\nvar cookieSeparatorRegEx = /[;,] */;\nvar httpStatusDescriptions = {\n    100: \"Continue\",\n    101: \"Switching Protocols\",\n    200: \"OK\",\n    201: \"Created\",\n    203: \"Non-Authoritative Information\",\n    204: \"No Content\",\n    205: \"Reset Content\",\n    206: \"Partial Content\",\n    300: \"Multiple Choices\",\n    301: \"Moved Permanently\",\n    302: \"Found\",\n    303: \"See Other\",\n    304: \"Not Modified\",\n    305: \"Use Proxy\",\n    307: \"Temporary Redirect\",\n    400: \"Bad Request\",\n    401: \"Unauthorized\",\n    402: \"Payment Required\",\n    403: \"Forbidden\",\n    404: \"Not Found\",\n    406: \"Not Acceptable\",\n    407: \"Proxy Authorization Required\",\n    408: \"Request Timeout\",\n    409: \"Conflict\",\n    410: \"Gone\",\n    411: \"Length Required\",\n    412: \"Precondition Failed\",\n    413: \"Request Entity Too Long\",\n    414: \"Request-URI Too Long\",\n    415: \"Unsupported Media Type\",\n    416: \"Requested Range Not Satisfiable\",\n    417: \"Expectation Failed\",\n    426: \"Upgrade Required\",\n    500: \"Internal Server Error\",\n    501: \"Not Implemented\",\n    502: \"Bad Gateway\",\n    503: \"Service Unavailable\",\n    504: \"Gateway Timeout\",\n    505: \"HTTP Version Not Supported\"\n};\nfunction WebSocketRequest(socket, httpRequest, serverConfig) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n    this.socket = socket;\n    this.httpRequest = httpRequest;\n    this.resource = httpRequest.url;\n    this.remoteAddress = socket.remoteAddress;\n    this.remoteAddresses = [\n        this.remoteAddress\n    ];\n    this.serverConfig = serverConfig;\n    // Watch for the underlying TCP socket closing before we call accept\n    this._socketIsClosing = false;\n    this._socketCloseHandler = this._handleSocketCloseBeforeAccept.bind(this);\n    this.socket.on(\"end\", this._socketCloseHandler);\n    this.socket.on(\"close\", this._socketCloseHandler);\n    this._resolved = false;\n}\nutil.inherits(WebSocketRequest, EventEmitter);\nWebSocketRequest.prototype.readHandshake = function() {\n    var self = this;\n    var request = this.httpRequest;\n    // Decode URL\n    this.resourceURL = url.parse(this.resource, true);\n    this.host = request.headers[\"host\"];\n    if (!this.host) {\n        throw new Error(\"Client must provide a Host header.\");\n    }\n    this.key = request.headers[\"sec-websocket-key\"];\n    if (!this.key) {\n        throw new Error(\"Client must provide a value for Sec-WebSocket-Key.\");\n    }\n    this.webSocketVersion = parseInt(request.headers[\"sec-websocket-version\"], 10);\n    if (!this.webSocketVersion || isNaN(this.webSocketVersion)) {\n        throw new Error(\"Client must provide a value for Sec-WebSocket-Version.\");\n    }\n    switch(this.webSocketVersion){\n        case 8:\n        case 13:\n            break;\n        default:\n            var e = new Error(\"Unsupported websocket client version: \" + this.webSocketVersion + \"Only versions 8 and 13 are supported.\");\n            e.httpCode = 426;\n            e.headers = {\n                \"Sec-WebSocket-Version\": \"13\"\n            };\n            throw e;\n    }\n    if (this.webSocketVersion === 13) {\n        this.origin = request.headers[\"origin\"];\n    } else if (this.webSocketVersion === 8) {\n        this.origin = request.headers[\"sec-websocket-origin\"];\n    }\n    // Protocol is optional.\n    var protocolString = request.headers[\"sec-websocket-protocol\"];\n    this.protocolFullCaseMap = {};\n    this.requestedProtocols = [];\n    if (protocolString) {\n        var requestedProtocolsFullCase = protocolString.split(headerValueSplitRegExp);\n        requestedProtocolsFullCase.forEach(function(protocol) {\n            var lcProtocol = protocol.toLocaleLowerCase();\n            self.requestedProtocols.push(lcProtocol);\n            self.protocolFullCaseMap[lcProtocol] = protocol;\n        });\n    }\n    if (!this.serverConfig.ignoreXForwardedFor && request.headers[\"x-forwarded-for\"]) {\n        var immediatePeerIP = this.remoteAddress;\n        this.remoteAddresses = request.headers[\"x-forwarded-for\"].split(xForwardedForSeparatorRegExp);\n        this.remoteAddresses.push(immediatePeerIP);\n        this.remoteAddress = this.remoteAddresses[0];\n    }\n    // Extensions are optional.\n    if (this.serverConfig.parseExtensions) {\n        var extensionsString = request.headers[\"sec-websocket-extensions\"];\n        this.requestedExtensions = this.parseExtensions(extensionsString);\n    } else {\n        this.requestedExtensions = [];\n    }\n    // Cookies are optional\n    if (this.serverConfig.parseCookies) {\n        var cookieString = request.headers[\"cookie\"];\n        this.cookies = this.parseCookies(cookieString);\n    } else {\n        this.cookies = [];\n    }\n};\nWebSocketRequest.prototype.parseExtensions = function(extensionsString) {\n    if (!extensionsString || extensionsString.length === 0) {\n        return [];\n    }\n    var extensions = extensionsString.toLocaleLowerCase().split(headerValueSplitRegExp);\n    extensions.forEach(function(extension, index, array) {\n        var params = extension.split(headerParamSplitRegExp);\n        var extensionName = params[0];\n        var extensionParams = params.slice(1);\n        extensionParams.forEach(function(rawParam, index, array) {\n            var arr = rawParam.split(\"=\");\n            var obj = {\n                name: arr[0],\n                value: arr[1]\n            };\n            array.splice(index, 1, obj);\n        });\n        var obj = {\n            name: extensionName,\n            params: extensionParams\n        };\n        array.splice(index, 1, obj);\n    });\n    return extensions;\n};\n// This function adapted from node-cookie\n// https://github.com/shtylman/node-cookie\nWebSocketRequest.prototype.parseCookies = function(str) {\n    // Sanity Check\n    if (!str || typeof str !== \"string\") {\n        return [];\n    }\n    var cookies = [];\n    var pairs = str.split(cookieSeparatorRegEx);\n    pairs.forEach(function(pair) {\n        var eq_idx = pair.indexOf(\"=\");\n        if (eq_idx === -1) {\n            cookies.push({\n                name: pair,\n                value: null\n            });\n            return;\n        }\n        var key = pair.substr(0, eq_idx).trim();\n        var val = pair.substr(++eq_idx, pair.length).trim();\n        // quoted values\n        if ('\"' === val[0]) {\n            val = val.slice(1, -1);\n        }\n        cookies.push({\n            name: key,\n            value: decodeURIComponent(val)\n        });\n    });\n    return cookies;\n};\nWebSocketRequest.prototype.accept = function(acceptedProtocol, allowedOrigin, cookies) {\n    this._verifyResolution();\n    // TODO: Handle extensions\n    var protocolFullCase;\n    if (acceptedProtocol) {\n        protocolFullCase = this.protocolFullCaseMap[acceptedProtocol.toLocaleLowerCase()];\n        if (typeof protocolFullCase === \"undefined\") {\n            protocolFullCase = acceptedProtocol;\n        }\n    } else {\n        protocolFullCase = acceptedProtocol;\n    }\n    this.protocolFullCaseMap = null;\n    // Create key validation hash\n    var sha1 = crypto.createHash(\"sha1\");\n    sha1.update(this.key + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\");\n    var acceptKey = sha1.digest(\"base64\");\n    var response = \"HTTP/1.1 101 Switching Protocols\\r\\n\" + \"Upgrade: websocket\\r\\n\" + \"Connection: Upgrade\\r\\n\" + \"Sec-WebSocket-Accept: \" + acceptKey + \"\\r\\n\";\n    if (protocolFullCase) {\n        // validate protocol\n        for(var i = 0; i < protocolFullCase.length; i++){\n            var charCode = protocolFullCase.charCodeAt(i);\n            var character = protocolFullCase.charAt(i);\n            if (charCode < 0x21 || charCode > 0x7E || separators.indexOf(character) !== -1) {\n                this.reject(500);\n                throw new Error('Illegal character \"' + String.fromCharCode(character) + '\" in subprotocol.');\n            }\n        }\n        if (this.requestedProtocols.indexOf(acceptedProtocol) === -1) {\n            this.reject(500);\n            throw new Error(\"Specified protocol was not requested by the client.\");\n        }\n        protocolFullCase = protocolFullCase.replace(headerSanitizeRegExp, \"\");\n        response += \"Sec-WebSocket-Protocol: \" + protocolFullCase + \"\\r\\n\";\n    }\n    this.requestedProtocols = null;\n    if (allowedOrigin) {\n        allowedOrigin = allowedOrigin.replace(headerSanitizeRegExp, \"\");\n        if (this.webSocketVersion === 13) {\n            response += \"Origin: \" + allowedOrigin + \"\\r\\n\";\n        } else if (this.webSocketVersion === 8) {\n            response += \"Sec-WebSocket-Origin: \" + allowedOrigin + \"\\r\\n\";\n        }\n    }\n    if (cookies) {\n        if (!Array.isArray(cookies)) {\n            this.reject(500);\n            throw new Error('Value supplied for \"cookies\" argument must be an array.');\n        }\n        var seenCookies = {};\n        cookies.forEach((function(cookie) {\n            if (!cookie.name || !cookie.value) {\n                this.reject(500);\n                throw new Error('Each cookie to set must at least provide a \"name\" and \"value\"');\n            }\n            // Make sure there are no \\r\\n sequences inserted\n            cookie.name = cookie.name.replace(controlCharsAndSemicolonRegEx, \"\");\n            cookie.value = cookie.value.replace(controlCharsAndSemicolonRegEx, \"\");\n            if (seenCookies[cookie.name]) {\n                this.reject(500);\n                throw new Error(\"You may not specify the same cookie name twice.\");\n            }\n            seenCookies[cookie.name] = true;\n            // token (RFC 2616, Section 2.2)\n            var invalidChar = cookie.name.match(cookieNameValidateRegEx);\n            if (invalidChar) {\n                this.reject(500);\n                throw new Error(\"Illegal character \" + invalidChar[0] + \" in cookie name\");\n            }\n            // RFC 6265, Section 4.1.1\n            // *cookie-octet / ( DQUOTE *cookie-octet DQUOTE ) | %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n            if (cookie.value.match(cookieValueDQuoteValidateRegEx)) {\n                invalidChar = cookie.value.slice(1, -1).match(cookieValueValidateRegEx);\n            } else {\n                invalidChar = cookie.value.match(cookieValueValidateRegEx);\n            }\n            if (invalidChar) {\n                this.reject(500);\n                throw new Error(\"Illegal character \" + invalidChar[0] + \" in cookie value\");\n            }\n            var cookieParts = [\n                cookie.name + \"=\" + cookie.value\n            ];\n            // RFC 6265, Section 4.1.1\n            // 'Path=' path-value | <any CHAR except CTLs or ';'>\n            if (cookie.path) {\n                invalidChar = cookie.path.match(controlCharsAndSemicolonRegEx);\n                if (invalidChar) {\n                    this.reject(500);\n                    throw new Error(\"Illegal character \" + invalidChar[0] + \" in cookie path\");\n                }\n                cookieParts.push(\"Path=\" + cookie.path);\n            }\n            // RFC 6265, Section 4.1.2.3\n            // 'Domain=' subdomain\n            if (cookie.domain) {\n                if (typeof cookie.domain !== \"string\") {\n                    this.reject(500);\n                    throw new Error(\"Domain must be specified and must be a string.\");\n                }\n                invalidChar = cookie.domain.match(controlCharsAndSemicolonRegEx);\n                if (invalidChar) {\n                    this.reject(500);\n                    throw new Error(\"Illegal character \" + invalidChar[0] + \" in cookie domain\");\n                }\n                cookieParts.push(\"Domain=\" + cookie.domain.toLowerCase());\n            }\n            // RFC 6265, Section 4.1.1\n            //'Expires=' sane-cookie-date | Force Date object requirement by using only epoch\n            if (cookie.expires) {\n                if (!(cookie.expires instanceof Date)) {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"expires\" must be a vaild date object');\n                }\n                cookieParts.push(\"Expires=\" + cookie.expires.toGMTString());\n            }\n            // RFC 6265, Section 4.1.1\n            //'Max-Age=' non-zero-digit *DIGIT\n            if (cookie.maxage) {\n                var maxage = cookie.maxage;\n                if (typeof maxage === \"string\") {\n                    maxage = parseInt(maxage, 10);\n                }\n                if (isNaN(maxage) || maxage <= 0) {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"maxage\" must be a non-zero number');\n                }\n                maxage = Math.round(maxage);\n                cookieParts.push(\"Max-Age=\" + maxage.toString(10));\n            }\n            // RFC 6265, Section 4.1.1\n            //'Secure;'\n            if (cookie.secure) {\n                if (typeof cookie.secure !== \"boolean\") {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"secure\" must be of type boolean');\n                }\n                cookieParts.push(\"Secure\");\n            }\n            // RFC 6265, Section 4.1.1\n            //'HttpOnly;'\n            if (cookie.httponly) {\n                if (typeof cookie.httponly !== \"boolean\") {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"httponly\" must be of type boolean');\n                }\n                cookieParts.push(\"HttpOnly\");\n            }\n            response += \"Set-Cookie: \" + cookieParts.join(\";\") + \"\\r\\n\";\n        }).bind(this));\n    }\n    // TODO: handle negotiated extensions\n    // if (negotiatedExtensions) {\n    //     response += 'Sec-WebSocket-Extensions: ' + negotiatedExtensions.join(', ') + '\\r\\n';\n    // }\n    // Mark the request resolved now so that the user can't call accept or\n    // reject a second time.\n    this._resolved = true;\n    this.emit(\"requestResolved\", this);\n    response += \"\\r\\n\";\n    var connection = new WebSocketConnection(this.socket, [], acceptedProtocol, false, this.serverConfig);\n    connection.webSocketVersion = this.webSocketVersion;\n    connection.remoteAddress = this.remoteAddress;\n    connection.remoteAddresses = this.remoteAddresses;\n    var self = this;\n    if (this._socketIsClosing) {\n        // Handle case when the client hangs up before we get a chance to\n        // accept the connection and send our side of the opening handshake.\n        cleanupFailedConnection(connection);\n    } else {\n        this.socket.write(response, \"ascii\", function(error) {\n            if (error) {\n                cleanupFailedConnection(connection);\n                return;\n            }\n            self._removeSocketCloseListeners();\n            connection._addSocketEventListeners();\n        });\n    }\n    this.emit(\"requestAccepted\", connection);\n    return connection;\n};\nWebSocketRequest.prototype.reject = function(status, reason, extraHeaders) {\n    this._verifyResolution();\n    // Mark the request resolved now so that the user can't call accept or\n    // reject a second time.\n    this._resolved = true;\n    this.emit(\"requestResolved\", this);\n    if (typeof status !== \"number\") {\n        status = 403;\n    }\n    var response = \"HTTP/1.1 \" + status + \" \" + httpStatusDescriptions[status] + \"\\r\\n\" + \"Connection: close\\r\\n\";\n    if (reason) {\n        reason = reason.replace(headerSanitizeRegExp, \"\");\n        response += \"X-WebSocket-Reject-Reason: \" + reason + \"\\r\\n\";\n    }\n    if (extraHeaders) {\n        for(var key in extraHeaders){\n            var sanitizedValue = extraHeaders[key].toString().replace(headerSanitizeRegExp, \"\");\n            var sanitizedKey = key.replace(headerSanitizeRegExp, \"\");\n            response += sanitizedKey + \": \" + sanitizedValue + \"\\r\\n\";\n        }\n    }\n    response += \"\\r\\n\";\n    this.socket.end(response, \"ascii\");\n    this.emit(\"requestRejected\", this);\n};\nWebSocketRequest.prototype._handleSocketCloseBeforeAccept = function() {\n    this._socketIsClosing = true;\n    this._removeSocketCloseListeners();\n};\nWebSocketRequest.prototype._removeSocketCloseListeners = function() {\n    this.socket.removeListener(\"end\", this._socketCloseHandler);\n    this.socket.removeListener(\"close\", this._socketCloseHandler);\n};\nWebSocketRequest.prototype._verifyResolution = function() {\n    if (this._resolved) {\n        throw new Error(\"WebSocketRequest may only be accepted or rejected one time.\");\n    }\n};\nfunction cleanupFailedConnection(connection) {\n    // Since we have to return a connection object even if the socket is\n    // already dead in order not to break the API, we schedule a 'close'\n    // event on the connection object to occur immediately.\n    process.nextTick(function() {\n        // WebSocketConnection.CLOSE_REASON_ABNORMAL = 1006\n        // Third param: Skip sending the close frame to a dead socket\n        connection.drop(1006, \"TCP connection lost before handshake completed.\", true);\n    });\n}\nmodule.exports = WebSocketRequest;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRSZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozt1RUFjdUUsR0FFdkUsSUFBSUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDckIsSUFBSUMsT0FBT0QsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUUsTUFBTUYsbUJBQU9BLENBQUM7QUFDbEIsSUFBSUcsZUFBZUgsMERBQThCO0FBQ2pELElBQUlJLHNCQUFzQkosbUJBQU9BLENBQUM7QUFFbEMsSUFBSUsseUJBQXlCO0FBQzdCLElBQUlDLHlCQUF5QjtBQUM3QixJQUFJQyx1QkFBdUI7QUFDM0IsSUFBSUMsK0JBQStCO0FBQ25DLElBQUlDLGFBQWE7SUFDYjtJQUFLO0lBQUs7SUFBSztJQUFLO0lBQ3BCO0lBQUs7SUFBSztJQUFLO0lBQU07SUFDckI7SUFBSztJQUFLO0lBQUs7SUFBSztJQUNwQjtJQUFLO0lBQUs7SUFBS0MsT0FBT0MsWUFBWSxDQUFDO0NBQ3RDO0FBQ0QsSUFBSUMsZUFBZTtJQUFDRixPQUFPQyxZQUFZLENBQUM7Q0FBZTtBQUN2RCxJQUFLLElBQUlFLElBQUUsR0FBR0EsSUFBSSxJQUFJQSxJQUFNO0lBQ3hCLCtCQUErQixHQUMvQkQsYUFBYUUsSUFBSSxDQUFDSixPQUFPQyxZQUFZLENBQUNFO0FBQzFDO0FBRUEsSUFBSUUsMEJBQTBCO0FBQzlCLElBQUlDLDJCQUEyQjtBQUMvQixJQUFJQyxpQ0FBaUM7QUFDckMsSUFBSUMsZ0NBQWdDO0FBRXBDLElBQUlDLHVCQUF1QjtBQUUzQixJQUFJQyx5QkFBeUI7SUFDekIsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0FBQ1Q7QUFFQSxTQUFTQyxpQkFBaUJDLE1BQU0sRUFBRUMsV0FBVyxFQUFFQyxZQUFZO0lBQ3ZELHlCQUF5QjtJQUN6QnJCLGFBQWFzQixJQUFJLENBQUMsSUFBSTtJQUV0QixJQUFJLENBQUNILE1BQU0sR0FBR0E7SUFDZCxJQUFJLENBQUNDLFdBQVcsR0FBR0E7SUFDbkIsSUFBSSxDQUFDRyxRQUFRLEdBQUdILFlBQVlyQixHQUFHO0lBQy9CLElBQUksQ0FBQ3lCLGFBQWEsR0FBR0wsT0FBT0ssYUFBYTtJQUN6QyxJQUFJLENBQUNDLGVBQWUsR0FBRztRQUFDLElBQUksQ0FBQ0QsYUFBYTtLQUFDO0lBQzNDLElBQUksQ0FBQ0gsWUFBWSxHQUFHQTtJQUVwQixvRUFBb0U7SUFDcEUsSUFBSSxDQUFDSyxnQkFBZ0IsR0FBRztJQUN4QixJQUFJLENBQUNDLG1CQUFtQixHQUFHLElBQUksQ0FBQ0MsOEJBQThCLENBQUNDLElBQUksQ0FBQyxJQUFJO0lBQ3hFLElBQUksQ0FBQ1YsTUFBTSxDQUFDVyxFQUFFLENBQUMsT0FBTyxJQUFJLENBQUNILG1CQUFtQjtJQUM5QyxJQUFJLENBQUNSLE1BQU0sQ0FBQ1csRUFBRSxDQUFDLFNBQVMsSUFBSSxDQUFDSCxtQkFBbUI7SUFFaEQsSUFBSSxDQUFDSSxTQUFTLEdBQUc7QUFDckI7QUFFQWpDLEtBQUtrQyxRQUFRLENBQUNkLGtCQUFrQmxCO0FBRWhDa0IsaUJBQWlCZSxTQUFTLENBQUNDLGFBQWEsR0FBRztJQUN2QyxJQUFJQyxPQUFPLElBQUk7SUFDZixJQUFJQyxVQUFVLElBQUksQ0FBQ2hCLFdBQVc7SUFFOUIsYUFBYTtJQUNiLElBQUksQ0FBQ2lCLFdBQVcsR0FBR3RDLElBQUl1QyxLQUFLLENBQUMsSUFBSSxDQUFDZixRQUFRLEVBQUU7SUFFNUMsSUFBSSxDQUFDZ0IsSUFBSSxHQUFHSCxRQUFRSSxPQUFPLENBQUMsT0FBTztJQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDRCxJQUFJLEVBQUU7UUFDWixNQUFNLElBQUlFLE1BQU07SUFDcEI7SUFFQSxJQUFJLENBQUNDLEdBQUcsR0FBR04sUUFBUUksT0FBTyxDQUFDLG9CQUFvQjtJQUMvQyxJQUFJLENBQUMsSUFBSSxDQUFDRSxHQUFHLEVBQUU7UUFDWCxNQUFNLElBQUlELE1BQU07SUFDcEI7SUFFQSxJQUFJLENBQUNFLGdCQUFnQixHQUFHQyxTQUFTUixRQUFRSSxPQUFPLENBQUMsd0JBQXdCLEVBQUU7SUFFM0UsSUFBSSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCLElBQUlFLE1BQU0sSUFBSSxDQUFDRixnQkFBZ0IsR0FBRztRQUN4RCxNQUFNLElBQUlGLE1BQU07SUFDcEI7SUFFQSxPQUFRLElBQUksQ0FBQ0UsZ0JBQWdCO1FBQ3pCLEtBQUs7UUFDTCxLQUFLO1lBQ0Q7UUFDSjtZQUNJLElBQUlHLElBQUksSUFBSUwsTUFBTSwyQ0FBMkMsSUFBSSxDQUFDRSxnQkFBZ0IsR0FDaEU7WUFDbEJHLEVBQUVDLFFBQVEsR0FBRztZQUNiRCxFQUFFTixPQUFPLEdBQUc7Z0JBQ1IseUJBQXlCO1lBQzdCO1lBQ0EsTUFBTU07SUFDZDtJQUVBLElBQUksSUFBSSxDQUFDSCxnQkFBZ0IsS0FBSyxJQUFJO1FBQzlCLElBQUksQ0FBQ0ssTUFBTSxHQUFHWixRQUFRSSxPQUFPLENBQUMsU0FBUztJQUMzQyxPQUNLLElBQUksSUFBSSxDQUFDRyxnQkFBZ0IsS0FBSyxHQUFHO1FBQ2xDLElBQUksQ0FBQ0ssTUFBTSxHQUFHWixRQUFRSSxPQUFPLENBQUMsdUJBQXVCO0lBQ3pEO0lBRUEsd0JBQXdCO0lBQ3hCLElBQUlTLGlCQUFpQmIsUUFBUUksT0FBTyxDQUFDLHlCQUF5QjtJQUM5RCxJQUFJLENBQUNVLG1CQUFtQixHQUFHLENBQUM7SUFDNUIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRyxFQUFFO0lBQzVCLElBQUlGLGdCQUFnQjtRQUNoQixJQUFJRyw2QkFBNkJILGVBQWVJLEtBQUssQ0FBQ25EO1FBQ3REa0QsMkJBQTJCRSxPQUFPLENBQUMsU0FBU0MsUUFBUTtZQUNoRCxJQUFJQyxhQUFhRCxTQUFTRSxpQkFBaUI7WUFDM0N0QixLQUFLZ0Isa0JBQWtCLENBQUN4QyxJQUFJLENBQUM2QztZQUM3QnJCLEtBQUtlLG1CQUFtQixDQUFDTSxXQUFXLEdBQUdEO1FBQzNDO0lBQ0o7SUFFQSxJQUFJLENBQUMsSUFBSSxDQUFDbEMsWUFBWSxDQUFDcUMsbUJBQW1CLElBQ3RDdEIsUUFBUUksT0FBTyxDQUFDLGtCQUFrQixFQUFFO1FBQ3BDLElBQUltQixrQkFBa0IsSUFBSSxDQUFDbkMsYUFBYTtRQUN4QyxJQUFJLENBQUNDLGVBQWUsR0FBR1csUUFBUUksT0FBTyxDQUFDLGtCQUFrQixDQUNwRGEsS0FBSyxDQUFDaEQ7UUFDWCxJQUFJLENBQUNvQixlQUFlLENBQUNkLElBQUksQ0FBQ2dEO1FBQzFCLElBQUksQ0FBQ25DLGFBQWEsR0FBRyxJQUFJLENBQUNDLGVBQWUsQ0FBQyxFQUFFO0lBQ2hEO0lBRUEsMkJBQTJCO0lBQzNCLElBQUksSUFBSSxDQUFDSixZQUFZLENBQUN1QyxlQUFlLEVBQUU7UUFDbkMsSUFBSUMsbUJBQW1CekIsUUFBUUksT0FBTyxDQUFDLDJCQUEyQjtRQUNsRSxJQUFJLENBQUNzQixtQkFBbUIsR0FBRyxJQUFJLENBQUNGLGVBQWUsQ0FBQ0M7SUFDcEQsT0FBTztRQUNILElBQUksQ0FBQ0MsbUJBQW1CLEdBQUcsRUFBRTtJQUNqQztJQUVBLHVCQUF1QjtJQUN2QixJQUFJLElBQUksQ0FBQ3pDLFlBQVksQ0FBQzBDLFlBQVksRUFBRTtRQUNoQyxJQUFJQyxlQUFlNUIsUUFBUUksT0FBTyxDQUFDLFNBQVM7UUFDNUMsSUFBSSxDQUFDeUIsT0FBTyxHQUFHLElBQUksQ0FBQ0YsWUFBWSxDQUFDQztJQUNyQyxPQUFPO1FBQ0gsSUFBSSxDQUFDQyxPQUFPLEdBQUcsRUFBRTtJQUNyQjtBQUNKO0FBRUEvQyxpQkFBaUJlLFNBQVMsQ0FBQzJCLGVBQWUsR0FBRyxTQUFTQyxnQkFBZ0I7SUFDbEUsSUFBSSxDQUFDQSxvQkFBb0JBLGlCQUFpQkssTUFBTSxLQUFLLEdBQUc7UUFDcEQsT0FBTyxFQUFFO0lBQ2I7SUFDQSxJQUFJQyxhQUFhTixpQkFBaUJKLGlCQUFpQixHQUFHSixLQUFLLENBQUNuRDtJQUM1RGlFLFdBQVdiLE9BQU8sQ0FBQyxTQUFTYyxTQUFTLEVBQUVDLEtBQUssRUFBRUMsS0FBSztRQUMvQyxJQUFJQyxTQUFTSCxVQUFVZixLQUFLLENBQUNsRDtRQUM3QixJQUFJcUUsZ0JBQWdCRCxNQUFNLENBQUMsRUFBRTtRQUM3QixJQUFJRSxrQkFBa0JGLE9BQU9HLEtBQUssQ0FBQztRQUNuQ0QsZ0JBQWdCbkIsT0FBTyxDQUFDLFNBQVNxQixRQUFRLEVBQUVOLEtBQUssRUFBRUMsS0FBSztZQUNuRCxJQUFJTSxNQUFNRCxTQUFTdEIsS0FBSyxDQUFDO1lBQ3pCLElBQUl3QixNQUFNO2dCQUNOQyxNQUFNRixHQUFHLENBQUMsRUFBRTtnQkFDWkcsT0FBT0gsR0FBRyxDQUFDLEVBQUU7WUFDakI7WUFDQU4sTUFBTVUsTUFBTSxDQUFDWCxPQUFPLEdBQUdRO1FBQzNCO1FBQ0EsSUFBSUEsTUFBTTtZQUNOQyxNQUFNTjtZQUNORCxRQUFRRTtRQUNaO1FBQ0FILE1BQU1VLE1BQU0sQ0FBQ1gsT0FBTyxHQUFHUTtJQUMzQjtJQUNBLE9BQU9WO0FBQ1g7QUFFQSx5Q0FBeUM7QUFDekMsMENBQTBDO0FBQzFDakQsaUJBQWlCZSxTQUFTLENBQUM4QixZQUFZLEdBQUcsU0FBU2tCLEdBQUc7SUFDbEQsZUFBZTtJQUNmLElBQUksQ0FBQ0EsT0FBTyxPQUFPQSxRQUFTLFVBQVU7UUFDbEMsT0FBTyxFQUFFO0lBQ2I7SUFFQSxJQUFJaEIsVUFBVSxFQUFFO0lBQ2hCLElBQUlpQixRQUFRRCxJQUFJNUIsS0FBSyxDQUFDckM7SUFFdEJrRSxNQUFNNUIsT0FBTyxDQUFDLFNBQVM2QixJQUFJO1FBQ3ZCLElBQUlDLFNBQVNELEtBQUtFLE9BQU8sQ0FBQztRQUMxQixJQUFJRCxXQUFXLENBQUMsR0FBRztZQUNmbkIsUUFBUXRELElBQUksQ0FBQztnQkFDVG1FLE1BQU1LO2dCQUNOSixPQUFPO1lBQ1g7WUFDQTtRQUNKO1FBRUEsSUFBSXJDLE1BQU15QyxLQUFLRyxNQUFNLENBQUMsR0FBR0YsUUFBUUcsSUFBSTtRQUNyQyxJQUFJQyxNQUFNTCxLQUFLRyxNQUFNLENBQUMsRUFBRUYsUUFBUUQsS0FBS2pCLE1BQU0sRUFBRXFCLElBQUk7UUFFakQsZ0JBQWdCO1FBQ2hCLElBQUksUUFBUUMsR0FBRyxDQUFDLEVBQUUsRUFBRTtZQUNoQkEsTUFBTUEsSUFBSWQsS0FBSyxDQUFDLEdBQUcsQ0FBQztRQUN4QjtRQUVBVCxRQUFRdEQsSUFBSSxDQUFDO1lBQ1RtRSxNQUFNcEM7WUFDTnFDLE9BQU9VLG1CQUFtQkQ7UUFDOUI7SUFDSjtJQUVBLE9BQU92QjtBQUNYO0FBRUEvQyxpQkFBaUJlLFNBQVMsQ0FBQ3lELE1BQU0sR0FBRyxTQUFTQyxnQkFBZ0IsRUFBRUMsYUFBYSxFQUFFM0IsT0FBTztJQUNqRixJQUFJLENBQUM0QixpQkFBaUI7SUFFdEIsMEJBQTBCO0lBRTFCLElBQUlDO0lBRUosSUFBSUgsa0JBQWtCO1FBQ2xCRyxtQkFBbUIsSUFBSSxDQUFDNUMsbUJBQW1CLENBQUN5QyxpQkFBaUJsQyxpQkFBaUIsR0FBRztRQUNqRixJQUFJLE9BQU9xQyxxQkFBc0IsYUFBYTtZQUMxQ0EsbUJBQW1CSDtRQUN2QjtJQUNKLE9BQ0s7UUFDREcsbUJBQW1CSDtJQUN2QjtJQUNBLElBQUksQ0FBQ3pDLG1CQUFtQixHQUFHO0lBRTNCLDZCQUE2QjtJQUM3QixJQUFJNkMsT0FBT25HLE9BQU9vRyxVQUFVLENBQUM7SUFDN0JELEtBQUtFLE1BQU0sQ0FBQyxJQUFJLENBQUN2RCxHQUFHLEdBQUc7SUFDdkIsSUFBSXdELFlBQVlILEtBQUtJLE1BQU0sQ0FBQztJQUU1QixJQUFJQyxXQUFXLHlDQUNBLDJCQUNBLDRCQUNBLDJCQUEyQkYsWUFBWTtJQUV0RCxJQUFJSixrQkFBa0I7UUFDbEIsb0JBQW9CO1FBQ3BCLElBQUssSUFBSXBGLElBQUUsR0FBR0EsSUFBSW9GLGlCQUFpQjVCLE1BQU0sRUFBRXhELElBQUs7WUFDNUMsSUFBSTJGLFdBQVdQLGlCQUFpQlEsVUFBVSxDQUFDNUY7WUFDM0MsSUFBSTZGLFlBQVlULGlCQUFpQlUsTUFBTSxDQUFDOUY7WUFDeEMsSUFBSTJGLFdBQVcsUUFBUUEsV0FBVyxRQUFRL0YsV0FBVytFLE9BQU8sQ0FBQ2tCLGVBQWUsQ0FBQyxHQUFHO2dCQUM1RSxJQUFJLENBQUNFLE1BQU0sQ0FBQztnQkFDWixNQUFNLElBQUloRSxNQUFNLHdCQUF3QmxDLE9BQU9DLFlBQVksQ0FBQytGLGFBQWE7WUFDN0U7UUFDSjtRQUNBLElBQUksSUFBSSxDQUFDcEQsa0JBQWtCLENBQUNrQyxPQUFPLENBQUNNLHNCQUFzQixDQUFDLEdBQUc7WUFDMUQsSUFBSSxDQUFDYyxNQUFNLENBQUM7WUFDWixNQUFNLElBQUloRSxNQUFNO1FBQ3BCO1FBRUFxRCxtQkFBbUJBLGlCQUFpQlksT0FBTyxDQUFDdEcsc0JBQXNCO1FBQ2xFZ0csWUFBWSw2QkFBNkJOLG1CQUFtQjtJQUNoRTtJQUNBLElBQUksQ0FBQzNDLGtCQUFrQixHQUFHO0lBRTFCLElBQUl5QyxlQUFlO1FBQ2ZBLGdCQUFnQkEsY0FBY2MsT0FBTyxDQUFDdEcsc0JBQXNCO1FBQzVELElBQUksSUFBSSxDQUFDdUMsZ0JBQWdCLEtBQUssSUFBSTtZQUM5QnlELFlBQVksYUFBYVIsZ0JBQWdCO1FBQzdDLE9BQ0ssSUFBSSxJQUFJLENBQUNqRCxnQkFBZ0IsS0FBSyxHQUFHO1lBQ2xDeUQsWUFBWSwyQkFBMkJSLGdCQUFnQjtRQUMzRDtJQUNKO0lBRUEsSUFBSTNCLFNBQVM7UUFDVCxJQUFJLENBQUMwQyxNQUFNQyxPQUFPLENBQUMzQyxVQUFVO1lBQ3pCLElBQUksQ0FBQ3dDLE1BQU0sQ0FBQztZQUNaLE1BQU0sSUFBSWhFLE1BQU07UUFDcEI7UUFDQSxJQUFJb0UsY0FBYyxDQUFDO1FBQ25CNUMsUUFBUVgsT0FBTyxDQUFDLFVBQVN3RCxNQUFNO1lBQzNCLElBQUksQ0FBQ0EsT0FBT2hDLElBQUksSUFBSSxDQUFDZ0MsT0FBTy9CLEtBQUssRUFBRTtnQkFDL0IsSUFBSSxDQUFDMEIsTUFBTSxDQUFDO2dCQUNaLE1BQU0sSUFBSWhFLE1BQU07WUFDcEI7WUFFQSxpREFBaUQ7WUFDakRxRSxPQUFPaEMsSUFBSSxHQUFHZ0MsT0FBT2hDLElBQUksQ0FBQzRCLE9BQU8sQ0FBQzNGLCtCQUErQjtZQUNqRStGLE9BQU8vQixLQUFLLEdBQUcrQixPQUFPL0IsS0FBSyxDQUFDMkIsT0FBTyxDQUFDM0YsK0JBQStCO1lBRW5FLElBQUk4RixXQUFXLENBQUNDLE9BQU9oQyxJQUFJLENBQUMsRUFBRTtnQkFDMUIsSUFBSSxDQUFDMkIsTUFBTSxDQUFDO2dCQUNaLE1BQU0sSUFBSWhFLE1BQU07WUFDcEI7WUFDQW9FLFdBQVcsQ0FBQ0MsT0FBT2hDLElBQUksQ0FBQyxHQUFHO1lBRTNCLGdDQUFnQztZQUNoQyxJQUFJaUMsY0FBY0QsT0FBT2hDLElBQUksQ0FBQ2tDLEtBQUssQ0FBQ3BHO1lBQ3BDLElBQUltRyxhQUFhO2dCQUNiLElBQUksQ0FBQ04sTUFBTSxDQUFDO2dCQUNaLE1BQU0sSUFBSWhFLE1BQU0sdUJBQXVCc0UsV0FBVyxDQUFDLEVBQUUsR0FBRztZQUM1RDtZQUVBLDBCQUEwQjtZQUMxQixpR0FBaUc7WUFDakcsSUFBSUQsT0FBTy9CLEtBQUssQ0FBQ2lDLEtBQUssQ0FBQ2xHLGlDQUFpQztnQkFDcERpRyxjQUFjRCxPQUFPL0IsS0FBSyxDQUFDTCxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUdzQyxLQUFLLENBQUNuRztZQUNsRCxPQUFPO2dCQUNIa0csY0FBY0QsT0FBTy9CLEtBQUssQ0FBQ2lDLEtBQUssQ0FBQ25HO1lBQ3JDO1lBQ0EsSUFBSWtHLGFBQWE7Z0JBQ2IsSUFBSSxDQUFDTixNQUFNLENBQUM7Z0JBQ1osTUFBTSxJQUFJaEUsTUFBTSx1QkFBdUJzRSxXQUFXLENBQUMsRUFBRSxHQUFHO1lBQzVEO1lBRUEsSUFBSUUsY0FBYztnQkFBQ0gsT0FBT2hDLElBQUksR0FBRyxNQUFNZ0MsT0FBTy9CLEtBQUs7YUFBQztZQUVwRCwwQkFBMEI7WUFDMUIscURBQXFEO1lBQ3JELElBQUcrQixPQUFPSSxJQUFJLEVBQUM7Z0JBQ1hILGNBQWNELE9BQU9JLElBQUksQ0FBQ0YsS0FBSyxDQUFDakc7Z0JBQ2hDLElBQUlnRyxhQUFhO29CQUNiLElBQUksQ0FBQ04sTUFBTSxDQUFDO29CQUNaLE1BQU0sSUFBSWhFLE1BQU0sdUJBQXVCc0UsV0FBVyxDQUFDLEVBQUUsR0FBRztnQkFDNUQ7Z0JBQ0FFLFlBQVl0RyxJQUFJLENBQUMsVUFBVW1HLE9BQU9JLElBQUk7WUFDMUM7WUFFQSw0QkFBNEI7WUFDNUIsc0JBQXNCO1lBQ3RCLElBQUlKLE9BQU9LLE1BQU0sRUFBRTtnQkFDZixJQUFJLE9BQU9MLE9BQU9LLE1BQU0sS0FBTSxVQUFVO29CQUNwQyxJQUFJLENBQUNWLE1BQU0sQ0FBQztvQkFDWixNQUFNLElBQUloRSxNQUFNO2dCQUNwQjtnQkFDQXNFLGNBQWNELE9BQU9LLE1BQU0sQ0FBQ0gsS0FBSyxDQUFDakc7Z0JBQ2xDLElBQUlnRyxhQUFhO29CQUNiLElBQUksQ0FBQ04sTUFBTSxDQUFDO29CQUNaLE1BQU0sSUFBSWhFLE1BQU0sdUJBQXVCc0UsV0FBVyxDQUFDLEVBQUUsR0FBRztnQkFDNUQ7Z0JBQ0FFLFlBQVl0RyxJQUFJLENBQUMsWUFBWW1HLE9BQU9LLE1BQU0sQ0FBQ0MsV0FBVztZQUMxRDtZQUVBLDBCQUEwQjtZQUMxQixpRkFBaUY7WUFDakYsSUFBSU4sT0FBT08sT0FBTyxFQUFFO2dCQUNoQixJQUFJLENBQUVQLENBQUFBLE9BQU9PLE9BQU8sWUFBWUMsSUFBRyxHQUFHO29CQUNsQyxJQUFJLENBQUNiLE1BQU0sQ0FBQztvQkFDWixNQUFNLElBQUloRSxNQUFNO2dCQUNwQjtnQkFDQXdFLFlBQVl0RyxJQUFJLENBQUMsYUFBYW1HLE9BQU9PLE9BQU8sQ0FBQ0UsV0FBVztZQUM1RDtZQUVBLDBCQUEwQjtZQUMxQixrQ0FBa0M7WUFDbEMsSUFBSVQsT0FBT1UsTUFBTSxFQUFFO2dCQUNmLElBQUlBLFNBQVNWLE9BQU9VLE1BQU07Z0JBQzFCLElBQUksT0FBT0EsV0FBWSxVQUFVO29CQUM3QkEsU0FBUzVFLFNBQVM0RSxRQUFRO2dCQUM5QjtnQkFDQSxJQUFJM0UsTUFBTTJFLFdBQVdBLFVBQVUsR0FBSTtvQkFDL0IsSUFBSSxDQUFDZixNQUFNLENBQUM7b0JBQ1osTUFBTSxJQUFJaEUsTUFBTTtnQkFDcEI7Z0JBQ0ErRSxTQUFTQyxLQUFLQyxLQUFLLENBQUNGO2dCQUNwQlAsWUFBWXRHLElBQUksQ0FBQyxhQUFhNkcsT0FBT0csUUFBUSxDQUFDO1lBQ2xEO1lBRUEsMEJBQTBCO1lBQzFCLFdBQVc7WUFDWCxJQUFJYixPQUFPYyxNQUFNLEVBQUU7Z0JBQ2YsSUFBSSxPQUFPZCxPQUFPYyxNQUFNLEtBQU0sV0FBVztvQkFDckMsSUFBSSxDQUFDbkIsTUFBTSxDQUFDO29CQUNaLE1BQU0sSUFBSWhFLE1BQU07Z0JBQ3BCO2dCQUNBd0UsWUFBWXRHLElBQUksQ0FBQztZQUNyQjtZQUVBLDBCQUEwQjtZQUMxQixhQUFhO1lBQ2IsSUFBSW1HLE9BQU9lLFFBQVEsRUFBRTtnQkFDakIsSUFBSSxPQUFPZixPQUFPZSxRQUFRLEtBQU0sV0FBVztvQkFDdkMsSUFBSSxDQUFDcEIsTUFBTSxDQUFDO29CQUNaLE1BQU0sSUFBSWhFLE1BQU07Z0JBQ3BCO2dCQUNBd0UsWUFBWXRHLElBQUksQ0FBQztZQUNyQjtZQUVBeUYsWUFBYSxpQkFBaUJhLFlBQVlhLElBQUksQ0FBQyxPQUFPO1FBQzFELEdBQUVqRyxJQUFJLENBQUMsSUFBSTtJQUNmO0lBRUEscUNBQXFDO0lBQ3JDLDhCQUE4QjtJQUM5QiwyRkFBMkY7SUFDM0YsSUFBSTtJQUVKLHNFQUFzRTtJQUN0RSx3QkFBd0I7SUFDeEIsSUFBSSxDQUFDRSxTQUFTLEdBQUc7SUFDakIsSUFBSSxDQUFDZ0csSUFBSSxDQUFDLG1CQUFtQixJQUFJO0lBRWpDM0IsWUFBWTtJQUVaLElBQUk0QixhQUFhLElBQUkvSCxvQkFBb0IsSUFBSSxDQUFDa0IsTUFBTSxFQUFFLEVBQUUsRUFBRXdFLGtCQUFrQixPQUFPLElBQUksQ0FBQ3RFLFlBQVk7SUFDcEcyRyxXQUFXckYsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDQSxnQkFBZ0I7SUFDbkRxRixXQUFXeEcsYUFBYSxHQUFHLElBQUksQ0FBQ0EsYUFBYTtJQUM3Q3dHLFdBQVd2RyxlQUFlLEdBQUcsSUFBSSxDQUFDQSxlQUFlO0lBRWpELElBQUlVLE9BQU8sSUFBSTtJQUVmLElBQUksSUFBSSxDQUFDVCxnQkFBZ0IsRUFBRTtRQUN2QixpRUFBaUU7UUFDakUsb0VBQW9FO1FBQ3BFdUcsd0JBQXdCRDtJQUM1QixPQUNLO1FBQ0QsSUFBSSxDQUFDN0csTUFBTSxDQUFDK0csS0FBSyxDQUFDOUIsVUFBVSxTQUFTLFNBQVMrQixLQUFLO1lBQy9DLElBQUlBLE9BQU87Z0JBQ1BGLHdCQUF3QkQ7Z0JBQ3hCO1lBQ0o7WUFFQTdGLEtBQUtpRywyQkFBMkI7WUFDaENKLFdBQVdLLHdCQUF3QjtRQUN2QztJQUNKO0lBRUEsSUFBSSxDQUFDTixJQUFJLENBQUMsbUJBQW1CQztJQUM3QixPQUFPQTtBQUNYO0FBRUE5RyxpQkFBaUJlLFNBQVMsQ0FBQ3dFLE1BQU0sR0FBRyxTQUFTNkIsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFlBQVk7SUFDckUsSUFBSSxDQUFDM0MsaUJBQWlCO0lBRXRCLHNFQUFzRTtJQUN0RSx3QkFBd0I7SUFDeEIsSUFBSSxDQUFDOUQsU0FBUyxHQUFHO0lBQ2pCLElBQUksQ0FBQ2dHLElBQUksQ0FBQyxtQkFBbUIsSUFBSTtJQUVqQyxJQUFJLE9BQU9PLFdBQVksVUFBVTtRQUM3QkEsU0FBUztJQUNiO0lBQ0EsSUFBSWxDLFdBQVcsY0FBY2tDLFNBQVMsTUFBTXJILHNCQUFzQixDQUFDcUgsT0FBTyxHQUFHLFNBQzlEO0lBQ2YsSUFBSUMsUUFBUTtRQUNSQSxTQUFTQSxPQUFPN0IsT0FBTyxDQUFDdEcsc0JBQXNCO1FBQzlDZ0csWUFBWSxnQ0FBZ0NtQyxTQUFTO0lBQ3pEO0lBRUEsSUFBSUMsY0FBYztRQUNkLElBQUssSUFBSTlGLE9BQU84RixhQUFjO1lBQzFCLElBQUlDLGlCQUFpQkQsWUFBWSxDQUFDOUYsSUFBSSxDQUFDaUYsUUFBUSxHQUFHakIsT0FBTyxDQUFDdEcsc0JBQXNCO1lBQ2hGLElBQUlzSSxlQUFlaEcsSUFBSWdFLE9BQU8sQ0FBQ3RHLHNCQUFzQjtZQUNyRGdHLFlBQWFzQyxlQUFlLE9BQU9ELGlCQUFpQjtRQUN4RDtJQUNKO0lBRUFyQyxZQUFZO0lBQ1osSUFBSSxDQUFDakYsTUFBTSxDQUFDd0gsR0FBRyxDQUFDdkMsVUFBVTtJQUUxQixJQUFJLENBQUMyQixJQUFJLENBQUMsbUJBQW1CLElBQUk7QUFDckM7QUFFQTdHLGlCQUFpQmUsU0FBUyxDQUFDTCw4QkFBOEIsR0FBRztJQUN4RCxJQUFJLENBQUNGLGdCQUFnQixHQUFHO0lBQ3hCLElBQUksQ0FBQzBHLDJCQUEyQjtBQUNwQztBQUVBbEgsaUJBQWlCZSxTQUFTLENBQUNtRywyQkFBMkIsR0FBRztJQUNyRCxJQUFJLENBQUNqSCxNQUFNLENBQUN5SCxjQUFjLENBQUMsT0FBTyxJQUFJLENBQUNqSCxtQkFBbUI7SUFDMUQsSUFBSSxDQUFDUixNQUFNLENBQUN5SCxjQUFjLENBQUMsU0FBUyxJQUFJLENBQUNqSCxtQkFBbUI7QUFDaEU7QUFFQVQsaUJBQWlCZSxTQUFTLENBQUM0RCxpQkFBaUIsR0FBRztJQUMzQyxJQUFJLElBQUksQ0FBQzlELFNBQVMsRUFBRTtRQUNoQixNQUFNLElBQUlVLE1BQU07SUFDcEI7QUFDSjtBQUVBLFNBQVN3Rix3QkFBd0JELFVBQVU7SUFDdkMsb0VBQW9FO0lBQ3BFLG9FQUFvRTtJQUNwRSx1REFBdUQ7SUFDdkRhLFFBQVFDLFFBQVEsQ0FBQztRQUNiLG1EQUFtRDtRQUNuRCw2REFBNkQ7UUFDN0RkLFdBQVdlLElBQUksQ0FBQyxNQUFNLG1EQUFtRDtJQUM3RTtBQUNKO0FBRUFDLE9BQU9DLE9BQU8sR0FBRy9IIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1dlYlNvY2tldFJlcXVlc3QuanM/MmJlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQ29weXJpZ2h0IDIwMTAtMjAxNSBCcmlhbiBNY0tlbHZleS5cbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBXZWJTb2NrZXRDb25uZWN0aW9uID0gcmVxdWlyZSgnLi9XZWJTb2NrZXRDb25uZWN0aW9uJyk7XG5cbnZhciBoZWFkZXJWYWx1ZVNwbGl0UmVnRXhwID0gLyxcXHMqLztcbnZhciBoZWFkZXJQYXJhbVNwbGl0UmVnRXhwID0gLztcXHMqLztcbnZhciBoZWFkZXJTYW5pdGl6ZVJlZ0V4cCA9IC9bXFxyXFxuXS9nO1xudmFyIHhGb3J3YXJkZWRGb3JTZXBhcmF0b3JSZWdFeHAgPSAvLFxccyovO1xudmFyIHNlcGFyYXRvcnMgPSBbXG4gICAgJygnLCAnKScsICc8JywgJz4nLCAnQCcsXG4gICAgJywnLCAnOycsICc6JywgJ1xcXFwnLCAnXFxcIicsXG4gICAgJy8nLCAnWycsICddJywgJz8nLCAnPScsXG4gICAgJ3snLCAnfScsICcgJywgU3RyaW5nLmZyb21DaGFyQ29kZSg5KVxuXTtcbnZhciBjb250cm9sQ2hhcnMgPSBbU3RyaW5nLmZyb21DaGFyQ29kZSgxMjcpIC8qIERFTCAqL107XG5mb3IgKHZhciBpPTA7IGkgPCAzMTsgaSArKykge1xuICAgIC8qIFVTLUFTQ0lJIENvbnRyb2wgQ2hhcmFjdGVycyAqL1xuICAgIGNvbnRyb2xDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaSkpO1xufVxuXG52YXIgY29va2llTmFtZVZhbGlkYXRlUmVnRXggPSAvKFtcXHgwMC1cXHgyMFxceDIyXFx4MjhcXHgyOVxceDJjXFx4MmZcXHgzYS1cXHgzZlxceDQwXFx4NWItXFx4NWVcXHg3YlxceDdkXFx4N2ZdKS87XG52YXIgY29va2llVmFsdWVWYWxpZGF0ZVJlZ0V4ID0gL1teXFx4MjFcXHgyMy1cXHgyYlxceDJkLVxceDNhXFx4M2MtXFx4NWJcXHg1ZC1cXHg3ZV0vO1xudmFyIGNvb2tpZVZhbHVlRFF1b3RlVmFsaWRhdGVSZWdFeCA9IC9eXCJbXlwiXSpcIiQvO1xudmFyIGNvbnRyb2xDaGFyc0FuZFNlbWljb2xvblJlZ0V4ID0gL1tcXHgwMC1cXHgyMFxceDNiXS9nO1xuXG52YXIgY29va2llU2VwYXJhdG9yUmVnRXggPSAvWzssXSAqLztcblxudmFyIGh0dHBTdGF0dXNEZXNjcmlwdGlvbnMgPSB7XG4gICAgMTAwOiAnQ29udGludWUnLFxuICAgIDEwMTogJ1N3aXRjaGluZyBQcm90b2NvbHMnLFxuICAgIDIwMDogJ09LJyxcbiAgICAyMDE6ICdDcmVhdGVkJyxcbiAgICAyMDM6ICdOb24tQXV0aG9yaXRhdGl2ZSBJbmZvcm1hdGlvbicsXG4gICAgMjA0OiAnTm8gQ29udGVudCcsXG4gICAgMjA1OiAnUmVzZXQgQ29udGVudCcsXG4gICAgMjA2OiAnUGFydGlhbCBDb250ZW50JyxcbiAgICAzMDA6ICdNdWx0aXBsZSBDaG9pY2VzJyxcbiAgICAzMDE6ICdNb3ZlZCBQZXJtYW5lbnRseScsXG4gICAgMzAyOiAnRm91bmQnLFxuICAgIDMwMzogJ1NlZSBPdGhlcicsXG4gICAgMzA0OiAnTm90IE1vZGlmaWVkJyxcbiAgICAzMDU6ICdVc2UgUHJveHknLFxuICAgIDMwNzogJ1RlbXBvcmFyeSBSZWRpcmVjdCcsXG4gICAgNDAwOiAnQmFkIFJlcXVlc3QnLFxuICAgIDQwMTogJ1VuYXV0aG9yaXplZCcsXG4gICAgNDAyOiAnUGF5bWVudCBSZXF1aXJlZCcsXG4gICAgNDAzOiAnRm9yYmlkZGVuJyxcbiAgICA0MDQ6ICdOb3QgRm91bmQnLFxuICAgIDQwNjogJ05vdCBBY2NlcHRhYmxlJyxcbiAgICA0MDc6ICdQcm94eSBBdXRob3JpemF0aW9uIFJlcXVpcmVkJyxcbiAgICA0MDg6ICdSZXF1ZXN0IFRpbWVvdXQnLFxuICAgIDQwOTogJ0NvbmZsaWN0JyxcbiAgICA0MTA6ICdHb25lJyxcbiAgICA0MTE6ICdMZW5ndGggUmVxdWlyZWQnLFxuICAgIDQxMjogJ1ByZWNvbmRpdGlvbiBGYWlsZWQnLFxuICAgIDQxMzogJ1JlcXVlc3QgRW50aXR5IFRvbyBMb25nJyxcbiAgICA0MTQ6ICdSZXF1ZXN0LVVSSSBUb28gTG9uZycsXG4gICAgNDE1OiAnVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZScsXG4gICAgNDE2OiAnUmVxdWVzdGVkIFJhbmdlIE5vdCBTYXRpc2ZpYWJsZScsXG4gICAgNDE3OiAnRXhwZWN0YXRpb24gRmFpbGVkJyxcbiAgICA0MjY6ICdVcGdyYWRlIFJlcXVpcmVkJyxcbiAgICA1MDA6ICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3InLFxuICAgIDUwMTogJ05vdCBJbXBsZW1lbnRlZCcsXG4gICAgNTAyOiAnQmFkIEdhdGV3YXknLFxuICAgIDUwMzogJ1NlcnZpY2UgVW5hdmFpbGFibGUnLFxuICAgIDUwNDogJ0dhdGV3YXkgVGltZW91dCcsXG4gICAgNTA1OiAnSFRUUCBWZXJzaW9uIE5vdCBTdXBwb3J0ZWQnXG59O1xuXG5mdW5jdGlvbiBXZWJTb2NrZXRSZXF1ZXN0KHNvY2tldCwgaHR0cFJlcXVlc3QsIHNlcnZlckNvbmZpZykge1xuICAgIC8vIFN1cGVyY2xhc3MgQ29uc3RydWN0b3JcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgIHRoaXMuaHR0cFJlcXVlc3QgPSBodHRwUmVxdWVzdDtcbiAgICB0aGlzLnJlc291cmNlID0gaHR0cFJlcXVlc3QudXJsO1xuICAgIHRoaXMucmVtb3RlQWRkcmVzcyA9IHNvY2tldC5yZW1vdGVBZGRyZXNzO1xuICAgIHRoaXMucmVtb3RlQWRkcmVzc2VzID0gW3RoaXMucmVtb3RlQWRkcmVzc107XG4gICAgdGhpcy5zZXJ2ZXJDb25maWcgPSBzZXJ2ZXJDb25maWc7XG5cbiAgICAvLyBXYXRjaCBmb3IgdGhlIHVuZGVybHlpbmcgVENQIHNvY2tldCBjbG9zaW5nIGJlZm9yZSB3ZSBjYWxsIGFjY2VwdFxuICAgIHRoaXMuX3NvY2tldElzQ2xvc2luZyA9IGZhbHNlO1xuICAgIHRoaXMuX3NvY2tldENsb3NlSGFuZGxlciA9IHRoaXMuX2hhbmRsZVNvY2tldENsb3NlQmVmb3JlQWNjZXB0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5zb2NrZXQub24oJ2VuZCcsIHRoaXMuX3NvY2tldENsb3NlSGFuZGxlcik7XG4gICAgdGhpcy5zb2NrZXQub24oJ2Nsb3NlJywgdGhpcy5fc29ja2V0Q2xvc2VIYW5kbGVyKTtcblxuICAgIHRoaXMuX3Jlc29sdmVkID0gZmFsc2U7XG59XG5cbnV0aWwuaW5oZXJpdHMoV2ViU29ja2V0UmVxdWVzdCwgRXZlbnRFbWl0dGVyKTtcblxuV2ViU29ja2V0UmVxdWVzdC5wcm90b3R5cGUucmVhZEhhbmRzaGFrZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcmVxdWVzdCA9IHRoaXMuaHR0cFJlcXVlc3Q7XG5cbiAgICAvLyBEZWNvZGUgVVJMXG4gICAgdGhpcy5yZXNvdXJjZVVSTCA9IHVybC5wYXJzZSh0aGlzLnJlc291cmNlLCB0cnVlKTtcblxuICAgIHRoaXMuaG9zdCA9IHJlcXVlc3QuaGVhZGVyc1snaG9zdCddO1xuICAgIGlmICghdGhpcy5ob3N0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50IG11c3QgcHJvdmlkZSBhIEhvc3QgaGVhZGVyLicpO1xuICAgIH1cblxuICAgIHRoaXMua2V5ID0gcmVxdWVzdC5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleSddO1xuICAgIGlmICghdGhpcy5rZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQgbXVzdCBwcm92aWRlIGEgdmFsdWUgZm9yIFNlYy1XZWJTb2NrZXQtS2V5LicpO1xuICAgIH1cblxuICAgIHRoaXMud2ViU29ja2V0VmVyc2lvbiA9IHBhcnNlSW50KHJlcXVlc3QuaGVhZGVyc1snc2VjLXdlYnNvY2tldC12ZXJzaW9uJ10sIDEwKTtcblxuICAgIGlmICghdGhpcy53ZWJTb2NrZXRWZXJzaW9uIHx8IGlzTmFOKHRoaXMud2ViU29ja2V0VmVyc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQgbXVzdCBwcm92aWRlIGEgdmFsdWUgZm9yIFNlYy1XZWJTb2NrZXQtVmVyc2lvbi4nKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMud2ViU29ja2V0VmVyc2lvbikge1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciBlID0gbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB3ZWJzb2NrZXQgY2xpZW50IHZlcnNpb246ICcgKyB0aGlzLndlYlNvY2tldFZlcnNpb24gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ09ubHkgdmVyc2lvbnMgOCBhbmQgMTMgYXJlIHN1cHBvcnRlZC4nKTtcbiAgICAgICAgICAgIGUuaHR0cENvZGUgPSA0MjY7XG4gICAgICAgICAgICBlLmhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ1NlYy1XZWJTb2NrZXQtVmVyc2lvbic6ICcxMydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLndlYlNvY2tldFZlcnNpb24gPT09IDEzKSB7XG4gICAgICAgIHRoaXMub3JpZ2luID0gcmVxdWVzdC5oZWFkZXJzWydvcmlnaW4nXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy53ZWJTb2NrZXRWZXJzaW9uID09PSA4KSB7XG4gICAgICAgIHRoaXMub3JpZ2luID0gcmVxdWVzdC5oZWFkZXJzWydzZWMtd2Vic29ja2V0LW9yaWdpbiddO1xuICAgIH1cblxuICAgIC8vIFByb3RvY29sIGlzIG9wdGlvbmFsLlxuICAgIHZhciBwcm90b2NvbFN0cmluZyA9IHJlcXVlc3QuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgIHRoaXMucHJvdG9jb2xGdWxsQ2FzZU1hcCA9IHt9O1xuICAgIHRoaXMucmVxdWVzdGVkUHJvdG9jb2xzID0gW107XG4gICAgaWYgKHByb3RvY29sU3RyaW5nKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ZWRQcm90b2NvbHNGdWxsQ2FzZSA9IHByb3RvY29sU3RyaW5nLnNwbGl0KGhlYWRlclZhbHVlU3BsaXRSZWdFeHApO1xuICAgICAgICByZXF1ZXN0ZWRQcm90b2NvbHNGdWxsQ2FzZS5mb3JFYWNoKGZ1bmN0aW9uKHByb3RvY29sKSB7XG4gICAgICAgICAgICB2YXIgbGNQcm90b2NvbCA9IHByb3RvY29sLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBzZWxmLnJlcXVlc3RlZFByb3RvY29scy5wdXNoKGxjUHJvdG9jb2wpO1xuICAgICAgICAgICAgc2VsZi5wcm90b2NvbEZ1bGxDYXNlTWFwW2xjUHJvdG9jb2xdID0gcHJvdG9jb2w7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zZXJ2ZXJDb25maWcuaWdub3JlWEZvcndhcmRlZEZvciAmJlxuICAgICAgICByZXF1ZXN0LmhlYWRlcnNbJ3gtZm9yd2FyZGVkLWZvciddKSB7XG4gICAgICAgIHZhciBpbW1lZGlhdGVQZWVySVAgPSB0aGlzLnJlbW90ZUFkZHJlc3M7XG4gICAgICAgIHRoaXMucmVtb3RlQWRkcmVzc2VzID0gcmVxdWVzdC5oZWFkZXJzWyd4LWZvcndhcmRlZC1mb3InXVxuICAgICAgICAgICAgLnNwbGl0KHhGb3J3YXJkZWRGb3JTZXBhcmF0b3JSZWdFeHApO1xuICAgICAgICB0aGlzLnJlbW90ZUFkZHJlc3Nlcy5wdXNoKGltbWVkaWF0ZVBlZXJJUCk7XG4gICAgICAgIHRoaXMucmVtb3RlQWRkcmVzcyA9IHRoaXMucmVtb3RlQWRkcmVzc2VzWzBdO1xuICAgIH1cblxuICAgIC8vIEV4dGVuc2lvbnMgYXJlIG9wdGlvbmFsLlxuICAgIGlmICh0aGlzLnNlcnZlckNvbmZpZy5wYXJzZUV4dGVuc2lvbnMpIHtcbiAgICAgICAgdmFyIGV4dGVuc2lvbnNTdHJpbmcgPSByZXF1ZXN0LmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuICAgICAgICB0aGlzLnJlcXVlc3RlZEV4dGVuc2lvbnMgPSB0aGlzLnBhcnNlRXh0ZW5zaW9ucyhleHRlbnNpb25zU3RyaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlcXVlc3RlZEV4dGVuc2lvbnMgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBDb29raWVzIGFyZSBvcHRpb25hbFxuICAgIGlmICh0aGlzLnNlcnZlckNvbmZpZy5wYXJzZUNvb2tpZXMpIHtcbiAgICAgICAgdmFyIGNvb2tpZVN0cmluZyA9IHJlcXVlc3QuaGVhZGVyc1snY29va2llJ107XG4gICAgICAgIHRoaXMuY29va2llcyA9IHRoaXMucGFyc2VDb29raWVzKGNvb2tpZVN0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb29raWVzID0gW107XG4gICAgfVxufTtcblxuV2ViU29ja2V0UmVxdWVzdC5wcm90b3R5cGUucGFyc2VFeHRlbnNpb25zID0gZnVuY3Rpb24oZXh0ZW5zaW9uc1N0cmluZykge1xuICAgIGlmICghZXh0ZW5zaW9uc1N0cmluZyB8fCBleHRlbnNpb25zU3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciBleHRlbnNpb25zID0gZXh0ZW5zaW9uc1N0cmluZy50b0xvY2FsZUxvd2VyQ2FzZSgpLnNwbGl0KGhlYWRlclZhbHVlU3BsaXRSZWdFeHApO1xuICAgIGV4dGVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbihleHRlbnNpb24sIGluZGV4LCBhcnJheSkge1xuICAgICAgICB2YXIgcGFyYW1zID0gZXh0ZW5zaW9uLnNwbGl0KGhlYWRlclBhcmFtU3BsaXRSZWdFeHApO1xuICAgICAgICB2YXIgZXh0ZW5zaW9uTmFtZSA9IHBhcmFtc1swXTtcbiAgICAgICAgdmFyIGV4dGVuc2lvblBhcmFtcyA9IHBhcmFtcy5zbGljZSgxKTtcbiAgICAgICAgZXh0ZW5zaW9uUGFyYW1zLmZvckVhY2goZnVuY3Rpb24ocmF3UGFyYW0sIGluZGV4LCBhcnJheSkge1xuICAgICAgICAgICAgdmFyIGFyciA9IHJhd1BhcmFtLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGFyclswXSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXJyWzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxLCBvYmopO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbk5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IGV4dGVuc2lvblBhcmFtc1xuICAgICAgICB9O1xuICAgICAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEsIG9iaik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGV4dGVuc2lvbnM7XG59O1xuXG4vLyBUaGlzIGZ1bmN0aW9uIGFkYXB0ZWQgZnJvbSBub2RlLWNvb2tpZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NodHlsbWFuL25vZGUtY29va2llXG5XZWJTb2NrZXRSZXF1ZXN0LnByb3RvdHlwZS5wYXJzZUNvb2tpZXMgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAvLyBTYW5pdHkgQ2hlY2tcbiAgICBpZiAoIXN0ciB8fCB0eXBlb2Yoc3RyKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBjb29raWVzID0gW107XG4gICAgdmFyIHBhaXJzID0gc3RyLnNwbGl0KGNvb2tpZVNlcGFyYXRvclJlZ0V4KTtcblxuICAgIHBhaXJzLmZvckVhY2goZnVuY3Rpb24ocGFpcikge1xuICAgICAgICB2YXIgZXFfaWR4ID0gcGFpci5pbmRleE9mKCc9Jyk7XG4gICAgICAgIGlmIChlcV9pZHggPT09IC0xKSB7XG4gICAgICAgICAgICBjb29raWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhaXIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleSA9IHBhaXIuc3Vic3RyKDAsIGVxX2lkeCkudHJpbSgpO1xuICAgICAgICB2YXIgdmFsID0gcGFpci5zdWJzdHIoKytlcV9pZHgsIHBhaXIubGVuZ3RoKS50cmltKCk7XG5cbiAgICAgICAgLy8gcXVvdGVkIHZhbHVlc1xuICAgICAgICBpZiAoJ1wiJyA9PT0gdmFsWzBdKSB7XG4gICAgICAgICAgICB2YWwgPSB2YWwuc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29va2llcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgIHZhbHVlOiBkZWNvZGVVUklDb21wb25lbnQodmFsKVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjb29raWVzO1xufTtcblxuV2ViU29ja2V0UmVxdWVzdC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24oYWNjZXB0ZWRQcm90b2NvbCwgYWxsb3dlZE9yaWdpbiwgY29va2llcykge1xuICAgIHRoaXMuX3ZlcmlmeVJlc29sdXRpb24oKTtcblxuICAgIC8vIFRPRE86IEhhbmRsZSBleHRlbnNpb25zXG5cbiAgICB2YXIgcHJvdG9jb2xGdWxsQ2FzZTtcblxuICAgIGlmIChhY2NlcHRlZFByb3RvY29sKSB7XG4gICAgICAgIHByb3RvY29sRnVsbENhc2UgPSB0aGlzLnByb3RvY29sRnVsbENhc2VNYXBbYWNjZXB0ZWRQcm90b2NvbC50b0xvY2FsZUxvd2VyQ2FzZSgpXTtcbiAgICAgICAgaWYgKHR5cGVvZihwcm90b2NvbEZ1bGxDYXNlKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHByb3RvY29sRnVsbENhc2UgPSBhY2NlcHRlZFByb3RvY29sO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwcm90b2NvbEZ1bGxDYXNlID0gYWNjZXB0ZWRQcm90b2NvbDtcbiAgICB9XG4gICAgdGhpcy5wcm90b2NvbEZ1bGxDYXNlTWFwID0gbnVsbDtcblxuICAgIC8vIENyZWF0ZSBrZXkgdmFsaWRhdGlvbiBoYXNoXG4gICAgdmFyIHNoYTEgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpO1xuICAgIHNoYTEudXBkYXRlKHRoaXMua2V5ICsgJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMScpO1xuICAgIHZhciBhY2NlcHRLZXkgPSBzaGExLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgICB2YXIgcmVzcG9uc2UgPSAnSFRUUC8xLjEgMTAxIFN3aXRjaGluZyBQcm90b2NvbHNcXHJcXG4nICtcbiAgICAgICAgICAgICAgICAgICAnVXBncmFkZTogd2Vic29ja2V0XFxyXFxuJyArXG4gICAgICAgICAgICAgICAgICAgJ0Nvbm5lY3Rpb246IFVwZ3JhZGVcXHJcXG4nICtcbiAgICAgICAgICAgICAgICAgICAnU2VjLVdlYlNvY2tldC1BY2NlcHQ6ICcgKyBhY2NlcHRLZXkgKyAnXFxyXFxuJztcblxuICAgIGlmIChwcm90b2NvbEZ1bGxDYXNlKSB7XG4gICAgICAgIC8vIHZhbGlkYXRlIHByb3RvY29sXG4gICAgICAgIGZvciAodmFyIGk9MDsgaSA8IHByb3RvY29sRnVsbENhc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHByb3RvY29sRnVsbENhc2UuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIHZhciBjaGFyYWN0ZXIgPSBwcm90b2NvbEZ1bGxDYXNlLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDB4MjEgfHwgY2hhckNvZGUgPiAweDdFIHx8IHNlcGFyYXRvcnMuaW5kZXhPZihjaGFyYWN0ZXIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGNoYXJhY3RlciBcIicgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJhY3RlcikgKyAnXCIgaW4gc3VicHJvdG9jb2wuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdGVkUHJvdG9jb2xzLmluZGV4T2YoYWNjZXB0ZWRQcm90b2NvbCkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTcGVjaWZpZWQgcHJvdG9jb2wgd2FzIG5vdCByZXF1ZXN0ZWQgYnkgdGhlIGNsaWVudC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3RvY29sRnVsbENhc2UgPSBwcm90b2NvbEZ1bGxDYXNlLnJlcGxhY2UoaGVhZGVyU2FuaXRpemVSZWdFeHAsICcnKTtcbiAgICAgICAgcmVzcG9uc2UgKz0gJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2w6ICcgKyBwcm90b2NvbEZ1bGxDYXNlICsgJ1xcclxcbic7XG4gICAgfVxuICAgIHRoaXMucmVxdWVzdGVkUHJvdG9jb2xzID0gbnVsbDtcblxuICAgIGlmIChhbGxvd2VkT3JpZ2luKSB7XG4gICAgICAgIGFsbG93ZWRPcmlnaW4gPSBhbGxvd2VkT3JpZ2luLnJlcGxhY2UoaGVhZGVyU2FuaXRpemVSZWdFeHAsICcnKTtcbiAgICAgICAgaWYgKHRoaXMud2ViU29ja2V0VmVyc2lvbiA9PT0gMTMpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlICs9ICdPcmlnaW46ICcgKyBhbGxvd2VkT3JpZ2luICsgJ1xcclxcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy53ZWJTb2NrZXRWZXJzaW9uID09PSA4KSB7XG4gICAgICAgICAgICByZXNwb25zZSArPSAnU2VjLVdlYlNvY2tldC1PcmlnaW46ICcgKyBhbGxvd2VkT3JpZ2luICsgJ1xcclxcbic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29va2llcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29va2llcykpIHtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHN1cHBsaWVkIGZvciBcImNvb2tpZXNcIiBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWVuQ29va2llcyA9IHt9O1xuICAgICAgICBjb29raWVzLmZvckVhY2goZnVuY3Rpb24oY29va2llKSB7XG4gICAgICAgICAgICBpZiAoIWNvb2tpZS5uYW1lIHx8ICFjb29raWUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWFjaCBjb29raWUgdG8gc2V0IG11c3QgYXQgbGVhc3QgcHJvdmlkZSBhIFwibmFtZVwiIGFuZCBcInZhbHVlXCInKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZXJlIGFyZSBubyBcXHJcXG4gc2VxdWVuY2VzIGluc2VydGVkXG4gICAgICAgICAgICBjb29raWUubmFtZSA9IGNvb2tpZS5uYW1lLnJlcGxhY2UoY29udHJvbENoYXJzQW5kU2VtaWNvbG9uUmVnRXgsICcnKTtcbiAgICAgICAgICAgIGNvb2tpZS52YWx1ZSA9IGNvb2tpZS52YWx1ZS5yZXBsYWNlKGNvbnRyb2xDaGFyc0FuZFNlbWljb2xvblJlZ0V4LCAnJyk7XG5cbiAgICAgICAgICAgIGlmIChzZWVuQ29va2llc1tjb29raWUubmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG1heSBub3Qgc3BlY2lmeSB0aGUgc2FtZSBjb29raWUgbmFtZSB0d2ljZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW5Db29raWVzW2Nvb2tpZS5uYW1lXSA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIHRva2VuIChSRkMgMjYxNiwgU2VjdGlvbiAyLjIpXG4gICAgICAgICAgICB2YXIgaW52YWxpZENoYXIgPSBjb29raWUubmFtZS5tYXRjaChjb29raWVOYW1lVmFsaWRhdGVSZWdFeCk7XG4gICAgICAgICAgICBpZiAoaW52YWxpZENoYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBjaGFyYWN0ZXIgJyArIGludmFsaWRDaGFyWzBdICsgJyBpbiBjb29raWUgbmFtZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSRkMgNjI2NSwgU2VjdGlvbiA0LjEuMVxuICAgICAgICAgICAgLy8gKmNvb2tpZS1vY3RldCAvICggRFFVT1RFICpjb29raWUtb2N0ZXQgRFFVT1RFICkgfCAleDIxIC8gJXgyMy0yQiAvICV4MkQtM0EgLyAleDNDLTVCIC8gJXg1RC03RVxuICAgICAgICAgICAgaWYgKGNvb2tpZS52YWx1ZS5tYXRjaChjb29raWVWYWx1ZURRdW90ZVZhbGlkYXRlUmVnRXgpKSB7XG4gICAgICAgICAgICAgICAgaW52YWxpZENoYXIgPSBjb29raWUudmFsdWUuc2xpY2UoMSwgLTEpLm1hdGNoKGNvb2tpZVZhbHVlVmFsaWRhdGVSZWdFeCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGludmFsaWRDaGFyID0gY29va2llLnZhbHVlLm1hdGNoKGNvb2tpZVZhbHVlVmFsaWRhdGVSZWdFeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW52YWxpZENoYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBjaGFyYWN0ZXIgJyArIGludmFsaWRDaGFyWzBdICsgJyBpbiBjb29raWUgdmFsdWUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvb2tpZVBhcnRzID0gW2Nvb2tpZS5uYW1lICsgJz0nICsgY29va2llLnZhbHVlXTtcblxuICAgICAgICAgICAgLy8gUkZDIDYyNjUsIFNlY3Rpb24gNC4xLjFcbiAgICAgICAgICAgIC8vICdQYXRoPScgcGF0aC12YWx1ZSB8IDxhbnkgQ0hBUiBleGNlcHQgQ1RMcyBvciAnOyc+XG4gICAgICAgICAgICBpZihjb29raWUucGF0aCl7XG4gICAgICAgICAgICAgICAgaW52YWxpZENoYXIgPSBjb29raWUucGF0aC5tYXRjaChjb250cm9sQ2hhcnNBbmRTZW1pY29sb25SZWdFeCk7XG4gICAgICAgICAgICAgICAgaWYgKGludmFsaWRDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBjaGFyYWN0ZXIgJyArIGludmFsaWRDaGFyWzBdICsgJyBpbiBjb29raWUgcGF0aCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb29raWVQYXJ0cy5wdXNoKCdQYXRoPScgKyBjb29raWUucGF0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJGQyA2MjY1LCBTZWN0aW9uIDQuMS4yLjNcbiAgICAgICAgICAgIC8vICdEb21haW49JyBzdWJkb21haW5cbiAgICAgICAgICAgIGlmIChjb29raWUuZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihjb29raWUuZG9tYWluKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEb21haW4gbXVzdCBiZSBzcGVjaWZpZWQgYW5kIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGludmFsaWRDaGFyID0gY29va2llLmRvbWFpbi5tYXRjaChjb250cm9sQ2hhcnNBbmRTZW1pY29sb25SZWdFeCk7XG4gICAgICAgICAgICAgICAgaWYgKGludmFsaWRDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBjaGFyYWN0ZXIgJyArIGludmFsaWRDaGFyWzBdICsgJyBpbiBjb29raWUgZG9tYWluJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvb2tpZVBhcnRzLnB1c2goJ0RvbWFpbj0nICsgY29va2llLmRvbWFpbi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUkZDIDYyNjUsIFNlY3Rpb24gNC4xLjFcbiAgICAgICAgICAgIC8vJ0V4cGlyZXM9JyBzYW5lLWNvb2tpZS1kYXRlIHwgRm9yY2UgRGF0ZSBvYmplY3QgcmVxdWlyZW1lbnQgYnkgdXNpbmcgb25seSBlcG9jaFxuICAgICAgICAgICAgaWYgKGNvb2tpZS5leHBpcmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoY29va2llLmV4cGlyZXMgaW5zdGFuY2VvZiBEYXRlKSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgc3VwcGxpZWQgZm9yIGNvb2tpZSBcImV4cGlyZXNcIiBtdXN0IGJlIGEgdmFpbGQgZGF0ZSBvYmplY3QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29va2llUGFydHMucHVzaCgnRXhwaXJlcz0nICsgY29va2llLmV4cGlyZXMudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJGQyA2MjY1LCBTZWN0aW9uIDQuMS4xXG4gICAgICAgICAgICAvLydNYXgtQWdlPScgbm9uLXplcm8tZGlnaXQgKkRJR0lUXG4gICAgICAgICAgICBpZiAoY29va2llLm1heGFnZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXhhZ2UgPSBjb29raWUubWF4YWdlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YobWF4YWdlKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4YWdlID0gcGFyc2VJbnQobWF4YWdlLCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc05hTihtYXhhZ2UpIHx8IG1heGFnZSA8PSAwICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHN1cHBsaWVkIGZvciBjb29raWUgXCJtYXhhZ2VcIiBtdXN0IGJlIGEgbm9uLXplcm8gbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1heGFnZSA9IE1hdGgucm91bmQobWF4YWdlKTtcbiAgICAgICAgICAgICAgICBjb29raWVQYXJ0cy5wdXNoKCdNYXgtQWdlPScgKyBtYXhhZ2UudG9TdHJpbmcoMTApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUkZDIDYyNjUsIFNlY3Rpb24gNC4xLjFcbiAgICAgICAgICAgIC8vJ1NlY3VyZTsnXG4gICAgICAgICAgICBpZiAoY29va2llLnNlY3VyZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoY29va2llLnNlY3VyZSkgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHN1cHBsaWVkIGZvciBjb29raWUgXCJzZWN1cmVcIiBtdXN0IGJlIG9mIHR5cGUgYm9vbGVhbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb29raWVQYXJ0cy5wdXNoKCdTZWN1cmUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUkZDIDYyNjUsIFNlY3Rpb24gNC4xLjFcbiAgICAgICAgICAgIC8vJ0h0dHBPbmx5OydcbiAgICAgICAgICAgIGlmIChjb29raWUuaHR0cG9ubHkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGNvb2tpZS5odHRwb25seSkgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHN1cHBsaWVkIGZvciBjb29raWUgXCJodHRwb25seVwiIG11c3QgYmUgb2YgdHlwZSBib29sZWFuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvb2tpZVBhcnRzLnB1c2goJ0h0dHBPbmx5Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3BvbnNlICs9ICgnU2V0LUNvb2tpZTogJyArIGNvb2tpZVBhcnRzLmpvaW4oJzsnKSArICdcXHJcXG4nKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBoYW5kbGUgbmVnb3RpYXRlZCBleHRlbnNpb25zXG4gICAgLy8gaWYgKG5lZ290aWF0ZWRFeHRlbnNpb25zKSB7XG4gICAgLy8gICAgIHJlc3BvbnNlICs9ICdTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnM6ICcgKyBuZWdvdGlhdGVkRXh0ZW5zaW9ucy5qb2luKCcsICcpICsgJ1xcclxcbic7XG4gICAgLy8gfVxuXG4gICAgLy8gTWFyayB0aGUgcmVxdWVzdCByZXNvbHZlZCBub3cgc28gdGhhdCB0aGUgdXNlciBjYW4ndCBjYWxsIGFjY2VwdCBvclxuICAgIC8vIHJlamVjdCBhIHNlY29uZCB0aW1lLlxuICAgIHRoaXMuX3Jlc29sdmVkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ3JlcXVlc3RSZXNvbHZlZCcsIHRoaXMpO1xuXG4gICAgcmVzcG9uc2UgKz0gJ1xcclxcbic7XG5cbiAgICB2YXIgY29ubmVjdGlvbiA9IG5ldyBXZWJTb2NrZXRDb25uZWN0aW9uKHRoaXMuc29ja2V0LCBbXSwgYWNjZXB0ZWRQcm90b2NvbCwgZmFsc2UsIHRoaXMuc2VydmVyQ29uZmlnKTtcbiAgICBjb25uZWN0aW9uLndlYlNvY2tldFZlcnNpb24gPSB0aGlzLndlYlNvY2tldFZlcnNpb247XG4gICAgY29ubmVjdGlvbi5yZW1vdGVBZGRyZXNzID0gdGhpcy5yZW1vdGVBZGRyZXNzO1xuICAgIGNvbm5lY3Rpb24ucmVtb3RlQWRkcmVzc2VzID0gdGhpcy5yZW1vdGVBZGRyZXNzZXM7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5fc29ja2V0SXNDbG9zaW5nKSB7XG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gdGhlIGNsaWVudCBoYW5ncyB1cCBiZWZvcmUgd2UgZ2V0IGEgY2hhbmNlIHRvXG4gICAgICAgIC8vIGFjY2VwdCB0aGUgY29ubmVjdGlvbiBhbmQgc2VuZCBvdXIgc2lkZSBvZiB0aGUgb3BlbmluZyBoYW5kc2hha2UuXG4gICAgICAgIGNsZWFudXBGYWlsZWRDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5zb2NrZXQud3JpdGUocmVzcG9uc2UsICdhc2NpaScsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjbGVhbnVwRmFpbGVkQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuX3JlbW92ZVNvY2tldENsb3NlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBjb25uZWN0aW9uLl9hZGRTb2NrZXRFdmVudExpc3RlbmVycygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ3JlcXVlc3RBY2NlcHRlZCcsIGNvbm5lY3Rpb24pO1xuICAgIHJldHVybiBjb25uZWN0aW9uO1xufTtcblxuV2ViU29ja2V0UmVxdWVzdC5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24oc3RhdHVzLCByZWFzb24sIGV4dHJhSGVhZGVycykge1xuICAgIHRoaXMuX3ZlcmlmeVJlc29sdXRpb24oKTtcblxuICAgIC8vIE1hcmsgdGhlIHJlcXVlc3QgcmVzb2x2ZWQgbm93IHNvIHRoYXQgdGhlIHVzZXIgY2FuJ3QgY2FsbCBhY2NlcHQgb3JcbiAgICAvLyByZWplY3QgYSBzZWNvbmQgdGltZS5cbiAgICB0aGlzLl9yZXNvbHZlZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdyZXF1ZXN0UmVzb2x2ZWQnLCB0aGlzKTtcblxuICAgIGlmICh0eXBlb2Yoc3RhdHVzKSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgc3RhdHVzID0gNDAzO1xuICAgIH1cbiAgICB2YXIgcmVzcG9uc2UgPSAnSFRUUC8xLjEgJyArIHN0YXR1cyArICcgJyArIGh0dHBTdGF0dXNEZXNjcmlwdGlvbnNbc3RhdHVzXSArICdcXHJcXG4nICtcbiAgICAgICAgICAgICAgICAgICAnQ29ubmVjdGlvbjogY2xvc2VcXHJcXG4nO1xuICAgIGlmIChyZWFzb24pIHtcbiAgICAgICAgcmVhc29uID0gcmVhc29uLnJlcGxhY2UoaGVhZGVyU2FuaXRpemVSZWdFeHAsICcnKTtcbiAgICAgICAgcmVzcG9uc2UgKz0gJ1gtV2ViU29ja2V0LVJlamVjdC1SZWFzb246ICcgKyByZWFzb24gKyAnXFxyXFxuJztcbiAgICB9XG5cbiAgICBpZiAoZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBleHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICAgIHZhciBzYW5pdGl6ZWRWYWx1ZSA9IGV4dHJhSGVhZGVyc1trZXldLnRvU3RyaW5nKCkucmVwbGFjZShoZWFkZXJTYW5pdGl6ZVJlZ0V4cCwgJycpO1xuICAgICAgICAgICAgdmFyIHNhbml0aXplZEtleSA9IGtleS5yZXBsYWNlKGhlYWRlclNhbml0aXplUmVnRXhwLCAnJyk7XG4gICAgICAgICAgICByZXNwb25zZSArPSAoc2FuaXRpemVkS2V5ICsgJzogJyArIHNhbml0aXplZFZhbHVlICsgJ1xcclxcbicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzcG9uc2UgKz0gJ1xcclxcbic7XG4gICAgdGhpcy5zb2NrZXQuZW5kKHJlc3BvbnNlLCAnYXNjaWknKTtcblxuICAgIHRoaXMuZW1pdCgncmVxdWVzdFJlamVjdGVkJywgdGhpcyk7XG59O1xuXG5XZWJTb2NrZXRSZXF1ZXN0LnByb3RvdHlwZS5faGFuZGxlU29ja2V0Q2xvc2VCZWZvcmVBY2NlcHQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9zb2NrZXRJc0Nsb3NpbmcgPSB0cnVlO1xuICAgIHRoaXMuX3JlbW92ZVNvY2tldENsb3NlTGlzdGVuZXJzKCk7XG59O1xuXG5XZWJTb2NrZXRSZXF1ZXN0LnByb3RvdHlwZS5fcmVtb3ZlU29ja2V0Q2xvc2VMaXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNvY2tldC5yZW1vdmVMaXN0ZW5lcignZW5kJywgdGhpcy5fc29ja2V0Q2xvc2VIYW5kbGVyKTtcbiAgICB0aGlzLnNvY2tldC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCB0aGlzLl9zb2NrZXRDbG9zZUhhbmRsZXIpO1xufTtcblxuV2ViU29ja2V0UmVxdWVzdC5wcm90b3R5cGUuX3ZlcmlmeVJlc29sdXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fcmVzb2x2ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXRSZXF1ZXN0IG1heSBvbmx5IGJlIGFjY2VwdGVkIG9yIHJlamVjdGVkIG9uZSB0aW1lLicpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGNsZWFudXBGYWlsZWRDb25uZWN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAvLyBTaW5jZSB3ZSBoYXZlIHRvIHJldHVybiBhIGNvbm5lY3Rpb24gb2JqZWN0IGV2ZW4gaWYgdGhlIHNvY2tldCBpc1xuICAgIC8vIGFscmVhZHkgZGVhZCBpbiBvcmRlciBub3QgdG8gYnJlYWsgdGhlIEFQSSwgd2Ugc2NoZWR1bGUgYSAnY2xvc2UnXG4gICAgLy8gZXZlbnQgb24gdGhlIGNvbm5lY3Rpb24gb2JqZWN0IHRvIG9jY3VyIGltbWVkaWF0ZWx5LlxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX0FCTk9STUFMID0gMTAwNlxuICAgICAgICAvLyBUaGlyZCBwYXJhbTogU2tpcCBzZW5kaW5nIHRoZSBjbG9zZSBmcmFtZSB0byBhIGRlYWQgc29ja2V0XG4gICAgICAgIGNvbm5lY3Rpb24uZHJvcCgxMDA2LCAnVENQIGNvbm5lY3Rpb24gbG9zdCBiZWZvcmUgaGFuZHNoYWtlIGNvbXBsZXRlZC4nLCB0cnVlKTtcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRSZXF1ZXN0O1xuIl0sIm5hbWVzIjpbImNyeXB0byIsInJlcXVpcmUiLCJ1dGlsIiwidXJsIiwiRXZlbnRFbWl0dGVyIiwiV2ViU29ja2V0Q29ubmVjdGlvbiIsImhlYWRlclZhbHVlU3BsaXRSZWdFeHAiLCJoZWFkZXJQYXJhbVNwbGl0UmVnRXhwIiwiaGVhZGVyU2FuaXRpemVSZWdFeHAiLCJ4Rm9yd2FyZGVkRm9yU2VwYXJhdG9yUmVnRXhwIiwic2VwYXJhdG9ycyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImNvbnRyb2xDaGFycyIsImkiLCJwdXNoIiwiY29va2llTmFtZVZhbGlkYXRlUmVnRXgiLCJjb29raWVWYWx1ZVZhbGlkYXRlUmVnRXgiLCJjb29raWVWYWx1ZURRdW90ZVZhbGlkYXRlUmVnRXgiLCJjb250cm9sQ2hhcnNBbmRTZW1pY29sb25SZWdFeCIsImNvb2tpZVNlcGFyYXRvclJlZ0V4IiwiaHR0cFN0YXR1c0Rlc2NyaXB0aW9ucyIsIldlYlNvY2tldFJlcXVlc3QiLCJzb2NrZXQiLCJodHRwUmVxdWVzdCIsInNlcnZlckNvbmZpZyIsImNhbGwiLCJyZXNvdXJjZSIsInJlbW90ZUFkZHJlc3MiLCJyZW1vdGVBZGRyZXNzZXMiLCJfc29ja2V0SXNDbG9zaW5nIiwiX3NvY2tldENsb3NlSGFuZGxlciIsIl9oYW5kbGVTb2NrZXRDbG9zZUJlZm9yZUFjY2VwdCIsImJpbmQiLCJvbiIsIl9yZXNvbHZlZCIsImluaGVyaXRzIiwicHJvdG90eXBlIiwicmVhZEhhbmRzaGFrZSIsInNlbGYiLCJyZXF1ZXN0IiwicmVzb3VyY2VVUkwiLCJwYXJzZSIsImhvc3QiLCJoZWFkZXJzIiwiRXJyb3IiLCJrZXkiLCJ3ZWJTb2NrZXRWZXJzaW9uIiwicGFyc2VJbnQiLCJpc05hTiIsImUiLCJodHRwQ29kZSIsIm9yaWdpbiIsInByb3RvY29sU3RyaW5nIiwicHJvdG9jb2xGdWxsQ2FzZU1hcCIsInJlcXVlc3RlZFByb3RvY29scyIsInJlcXVlc3RlZFByb3RvY29sc0Z1bGxDYXNlIiwic3BsaXQiLCJmb3JFYWNoIiwicHJvdG9jb2wiLCJsY1Byb3RvY29sIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJpZ25vcmVYRm9yd2FyZGVkRm9yIiwiaW1tZWRpYXRlUGVlcklQIiwicGFyc2VFeHRlbnNpb25zIiwiZXh0ZW5zaW9uc1N0cmluZyIsInJlcXVlc3RlZEV4dGVuc2lvbnMiLCJwYXJzZUNvb2tpZXMiLCJjb29raWVTdHJpbmciLCJjb29raWVzIiwibGVuZ3RoIiwiZXh0ZW5zaW9ucyIsImV4dGVuc2lvbiIsImluZGV4IiwiYXJyYXkiLCJwYXJhbXMiLCJleHRlbnNpb25OYW1lIiwiZXh0ZW5zaW9uUGFyYW1zIiwic2xpY2UiLCJyYXdQYXJhbSIsImFyciIsIm9iaiIsIm5hbWUiLCJ2YWx1ZSIsInNwbGljZSIsInN0ciIsInBhaXJzIiwicGFpciIsImVxX2lkeCIsImluZGV4T2YiLCJzdWJzdHIiLCJ0cmltIiwidmFsIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiYWNjZXB0IiwiYWNjZXB0ZWRQcm90b2NvbCIsImFsbG93ZWRPcmlnaW4iLCJfdmVyaWZ5UmVzb2x1dGlvbiIsInByb3RvY29sRnVsbENhc2UiLCJzaGExIiwiY3JlYXRlSGFzaCIsInVwZGF0ZSIsImFjY2VwdEtleSIsImRpZ2VzdCIsInJlc3BvbnNlIiwiY2hhckNvZGUiLCJjaGFyQ29kZUF0IiwiY2hhcmFjdGVyIiwiY2hhckF0IiwicmVqZWN0IiwicmVwbGFjZSIsIkFycmF5IiwiaXNBcnJheSIsInNlZW5Db29raWVzIiwiY29va2llIiwiaW52YWxpZENoYXIiLCJtYXRjaCIsImNvb2tpZVBhcnRzIiwicGF0aCIsImRvbWFpbiIsInRvTG93ZXJDYXNlIiwiZXhwaXJlcyIsIkRhdGUiLCJ0b0dNVFN0cmluZyIsIm1heGFnZSIsIk1hdGgiLCJyb3VuZCIsInRvU3RyaW5nIiwic2VjdXJlIiwiaHR0cG9ubHkiLCJqb2luIiwiZW1pdCIsImNvbm5lY3Rpb24iLCJjbGVhbnVwRmFpbGVkQ29ubmVjdGlvbiIsIndyaXRlIiwiZXJyb3IiLCJfcmVtb3ZlU29ja2V0Q2xvc2VMaXN0ZW5lcnMiLCJfYWRkU29ja2V0RXZlbnRMaXN0ZW5lcnMiLCJzdGF0dXMiLCJyZWFzb24iLCJleHRyYUhlYWRlcnMiLCJzYW5pdGl6ZWRWYWx1ZSIsInNhbml0aXplZEtleSIsImVuZCIsInJlbW92ZUxpc3RlbmVyIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiZHJvcCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/WebSocketRequest.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/WebSocketRouter.js":
/*!*******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketRouter.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ var extend = (__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/websocket/lib/utils.js\").extend);\nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar WebSocketRouterRequest = __webpack_require__(/*! ./WebSocketRouterRequest */ \"(ssr)/./node_modules/websocket/lib/WebSocketRouterRequest.js\");\nfunction WebSocketRouter(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n    this.config = {\n        // The WebSocketServer instance to attach to.\n        server: null\n    };\n    if (config) {\n        extend(this.config, config);\n    }\n    this.handlers = [];\n    this._requestHandler = this.handleRequest.bind(this);\n    if (this.config.server) {\n        this.attachServer(this.config.server);\n    }\n}\nutil.inherits(WebSocketRouter, EventEmitter);\nWebSocketRouter.prototype.attachServer = function(server) {\n    if (server) {\n        this.server = server;\n        this.server.on(\"request\", this._requestHandler);\n    } else {\n        throw new Error(\"You must specify a WebSocketServer instance to attach to.\");\n    }\n};\nWebSocketRouter.prototype.detachServer = function() {\n    if (this.server) {\n        this.server.removeListener(\"request\", this._requestHandler);\n        this.server = null;\n    } else {\n        throw new Error(\"Cannot detach from server: not attached.\");\n    }\n};\nWebSocketRouter.prototype.mount = function(path, protocol, callback) {\n    if (!path) {\n        throw new Error(\"You must specify a path for this handler.\");\n    }\n    if (!protocol) {\n        protocol = \"____no_protocol____\";\n    }\n    if (!callback) {\n        throw new Error(\"You must specify a callback for this handler.\");\n    }\n    path = this.pathToRegExp(path);\n    if (!(path instanceof RegExp)) {\n        throw new Error(\"Path must be specified as either a string or a RegExp.\");\n    }\n    var pathString = path.toString();\n    // normalize protocol to lower-case\n    protocol = protocol.toLocaleLowerCase();\n    if (this.findHandlerIndex(pathString, protocol) !== -1) {\n        throw new Error(\"You may only mount one handler per path/protocol combination.\");\n    }\n    this.handlers.push({\n        \"path\": path,\n        \"pathString\": pathString,\n        \"protocol\": protocol,\n        \"callback\": callback\n    });\n};\nWebSocketRouter.prototype.unmount = function(path, protocol) {\n    var index = this.findHandlerIndex(this.pathToRegExp(path).toString(), protocol);\n    if (index !== -1) {\n        this.handlers.splice(index, 1);\n    } else {\n        throw new Error(\"Unable to find a route matching the specified path and protocol.\");\n    }\n};\nWebSocketRouter.prototype.findHandlerIndex = function(pathString, protocol) {\n    protocol = protocol.toLocaleLowerCase();\n    for(var i = 0, len = this.handlers.length; i < len; i++){\n        var handler = this.handlers[i];\n        if (handler.pathString === pathString && handler.protocol === protocol) {\n            return i;\n        }\n    }\n    return -1;\n};\nWebSocketRouter.prototype.pathToRegExp = function(path) {\n    if (typeof path === \"string\") {\n        if (path === \"*\") {\n            path = /^.*$/;\n        } else {\n            path = path.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n            path = new RegExp(\"^\" + path + \"$\");\n        }\n    }\n    return path;\n};\nWebSocketRouter.prototype.handleRequest = function(request) {\n    var requestedProtocols = request.requestedProtocols;\n    if (requestedProtocols.length === 0) {\n        requestedProtocols = [\n            \"____no_protocol____\"\n        ];\n    }\n    // Find a handler with the first requested protocol first\n    for(var i = 0; i < requestedProtocols.length; i++){\n        var requestedProtocol = requestedProtocols[i].toLocaleLowerCase();\n        // find the first handler that can process this request\n        for(var j = 0, len = this.handlers.length; j < len; j++){\n            var handler = this.handlers[j];\n            if (handler.path.test(request.resourceURL.pathname)) {\n                if (requestedProtocol === handler.protocol || handler.protocol === \"*\") {\n                    var routerRequest = new WebSocketRouterRequest(request, requestedProtocol);\n                    handler.callback(routerRequest);\n                    return;\n                }\n            }\n        }\n    }\n    // If we get here we were unable to find a suitable handler.\n    request.reject(404, \"No handler is available for the given request.\");\n};\nmodule.exports = WebSocketRouter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRSb3V0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O3VFQWN1RSxHQUV2RSxJQUFJQSxTQUFTQywwRkFBeUI7QUFDdEMsSUFBSUMsT0FBT0QsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUUsZUFBZUYsMERBQThCO0FBQ2pELElBQUlHLHlCQUF5QkgsbUJBQU9BLENBQUM7QUFFckMsU0FBU0ksZ0JBQWdCQyxNQUFNO0lBQzNCLHlCQUF5QjtJQUN6QkgsYUFBYUksSUFBSSxDQUFDLElBQUk7SUFFdEIsSUFBSSxDQUFDRCxNQUFNLEdBQUc7UUFDViw2Q0FBNkM7UUFDN0NFLFFBQVE7SUFDWjtJQUNBLElBQUlGLFFBQVE7UUFDUk4sT0FBTyxJQUFJLENBQUNNLE1BQU0sRUFBRUE7SUFDeEI7SUFDQSxJQUFJLENBQUNHLFFBQVEsR0FBRyxFQUFFO0lBRWxCLElBQUksQ0FBQ0MsZUFBZSxHQUFHLElBQUksQ0FBQ0MsYUFBYSxDQUFDQyxJQUFJLENBQUMsSUFBSTtJQUNuRCxJQUFJLElBQUksQ0FBQ04sTUFBTSxDQUFDRSxNQUFNLEVBQUU7UUFDcEIsSUFBSSxDQUFDSyxZQUFZLENBQUMsSUFBSSxDQUFDUCxNQUFNLENBQUNFLE1BQU07SUFDeEM7QUFDSjtBQUVBTixLQUFLWSxRQUFRLENBQUNULGlCQUFpQkY7QUFFL0JFLGdCQUFnQlUsU0FBUyxDQUFDRixZQUFZLEdBQUcsU0FBU0wsTUFBTTtJQUNwRCxJQUFJQSxRQUFRO1FBQ1IsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQSxNQUFNLENBQUNRLEVBQUUsQ0FBQyxXQUFXLElBQUksQ0FBQ04sZUFBZTtJQUNsRCxPQUNLO1FBQ0QsTUFBTSxJQUFJTyxNQUFNO0lBQ3BCO0FBQ0o7QUFFQVosZ0JBQWdCVSxTQUFTLENBQUNHLFlBQVksR0FBRztJQUNyQyxJQUFJLElBQUksQ0FBQ1YsTUFBTSxFQUFFO1FBQ2Is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RU0sSUFBSVAsS0FBS08sSUFBSztZQUNsRCxJQUFJTCxVQUFVLElBQUksQ0FBQzVCLFFBQVEsQ0FBQ2lDLEVBQUU7WUFDOUIsSUFBSUwsUUFBUWhCLElBQUksQ0FBQ3NCLElBQUksQ0FBQ0osUUFBUUssV0FBVyxDQUFDQyxRQUFRLEdBQUc7Z0JBQ2pELElBQUlKLHNCQUFzQkosUUFBUWYsUUFBUSxJQUN0Q2UsUUFBUWYsUUFBUSxLQUFLLEtBQ3pCO29CQUNJLElBQUl3QixnQkFBZ0IsSUFBSTFDLHVCQUF1Qm1DLFNBQVNFO29CQUN4REosUUFBUWQsUUFBUSxDQUFDdUI7b0JBQ2pCO2dCQUNKO1lBQ0o7UUFDSjtJQUNKO0lBRUEsNERBQTREO0lBQzVEUCxRQUFRUSxNQUFNLENBQUMsS0FBSztBQUN4QjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRSb3V0ZXIuanM/OTFiOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQ29weXJpZ2h0IDIwMTAtMjAxNSBCcmlhbiBNY0tlbHZleS5cbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBleHRlbmQgPSByZXF1aXJlKCcuL3V0aWxzJykuZXh0ZW5kO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIFdlYlNvY2tldFJvdXRlclJlcXVlc3QgPSByZXF1aXJlKCcuL1dlYlNvY2tldFJvdXRlclJlcXVlc3QnKTtcblxuZnVuY3Rpb24gV2ViU29ja2V0Um91dGVyKGNvbmZpZykge1xuICAgIC8vIFN1cGVyY2xhc3MgQ29uc3RydWN0b3JcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAvLyBUaGUgV2ViU29ja2V0U2VydmVyIGluc3RhbmNlIHRvIGF0dGFjaCB0by5cbiAgICAgICAgc2VydmVyOiBudWxsXG4gICAgfTtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgIGV4dGVuZCh0aGlzLmNvbmZpZywgY29uZmlnKTtcbiAgICB9XG4gICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuXG4gICAgdGhpcy5fcmVxdWVzdEhhbmRsZXIgPSB0aGlzLmhhbmRsZVJlcXVlc3QuYmluZCh0aGlzKTtcbiAgICBpZiAodGhpcy5jb25maWcuc2VydmVyKSB7XG4gICAgICAgIHRoaXMuYXR0YWNoU2VydmVyKHRoaXMuY29uZmlnLnNlcnZlcik7XG4gICAgfVxufVxuXG51dGlsLmluaGVyaXRzKFdlYlNvY2tldFJvdXRlciwgRXZlbnRFbWl0dGVyKTtcblxuV2ViU29ja2V0Um91dGVyLnByb3RvdHlwZS5hdHRhY2hTZXJ2ZXIgPSBmdW5jdGlvbihzZXJ2ZXIpIHtcbiAgICBpZiAoc2VydmVyKSB7XG4gICAgICAgIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICAgICAgICB0aGlzLnNlcnZlci5vbigncmVxdWVzdCcsIHRoaXMuX3JlcXVlc3RIYW5kbGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBhIFdlYlNvY2tldFNlcnZlciBpbnN0YW5jZSB0byBhdHRhY2ggdG8uJyk7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Um91dGVyLnByb3RvdHlwZS5kZXRhY2hTZXJ2ZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5zZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoJ3JlcXVlc3QnLCB0aGlzLl9yZXF1ZXN0SGFuZGxlcik7XG4gICAgICAgIHRoaXMuc2VydmVyID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRldGFjaCBmcm9tIHNlcnZlcjogbm90IGF0dGFjaGVkLicpO1xuICAgIH1cbn07XG5cbldlYlNvY2tldFJvdXRlci5wcm90b3R5cGUubW91bnQgPSBmdW5jdGlvbihwYXRoLCBwcm90b2NvbCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgcGF0aCBmb3IgdGhpcyBoYW5kbGVyLicpO1xuICAgIH1cbiAgICBpZiAoIXByb3RvY29sKSB7XG4gICAgICAgIHByb3RvY29sID0gJ19fX19ub19wcm90b2NvbF9fX18nO1xuICAgIH1cbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBhIGNhbGxiYWNrIGZvciB0aGlzIGhhbmRsZXIuJyk7XG4gICAgfVxuXG4gICAgcGF0aCA9IHRoaXMucGF0aFRvUmVnRXhwKHBhdGgpO1xuICAgIGlmICghKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBtdXN0IGJlIHNwZWNpZmllZCBhcyBlaXRoZXIgYSBzdHJpbmcgb3IgYSBSZWdFeHAuJyk7XG4gICAgfVxuICAgIHZhciBwYXRoU3RyaW5nID0gcGF0aC50b1N0cmluZygpO1xuXG4gICAgLy8gbm9ybWFsaXplIHByb3RvY29sIHRvIGxvd2VyLWNhc2VcbiAgICBwcm90b2NvbCA9IHByb3RvY29sLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAodGhpcy5maW5kSGFuZGxlckluZGV4KHBhdGhTdHJpbmcsIHByb3RvY29sKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbWF5IG9ubHkgbW91bnQgb25lIGhhbmRsZXIgcGVyIHBhdGgvcHJvdG9jb2wgY29tYmluYXRpb24uJyk7XG4gICAgfVxuXG4gICAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICAgICAgJ3BhdGgnOiBwYXRoLFxuICAgICAgICAncGF0aFN0cmluZyc6IHBhdGhTdHJpbmcsXG4gICAgICAgICdwcm90b2NvbCc6IHByb3RvY29sLFxuICAgICAgICAnY2FsbGJhY2snOiBjYWxsYmFja1xuICAgIH0pO1xufTtcbldlYlNvY2tldFJvdXRlci5wcm90b3R5cGUudW5tb3VudCA9IGZ1bmN0aW9uKHBhdGgsIHByb3RvY29sKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5maW5kSGFuZGxlckluZGV4KHRoaXMucGF0aFRvUmVnRXhwKHBhdGgpLnRvU3RyaW5nKCksIHByb3RvY29sKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgYSByb3V0ZSBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIHBhdGggYW5kIHByb3RvY29sLicpO1xuICAgIH1cbn07XG5cbldlYlNvY2tldFJvdXRlci5wcm90b3R5cGUuZmluZEhhbmRsZXJJbmRleCA9IGZ1bmN0aW9uKHBhdGhTdHJpbmcsIHByb3RvY29sKSB7XG4gICAgcHJvdG9jb2wgPSBwcm90b2NvbC50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIGZvciAodmFyIGk9MCwgbGVuPXRoaXMuaGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLmhhbmRsZXJzW2ldO1xuICAgICAgICBpZiAoaGFuZGxlci5wYXRoU3RyaW5nID09PSBwYXRoU3RyaW5nICYmIGhhbmRsZXIucHJvdG9jb2wgPT09IHByb3RvY29sKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuXG5XZWJTb2NrZXRSb3V0ZXIucHJvdG90eXBlLnBhdGhUb1JlZ0V4cCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBpZiAodHlwZW9mKHBhdGgpID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAocGF0aCA9PT0gJyonKSB7XG4gICAgICAgICAgICBwYXRoID0gL14uKiQvO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcbiAgICAgICAgICAgIHBhdGggPSBuZXcgUmVnRXhwKCdeJyArIHBhdGggKyAnJCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufTtcblxuV2ViU29ja2V0Um91dGVyLnByb3RvdHlwZS5oYW5kbGVSZXF1ZXN0ID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIHZhciByZXF1ZXN0ZWRQcm90b2NvbHMgPSByZXF1ZXN0LnJlcXVlc3RlZFByb3RvY29scztcbiAgICBpZiAocmVxdWVzdGVkUHJvdG9jb2xzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXF1ZXN0ZWRQcm90b2NvbHMgPSBbJ19fX19ub19wcm90b2NvbF9fX18nXTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIGEgaGFuZGxlciB3aXRoIHRoZSBmaXJzdCByZXF1ZXN0ZWQgcHJvdG9jb2wgZmlyc3RcbiAgICBmb3IgKHZhciBpPTA7IGkgPCByZXF1ZXN0ZWRQcm90b2NvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJlcXVlc3RlZFByb3RvY29sID0gcmVxdWVzdGVkUHJvdG9jb2xzW2ldLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgZmlyc3QgaGFuZGxlciB0aGF0IGNhbiBwcm9jZXNzIHRoaXMgcmVxdWVzdFxuICAgICAgICBmb3IgKHZhciBqPTAsIGxlbj10aGlzLmhhbmRsZXJzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuaGFuZGxlcnNbal07XG4gICAgICAgICAgICBpZiAoaGFuZGxlci5wYXRoLnRlc3QocmVxdWVzdC5yZXNvdXJjZVVSTC5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdGVkUHJvdG9jb2wgPT09IGhhbmRsZXIucHJvdG9jb2wgfHxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5wcm90b2NvbCA9PT0gJyonKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdXRlclJlcXVlc3QgPSBuZXcgV2ViU29ja2V0Um91dGVyUmVxdWVzdChyZXF1ZXN0LCByZXF1ZXN0ZWRQcm90b2NvbCk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbGJhY2socm91dGVyUmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBnZXQgaGVyZSB3ZSB3ZXJlIHVuYWJsZSB0byBmaW5kIGEgc3VpdGFibGUgaGFuZGxlci5cbiAgICByZXF1ZXN0LnJlamVjdCg0MDQsICdObyBoYW5kbGVyIGlzIGF2YWlsYWJsZSBmb3IgdGhlIGdpdmVuIHJlcXVlc3QuJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFJvdXRlcjtcbiJdLCJuYW1lcyI6WyJleHRlbmQiLCJyZXF1aXJlIiwidXRpbCIsIkV2ZW50RW1pdHRlciIsIldlYlNvY2tldFJvdXRlclJlcXVlc3QiLCJXZWJTb2NrZXRSb3V0ZXIiLCJjb25maWciLCJjYWxsIiwic2VydmVyIiwiaGFuZGxlcnMiLCJfcmVxdWVzdEhhbmRsZXIiLCJoYW5kbGVSZXF1ZXN0IiwiYmluZCIsImF0dGFjaFNlcnZlciIsImluaGVyaXRzIiwicHJvdG90eXBlIiwib24iLCJFcnJvciIsImRldGFjaFNlcnZlciIsInJlbW92ZUxpc3RlbmVyIiwibW91bnQiLCJwYXRoIiwicHJvdG9jb2wiLCJjYWxsYmFjayIsInBhdGhUb1JlZ0V4cCIsIlJlZ0V4cCIsInBhdGhTdHJpbmciLCJ0b1N0cmluZyIsInRvTG9jYWxlTG93ZXJDYXNlIiwiZmluZEhhbmRsZXJJbmRleCIsInB1c2giLCJ1bm1vdW50IiwiaW5kZXgiLCJzcGxpY2UiLCJpIiwibGVuIiwibGVuZ3RoIiwiaGFuZGxlciIsInJlcGxhY2UiLCJyZXF1ZXN0IiwicmVxdWVzdGVkUHJvdG9jb2xzIiwicmVxdWVzdGVkUHJvdG9jb2wiLCJqIiwidGVzdCIsInJlc291cmNlVVJMIiwicGF0aG5hbWUiLCJyb3V0ZXJSZXF1ZXN0IiwicmVqZWN0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/WebSocketRouter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/WebSocketRouterRequest.js":
/*!**************************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketRouterRequest.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ var util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nfunction WebSocketRouterRequest(webSocketRequest, resolvedProtocol) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n    this.webSocketRequest = webSocketRequest;\n    if (resolvedProtocol === \"____no_protocol____\") {\n        this.protocol = null;\n    } else {\n        this.protocol = resolvedProtocol;\n    }\n    this.origin = webSocketRequest.origin;\n    this.resource = webSocketRequest.resource;\n    this.resourceURL = webSocketRequest.resourceURL;\n    this.httpRequest = webSocketRequest.httpRequest;\n    this.remoteAddress = webSocketRequest.remoteAddress;\n    this.webSocketVersion = webSocketRequest.webSocketVersion;\n    this.requestedExtensions = webSocketRequest.requestedExtensions;\n    this.cookies = webSocketRequest.cookies;\n}\nutil.inherits(WebSocketRouterRequest, EventEmitter);\nWebSocketRouterRequest.prototype.accept = function(origin, cookies) {\n    var connection = this.webSocketRequest.accept(this.protocol, origin, cookies);\n    this.emit(\"requestAccepted\", connection);\n    return connection;\n};\nWebSocketRouterRequest.prototype.reject = function(status, reason, extraHeaders) {\n    this.webSocketRequest.reject(status, reason, extraHeaders);\n    this.emit(\"requestRejected\", this);\n};\nmodule.exports = WebSocketRouterRequest;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRSb3V0ZXJSZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozt1RUFjdUUsR0FFdkUsSUFBSUEsT0FBT0MsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUMsZUFBZUQsMERBQThCO0FBRWpELFNBQVNFLHVCQUF1QkMsZ0JBQWdCLEVBQUVDLGdCQUFnQjtJQUM5RCx5QkFBeUI7SUFDekJILGFBQWFJLElBQUksQ0FBQyxJQUFJO0lBRXRCLElBQUksQ0FBQ0YsZ0JBQWdCLEdBQUdBO0lBQ3hCLElBQUlDLHFCQUFxQix1QkFBdUI7UUFDNUMsSUFBSSxDQUFDRSxRQUFRLEdBQUc7SUFDcEIsT0FDSztRQUNELElBQUksQ0FBQ0EsUUFBUSxHQUFHRjtJQUNwQjtJQUNBLElBQUksQ0FBQ0csTUFBTSxHQUFHSixpQkFBaUJJLE1BQU07SUFDckMsSUFBSSxDQUFDQyxRQUFRLEdBQUdMLGlCQUFpQkssUUFBUTtJQUN6QyxJQUFJLENBQUNDLFdBQVcsR0FBR04saUJBQWlCTSxXQUFXO0lBQy9DLElBQUksQ0FBQ0MsV0FBVyxHQUFHUCxpQkFBaUJPLFdBQVc7SUFDL0MsSUFBSSxDQUFDQyxhQUFhLEdBQUdSLGlCQUFpQlEsYUFBYTtJQUNuRCxJQUFJLENBQUNDLGdCQUFnQixHQUFHVCxpQkFBaUJTLGdCQUFnQjtJQUN6RCxJQUFJLENBQUNDLG1CQUFtQixHQUFHVixpQkFBaUJVLG1CQUFtQjtJQUMvRCxJQUFJLENBQUNDLE9BQU8sR0FBR1gsaUJBQWlCVyxPQUFPO0FBQzNDO0FBRUFmLEtBQUtnQixRQUFRLENBQUNiLHdCQUF3QkQ7QUFFdENDLHVCQUF1QmMsU0FBUyxDQUFDQyxNQUFNLEdBQUcsU0FBU1YsTUFBTSxFQUFFTyxPQUFPO0lBQzlELElBQUlJLGFBQWEsSUFBSSxDQUFDZixnQkFBZ0IsQ0FBQ2MsTUFBTSxDQUFDLElBQUksQ0FBQ1gsUUFBUSxFQUFFQyxRQUFRTztJQUNyRSxJQUFJLENBQUNLLElBQUksQ0FBQyxtQkFBbUJEO0lBQzdCLE9BQU9BO0FBQ1g7QUFFQWhCLHVCQUF1QmMsU0FBUyxDQUFDSSxNQUFNLEdBQUcsU0FBU0MsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFlBQVk7SUFDM0UsSUFBSSxDQUFDcEIsZ0JBQWdCLENBQUNpQixNQUFNLENBQUNDLFFBQVFDLFFBQVFDO0lBQzdDLElBQUksQ0FBQ0osSUFBSSxDQUFDLG1CQUFtQixJQUFJO0FBQ3JDO0FBRUFLLE9BQU9DLE9BQU8sR0FBR3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1dlYlNvY2tldFJvdXRlclJlcXVlc3QuanM/M2I5OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQ29weXJpZ2h0IDIwMTAtMjAxNSBCcmlhbiBNY0tlbHZleS5cbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuZnVuY3Rpb24gV2ViU29ja2V0Um91dGVyUmVxdWVzdCh3ZWJTb2NrZXRSZXF1ZXN0LCByZXNvbHZlZFByb3RvY29sKSB7XG4gICAgLy8gU3VwZXJjbGFzcyBDb25zdHJ1Y3RvclxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy53ZWJTb2NrZXRSZXF1ZXN0ID0gd2ViU29ja2V0UmVxdWVzdDtcbiAgICBpZiAocmVzb2x2ZWRQcm90b2NvbCA9PT0gJ19fX19ub19wcm90b2NvbF9fX18nKSB7XG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5wcm90b2NvbCA9IHJlc29sdmVkUHJvdG9jb2w7XG4gICAgfVxuICAgIHRoaXMub3JpZ2luID0gd2ViU29ja2V0UmVxdWVzdC5vcmlnaW47XG4gICAgdGhpcy5yZXNvdXJjZSA9IHdlYlNvY2tldFJlcXVlc3QucmVzb3VyY2U7XG4gICAgdGhpcy5yZXNvdXJjZVVSTCA9IHdlYlNvY2tldFJlcXVlc3QucmVzb3VyY2VVUkw7XG4gICAgdGhpcy5odHRwUmVxdWVzdCA9IHdlYlNvY2tldFJlcXVlc3QuaHR0cFJlcXVlc3Q7XG4gICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gd2ViU29ja2V0UmVxdWVzdC5yZW1vdGVBZGRyZXNzO1xuICAgIHRoaXMud2ViU29ja2V0VmVyc2lvbiA9IHdlYlNvY2tldFJlcXVlc3Qud2ViU29ja2V0VmVyc2lvbjtcbiAgICB0aGlzLnJlcXVlc3RlZEV4dGVuc2lvbnMgPSB3ZWJTb2NrZXRSZXF1ZXN0LnJlcXVlc3RlZEV4dGVuc2lvbnM7XG4gICAgdGhpcy5jb29raWVzID0gd2ViU29ja2V0UmVxdWVzdC5jb29raWVzO1xufVxuXG51dGlsLmluaGVyaXRzKFdlYlNvY2tldFJvdXRlclJlcXVlc3QsIEV2ZW50RW1pdHRlcik7XG5cbldlYlNvY2tldFJvdXRlclJlcXVlc3QucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKG9yaWdpbiwgY29va2llcykge1xuICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy53ZWJTb2NrZXRSZXF1ZXN0LmFjY2VwdCh0aGlzLnByb3RvY29sLCBvcmlnaW4sIGNvb2tpZXMpO1xuICAgIHRoaXMuZW1pdCgncmVxdWVzdEFjY2VwdGVkJywgY29ubmVjdGlvbik7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG59O1xuXG5XZWJTb2NrZXRSb3V0ZXJSZXF1ZXN0LnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihzdGF0dXMsIHJlYXNvbiwgZXh0cmFIZWFkZXJzKSB7XG4gICAgdGhpcy53ZWJTb2NrZXRSZXF1ZXN0LnJlamVjdChzdGF0dXMsIHJlYXNvbiwgZXh0cmFIZWFkZXJzKTtcbiAgICB0aGlzLmVtaXQoJ3JlcXVlc3RSZWplY3RlZCcsIHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRSb3V0ZXJSZXF1ZXN0O1xuIl0sIm5hbWVzIjpbInV0aWwiLCJyZXF1aXJlIiwiRXZlbnRFbWl0dGVyIiwiV2ViU29ja2V0Um91dGVyUmVxdWVzdCIsIndlYlNvY2tldFJlcXVlc3QiLCJyZXNvbHZlZFByb3RvY29sIiwiY2FsbCIsInByb3RvY29sIiwib3JpZ2luIiwicmVzb3VyY2UiLCJyZXNvdXJjZVVSTCIsImh0dHBSZXF1ZXN0IiwicmVtb3RlQWRkcmVzcyIsIndlYlNvY2tldFZlcnNpb24iLCJyZXF1ZXN0ZWRFeHRlbnNpb25zIiwiY29va2llcyIsImluaGVyaXRzIiwicHJvdG90eXBlIiwiYWNjZXB0IiwiY29ubmVjdGlvbiIsImVtaXQiLCJyZWplY3QiLCJzdGF0dXMiLCJyZWFzb24iLCJleHRyYUhlYWRlcnMiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/WebSocketRouterRequest.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/WebSocketServer.js":
/*!*******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketServer.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/ var extend = (__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/websocket/lib/utils.js\").extend);\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/websocket/lib/utils.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/websocket/node_modules/debug/src/index.js\")(\"websocket:server\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar WebSocketRequest = __webpack_require__(/*! ./WebSocketRequest */ \"(ssr)/./node_modules/websocket/lib/WebSocketRequest.js\");\nvar WebSocketServer = function WebSocketServer(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n    this._handlers = {\n        upgrade: this.handleUpgrade.bind(this),\n        requestAccepted: this.handleRequestAccepted.bind(this),\n        requestResolved: this.handleRequestResolved.bind(this)\n    };\n    this.connections = [];\n    this.pendingRequests = [];\n    if (config) {\n        this.mount(config);\n    }\n};\nutil.inherits(WebSocketServer, EventEmitter);\nWebSocketServer.prototype.mount = function(config) {\n    this.config = {\n        // The http server instance to attach to.  Required.\n        httpServer: null,\n        // 64KiB max frame size.\n        maxReceivedFrameSize: 0x10000,\n        // 1MiB max message size, only applicable if\n        // assembleFragments is true\n        maxReceivedMessageSize: 0x100000,\n        // Outgoing messages larger than fragmentationThreshold will be\n        // split into multiple fragments.\n        fragmentOutgoingMessages: true,\n        // Outgoing frames are fragmented if they exceed this threshold.\n        // Default is 16KiB\n        fragmentationThreshold: 0x4000,\n        // If true, the server will automatically send a ping to all\n        // clients every 'keepaliveInterval' milliseconds.  The timer is\n        // reset on any received data from the client.\n        keepalive: true,\n        // The interval to send keepalive pings to connected clients if the\n        // connection is idle.  Any received data will reset the counter.\n        keepaliveInterval: 20000,\n        // If true, the server will consider any connection that has not\n        // received any data within the amount of time specified by\n        // 'keepaliveGracePeriod' after a keepalive ping has been sent to\n        // be dead, and will drop the connection.\n        // Ignored if keepalive is false.\n        dropConnectionOnKeepaliveTimeout: true,\n        // The amount of time to wait after sending a keepalive ping before\n        // closing the connection if the connected peer does not respond.\n        // Ignored if keepalive is false.\n        keepaliveGracePeriod: 10000,\n        // Whether to use native TCP keep-alive instead of WebSockets ping\n        // and pong packets.  Native TCP keep-alive sends smaller packets\n        // on the wire and so uses bandwidth more efficiently.  This may\n        // be more important when talking to mobile devices.\n        // If this value is set to true, then these values will be ignored:\n        //   keepaliveGracePeriod\n        //   dropConnectionOnKeepaliveTimeout\n        useNativeKeepalive: false,\n        // If true, fragmented messages will be automatically assembled\n        // and the full message will be emitted via a 'message' event.\n        // If false, each frame will be emitted via a 'frame' event and\n        // the application will be responsible for aggregating multiple\n        // fragmented frames.  Single-frame messages will emit a 'message'\n        // event in addition to the 'frame' event.\n        // Most users will want to leave this set to 'true'\n        assembleFragments: true,\n        // If this is true, websocket connections will be accepted\n        // regardless of the path and protocol specified by the client.\n        // The protocol accepted will be the first that was requested\n        // by the client.  Clients from any origin will be accepted.\n        // This should only be used in the simplest of cases.  You should\n        // probably leave this set to 'false' and inspect the request\n        // object to make sure it's acceptable before accepting it.\n        autoAcceptConnections: false,\n        // Whether or not the X-Forwarded-For header should be respected.\n        // It's important to set this to 'true' when accepting connections\n        // from untrusted clients, as a malicious client could spoof its\n        // IP address by simply setting this header.  It's meant to be added\n        // by a trusted proxy or other intermediary within your own\n        // infrastructure.\n        // See:  http://en.wikipedia.org/wiki/X-Forwarded-For\n        ignoreXForwardedFor: false,\n        // If this is true, 'cookie' headers are parsed and exposed as WebSocketRequest.cookies\n        parseCookies: true,\n        // If this is true, 'sec-websocket-extensions' headers are parsed and exposed as WebSocketRequest.requestedExtensions\n        parseExtensions: true,\n        // The Nagle Algorithm makes more efficient use of network resources\n        // by introducing a small delay before sending small packets so that\n        // multiple messages can be batched together before going onto the\n        // wire.  This however comes at the cost of latency, so the default\n        // is to disable it.  If you don't need low latency and are streaming\n        // lots of small messages, you can change this to 'false'\n        disableNagleAlgorithm: true,\n        // The number of milliseconds to wait after sending a close frame\n        // for an acknowledgement to come back before giving up and just\n        // closing the socket.\n        closeTimeout: 5000\n    };\n    extend(this.config, config);\n    if (this.config.httpServer) {\n        if (!Array.isArray(this.config.httpServer)) {\n            this.config.httpServer = [\n                this.config.httpServer\n            ];\n        }\n        var upgradeHandler = this._handlers.upgrade;\n        this.config.httpServer.forEach(function(httpServer) {\n            httpServer.on(\"upgrade\", upgradeHandler);\n        });\n    } else {\n        throw new Error(\"You must specify an httpServer on which to mount the WebSocket server.\");\n    }\n};\nWebSocketServer.prototype.unmount = function() {\n    var upgradeHandler = this._handlers.upgrade;\n    this.config.httpServer.forEach(function(httpServer) {\n        httpServer.removeListener(\"upgrade\", upgradeHandler);\n    });\n};\nWebSocketServer.prototype.closeAllConnections = function() {\n    this.connections.forEach(function(connection) {\n        connection.close();\n    });\n    this.pendingRequests.forEach(function(request) {\n        process.nextTick(function() {\n            request.reject(503); // HTTP 503 Service Unavailable\n        });\n    });\n};\nWebSocketServer.prototype.broadcast = function(data) {\n    if (Buffer.isBuffer(data)) {\n        this.broadcastBytes(data);\n    } else if (typeof data.toString === \"function\") {\n        this.broadcastUTF(data);\n    }\n};\nWebSocketServer.prototype.broadcastUTF = function(utfData) {\n    this.connections.forEach(function(connection) {\n        connection.sendUTF(utfData);\n    });\n};\nWebSocketServer.prototype.broadcastBytes = function(binaryData) {\n    this.connections.forEach(function(connection) {\n        connection.sendBytes(binaryData);\n    });\n};\nWebSocketServer.prototype.shutDown = function() {\n    this.unmount();\n    this.closeAllConnections();\n};\nWebSocketServer.prototype.handleUpgrade = function(request, socket) {\n    var self = this;\n    var wsRequest = new WebSocketRequest(socket, request, this.config);\n    try {\n        wsRequest.readHandshake();\n    } catch (e) {\n        wsRequest.reject(e.httpCode ? e.httpCode : 400, e.message, e.headers);\n        debug(\"Invalid handshake: %s\", e.message);\n        this.emit(\"upgradeError\", e);\n        return;\n    }\n    this.pendingRequests.push(wsRequest);\n    wsRequest.once(\"requestAccepted\", this._handlers.requestAccepted);\n    wsRequest.once(\"requestResolved\", this._handlers.requestResolved);\n    socket.once(\"close\", function() {\n        self._handlers.requestResolved(wsRequest);\n    });\n    if (!this.config.autoAcceptConnections && utils.eventEmitterListenerCount(this, \"request\") > 0) {\n        this.emit(\"request\", wsRequest);\n    } else if (this.config.autoAcceptConnections) {\n        wsRequest.accept(wsRequest.requestedProtocols[0], wsRequest.origin);\n    } else {\n        wsRequest.reject(404, \"No handler is configured to accept the connection.\");\n    }\n};\nWebSocketServer.prototype.handleRequestAccepted = function(connection) {\n    var self = this;\n    connection.once(\"close\", function(closeReason, description) {\n        self.handleConnectionClose(connection, closeReason, description);\n    });\n    this.connections.push(connection);\n    this.emit(\"connect\", connection);\n};\nWebSocketServer.prototype.handleConnectionClose = function(connection, closeReason, description) {\n    var index = this.connections.indexOf(connection);\n    if (index !== -1) {\n        this.connections.splice(index, 1);\n    }\n    this.emit(\"close\", connection, closeReason, description);\n};\nWebSocketServer.prototype.handleRequestResolved = function(request) {\n    var index = this.pendingRequests.indexOf(request);\n    if (index !== -1) {\n        this.pendingRequests.splice(index, 1);\n    }\n};\nmodule.exports = WebSocketServer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRTZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O3VFQWN1RSxHQUV2RSxJQUFJQSxTQUFTQywwRkFBeUI7QUFDdEMsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUUsT0FBT0YsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUcsUUFBUUgsbUJBQU9BLENBQUMsK0VBQVM7QUFDN0IsSUFBSUksZUFBZUosMERBQThCO0FBQ2pELElBQUlLLG1CQUFtQkwsbUJBQU9BLENBQUM7QUFFL0IsSUFBSU0sa0JBQWtCLFNBQVNBLGdCQUFnQkMsTUFBTTtJQUNqRCx5QkFBeUI7SUFDekJILGFBQWFJLElBQUksQ0FBQyxJQUFJO0lBRXRCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2JDLFNBQVMsSUFBSSxDQUFDQyxhQUFhLENBQUNDLElBQUksQ0FBQyxJQUFJO1FBQ3JDQyxpQkFBaUIsSUFBSSxDQUFDQyxxQkFBcUIsQ0FBQ0YsSUFBSSxDQUFDLElBQUk7UUFDckRHLGlCQUFpQixJQUFJLENBQUNDLHFCQUFxQixDQUFDSixJQUFJLENBQUMsSUFBSTtJQUN6RDtJQUNBLElBQUksQ0FBQ0ssV0FBVyxHQUFHLEVBQUU7SUFDckIsSUFBSSxDQUFDQyxlQUFlLEdBQUcsRUFBRTtJQUN6QixJQUFJWCxRQUFRO1FBQ1IsSUFBSSxDQUFDWSxLQUFLLENBQUNaO0lBQ2Y7QUFDSjtBQUVBTCxLQUFLa0IsUUFBUSxDQUFDZCxpQkFBaUJGO0FBRS9CRSxnQkFBZ0JlLFNBQVMsQ0FBQ0YsS0FBSyxHQUFHLFNBQVNaLE1BQU07SUFDN0MsSUFBSSxDQUFDQSxNQUFNLEdBQUc7UUFDVixvREFBb0Q7UUFDcERlLFlBQVk7UUFFWix3QkFBd0I7UUFDeEJDLHNCQUFzQjtRQUV0Qiw0Q0FBNEM7UUFDNUMsNEJBQTRCO1FBQzVCQyx3QkFBd0I7UUFFeEIsK0RBQStEO1FBQy9ELGlDQUFpQztRQUNqQ0MsMEJBQTBCO1FBRTFCLGdFQUFnRTtRQUNoRSxtQkFBbUI7UUFDbkJDLHdCQUF3QjtRQUV4Qiw0REFBNEQ7UUFDNUQsZ0VBQWdFO1FBQ2hFLDhDQUE4QztRQUM5Q0MsV0FBVztRQUVYLG1FQUFtRTtRQUNuRSxpRUFBaUU7UUFDakVDLG1CQUFtQjtRQUVuQixnRUFBZ0U7UUFDaEUsMkRBQTJEO1FBQzNELGlFQUFpRTtRQUNqRSx5Q0FBeUM7UUFDekMsaUNBQWlDO1FBQ2pDQyxrQ0FBa0M7UUFFbEMsbUVBQW1FO1FBQ25FLGlFQUFpRTtRQUNqRSxpQ0FBaUM7UUFDakNDLHNCQUFzQjtRQUV0QixrRUFBa0U7UUFDbEUsaUVBQWlFO1FBQ2pFLGdFQUFnRTtRQUNoRSxvREFBb0Q7UUFDcEQsbUVBQW1FO1FBQ25FLHlCQUF5QjtRQUN6QixxQ0FBcUM7UUFDckNDLG9CQUFvQjtRQUVwQiwrREFBK0Q7UUFDL0QsOERBQThEO1FBQzlELCtEQUErRDtRQUMvRCwrREFBK0Q7UUFDL0Qsa0VBQWtFO1FBQ2xFLDBDQUEwQztRQUMxQyxtREFBbUQ7UUFDbkRDLG1CQUFtQjtRQUVuQiwwREFBMEQ7UUFDMUQsK0RBQStEO1FBQy9ELDZEQUE2RDtRQUM3RCw0REFBNEQ7UUFDNUQsaUVBQWlFO1FBQ2pFLDZEQUE2RDtRQUM3RCwyREFBMkQ7UUFDM0RDLHVCQUF1QjtRQUV2QixpRUFBaUU7UUFDakUsa0VBQWtFO1FBQ2xFLGdFQUFnRTtRQUNoRSxvRUFBb0U7UUFDcEUsMkRBQTJEO1FBQzNELGtCQUFrQjtRQUNsQixxREFBcUQ7UUFDckRDLHFCQUFxQjtRQUVyQix1RkFBdUY7UUFDdkZDLGNBQWM7UUFFZCxxSEFBcUg7UUFDckhDLGlCQUFpQjtRQUVqQixvRUFBb0U7UUFDcEUsb0VBQW9FO1FBQ3BFLGtFQUFrRTtRQUNsRSxtRUFBbUU7UUFDbkUscUVBQXFFO1FBQ3JFLHlEQUF5RDtRQUN6REMsdUJBQXVCO1FBRXZCLGlFQUFpRTtRQUNqRSxnRUFBZ0U7UUFDaEUsc0JBQXNCO1FBQ3RCQyxjQUFjO0lBQ2xCO0lBQ0F2QyxPQUFPLElBQUksQ0FBQ1EsTUFBTSxFQUFFQTtJQUVwQixJQUFJLElBQUksQ0FBQ0EsTUFBTSxDQUFDZSxVQUFVLEVBQUU7UUFDeEIsSUFBSSxDQUFDaUIsTUFBTUMsT0FBTyxDQUFDLElBQUksQ0FBQ2pDLE1BQU0sQ0FBQ2UsVUFBVSxHQUFHO1lBQ3hDLElBQUksQ0FBQ2YsTUFBTSxDQUFDZSxVQUFVLEdBQUc7Z0JBQUMsSUFBSSxDQUFDZixNQUFNLENBQUNlLFVBQVU7YUFBQztRQUNyRDtRQUNBLElBQUltQixpQkFBaUIsSUFBSSxDQUFDaEMsU0FBUyxDQUFDQyxPQUFPO1FBQzNDLElBQUksQ0FBQ0gsTUFBTSxDQUFDZSxVQUFVLENBQUNvQixPQUFPLENBQUMsU0FBU3BCLFVBQVU7WUFDOUNBLFdBQVdxQixFQUFFLENBQUMsV0FBV0Y7UUFDN0I7SUFDSixPQUNLO1FBQ0QsTUFBTSxJQUFJRyxNQUFNO0lBQ3BCO0FBQ0o7QUFFQXRDLGdCQUFnQmUsU0FBUyxDQUFDd0IsT0FBTyxHQUFHO0lBQ2hDLElBQUlKLGlCQUFpQixJQUFJLENBQUNoQyxTQUFTLENBQUNDLE9BQU87SUFDM0MsSUFBSSxDQUFDSCxNQUFNLENBQUNlLFVBQVUsQ0FBQ29CLE9BQU8sQ0FBQyxTQUFTcEIsVUFBVTtRQUM5Q0EsV0FBV3dCLGNBQWMsQ0FBQyxXQUFXTDtJQUN6QztBQUNKO0FBRUFuQyxnQkFBZ0JlLFNBQVMsQ0FBQzBCLG1CQUFtQixHQUFHO0lBQzVDLElBQUksQ0FBQzlCLFdBQVcsQ0FBQ3lCLE9BQU8sQ0FBQyxTQUFTTSxVQUFVO1FBQ3hDQSxXQUFXQyxLQUFLO0lBQ3BCO0lBQ0EsSUFBSSxDQUFDL0IsZUFBZSxDQUFDd0IsT0FBTyxDQUFDLFNBQVNRLE9BQU87UUFDekNDLFFBQVFDLFFBQVEsQ0FBQztZQUNmRixRQUFRRyxNQUFNLENBQUMsTUFBTSwrQkFBK0I7UUFDdEQ7SUFDSjtBQUNKO0FBRUEvQyxnQkFBZ0JlLFNBQVMsQ0FBQ2lDLFNBQVMsR0FBRyxTQUFTQyxJQUFJO0lBQy9DLElBQUlDLE9BQU9DLFFBQVEsQ0FBQ0YsT0FBTztRQUN2QixJQUFJLENBQUNHLGNBQWMsQ0FBQ0g7SUFDeEIsT0FDSyxJQUFJLE9BQU9BLEtBQUtJLFFBQVEsS0FBTSxZQUFZO1FBQzNDLElBQUksQ0FBQ0MsWUFBWSxDQUFDTDtJQUN0QjtBQUNKO0FBRUFqRCxnQkFBZ0JlLFNBQVMsQ0FBQ3VDLFlBQVksR0FBRyxTQUFTQyxPQUFPO0lBQ3JELElBQUksQ0FBQzVDLFdBQVcsQ0FBQ3lCLE9BQU8sQ0FBQyxTQUFTTSxVQUFVO1FBQ3hDQSxXQUFXYyxPQUFPLENBQUNEO0lBQ3ZCO0FBQ0o7QUFFQXZELGdCQUFnQmUsU0FBUyxDQUFDcUMsY0FBYyxHQUFHLFNBQVNLLFVBQVU7SUFDMUQsSUFBSSxDQUFDOUMsV0FBVyxDQUFDeUIsT0FBTyxDQUFDLFNBQVNNLFVBQVU7UUFDeENBLFdBQVdnQixTQUFTLENBQUNEO0lBQ3pCO0FBQ0o7QUFFQXpELGdCQUFnQmUsU0FBUyxDQUFDNEMsUUFBUSxHQUFHO0lBQ2pDLElBQUksQ0FBQ3BCLE9BQU87SUFDWixJQUFJLENBQUNFLG1CQUFtQjtBQUM1QjtBQUVBekMsZ0JBQWdCZSxTQUFTLENBQUNWLGFBQWEsR0FBRyxTQUFTdUMsT0FBTyxFQUFFZ0IsTUFBTTtJQUM5RCxJQUFJQyxPQUFPLElBQUk7SUFDZixJQUFJQyxZQUFZLElBQUkvRCxpQkFBaUI2RCxRQUFRaEIsU0FBUyxJQUFJLENBQUMzQyxNQUFNO0lBQ2pFLElBQUk7UUFDQTZELFVBQVVDLGFBQWE7SUFDM0IsRUFDQSxPQUFNQyxHQUFHO1FBQ0xGLFVBQVVmLE1BQU0sQ0FDWmlCLEVBQUVDLFFBQVEsR0FBR0QsRUFBRUMsUUFBUSxHQUFHLEtBQzFCRCxFQUFFRSxPQUFPLEVBQ1RGLEVBQUVHLE9BQU87UUFFYnRFLE1BQU0seUJBQXlCbUUsRUFBRUUsT0FBTztRQUN4QyxJQUFJLENBQUNFLElBQUksQ0FBQyxnQkFBZ0JKO1FBQzFCO0lBQ0o7SUFFQSxJQUFJLENBQUNwRCxlQUFlLENBQUN5RCxJQUFJLENBQUNQO0lBRTFCQSxVQUFVUSxJQUFJLENBQUMsbUJBQW1CLElBQUksQ0FBQ25FLFNBQVMsQ0FBQ0ksZUFBZTtJQUNoRXVELFVBQVVRLElBQUksQ0FBQyxtQkFBbUIsSUFBSSxDQUFDbkUsU0FBUyxDQUFDTSxlQUFlO0lBQ2hFbUQsT0FBT1UsSUFBSSxDQUFDLFNBQVM7UUFDakJULEtBQUsxRCxTQUFTLENBQUNNLGVBQWUsQ0FBQ3FEO0lBQ25DO0lBRUEsSUFBSSxDQUFDLElBQUksQ0FBQzdELE1BQU0sQ0FBQzBCLHFCQUFxQixJQUFJaEMsTUFBTTRFLHlCQUF5QixDQUFDLElBQUksRUFBRSxhQUFhLEdBQUc7UUFDNUYsSUFBSSxDQUFDSCxJQUFJLENBQUMsV0FBV047SUFDekIsT0FDSyxJQUFJLElBQUksQ0FBQzdELE1BQU0sQ0FBQzBCLHFCQUFxQixFQUFFO1FBQ3hDbUMsVUFBVVUsTUFBTSxDQUFDVixVQUFVVyxrQkFBa0IsQ0FBQyxFQUFFLEVBQUVYLFVBQVVZLE1BQU07SUFDdEUsT0FDSztRQUNEWixVQUFVZixNQUFNLENBQUMsS0FBSztJQUMxQjtBQUNKO0FBRUEvQyxnQkFBZ0JlLFNBQVMsQ0FBQ1AscUJBQXFCLEdBQUcsU0FBU2tDLFVBQVU7SUFDakUsSUFBSW1CLE9BQU8sSUFBSTtJQUNmbkIsV0FBVzRCLElBQUksQ0FBQyxTQUFTLFNBQVNLLFdBQVcsRUFBRUMsV0FBVztRQUN0RGYsS0FBS2dCLHFCQUFxQixDQUFDbkMsWUFBWWlDLGFBQWFDO0lBQ3hEO0lBQ0EsSUFBSSxDQUFDakUsV0FBVyxDQUFDMEQsSUFBSSxDQUFDM0I7SUFDdEIsSUFBSSxDQUFDMEIsSUFBSSxDQUFDLFdBQVcxQjtBQUN6QjtBQUVBMUMsZ0JBQWdCZSxTQUFTLENBQUM4RCxxQkFBcUIsR0FBRyxTQUFTbkMsVUFBVSxFQUFFaUMsV0FBVyxFQUFFQyxXQUFXO0lBQzNGLElBQUlFLFFBQVEsSUFBSSxDQUFDbkUsV0FBVyxDQUFDb0UsT0FBTyxDQUFDckM7SUFDckMsSUFBSW9DLFVBQVUsQ0FBQyxHQUFHO1FBQ2QsSUFBSSxDQUFDbkUsV0FBVyxDQUFDcUUsTUFBTSxDQUFDRixPQUFPO0lBQ25DO0lBQ0EsSUFBSSxDQUFDVixJQUFJLENBQUMsU0FBUzFCLFlBQVlpQyxhQUFhQztBQUNoRDtBQUVBNUUsZ0JBQWdCZSxTQUFTLENBQUNMLHFCQUFxQixHQUFHLFNBQVNrQyxPQUFPO0lBQzlELElBQUlrQyxRQUFRLElBQUksQ0FBQ2xFLGVBQWUsQ0FBQ21FLE9BQU8sQ0FBQ25DO0lBQ3pDLElBQUlrQyxVQUFVLENBQUMsR0FBRztRQUFFLElBQUksQ0FBQ2xFLGVBQWUsQ0FBQ29FLE1BQU0sQ0FBQ0YsT0FBTztJQUFJO0FBQy9EO0FBRUFHLE9BQU9DLE9BQU8sR0FBR2xGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1dlYlNvY2tldFNlcnZlci5qcz9hZGI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDb3B5cmlnaHQgMjAxMC0yMDE1IEJyaWFuIE1jS2VsdmV5LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4vdXRpbHMnKS5leHRlbmQ7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3dlYnNvY2tldDpzZXJ2ZXInKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgV2ViU29ja2V0UmVxdWVzdCA9IHJlcXVpcmUoJy4vV2ViU29ja2V0UmVxdWVzdCcpO1xuXG52YXIgV2ViU29ja2V0U2VydmVyID0gZnVuY3Rpb24gV2ViU29ja2V0U2VydmVyKGNvbmZpZykge1xuICAgIC8vIFN1cGVyY2xhc3MgQ29uc3RydWN0b3JcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuX2hhbmRsZXJzID0ge1xuICAgICAgICB1cGdyYWRlOiB0aGlzLmhhbmRsZVVwZ3JhZGUuYmluZCh0aGlzKSxcbiAgICAgICAgcmVxdWVzdEFjY2VwdGVkOiB0aGlzLmhhbmRsZVJlcXVlc3RBY2NlcHRlZC5iaW5kKHRoaXMpLFxuICAgICAgICByZXF1ZXN0UmVzb2x2ZWQ6IHRoaXMuaGFuZGxlUmVxdWVzdFJlc29sdmVkLmJpbmQodGhpcylcbiAgICB9O1xuICAgIHRoaXMuY29ubmVjdGlvbnMgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cyA9IFtdO1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgdGhpcy5tb3VudChjb25maWcpO1xuICAgIH1cbn07XG5cbnV0aWwuaW5oZXJpdHMoV2ViU29ja2V0U2VydmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5XZWJTb2NrZXRTZXJ2ZXIucHJvdG90eXBlLm1vdW50ID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAgIC8vIFRoZSBodHRwIHNlcnZlciBpbnN0YW5jZSB0byBhdHRhY2ggdG8uICBSZXF1aXJlZC5cbiAgICAgICAgaHR0cFNlcnZlcjogbnVsbCxcblxuICAgICAgICAvLyA2NEtpQiBtYXggZnJhbWUgc2l6ZS5cbiAgICAgICAgbWF4UmVjZWl2ZWRGcmFtZVNpemU6IDB4MTAwMDAsXG5cbiAgICAgICAgLy8gMU1pQiBtYXggbWVzc2FnZSBzaXplLCBvbmx5IGFwcGxpY2FibGUgaWZcbiAgICAgICAgLy8gYXNzZW1ibGVGcmFnbWVudHMgaXMgdHJ1ZVxuICAgICAgICBtYXhSZWNlaXZlZE1lc3NhZ2VTaXplOiAweDEwMDAwMCxcblxuICAgICAgICAvLyBPdXRnb2luZyBtZXNzYWdlcyBsYXJnZXIgdGhhbiBmcmFnbWVudGF0aW9uVGhyZXNob2xkIHdpbGwgYmVcbiAgICAgICAgLy8gc3BsaXQgaW50byBtdWx0aXBsZSBmcmFnbWVudHMuXG4gICAgICAgIGZyYWdtZW50T3V0Z29pbmdNZXNzYWdlczogdHJ1ZSxcblxuICAgICAgICAvLyBPdXRnb2luZyBmcmFtZXMgYXJlIGZyYWdtZW50ZWQgaWYgdGhleSBleGNlZWQgdGhpcyB0aHJlc2hvbGQuXG4gICAgICAgIC8vIERlZmF1bHQgaXMgMTZLaUJcbiAgICAgICAgZnJhZ21lbnRhdGlvblRocmVzaG9sZDogMHg0MDAwLFxuXG4gICAgICAgIC8vIElmIHRydWUsIHRoZSBzZXJ2ZXIgd2lsbCBhdXRvbWF0aWNhbGx5IHNlbmQgYSBwaW5nIHRvIGFsbFxuICAgICAgICAvLyBjbGllbnRzIGV2ZXJ5ICdrZWVwYWxpdmVJbnRlcnZhbCcgbWlsbGlzZWNvbmRzLiAgVGhlIHRpbWVyIGlzXG4gICAgICAgIC8vIHJlc2V0IG9uIGFueSByZWNlaXZlZCBkYXRhIGZyb20gdGhlIGNsaWVudC5cbiAgICAgICAga2VlcGFsaXZlOiB0cnVlLFxuXG4gICAgICAgIC8vIFRoZSBpbnRlcnZhbCB0byBzZW5kIGtlZXBhbGl2ZSBwaW5ncyB0byBjb25uZWN0ZWQgY2xpZW50cyBpZiB0aGVcbiAgICAgICAgLy8gY29ubmVjdGlvbiBpcyBpZGxlLiAgQW55IHJlY2VpdmVkIGRhdGEgd2lsbCByZXNldCB0aGUgY291bnRlci5cbiAgICAgICAga2VlcGFsaXZlSW50ZXJ2YWw6IDIwMDAwLFxuXG4gICAgICAgIC8vIElmIHRydWUsIHRoZSBzZXJ2ZXIgd2lsbCBjb25zaWRlciBhbnkgY29ubmVjdGlvbiB0aGF0IGhhcyBub3RcbiAgICAgICAgLy8gcmVjZWl2ZWQgYW55IGRhdGEgd2l0aGluIHRoZSBhbW91bnQgb2YgdGltZSBzcGVjaWZpZWQgYnlcbiAgICAgICAgLy8gJ2tlZXBhbGl2ZUdyYWNlUGVyaW9kJyBhZnRlciBhIGtlZXBhbGl2ZSBwaW5nIGhhcyBiZWVuIHNlbnQgdG9cbiAgICAgICAgLy8gYmUgZGVhZCwgYW5kIHdpbGwgZHJvcCB0aGUgY29ubmVjdGlvbi5cbiAgICAgICAgLy8gSWdub3JlZCBpZiBrZWVwYWxpdmUgaXMgZmFsc2UuXG4gICAgICAgIGRyb3BDb25uZWN0aW9uT25LZWVwYWxpdmVUaW1lb3V0OiB0cnVlLFxuXG4gICAgICAgIC8vIFRoZSBhbW91bnQgb2YgdGltZSB0byB3YWl0IGFmdGVyIHNlbmRpbmcgYSBrZWVwYWxpdmUgcGluZyBiZWZvcmVcbiAgICAgICAgLy8gY2xvc2luZyB0aGUgY29ubmVjdGlvbiBpZiB0aGUgY29ubmVjdGVkIHBlZXIgZG9lcyBub3QgcmVzcG9uZC5cbiAgICAgICAgLy8gSWdub3JlZCBpZiBrZWVwYWxpdmUgaXMgZmFsc2UuXG4gICAgICAgIGtlZXBhbGl2ZUdyYWNlUGVyaW9kOiAxMDAwMCxcblxuICAgICAgICAvLyBXaGV0aGVyIHRvIHVzZSBuYXRpdmUgVENQIGtlZXAtYWxpdmUgaW5zdGVhZCBvZiBXZWJTb2NrZXRzIHBpbmdcbiAgICAgICAgLy8gYW5kIHBvbmcgcGFja2V0cy4gIE5hdGl2ZSBUQ1Aga2VlcC1hbGl2ZSBzZW5kcyBzbWFsbGVyIHBhY2tldHNcbiAgICAgICAgLy8gb24gdGhlIHdpcmUgYW5kIHNvIHVzZXMgYmFuZHdpZHRoIG1vcmUgZWZmaWNpZW50bHkuICBUaGlzIG1heVxuICAgICAgICAvLyBiZSBtb3JlIGltcG9ydGFudCB3aGVuIHRhbGtpbmcgdG8gbW9iaWxlIGRldmljZXMuXG4gICAgICAgIC8vIElmIHRoaXMgdmFsdWUgaXMgc2V0IHRvIHRydWUsIHRoZW4gdGhlc2UgdmFsdWVzIHdpbGwgYmUgaWdub3JlZDpcbiAgICAgICAgLy8gICBrZWVwYWxpdmVHcmFjZVBlcmlvZFxuICAgICAgICAvLyAgIGRyb3BDb25uZWN0aW9uT25LZWVwYWxpdmVUaW1lb3V0XG4gICAgICAgIHVzZU5hdGl2ZUtlZXBhbGl2ZTogZmFsc2UsXG5cbiAgICAgICAgLy8gSWYgdHJ1ZSwgZnJhZ21lbnRlZCBtZXNzYWdlcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYXNzZW1ibGVkXG4gICAgICAgIC8vIGFuZCB0aGUgZnVsbCBtZXNzYWdlIHdpbGwgYmUgZW1pdHRlZCB2aWEgYSAnbWVzc2FnZScgZXZlbnQuXG4gICAgICAgIC8vIElmIGZhbHNlLCBlYWNoIGZyYW1lIHdpbGwgYmUgZW1pdHRlZCB2aWEgYSAnZnJhbWUnIGV2ZW50IGFuZFxuICAgICAgICAvLyB0aGUgYXBwbGljYXRpb24gd2lsbCBiZSByZXNwb25zaWJsZSBmb3IgYWdncmVnYXRpbmcgbXVsdGlwbGVcbiAgICAgICAgLy8gZnJhZ21lbnRlZCBmcmFtZXMuICBTaW5nbGUtZnJhbWUgbWVzc2FnZXMgd2lsbCBlbWl0IGEgJ21lc3NhZ2UnXG4gICAgICAgIC8vIGV2ZW50IGluIGFkZGl0aW9uIHRvIHRoZSAnZnJhbWUnIGV2ZW50LlxuICAgICAgICAvLyBNb3N0IHVzZXJzIHdpbGwgd2FudCB0byBsZWF2ZSB0aGlzIHNldCB0byAndHJ1ZSdcbiAgICAgICAgYXNzZW1ibGVGcmFnbWVudHM6IHRydWUsXG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0cnVlLCB3ZWJzb2NrZXQgY29ubmVjdGlvbnMgd2lsbCBiZSBhY2NlcHRlZFxuICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHRoZSBwYXRoIGFuZCBwcm90b2NvbCBzcGVjaWZpZWQgYnkgdGhlIGNsaWVudC5cbiAgICAgICAgLy8gVGhlIHByb3RvY29sIGFjY2VwdGVkIHdpbGwgYmUgdGhlIGZpcnN0IHRoYXQgd2FzIHJlcXVlc3RlZFxuICAgICAgICAvLyBieSB0aGUgY2xpZW50LiAgQ2xpZW50cyBmcm9tIGFueSBvcmlnaW4gd2lsbCBiZSBhY2NlcHRlZC5cbiAgICAgICAgLy8gVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIGluIHRoZSBzaW1wbGVzdCBvZiBjYXNlcy4gIFlvdSBzaG91bGRcbiAgICAgICAgLy8gcHJvYmFibHkgbGVhdmUgdGhpcyBzZXQgdG8gJ2ZhbHNlJyBhbmQgaW5zcGVjdCB0aGUgcmVxdWVzdFxuICAgICAgICAvLyBvYmplY3QgdG8gbWFrZSBzdXJlIGl0J3MgYWNjZXB0YWJsZSBiZWZvcmUgYWNjZXB0aW5nIGl0LlxuICAgICAgICBhdXRvQWNjZXB0Q29ubmVjdGlvbnM6IGZhbHNlLFxuXG4gICAgICAgIC8vIFdoZXRoZXIgb3Igbm90IHRoZSBYLUZvcndhcmRlZC1Gb3IgaGVhZGVyIHNob3VsZCBiZSByZXNwZWN0ZWQuXG4gICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIHNldCB0aGlzIHRvICd0cnVlJyB3aGVuIGFjY2VwdGluZyBjb25uZWN0aW9uc1xuICAgICAgICAvLyBmcm9tIHVudHJ1c3RlZCBjbGllbnRzLCBhcyBhIG1hbGljaW91cyBjbGllbnQgY291bGQgc3Bvb2YgaXRzXG4gICAgICAgIC8vIElQIGFkZHJlc3MgYnkgc2ltcGx5IHNldHRpbmcgdGhpcyBoZWFkZXIuICBJdCdzIG1lYW50IHRvIGJlIGFkZGVkXG4gICAgICAgIC8vIGJ5IGEgdHJ1c3RlZCBwcm94eSBvciBvdGhlciBpbnRlcm1lZGlhcnkgd2l0aGluIHlvdXIgb3duXG4gICAgICAgIC8vIGluZnJhc3RydWN0dXJlLlxuICAgICAgICAvLyBTZWU6ICBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1gtRm9yd2FyZGVkLUZvclxuICAgICAgICBpZ25vcmVYRm9yd2FyZGVkRm9yOiBmYWxzZSxcblxuICAgICAgICAvLyBJZiB0aGlzIGlzIHRydWUsICdjb29raWUnIGhlYWRlcnMgYXJlIHBhcnNlZCBhbmQgZXhwb3NlZCBhcyBXZWJTb2NrZXRSZXF1ZXN0LmNvb2tpZXNcbiAgICAgICAgcGFyc2VDb29raWVzOiB0cnVlLFxuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgdHJ1ZSwgJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucycgaGVhZGVycyBhcmUgcGFyc2VkIGFuZCBleHBvc2VkIGFzIFdlYlNvY2tldFJlcXVlc3QucmVxdWVzdGVkRXh0ZW5zaW9uc1xuICAgICAgICBwYXJzZUV4dGVuc2lvbnM6IHRydWUsXG5cbiAgICAgICAgLy8gVGhlIE5hZ2xlIEFsZ29yaXRobSBtYWtlcyBtb3JlIGVmZmljaWVudCB1c2Ugb2YgbmV0d29yayByZXNvdXJjZXNcbiAgICAgICAgLy8gYnkgaW50cm9kdWNpbmcgYSBzbWFsbCBkZWxheSBiZWZvcmUgc2VuZGluZyBzbWFsbCBwYWNrZXRzIHNvIHRoYXRcbiAgICAgICAgLy8gbXVsdGlwbGUgbWVzc2FnZXMgY2FuIGJlIGJhdGNoZWQgdG9nZXRoZXIgYmVmb3JlIGdvaW5nIG9udG8gdGhlXG4gICAgICAgIC8vIHdpcmUuICBUaGlzIGhvd2V2ZXIgY29tZXMgYXQgdGhlIGNvc3Qgb2YgbGF0ZW5jeSwgc28gdGhlIGRlZmF1bHRcbiAgICAgICAgLy8gaXMgdG8gZGlzYWJsZSBpdC4gIElmIHlvdSBkb24ndCBuZWVkIGxvdyBsYXRlbmN5IGFuZCBhcmUgc3RyZWFtaW5nXG4gICAgICAgIC8vIGxvdHMgb2Ygc21hbGwgbWVzc2FnZXMsIHlvdSBjYW4gY2hhbmdlIHRoaXMgdG8gJ2ZhbHNlJ1xuICAgICAgICBkaXNhYmxlTmFnbGVBbGdvcml0aG06IHRydWUsXG5cbiAgICAgICAgLy8gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBhZnRlciBzZW5kaW5nIGEgY2xvc2UgZnJhbWVcbiAgICAgICAgLy8gZm9yIGFuIGFja25vd2xlZGdlbWVudCB0byBjb21lIGJhY2sgYmVmb3JlIGdpdmluZyB1cCBhbmQganVzdFxuICAgICAgICAvLyBjbG9zaW5nIHRoZSBzb2NrZXQuXG4gICAgICAgIGNsb3NlVGltZW91dDogNTAwMFxuICAgIH07XG4gICAgZXh0ZW5kKHRoaXMuY29uZmlnLCBjb25maWcpO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLmh0dHBTZXJ2ZXIpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuY29uZmlnLmh0dHBTZXJ2ZXIpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5odHRwU2VydmVyID0gW3RoaXMuY29uZmlnLmh0dHBTZXJ2ZXJdO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cGdyYWRlSGFuZGxlciA9IHRoaXMuX2hhbmRsZXJzLnVwZ3JhZGU7XG4gICAgICAgIHRoaXMuY29uZmlnLmh0dHBTZXJ2ZXIuZm9yRWFjaChmdW5jdGlvbihodHRwU2VydmVyKSB7XG4gICAgICAgICAgICBodHRwU2VydmVyLm9uKCd1cGdyYWRlJywgdXBncmFkZUhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBhbiBodHRwU2VydmVyIG9uIHdoaWNoIHRvIG1vdW50IHRoZSBXZWJTb2NrZXQgc2VydmVyLicpO1xuICAgIH1cbn07XG5cbldlYlNvY2tldFNlcnZlci5wcm90b3R5cGUudW5tb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB1cGdyYWRlSGFuZGxlciA9IHRoaXMuX2hhbmRsZXJzLnVwZ3JhZGU7XG4gICAgdGhpcy5jb25maWcuaHR0cFNlcnZlci5mb3JFYWNoKGZ1bmN0aW9uKGh0dHBTZXJ2ZXIpIHtcbiAgICAgICAgaHR0cFNlcnZlci5yZW1vdmVMaXN0ZW5lcigndXBncmFkZScsIHVwZ3JhZGVIYW5kbGVyKTtcbiAgICB9KTtcbn07XG5cbldlYlNvY2tldFNlcnZlci5wcm90b3R5cGUuY2xvc2VBbGxDb25uZWN0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29ubmVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICB9KTtcbiAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5mb3JFYWNoKGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXF1ZXN0LnJlamVjdCg1MDMpOyAvLyBIVFRQIDUwMyBTZXJ2aWNlIFVuYXZhaWxhYmxlXG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuV2ViU29ja2V0U2VydmVyLnByb3RvdHlwZS5icm9hZGNhc3QgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICB0aGlzLmJyb2FkY2FzdEJ5dGVzKGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YoZGF0YS50b1N0cmluZykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5icm9hZGNhc3RVVEYoZGF0YSk7XG4gICAgfVxufTtcblxuV2ViU29ja2V0U2VydmVyLnByb3RvdHlwZS5icm9hZGNhc3RVVEYgPSBmdW5jdGlvbih1dGZEYXRhKSB7XG4gICAgdGhpcy5jb25uZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgY29ubmVjdGlvbi5zZW5kVVRGKHV0ZkRhdGEpO1xuICAgIH0pO1xufTtcblxuV2ViU29ja2V0U2VydmVyLnByb3RvdHlwZS5icm9hZGNhc3RCeXRlcyA9IGZ1bmN0aW9uKGJpbmFyeURhdGEpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgICBjb25uZWN0aW9uLnNlbmRCeXRlcyhiaW5hcnlEYXRhKTtcbiAgICB9KTtcbn07XG5cbldlYlNvY2tldFNlcnZlci5wcm90b3R5cGUuc2h1dERvd24gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVubW91bnQoKTtcbiAgICB0aGlzLmNsb3NlQWxsQ29ubmVjdGlvbnMoKTtcbn07XG5cbldlYlNvY2tldFNlcnZlci5wcm90b3R5cGUuaGFuZGxlVXBncmFkZSA9IGZ1bmN0aW9uKHJlcXVlc3QsIHNvY2tldCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgd3NSZXF1ZXN0ID0gbmV3IFdlYlNvY2tldFJlcXVlc3Qoc29ja2V0LCByZXF1ZXN0LCB0aGlzLmNvbmZpZyk7XG4gICAgdHJ5IHtcbiAgICAgICAgd3NSZXF1ZXN0LnJlYWRIYW5kc2hha2UoKTtcbiAgICB9XG4gICAgY2F0Y2goZSkge1xuICAgICAgICB3c1JlcXVlc3QucmVqZWN0KFxuICAgICAgICAgICAgZS5odHRwQ29kZSA/IGUuaHR0cENvZGUgOiA0MDAsXG4gICAgICAgICAgICBlLm1lc3NhZ2UsXG4gICAgICAgICAgICBlLmhlYWRlcnNcbiAgICAgICAgKTtcbiAgICAgICAgZGVidWcoJ0ludmFsaWQgaGFuZHNoYWtlOiAlcycsIGUubWVzc2FnZSk7XG4gICAgICAgIHRoaXMuZW1pdCgndXBncmFkZUVycm9yJywgZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5wdXNoKHdzUmVxdWVzdCk7XG5cbiAgICB3c1JlcXVlc3Qub25jZSgncmVxdWVzdEFjY2VwdGVkJywgdGhpcy5faGFuZGxlcnMucmVxdWVzdEFjY2VwdGVkKTtcbiAgICB3c1JlcXVlc3Qub25jZSgncmVxdWVzdFJlc29sdmVkJywgdGhpcy5faGFuZGxlcnMucmVxdWVzdFJlc29sdmVkKTtcbiAgICBzb2NrZXQub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX2hhbmRsZXJzLnJlcXVlc3RSZXNvbHZlZCh3c1JlcXVlc3QpO1xuICAgIH0pO1xuXG4gICAgaWYgKCF0aGlzLmNvbmZpZy5hdXRvQWNjZXB0Q29ubmVjdGlvbnMgJiYgdXRpbHMuZXZlbnRFbWl0dGVyTGlzdGVuZXJDb3VudCh0aGlzLCAncmVxdWVzdCcpID4gMCkge1xuICAgICAgICB0aGlzLmVtaXQoJ3JlcXVlc3QnLCB3c1JlcXVlc3QpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmNvbmZpZy5hdXRvQWNjZXB0Q29ubmVjdGlvbnMpIHtcbiAgICAgICAgd3NSZXF1ZXN0LmFjY2VwdCh3c1JlcXVlc3QucmVxdWVzdGVkUHJvdG9jb2xzWzBdLCB3c1JlcXVlc3Qub3JpZ2luKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdzUmVxdWVzdC5yZWplY3QoNDA0LCAnTm8gaGFuZGxlciBpcyBjb25maWd1cmVkIHRvIGFjY2VwdCB0aGUgY29ubmVjdGlvbi4nKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRTZXJ2ZXIucHJvdG90eXBlLmhhbmRsZVJlcXVlc3RBY2NlcHRlZCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgY29ubmVjdGlvbi5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKGNsb3NlUmVhc29uLCBkZXNjcmlwdGlvbikge1xuICAgICAgICBzZWxmLmhhbmRsZUNvbm5lY3Rpb25DbG9zZShjb25uZWN0aW9uLCBjbG9zZVJlYXNvbiwgZGVzY3JpcHRpb24pO1xuICAgIH0pO1xuICAgIHRoaXMuY29ubmVjdGlvbnMucHVzaChjb25uZWN0aW9uKTtcbiAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnLCBjb25uZWN0aW9uKTtcbn07XG5cbldlYlNvY2tldFNlcnZlci5wcm90b3R5cGUuaGFuZGxlQ29ubmVjdGlvbkNsb3NlID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgY2xvc2VSZWFzb24sIGRlc2NyaXB0aW9uKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5jb25uZWN0aW9ucy5pbmRleE9mKGNvbm5lY3Rpb24pO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgY29ubmVjdGlvbiwgY2xvc2VSZWFzb24sIGRlc2NyaXB0aW9uKTtcbn07XG5cbldlYlNvY2tldFNlcnZlci5wcm90b3R5cGUuaGFuZGxlUmVxdWVzdFJlc29sdmVkID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMucGVuZGluZ1JlcXVlc3RzLmluZGV4T2YocmVxdWVzdCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkgeyB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5zcGxpY2UoaW5kZXgsIDEpOyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFNlcnZlcjtcbiJdLCJuYW1lcyI6WyJleHRlbmQiLCJyZXF1aXJlIiwidXRpbHMiLCJ1dGlsIiwiZGVidWciLCJFdmVudEVtaXR0ZXIiLCJXZWJTb2NrZXRSZXF1ZXN0IiwiV2ViU29ja2V0U2VydmVyIiwiY29uZmlnIiwiY2FsbCIsIl9oYW5kbGVycyIsInVwZ3JhZGUiLCJoYW5kbGVVcGdyYWRlIiwiYmluZCIsInJlcXVlc3RBY2NlcHRlZCIsImhhbmRsZVJlcXVlc3RBY2NlcHRlZCIsInJlcXVlc3RSZXNvbHZlZCIsImhhbmRsZVJlcXVlc3RSZXNvbHZlZCIsImNvbm5lY3Rpb25zIiwicGVuZGluZ1JlcXVlc3RzIiwibW91bnQiLCJpbmhlcml0cyIsInByb3RvdHlwZSIsImh0dHBTZXJ2ZXIiLCJtYXhSZWNlaXZlZEZyYW1lU2l6ZSIsIm1heFJlY2VpdmVkTWVzc2FnZVNpemUiLCJmcmFnbWVudE91dGdvaW5nTWVzc2FnZXMiLCJmcmFnbWVudGF0aW9uVGhyZXNob2xkIiwia2VlcGFsaXZlIiwia2VlcGFsaXZlSW50ZXJ2YWwiLCJkcm9wQ29ubmVjdGlvbk9uS2VlcGFsaXZlVGltZW91dCIsImtlZXBhbGl2ZUdyYWNlUGVyaW9kIiwidXNlTmF0aXZlS2VlcGFsaXZlIiwiYXNzZW1ibGVGcmFnbWVudHMiLCJhdXRvQWNjZXB0Q29ubmVjdGlvbnMiLCJpZ25vcmVYRm9yd2FyZGVkRm9yIiwicGFyc2VDb29raWVzIiwicGFyc2VFeHRlbnNpb25zIiwiZGlzYWJsZU5hZ2xlQWxnb3JpdGhtIiwiY2xvc2VUaW1lb3V0IiwiQXJyYXkiLCJpc0FycmF5IiwidXBncmFkZUhhbmRsZXIiLCJmb3JFYWNoIiwib24iLCJFcnJvciIsInVubW91bnQiLCJyZW1vdmVMaXN0ZW5lciIsImNsb3NlQWxsQ29ubmVjdGlvbnMiLCJjb25uZWN0aW9uIiwiY2xvc2UiLCJyZXF1ZXN0IiwicHJvY2VzcyIsIm5leHRUaWNrIiwicmVqZWN0IiwiYnJvYWRjYXN0IiwiZGF0YSIsIkJ1ZmZlciIsImlzQnVmZmVyIiwiYnJvYWRjYXN0Qnl0ZXMiLCJ0b1N0cmluZyIsImJyb2FkY2FzdFVURiIsInV0ZkRhdGEiLCJzZW5kVVRGIiwiYmluYXJ5RGF0YSIsInNlbmRCeXRlcyIsInNodXREb3duIiwic29ja2V0Iiwic2VsZiIsIndzUmVxdWVzdCIsInJlYWRIYW5kc2hha2UiLCJlIiwiaHR0cENvZGUiLCJtZXNzYWdlIiwiaGVhZGVycyIsImVtaXQiLCJwdXNoIiwib25jZSIsImV2ZW50RW1pdHRlckxpc3RlbmVyQ291bnQiLCJhY2NlcHQiLCJyZXF1ZXN0ZWRQcm90b2NvbHMiLCJvcmlnaW4iLCJjbG9zZVJlYXNvbiIsImRlc2NyaXB0aW9uIiwiaGFuZGxlQ29ubmVjdGlvbkNsb3NlIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/WebSocketServer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/websocket/lib/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var noop = exports.noop = function() {};\nexports.extend = function extend(dest, source) {\n    for(var prop in source){\n        dest[prop] = source[prop];\n    }\n};\nexports.eventEmitterListenerCount = (__webpack_require__(/*! events */ \"events\").EventEmitter.listenerCount) || function(emitter, type) {\n    return emitter.listeners(type).length;\n};\nexports.bufferAllocUnsafe = Buffer.allocUnsafe ? Buffer.allocUnsafe : function oldBufferAllocUnsafe(size) {\n    return new Buffer(size);\n};\nexports.bufferFromString = Buffer.from ? Buffer.from : function oldBufferFromString(string, encoding) {\n    return new Buffer(string, encoding);\n};\nexports.BufferingLogger = function createBufferingLogger(identifier, uniqueID) {\n    var logFunction = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/websocket/node_modules/debug/src/index.js\")(identifier);\n    if (logFunction.enabled) {\n        var logger = new BufferingLogger(identifier, uniqueID, logFunction);\n        var debug = logger.log.bind(logger);\n        debug.printOutput = logger.printOutput.bind(logger);\n        debug.enabled = logFunction.enabled;\n        return debug;\n    }\n    logFunction.printOutput = noop;\n    return logFunction;\n};\nfunction BufferingLogger(identifier, uniqueID, logFunction) {\n    this.logFunction = logFunction;\n    this.identifier = identifier;\n    this.uniqueID = uniqueID;\n    this.buffer = [];\n}\nBufferingLogger.prototype.log = function() {\n    this.buffer.push([\n        new Date(),\n        Array.prototype.slice.call(arguments)\n    ]);\n    return this;\n};\nBufferingLogger.prototype.clear = function() {\n    this.buffer = [];\n    return this;\n};\nBufferingLogger.prototype.printOutput = function(logFunction) {\n    if (!logFunction) {\n        logFunction = this.logFunction;\n    }\n    var uniqueID = this.uniqueID;\n    this.buffer.forEach(function(entry) {\n        var date = entry[0].toLocaleString();\n        var args = entry[1].slice();\n        var formatString = args[0];\n        if (formatString !== void 0 && formatString !== null) {\n            formatString = \"%s - %s - \" + formatString.toString();\n            args.splice(0, 1, formatString, date, uniqueID);\n            logFunction.apply(global, args);\n        }\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxPQUFPQyxZQUFZLEdBQUcsWUFBVztBQUVyQ0EsY0FBYyxHQUFHLFNBQVNDLE9BQU9DLElBQUksRUFBRUMsTUFBTTtJQUN6QyxJQUFLLElBQUlDLFFBQVFELE9BQVE7UUFDckJELElBQUksQ0FBQ0UsS0FBSyxHQUFHRCxNQUFNLENBQUNDLEtBQUs7SUFDN0I7QUFDSjtBQUVBSixpQ0FBaUMsR0FDN0JNLHdFQUE0QyxJQUM1QyxTQUFTRyxPQUFPLEVBQUVDLElBQUk7SUFBSSxPQUFPRCxRQUFRRSxTQUFTLENBQUNELE1BQU1FLE1BQU07QUFBRTtBQUVyRVoseUJBQXlCLEdBQUdjLE9BQU9DLFdBQVcsR0FDMUNELE9BQU9DLFdBQVcsR0FDbEIsU0FBU0MscUJBQXFCQyxJQUFJO0lBQUksT0FBTyxJQUFJSCxPQUFPRztBQUFPO0FBRW5FakIsd0JBQXdCLEdBQUdjLE9BQU9LLElBQUksR0FDbENMLE9BQU9LLElBQUksR0FDWCxTQUFTQyxvQkFBb0JDLE1BQU0sRUFBRUMsUUFBUTtJQUMzQyxPQUFPLElBQUlSLE9BQU9PLFFBQVFDO0FBQzVCO0FBRUp0Qix1QkFBdUIsR0FBRyxTQUFTd0Isc0JBQXNCQyxVQUFVLEVBQUVDLFFBQVE7SUFDekUsSUFBSUMsY0FBY3JCLG1CQUFPQSxDQUFDLCtFQUFTbUI7SUFDbkMsSUFBSUUsWUFBWUMsT0FBTyxFQUFFO1FBQ3JCLElBQUlDLFNBQVMsSUFBSU4sZ0JBQWdCRSxZQUFZQyxVQUFVQztRQUN2RCxJQUFJRyxRQUFRRCxPQUFPRSxHQUFHLENBQUNDLElBQUksQ0FBQ0g7UUFDNUJDLE1BQU1HLFdBQVcsR0FBR0osT0FBT0ksV0FBVyxDQUFDRCxJQUFJLENBQUNIO1FBQzVDQyxNQUFNRixPQUFPLEdBQUdELFlBQVlDLE9BQU87UUFDbkMsT0FBT0U7SUFDWDtJQUNBSCxZQUFZTSxXQUFXLEdBQUdsQztJQUMxQixPQUFPNEI7QUFDWDtBQUVBLFNBQVNKLGdCQUFnQkUsVUFBVSxFQUFFQyxRQUFRLEVBQUVDLFdBQVc7SUFDdEQsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO0lBQ25CLElBQUksQ0FBQ0YsVUFBVSxHQUFHQTtJQUNsQixJQUFJLENBQUNDLFFBQVEsR0FBR0E7SUFDaEIsSUFBSSxDQUFDUSxNQUFNLEdBQUcsRUFBRTtBQUNwQjtBQUVBWCxnQkFBZ0JZLFNBQVMsQ0FBQ0osR0FBRyxHQUFHO0lBQzlCLElBQUksQ0FBQ0csTUFBTSxDQUFDRSxJQUFJLENBQUM7UUFBRSxJQUFJQztRQUFRQyxNQUFNSCxTQUFTLENBQUNJLEtBQUssQ0FBQ0MsSUFBSSxDQUFDQztLQUFZO0lBQ3RFLE9BQU8sSUFBSTtBQUNiO0FBRUFsQixnQkFBZ0JZLFNBQVMsQ0FBQ08sS0FBSyxHQUFHO0lBQ2hDLElBQUksQ0FBQ1IsTUFBTSxHQUFHLEVBQUU7SUFDaEIsT0FBTyxJQUFJO0FBQ2I7QUFFQVgsZ0JBQWdCWSxTQUFTLENBQUNGLFdBQVcsR0FBRyxTQUFTTixXQUFXO0lBQ3hELElBQUksQ0FBQ0EsYUFBYTtRQUFFQSxjQUFjLElBQUksQ0FBQ0EsV0FBVztJQUFFO0lBQ3BELElBQUlELFdBQVcsSUFBSSxDQUFDQSxRQUFRO0lBQzVCLElBQUksQ0FBQ1EsTUFBTSxDQUFDUyxPQUFPLENBQUMsU0FBU0MsS0FBSztRQUM5QixJQUFJQyxPQUFPRCxLQUFLLENBQUMsRUFBRSxDQUFDRSxjQUFjO1FBQ2xDLElBQUlDLE9BQU9ILEtBQUssQ0FBQyxFQUFFLENBQUNMLEtBQUs7UUFDekIsSUFBSVMsZUFBZUQsSUFBSSxDQUFDLEVBQUU7UUFDMUIsSUFBSUMsaUJBQWtCLEtBQUssS0FBTUEsaUJBQWlCLE1BQU07WUFDcERBLGVBQWUsZUFBZUEsYUFBYUMsUUFBUTtZQUNuREYsS0FBS0csTUFBTSxDQUFDLEdBQUcsR0FBR0YsY0FBY0gsTUFBTW5CO1lBQ3RDQyxZQUFZd0IsS0FBSyxDQUFDQyxRQUFRTDtRQUM5QjtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvdXRpbHMuanM/MWU2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbm9vcCA9IGV4cG9ydHMubm9vcCA9IGZ1bmN0aW9uKCl7fTtcblxuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQoZGVzdCwgc291cmNlKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgZGVzdFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG59O1xuXG5leHBvcnRzLmV2ZW50RW1pdHRlckxpc3RlbmVyQ291bnQgPVxuICAgIHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50IHx8XG4gICAgZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkgeyByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoOyB9O1xuXG5leHBvcnRzLmJ1ZmZlckFsbG9jVW5zYWZlID0gQnVmZmVyLmFsbG9jVW5zYWZlID9cbiAgICBCdWZmZXIuYWxsb2NVbnNhZmUgOlxuICAgIGZ1bmN0aW9uIG9sZEJ1ZmZlckFsbG9jVW5zYWZlKHNpemUpIHsgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7IH07XG5cbmV4cG9ydHMuYnVmZmVyRnJvbVN0cmluZyA9IEJ1ZmZlci5mcm9tID9cbiAgICBCdWZmZXIuZnJvbSA6XG4gICAgZnVuY3Rpb24gb2xkQnVmZmVyRnJvbVN0cmluZyhzdHJpbmcsIGVuY29kaW5nKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdHJpbmcsIGVuY29kaW5nKTtcbiAgICB9O1xuXG5leHBvcnRzLkJ1ZmZlcmluZ0xvZ2dlciA9IGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlcmluZ0xvZ2dlcihpZGVudGlmaWVyLCB1bmlxdWVJRCkge1xuICAgIHZhciBsb2dGdW5jdGlvbiA9IHJlcXVpcmUoJ2RlYnVnJykoaWRlbnRpZmllcik7XG4gICAgaWYgKGxvZ0Z1bmN0aW9uLmVuYWJsZWQpIHtcbiAgICAgICAgdmFyIGxvZ2dlciA9IG5ldyBCdWZmZXJpbmdMb2dnZXIoaWRlbnRpZmllciwgdW5pcXVlSUQsIGxvZ0Z1bmN0aW9uKTtcbiAgICAgICAgdmFyIGRlYnVnID0gbG9nZ2VyLmxvZy5iaW5kKGxvZ2dlcik7XG4gICAgICAgIGRlYnVnLnByaW50T3V0cHV0ID0gbG9nZ2VyLnByaW50T3V0cHV0LmJpbmQobG9nZ2VyKTtcbiAgICAgICAgZGVidWcuZW5hYmxlZCA9IGxvZ0Z1bmN0aW9uLmVuYWJsZWQ7XG4gICAgICAgIHJldHVybiBkZWJ1ZztcbiAgICB9XG4gICAgbG9nRnVuY3Rpb24ucHJpbnRPdXRwdXQgPSBub29wO1xuICAgIHJldHVybiBsb2dGdW5jdGlvbjtcbn07XG5cbmZ1bmN0aW9uIEJ1ZmZlcmluZ0xvZ2dlcihpZGVudGlmaWVyLCB1bmlxdWVJRCwgbG9nRnVuY3Rpb24pIHtcbiAgICB0aGlzLmxvZ0Z1bmN0aW9uID0gbG9nRnVuY3Rpb247XG4gICAgdGhpcy5pZGVudGlmaWVyID0gaWRlbnRpZmllcjtcbiAgICB0aGlzLnVuaXF1ZUlEID0gdW5pcXVlSUQ7XG4gICAgdGhpcy5idWZmZXIgPSBbXTtcbn1cblxuQnVmZmVyaW5nTG9nZ2VyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5idWZmZXIucHVzaChbIG5ldyBEYXRlKCksIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykgXSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuQnVmZmVyaW5nTG9nZ2VyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkJ1ZmZlcmluZ0xvZ2dlci5wcm90b3R5cGUucHJpbnRPdXRwdXQgPSBmdW5jdGlvbihsb2dGdW5jdGlvbikge1xuICAgIGlmICghbG9nRnVuY3Rpb24pIHsgbG9nRnVuY3Rpb24gPSB0aGlzLmxvZ0Z1bmN0aW9uOyB9XG4gICAgdmFyIHVuaXF1ZUlEID0gdGhpcy51bmlxdWVJRDtcbiAgICB0aGlzLmJ1ZmZlci5mb3JFYWNoKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgIHZhciBkYXRlID0gZW50cnlbMF0udG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBlbnRyeVsxXS5zbGljZSgpO1xuICAgICAgICB2YXIgZm9ybWF0U3RyaW5nID0gYXJnc1swXTtcbiAgICAgICAgaWYgKGZvcm1hdFN0cmluZyAhPT0gKHZvaWQgMCkgJiYgZm9ybWF0U3RyaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXRTdHJpbmcgPSAnJXMgLSAlcyAtICcgKyBmb3JtYXRTdHJpbmcudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGFyZ3Muc3BsaWNlKDAsIDEsIGZvcm1hdFN0cmluZywgZGF0ZSwgdW5pcXVlSUQpO1xuICAgICAgICAgICAgbG9nRnVuY3Rpb24uYXBwbHkoZ2xvYmFsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbiJdLCJuYW1lcyI6WyJub29wIiwiZXhwb3J0cyIsImV4dGVuZCIsImRlc3QiLCJzb3VyY2UiLCJwcm9wIiwiZXZlbnRFbWl0dGVyTGlzdGVuZXJDb3VudCIsInJlcXVpcmUiLCJFdmVudEVtaXR0ZXIiLCJsaXN0ZW5lckNvdW50IiwiZW1pdHRlciIsInR5cGUiLCJsaXN0ZW5lcnMiLCJsZW5ndGgiLCJidWZmZXJBbGxvY1Vuc2FmZSIsIkJ1ZmZlciIsImFsbG9jVW5zYWZlIiwib2xkQnVmZmVyQWxsb2NVbnNhZmUiLCJzaXplIiwiYnVmZmVyRnJvbVN0cmluZyIsImZyb20iLCJvbGRCdWZmZXJGcm9tU3RyaW5nIiwic3RyaW5nIiwiZW5jb2RpbmciLCJCdWZmZXJpbmdMb2dnZXIiLCJjcmVhdGVCdWZmZXJpbmdMb2dnZXIiLCJpZGVudGlmaWVyIiwidW5pcXVlSUQiLCJsb2dGdW5jdGlvbiIsImVuYWJsZWQiLCJsb2dnZXIiLCJkZWJ1ZyIsImxvZyIsImJpbmQiLCJwcmludE91dHB1dCIsImJ1ZmZlciIsInByb3RvdHlwZSIsInB1c2giLCJEYXRlIiwiQXJyYXkiLCJzbGljZSIsImNhbGwiLCJhcmd1bWVudHMiLCJjbGVhciIsImZvckVhY2giLCJlbnRyeSIsImRhdGUiLCJ0b0xvY2FsZVN0cmluZyIsImFyZ3MiLCJmb3JtYXRTdHJpbmciLCJ0b1N0cmluZyIsInNwbGljZSIsImFwcGx5IiwiZ2xvYmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/version.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/version.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../package.json */ \"(ssr)/./node_modules/websocket/package.json\").version;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBQSxrSEFBbUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvdmVyc2lvbi5qcz8xNDIzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/websocket.js":
/*!*************************************************!*\
  !*** ./node_modules/websocket/lib/websocket.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = {\n    \"server\": __webpack_require__(/*! ./WebSocketServer */ \"(ssr)/./node_modules/websocket/lib/WebSocketServer.js\"),\n    \"client\": __webpack_require__(/*! ./WebSocketClient */ \"(ssr)/./node_modules/websocket/lib/WebSocketClient.js\"),\n    \"router\": __webpack_require__(/*! ./WebSocketRouter */ \"(ssr)/./node_modules/websocket/lib/WebSocketRouter.js\"),\n    \"frame\": __webpack_require__(/*! ./WebSocketFrame */ \"(ssr)/./node_modules/websocket/lib/WebSocketFrame.js\"),\n    \"request\": __webpack_require__(/*! ./WebSocketRequest */ \"(ssr)/./node_modules/websocket/lib/WebSocketRequest.js\"),\n    \"connection\": __webpack_require__(/*! ./WebSocketConnection */ \"(ssr)/./node_modules/websocket/lib/WebSocketConnection.js\"),\n    \"w3cwebsocket\": __webpack_require__(/*! ./W3CWebSocket */ \"(ssr)/./node_modules/websocket/lib/W3CWebSocket.js\"),\n    \"deprecation\": __webpack_require__(/*! ./Deprecation */ \"(ssr)/./node_modules/websocket/lib/Deprecation.js\"),\n    \"version\": __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/websocket/lib/version.js\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi93ZWJzb2NrZXQuanMiLCJtYXBwaW5ncyI6IkFBQUFBLE9BQU9DLE9BQU8sR0FBRztJQUNiLFVBQWlCQyxtQkFBT0EsQ0FBQztJQUN6QixVQUFpQkEsbUJBQU9BLENBQUM7SUFDekIsVUFBaUJBLG1CQUFPQSxDQUFDO0lBQ3pCLFNBQWlCQSxtQkFBT0EsQ0FBQztJQUN6QixXQUFpQkEsbUJBQU9BLENBQUM7SUFDekIsY0FBaUJBLG1CQUFPQSxDQUFDO0lBQ3pCLGdCQUFpQkEsbUJBQU9BLENBQUM7SUFDekIsZUFBaUJBLG1CQUFPQSxDQUFDO0lBQ3pCLFdBQWlCQSxtQkFBT0EsQ0FBQztBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi93ZWJzb2NrZXQuanM/ZTk3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnc2VydmVyJyAgICAgICA6IHJlcXVpcmUoJy4vV2ViU29ja2V0U2VydmVyJyksXG4gICAgJ2NsaWVudCcgICAgICAgOiByZXF1aXJlKCcuL1dlYlNvY2tldENsaWVudCcpLFxuICAgICdyb3V0ZXInICAgICAgIDogcmVxdWlyZSgnLi9XZWJTb2NrZXRSb3V0ZXInKSxcbiAgICAnZnJhbWUnICAgICAgICA6IHJlcXVpcmUoJy4vV2ViU29ja2V0RnJhbWUnKSxcbiAgICAncmVxdWVzdCcgICAgICA6IHJlcXVpcmUoJy4vV2ViU29ja2V0UmVxdWVzdCcpLFxuICAgICdjb25uZWN0aW9uJyAgIDogcmVxdWlyZSgnLi9XZWJTb2NrZXRDb25uZWN0aW9uJyksXG4gICAgJ3czY3dlYnNvY2tldCcgOiByZXF1aXJlKCcuL1czQ1dlYlNvY2tldCcpLFxuICAgICdkZXByZWNhdGlvbicgIDogcmVxdWlyZSgnLi9EZXByZWNhdGlvbicpLFxuICAgICd2ZXJzaW9uJyAgICAgIDogcmVxdWlyZSgnLi92ZXJzaW9uJylcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/websocket.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/node_modules/debug/src/browser.js":
/*!******************************************************************!*\
  !*** ./node_modules/websocket/node_modules/debug/src/browser.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */ exports = module.exports = __webpack_require__(/*! ./debug */ \"(ssr)/./node_modules/websocket/node_modules/debug/src/debug.js\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = \"undefined\" != typeof chrome && \"undefined\" != typeof chrome.storage ? chrome.storage.local : localstorage();\n/**\n * Colors.\n */ exports.colors = [\n    \"lightseagreen\",\n    \"forestgreen\",\n    \"goldenrod\",\n    \"dodgerblue\",\n    \"darkorchid\",\n    \"crimson\"\n];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */ function useColors() {\n    // NB: In an Electron preload script, document will be defined but not fully\n    // initialized. Since we know we're in Chrome, we'll just detect this case\n    // explicitly\n    if (false) {}\n    // is webkit? http://stackoverflow.com/a/16459606/376773\n    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n    return typeof document !== \"undefined\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773\n     false && (0) || // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker\n    typeof navigator !== \"undefined\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */ exports.formatters.j = function(v) {\n    try {\n        return JSON.stringify(v);\n    } catch (err) {\n        return \"[UnexpectedJSONParseError]: \" + err.message;\n    }\n};\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    var useColors = this.useColors;\n    args[0] = (useColors ? \"%c\" : \"\") + this.namespace + (useColors ? \" %c\" : \" \") + args[0] + (useColors ? \"%c \" : \" \") + \"+\" + exports.humanize(this.diff);\n    if (!useColors) return;\n    var c = \"color: \" + this.color;\n    args.splice(1, 0, c, \"color: inherit\");\n    // the final \"%c\" is somewhat tricky, because there could be other\n    // arguments passed either before or after the %c, so we need to\n    // figure out the correct index to insert the CSS into\n    var index = 0;\n    var lastC = 0;\n    args[0].replace(/%[a-zA-Z%]/g, function(match) {\n        if (\"%%\" === match) return;\n        index++;\n        if (\"%c\" === match) {\n            // we only are interested in the *last* %c\n            // (the user may have provided their own)\n            lastC = index;\n        }\n    });\n    args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */ function log() {\n    // this hackery is required for IE8/9, where\n    // the `console.log` function doesn't have 'apply'\n    return \"object\" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    try {\n        if (null == namespaces) {\n            exports.storage.removeItem(\"debug\");\n        } else {\n            exports.storage.debug = namespaces;\n        }\n    } catch (e) {}\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    var r;\n    try {\n        r = exports.storage.debug;\n    } catch (e) {}\n    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n    if (!r && typeof process !== \"undefined\" && \"env\" in process) {\n        r = process.env.DEBUG;\n    }\n    return r;\n}\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */ exports.enable(load());\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */ function localstorage() {\n    try {\n        return window.localStorage;\n    } catch (e) {}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7OztDQUlDLEdBRURBLFVBQVVDLHFIQUF5QjtBQUNuQ0QsV0FBVyxHQUFHRztBQUNkSCxrQkFBa0IsR0FBR0k7QUFDckJKLFlBQVksR0FBR0s7QUFDZkwsWUFBWSxHQUFHTTtBQUNmTixpQkFBaUIsR0FBR087QUFDcEJQLGVBQWUsR0FBRyxlQUFlLE9BQU9TLFVBQ3RCLGVBQWUsT0FBT0EsT0FBT0QsT0FBTyxHQUNsQ0MsT0FBT0QsT0FBTyxDQUFDRSxLQUFLLEdBQ3BCQztBQUVwQjs7Q0FFQyxHQUVEWCxjQUFjLEdBQUc7SUFDZjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUVEOzs7Ozs7Q0FNQyxHQUVELFNBQVNPO0lBQ1AsNEVBQTRFO0lBQzVFLDBFQUEwRTtJQUMxRSxhQUFhO0lBQ2IsSUFBSSxLQUEyRSxFQUFZLEVBRTFGO0lBRUQsd0RBQXdEO0lBQ3hELDRGQUE0RjtJQUM1RixPQUFPLE9BQVFTLGFBQWEsZUFBZUEsU0FBU0MsZUFBZSxJQUFJRCxTQUFTQyxlQUFlLENBQUNDLEtBQUssSUFBSUYsU0FBU0MsZUFBZSxDQUFDQyxLQUFLLENBQUNDLGdCQUFnQixJQUN0Six1REFBdUQ7SUFDdEQsTUFBK0MsSUFBS04sQ0FBQUEsQ0FBMkUsS0FDaEkscUJBQXFCO0lBQ3JCLDhFQUE4RTtJQUM3RSxPQUFPVyxjQUFjLGVBQWVBLFVBQVVDLFNBQVMsSUFBSUQsVUFBVUMsU0FBUyxDQUFDQyxXQUFXLEdBQUdDLEtBQUssQ0FBQyxxQkFBcUJDLFNBQVNDLE9BQU9DLEVBQUUsRUFBRSxPQUFPLE1BQ3BKLG1FQUFtRTtJQUNsRSxPQUFPTixjQUFjLGVBQWVBLFVBQVVDLFNBQVMsSUFBSUQsVUFBVUMsU0FBUyxDQUFDQyxXQUFXLEdBQUdDLEtBQUssQ0FBQztBQUN4RztBQUVBOztDQUVDLEdBRUQzQixvQkFBb0IsR0FBRyxTQUFTaUMsQ0FBQztJQUMvQixJQUFJO1FBQ0YsT0FBT0MsS0FBS0MsU0FBUyxDQUFDRjtJQUN4QixFQUFFLE9BQU9HLEtBQUs7UUFDWixPQUFPLGlDQUFpQ0EsSUFBSUMsT0FBTztJQUNyRDtBQUNGO0FBR0E7Ozs7Q0FJQyxHQUVELFNBQVNqQyxXQUFXa0MsSUFBSTtJQUN0QixJQUFJL0IsWUFBWSxJQUFJLENBQUNBLFNBQVM7SUFFOUIrQixJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMvQixZQUFZLE9BQU8sRUFBQyxJQUMzQixJQUFJLENBQUNnQyxTQUFTLEdBQ2JoQyxDQUFBQSxZQUFZLFFBQVEsR0FBRSxJQUN2QitCLElBQUksQ0FBQyxFQUFFLEdBQ04vQixDQUFBQSxZQUFZLFFBQVEsR0FBRSxJQUN2QixNQUFNUCxRQUFRd0MsUUFBUSxDQUFDLElBQUksQ0FBQ0MsSUFBSTtJQUVwQyxJQUFJLENBQUNsQyxXQUFXO0lBRWhCLElBQUltQyxJQUFJLFlBQVksSUFBSSxDQUFDQyxLQUFLO0lBQzlCTCxLQUFLTSxNQUFNLENBQUMsR0FBRyxHQUFHRixHQUFHO0lBRXJCLGtFQUFrRTtJQUNsRSxnRUFBZ0U7SUFDaEUsc0RBQXNEO0lBQ3RELElBQUlHLFFBQVE7SUFDWixJQUFJQyxRQUFRO0lBQ1pSLElBQUksQ0FBQyxFQUFFLENBQUNTLE9BQU8sQ0FBQyxlQUFlLFNBQVNwQixLQUFLO1FBQzNDLElBQUksU0FBU0EsT0FBTztRQUNwQmtCO1FBQ0EsSUFBSSxTQUFTbEIsT0FBTztZQUNsQiwwQ0FBMEM7WUFDMUMseUNBQXlDO1lBQ3pDbUIsUUFBUUQ7UUFDVjtJQUNGO0lBRUFQLEtBQUtNLE1BQU0sQ0FBQ0UsT0FBTyxHQUFHSjtBQUN4QjtBQUVBOzs7OztDQUtDLEdBRUQsU0FBU3ZDO0lBQ1AsNENBQTRDO0lBQzVDLGtEQUFrRDtJQUNsRCxPQUFPLGFBQWEsT0FBT2lCLFdBQ3RCQSxRQUFRakIsR0FBRyxJQUNYNkMsU0FBU0MsU0FBUyxDQUFDQyxLQUFLLENBQUNDLElBQUksQ0FBQy9CLFFBQVFqQixHQUFHLEVBQUVpQixTQUFTZ0M7QUFDM0Q7QUFFQTs7Ozs7Q0FLQyxHQUVELFNBQVMvQyxLQUFLZ0QsVUFBVTtJQUN0QixJQUFJO1FBQ0YsSUFBSSxRQUFRQSxZQUFZO1lBQ3RCckQsUUFBUVEsT0FBTyxDQUFDOEMsVUFBVSxDQUFDO1FBQzdCLE9BQU87WUFDTHRELHFCQUFxQixHQUFHcUQ7UUFDMUI7SUFDRixFQUFFLE9BQU1HLEdBQUcsQ0FBQztBQUNkO0FBRUE7Ozs7O0NBS0MsR0FFRCxTQUFTbEQ7SUFDUCxJQUFJbUQ7SUFDSixJQUFJO1FBQ0ZBLElBQUl6RCxRQUFRUSxPQUFPLENBQUMrQyxLQUFLO0lBQzNCLEVBQUUsT0FBTUMsR0FBRyxDQUFDO0lBRVosc0VBQXNFO0lBQ3RFLElBQUksQ0FBQ0MsS0FBSyxPQUFPM0MsWUFBWSxlQUFlLFNBQVNBLFNBQVM7UUFDNUQyQyxJQUFJM0MsUUFBUTRDLEdBQUcsQ0FBQ0MsS0FBSztJQUN2QjtJQUVBLE9BQU9GO0FBQ1Q7QUFFQTs7Q0FFQyxHQUVEekQsUUFBUTRELE1BQU0sQ0FBQ3REO0FBRWY7Ozs7Ozs7OztDQVNDLEdBRUQsU0FBU0s7SUFDUCxJQUFJO1FBQ0YsT0FBT0UsT0FBT2dELFlBQVk7SUFDNUIsRUFBRSxPQUFPTCxHQUFHLENBQUM7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcz8yYzU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiJdLCJuYW1lcyI6WyJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImxvZyIsImZvcm1hdEFyZ3MiLCJzYXZlIiwibG9hZCIsInVzZUNvbG9ycyIsInN0b3JhZ2UiLCJjaHJvbWUiLCJsb2NhbCIsImxvY2Fsc3RvcmFnZSIsImNvbG9ycyIsIndpbmRvdyIsInByb2Nlc3MiLCJ0eXBlIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJzdHlsZSIsIldlYmtpdEFwcGVhcmFuY2UiLCJjb25zb2xlIiwiZmlyZWJ1ZyIsImV4Y2VwdGlvbiIsInRhYmxlIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidG9Mb3dlckNhc2UiLCJtYXRjaCIsInBhcnNlSW50IiwiUmVnRXhwIiwiJDEiLCJmb3JtYXR0ZXJzIiwiaiIsInYiLCJKU09OIiwic3RyaW5naWZ5IiwiZXJyIiwibWVzc2FnZSIsImFyZ3MiLCJuYW1lc3BhY2UiLCJodW1hbml6ZSIsImRpZmYiLCJjIiwiY29sb3IiLCJzcGxpY2UiLCJpbmRleCIsImxhc3RDIiwicmVwbGFjZSIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiYXJndW1lbnRzIiwibmFtZXNwYWNlcyIsInJlbW92ZUl0ZW0iLCJkZWJ1ZyIsImUiLCJyIiwiZW52IiwiREVCVUciLCJlbmFibGUiLCJsb2NhbFN0b3JhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/node_modules/debug/src/debug.js":
/*!****************************************************************!*\
  !*** ./node_modules/websocket/node_modules/debug/src/debug.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */ exports = module.exports = createDebug.debug = createDebug[\"default\"] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"(ssr)/./node_modules/websocket/node_modules/ms/index.js\");\n/**\n * The currently active debug mode names, and names to skip.\n */ exports.names = [];\nexports.skips = [];\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */ exports.formatters = {};\n/**\n * Previous log timestamp.\n */ var prevTime;\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */ function selectColor(namespace) {\n    var hash = 0, i;\n    for(i in namespace){\n        hash = (hash << 5) - hash + namespace.charCodeAt(i);\n        hash |= 0; // Convert to 32bit integer\n    }\n    return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */ function createDebug(namespace) {\n    function debug() {\n        // disabled?\n        if (!debug.enabled) return;\n        var self = debug;\n        // set `diff` timestamp\n        var curr = +new Date();\n        var ms = curr - (prevTime || curr);\n        self.diff = ms;\n        self.prev = prevTime;\n        self.curr = curr;\n        prevTime = curr;\n        // turn the `arguments` into a proper Array\n        var args = new Array(arguments.length);\n        for(var i = 0; i < args.length; i++){\n            args[i] = arguments[i];\n        }\n        args[0] = exports.coerce(args[0]);\n        if (\"string\" !== typeof args[0]) {\n            // anything else let's inspect with %O\n            args.unshift(\"%O\");\n        }\n        // apply any `formatters` transformations\n        var index = 0;\n        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n            // if we encounter an escaped % then don't increase the array index\n            if (match === \"%%\") return match;\n            index++;\n            var formatter = exports.formatters[format];\n            if (\"function\" === typeof formatter) {\n                var val = args[index];\n                match = formatter.call(self, val);\n                // now we need to remove `args[index]` since it's inlined in the `format`\n                args.splice(index, 1);\n                index--;\n            }\n            return match;\n        });\n        // apply env-specific formatting (colors, etc.)\n        exports.formatArgs.call(self, args);\n        var logFn = debug.log || exports.log || console.log.bind(console);\n        logFn.apply(self, args);\n    }\n    debug.namespace = namespace;\n    debug.enabled = exports.enabled(namespace);\n    debug.useColors = exports.useColors();\n    debug.color = selectColor(namespace);\n    // env-specific initialization logic for debug instances\n    if (\"function\" === typeof exports.init) {\n        exports.init(debug);\n    }\n    return debug;\n}\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */ function enable(namespaces) {\n    exports.save(namespaces);\n    exports.names = [];\n    exports.skips = [];\n    var split = (typeof namespaces === \"string\" ? namespaces : \"\").split(/[\\s,]+/);\n    var len = split.length;\n    for(var i = 0; i < len; i++){\n        if (!split[i]) continue; // ignore empty strings\n        namespaces = split[i].replace(/\\*/g, \".*?\");\n        if (namespaces[0] === \"-\") {\n            exports.skips.push(new RegExp(\"^\" + namespaces.substr(1) + \"$\"));\n        } else {\n            exports.names.push(new RegExp(\"^\" + namespaces + \"$\"));\n        }\n    }\n}\n/**\n * Disable debug output.\n *\n * @api public\n */ function disable() {\n    exports.enable(\"\");\n}\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */ function enabled(name) {\n    var i, len;\n    for(i = 0, len = exports.skips.length; i < len; i++){\n        if (exports.skips[i].test(name)) {\n            return false;\n        }\n    }\n    for(i = 0, len = exports.names.length; i < len; i++){\n        if (exports.names[i].test(name)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */ function coerce(val) {\n    if (val instanceof Error) return val.stack || val.message;\n    return val;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanMiLCJtYXBwaW5ncyI6IkFBQ0E7Ozs7O0NBS0MsR0FFREEsVUFBVUMsT0FBT0QsT0FBTyxHQUFHRSxZQUFZQyxLQUFLLEdBQUdELFdBQVcsQ0FBQyxVQUFVLEdBQUdBO0FBQ3hFRixjQUFjLEdBQUdJO0FBQ2pCSixlQUFlLEdBQUdLO0FBQ2xCTCxjQUFjLEdBQUdNO0FBQ2pCTixlQUFlLEdBQUdPO0FBQ2xCUCwyR0FBMkI7QUFFM0I7O0NBRUMsR0FFREEsYUFBYSxHQUFHLEVBQUU7QUFDbEJBLGFBQWEsR0FBRyxFQUFFO0FBRWxCOzs7O0NBSUMsR0FFREEsa0JBQWtCLEdBQUcsQ0FBQztBQUV0Qjs7Q0FFQyxHQUVELElBQUlhO0FBRUo7Ozs7O0NBS0MsR0FFRCxTQUFTQyxZQUFZQyxTQUFTO0lBQzVCLElBQUlDLE9BQU8sR0FBR0M7SUFFZCxJQUFLQSxLQUFLRixVQUFXO1FBQ25CQyxPQUFRLENBQUVBLFFBQVEsS0FBS0EsT0FBUUQsVUFBVUcsVUFBVSxDQUFDRDtRQUNwREQsUUFBUSxHQUFHLDJCQUEyQjtJQUN4QztJQUVBLE9BQU9oQixRQUFRbUIsTUFBTSxDQUFDQyxLQUFLQyxHQUFHLENBQUNMLFFBQVFoQixRQUFRbUIsTUFBTSxDQUFDRyxNQUFNLENBQUM7QUFDL0Q7QUFFQTs7Ozs7O0NBTUMsR0FFRCxTQUFTcEIsWUFBWWEsU0FBUztJQUU1QixTQUFTWjtRQUNQLFlBQVk7UUFDWixJQUFJLENBQUNBLE1BQU1JLE9BQU8sRUFBRTtRQUVwQixJQUFJZ0IsT0FBT3BCO1FBRVgsdUJBQXVCO1FBQ3ZCLElBQUlxQixPQUFPLENBQUMsSUFBSUM7UUFDaEIsSUFBSUMsS0FBS0YsT0FBUVgsQ0FBQUEsWUFBWVcsSUFBRztRQUNoQ0QsS0FBS0ksSUFBSSxHQUFHRDtRQUNaSCxLQUFLSyxJQUFJLEdBQUdmO1FBQ1pVLEtBQUtDLElBQUksR0FBR0E7UUFDWlgs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S0FBSyxDQUFDVyxNQUFNLEVBQUVMLElBQUlvQyxLQUFLcEMsSUFBSztRQUNwRCxJQUFJakIsUUFBUVcsS0FBSyxDQUFDTSxFQUFFLENBQUN5QyxJQUFJLENBQUNELE9BQU87WUFDL0IsT0FBTztRQUNUO0lBQ0Y7SUFDQSxJQUFLeEMsSUFBSSxHQUFHb0MsTUFBTXJELFFBQVFVLEtBQUssQ0FBQ1ksTUFBTSxFQUFFTCxJQUFJb0MsS0FBS3BDLElBQUs7UUFDcEQsSUFBSWpCLFFBQVFVLEtBQUssQ0FBQ08sRUFBRSxDQUFDeUMsSUFBSSxDQUFDRCxPQUFPO1lBQy9CLE9BQU87UUFDVDtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBRUE7Ozs7OztDQU1DLEdBRUQsU0FBU3JELE9BQU9rQyxHQUFHO0lBQ2pCLElBQUlBLGVBQWVxQixPQUFPLE9BQU9yQixJQUFJc0IsS0FBSyxJQUFJdEIsSUFBSXVCLE9BQU87SUFDekQsT0FBT3ZCO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzP2QyMTIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgdmFyIGhhc2ggPSAwLCBpO1xuXG4gIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIC8vIGRpc2FibGVkP1xuICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgdmFyIHNlbGYgPSBkZWJ1ZztcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gdHVybiB0aGUgYGFyZ3VtZW50c2AgaW50byBhIHByb3BlciBBcnJheVxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICBleHBvcnRzLm5hbWVzID0gW107XG4gIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiJdLCJuYW1lcyI6WyJleHBvcnRzIiwibW9kdWxlIiwiY3JlYXRlRGVidWciLCJkZWJ1ZyIsImNvZXJjZSIsImRpc2FibGUiLCJlbmFibGUiLCJlbmFibGVkIiwiaHVtYW5pemUiLCJyZXF1aXJlIiwibmFtZXMiLCJza2lwcyIsImZvcm1hdHRlcnMiLCJwcmV2VGltZSIsInNlbGVjdENvbG9yIiwibmFtZXNwYWNlIiwiaGFzaCIsImkiLCJjaGFyQ29kZUF0IiwiY29sb3JzIiwiTWF0aCIsImFicyIsImxlbmd0aCIsInNlbGYiLCJjdXJyIiwiRGF0ZSIsIm1zIiwiZGlmZiIsInByZXYiLCJhcmdzIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJ1bnNoaWZ0IiwiaW5kZXgiLCJyZXBsYWNlIiwibWF0Y2giLCJmb3JtYXQiLCJmb3JtYXR0ZXIiLCJ2YWwiLCJjYWxsIiwic3BsaWNlIiwiZm9ybWF0QXJncyIsImxvZ0ZuIiwibG9nIiwiY29uc29sZSIsImJpbmQiLCJhcHBseSIsInVzZUNvbG9ycyIsImNvbG9yIiwiaW5pdCIsIm5hbWVzcGFjZXMiLCJzYXZlIiwic3BsaXQiLCJsZW4iLCJwdXNoIiwiUmVnRXhwIiwic3Vic3RyIiwibmFtZSIsInRlc3QiLCJFcnJvciIsInN0YWNrIiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/node_modules/debug/src/debug.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/node_modules/debug/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/websocket/node_modules/debug/src/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */ if (typeof process !== \"undefined\" && process.type === \"renderer\") {\n    module.exports = __webpack_require__(/*! ./browser.js */ \"(ssr)/./node_modules/websocket/node_modules/debug/src/browser.js\");\n} else {\n    module.exports = __webpack_require__(/*! ./node.js */ \"(ssr)/./node_modules/websocket/node_modules/debug/src/node.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDLEdBRUQsSUFBSSxPQUFPQSxZQUFZLGVBQWVBLFFBQVFDLElBQUksS0FBSyxZQUFZO0lBQ2pFQyw0SEFBeUI7QUFDM0IsT0FBTztJQUNMQSxzSEFBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzP2E2ZDciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEZXRlY3QgRWxlY3Ryb24gcmVuZGVyZXIgcHJvY2Vzcywgd2hpY2ggaXMgbm9kZSwgYnV0IHdlIHNob3VsZFxuICogdHJlYXQgYXMgYSBicm93c2VyLlxuICovXG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9icm93c2VyLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbm9kZS5qcycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJ0eXBlIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/node_modules/debug/src/node.js":
/*!***************************************************************!*\
  !*** ./node_modules/websocket/node_modules/debug/src/node.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */ var tty = __webpack_require__(/*! tty */ \"tty\");\nvar util = __webpack_require__(/*! util */ \"util\");\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */ exports = module.exports = __webpack_require__(/*! ./debug */ \"(ssr)/./node_modules/websocket/node_modules/debug/src/debug.js\");\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n/**\n * Colors.\n */ exports.colors = [\n    6,\n    2,\n    3,\n    4,\n    5,\n    1\n];\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */ exports.inspectOpts = Object.keys(process.env).filter(function(key) {\n    return /^debug_/i.test(key);\n}).reduce(function(obj, key) {\n    // camel-case\n    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {\n        return k.toUpperCase();\n    });\n    // coerce string value into JS value\n    var val = process.env[key];\n    if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n    else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n    else if (val === \"null\") val = null;\n    else val = Number(val);\n    obj[prop] = val;\n    return obj;\n}, {});\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */ var fd = parseInt(process.env.DEBUG_FD, 10) || 2;\nif (1 !== fd && 2 !== fd) {\n    util.deprecate(function() {}, \"except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)\")();\n}\nvar stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */ function useColors() {\n    return \"colors\" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);\n}\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */ exports.formatters.o = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts).split(\"\\n\").map(function(str) {\n        return str.trim();\n    }).join(\" \");\n};\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */ exports.formatters.O = function(v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts);\n};\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    var name = this.namespace;\n    var useColors = this.useColors;\n    if (useColors) {\n        var c = this.color;\n        var prefix = \"  \\x1b[3\" + c + \";1m\" + name + \" \" + \"\\x1b[0m\";\n        args[0] = prefix + args[0].split(\"\\n\").join(\"\\n\" + prefix);\n        args.push(\"\\x1b[3\" + c + \"m+\" + exports.humanize(this.diff) + \"\\x1b[0m\");\n    } else {\n        args[0] = new Date().toUTCString() + \" \" + name + \" \" + args[0];\n    }\n}\n/**\n * Invokes `util.format()` with the specified arguments and writes to `stream`.\n */ function log() {\n    return stream.write(util.format.apply(util, arguments) + \"\\n\");\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    if (null == namespaces) {\n        // If you set a process.env field to null or undefined, it gets cast to the\n        // string 'null' or 'undefined'. Just delete instead.\n        delete process.env.DEBUG;\n    } else {\n        process.env.DEBUG = namespaces;\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    return process.env.DEBUG;\n}\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */ function createWritableStdioStream(fd) {\n    var stream;\n    var tty_wrap = process.binding(\"tty_wrap\");\n    // Note stream._type is used for test-module-load-list.js\n    switch(tty_wrap.guessHandleType(fd)){\n        case \"TTY\":\n            stream = new tty.WriteStream(fd);\n            stream._type = \"tty\";\n            // Hack to have stream not keep the event loop alive.\n            // See https://github.com/joyent/node/issues/1726\n            if (stream._handle && stream._handle.unref) {\n                stream._handle.unref();\n            }\n            break;\n        case \"FILE\":\n            var fs = __webpack_require__(/*! fs */ \"fs\");\n            stream = new fs.SyncWriteStream(fd, {\n                autoClose: false\n            });\n            stream._type = \"fs\";\n            break;\n        case \"PIPE\":\n        case \"TCP\":\n            var net = __webpack_require__(/*! net */ \"net\");\n            stream = new net.Socket({\n                fd: fd,\n                readable: false,\n                writable: true\n            });\n            // FIXME Should probably have an option in net.Socket to create a\n            // stream from an existing fd which is writable only. But for now\n            // we'll just add this hack and set the `readable` member to false.\n            // Test: ./node test/fixtures/echo.js < /etc/passwd\n            stream.readable = false;\n            stream.read = null;\n            stream._type = \"pipe\";\n            // FIXME Hack to have stream not keep the event loop alive.\n            // See https://github.com/joyent/node/issues/1726\n            if (stream._handle && stream._handle.unref) {\n                stream._handle.unref();\n            }\n            break;\n        default:\n            // Probably an error on in uv_guess_handle()\n            throw new Error(\"Implement me. Unknown stream file type!\");\n    }\n    // For supporting legacy API we put the FD here.\n    stream.fd = fd;\n    stream._isStdio = true;\n    return stream;\n}\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */ function init(debug) {\n    debug.inspectOpts = {};\n    var keys = Object.keys(exports.inspectOpts);\n    for(var i = 0; i < keys.length; i++){\n        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n    }\n}\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */ exports.enable(load());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVELElBQUlBLE1BQU1DLG1CQUFPQSxDQUFDO0FBQ2xCLElBQUlDLE9BQU9ELG1CQUFPQSxDQUFDO0FBRW5COzs7O0NBSUMsR0FFREUsVUFBVUMscUhBQXlCO0FBQ25DRCxZQUFZLEdBQUdFO0FBQ2ZGLFdBQVcsR0FBR0c7QUFDZEgsa0JBQWtCLEdBQUdJO0FBQ3JCSixZQUFZLEdBQUdLO0FBQ2ZMLFlBQVksR0FBR007QUFDZk4saUJBQWlCLEdBQUdPO0FBRXBCOztDQUVDLEdBRURQLGNBQWMsR0FBRztJQUFDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztDQUFFO0FBRW5DOzs7O0NBSUMsR0FFREEsbUJBQW1CLEdBQUdVLE9BQU9DLElBQUksQ0FBQ0MsUUFBUUMsR0FBRyxFQUFFQyxNQUFNLENBQUMsU0FBVUMsR0FBRztJQUNqRSxPQUFPLFdBQVdDLElBQUksQ0FBQ0Q7QUFDekIsR0FBR0UsTUFBTSxDQUFDLFNBQVVDLEdBQUcsRUFBRUgsR0FBRztJQUMxQixhQUFhO0lBQ2IsSUFBSUksT0FBT0osSUFDUkssU0FBUyxDQUFDLEdBQ1ZDLFdBQVcsR0FDWEMsT0FBTyxDQUFDLGFBQWEsU0FBVUMsQ0FBQyxFQUFFQyxDQUFDO1FBQUksT0FBT0EsRUFBRUMsV0FBVztJQUFHO0lBRWpFLG9DQUFvQztJQUNwQyxJQUFJQyxNQUFNZCxRQUFRQyxHQUFHLENBQUNFLElBQUk7SUFDMUIsSUFBSSwyQkFBMkJDLElBQUksQ0FBQ1UsTUFBTUEsTUFBTTtTQUMzQyxJQUFJLDZCQUE2QlYsSUFBSSxDQUFDVSxNQUFNQSxNQUFNO1NBQ2xELElBQUlBLFFBQVEsUUFBUUEsTUFBTTtTQUMxQkEsTUFBTUMsT0FBT0Q7SUFFbEJSLEdBQUcsQ0FBQ0MsS0FBSyxHQUFHTztJQUNaLE9BQU9SO0FBQ1QsR0FBRyxDQUFDO0FBRUo7Ozs7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Q0QsTUFBTXpFLFdBQVcsQ0FBQ0UsSUFBSSxDQUFDd0UsRUFBRSxDQUFDLEdBQUduRixRQUFRUyxXQUFXLENBQUNFLElBQUksQ0FBQ3dFLEVBQUUsQ0FBQztJQUMzRDtBQUNGO0FBRUE7O0NBRUMsR0FFRG5GLFFBQVFxRixNQUFNLENBQUMvRSIsInNvdXJjZXMiOlsid2VicGFjazovL3BvY2tldGgvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcz85OWI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBOb2RlLmpzIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5pbml0ID0gaW5pdDtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWzYsIDIsIDMsIDQsIDUsIDFdO1xuXG4vKipcbiAqIEJ1aWxkIHVwIHRoZSBkZWZhdWx0IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiAgICQgREVCVUdfQ09MT1JTPW5vIERFQlVHX0RFUFRIPTEwIERFQlVHX1NIT1dfSElEREVOPWVuYWJsZWQgbm9kZSBzY3JpcHQuanNcbiAqL1xuXG5leHBvcnRzLmluc3BlY3RPcHRzID0gT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAvXmRlYnVnXy9pLnRlc3Qoa2V5KTtcbn0pLnJlZHVjZShmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgLy8gY2FtZWwtY2FzZVxuICB2YXIgcHJvcCA9IGtleVxuICAgIC5zdWJzdHJpbmcoNilcbiAgICAudG9Mb3dlckNhc2UoKVxuICAgIC5yZXBsYWNlKC9fKFthLXpdKS9nLCBmdW5jdGlvbiAoXywgaykgeyByZXR1cm4gay50b1VwcGVyQ2FzZSgpIH0pO1xuXG4gIC8vIGNvZXJjZSBzdHJpbmcgdmFsdWUgaW50byBKUyB2YWx1ZVxuICB2YXIgdmFsID0gcHJvY2Vzcy5lbnZba2V5XTtcbiAgaWYgKC9eKHllc3xvbnx0cnVlfGVuYWJsZWQpJC9pLnRlc3QodmFsKSkgdmFsID0gdHJ1ZTtcbiAgZWxzZSBpZiAoL14obm98b2ZmfGZhbHNlfGRpc2FibGVkKSQvaS50ZXN0KHZhbCkpIHZhbCA9IGZhbHNlO1xuICBlbHNlIGlmICh2YWwgPT09ICdudWxsJykgdmFsID0gbnVsbDtcbiAgZWxzZSB2YWwgPSBOdW1iZXIodmFsKTtcblxuICBvYmpbcHJvcF0gPSB2YWw7XG4gIHJldHVybiBvYmo7XG59LCB7fSk7XG5cbi8qKlxuICogVGhlIGZpbGUgZGVzY3JpcHRvciB0byB3cml0ZSB0aGUgYGRlYnVnKClgIGNhbGxzIHRvLlxuICogU2V0IHRoZSBgREVCVUdfRkRgIGVudiB2YXJpYWJsZSB0byBvdmVycmlkZSB3aXRoIGFub3RoZXIgdmFsdWUuIGkuZS46XG4gKlxuICogICAkIERFQlVHX0ZEPTMgbm9kZSBzY3JpcHQuanMgMz5kZWJ1Zy5sb2dcbiAqL1xuXG52YXIgZmQgPSBwYXJzZUludChwcm9jZXNzLmVudi5ERUJVR19GRCwgMTApIHx8IDI7XG5cbmlmICgxICE9PSBmZCAmJiAyICE9PSBmZCkge1xuICB1dGlsLmRlcHJlY2F0ZShmdW5jdGlvbigpe30sICdleGNlcHQgZm9yIHN0ZGVycigyKSBhbmQgc3Rkb3V0KDEpLCBhbnkgb3RoZXIgdXNhZ2Ugb2YgREVCVUdfRkQgaXMgZGVwcmVjYXRlZC4gT3ZlcnJpZGUgZGVidWcubG9nIGlmIHlvdSB3YW50IHRvIHVzZSBhIGRpZmZlcmVudCBsb2cgZnVuY3Rpb24gKGh0dHBzOi8vZ2l0LmlvL2RlYnVnX2ZkKScpKClcbn1cblxudmFyIHN0cmVhbSA9IDEgPT09IGZkID8gcHJvY2Vzcy5zdGRvdXQgOlxuICAgICAgICAgICAgIDIgPT09IGZkID8gcHJvY2Vzcy5zdGRlcnIgOlxuICAgICAgICAgICAgIGNyZWF0ZVdyaXRhYmxlU3RkaW9TdHJlYW0oZmQpO1xuXG4vKipcbiAqIElzIHN0ZG91dCBhIFRUWT8gQ29sb3JlZCBvdXRwdXQgaXMgZW5hYmxlZCB3aGVuIGB0cnVlYC5cbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIHJldHVybiAnY29sb3JzJyBpbiBleHBvcnRzLmluc3BlY3RPcHRzXG4gICAgPyBCb29sZWFuKGV4cG9ydHMuaW5zcGVjdE9wdHMuY29sb3JzKVxuICAgIDogdHR5LmlzYXR0eShmZCk7XG59XG5cbi8qKlxuICogTWFwICVvIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbCBvbiBhIHNpbmdsZSBsaW5lLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5vID0gZnVuY3Rpb24odikge1xuICB0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuICByZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpXG4gICAgLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnRyaW0oKVxuICAgIH0pLmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogTWFwICVvIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbG93aW5nIG11bHRpcGxlIGxpbmVzIGlmIG5lZWRlZC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuTyA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcbiAgcmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKTtcbn07XG5cbi8qKlxuICogQWRkcyBBTlNJIGNvbG9yIGVzY2FwZSBjb2RlcyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciBuYW1lID0gdGhpcy5uYW1lc3BhY2U7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBpZiAodXNlQ29sb3JzKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNvbG9yO1xuICAgIHZhciBwcmVmaXggPSAnICBcXHUwMDFiWzMnICsgYyArICc7MW0nICsgbmFtZSArICcgJyArICdcXHUwMDFiWzBtJztcblxuICAgIGFyZ3NbMF0gPSBwcmVmaXggKyBhcmdzWzBdLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4nICsgcHJlZml4KTtcbiAgICBhcmdzLnB1c2goJ1xcdTAwMWJbMycgKyBjICsgJ20rJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKSArICdcXHUwMDFiWzBtJyk7XG4gIH0gZWxzZSB7XG4gICAgYXJnc1swXSA9IG5ldyBEYXRlKCkudG9VVENTdHJpbmcoKVxuICAgICAgKyAnICcgKyBuYW1lICsgJyAnICsgYXJnc1swXTtcbiAgfVxufVxuXG4vKipcbiAqIEludm9rZXMgYHV0aWwuZm9ybWF0KClgIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMgYW5kIHdyaXRlcyB0byBgc3RyZWFtYC5cbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHJldHVybiBzdHJlYW0ud3JpdGUodXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKSArICdcXG4nKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAvLyBJZiB5b3Ugc2V0IGEgcHJvY2Vzcy5lbnYgZmllbGQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGl0IGdldHMgY2FzdCB0byB0aGVcbiAgICAvLyBzdHJpbmcgJ251bGwnIG9yICd1bmRlZmluZWQnLiBKdXN0IGRlbGV0ZSBpbnN0ZWFkLlxuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLmVudi5ERUJVRyA9IG5hbWVzcGFjZXM7XG4gIH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuREVCVUc7XG59XG5cbi8qKlxuICogQ29waWVkIGZyb20gYG5vZGUvc3JjL25vZGUuanNgLlxuICpcbiAqIFhYWDogSXQncyBsYW1lIHRoYXQgbm9kZSBkb2Vzbid0IGV4cG9zZSB0aGlzIEFQSSBvdXQtb2YtdGhlLWJveC4gSXQgYWxzb1xuICogcmVsaWVzIG9uIHRoZSB1bmRvY3VtZW50ZWQgYHR0eV93cmFwLmd1ZXNzSGFuZGxlVHlwZSgpYCB3aGljaCBpcyBhbHNvIGxhbWUuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlV3JpdGFibGVTdGRpb1N0cmVhbSAoZmQpIHtcbiAgdmFyIHN0cmVhbTtcbiAgdmFyIHR0eV93cmFwID0gcHJvY2Vzcy5iaW5kaW5nKCd0dHlfd3JhcCcpO1xuXG4gIC8vIE5vdGUgc3RyZWFtLl90eXBlIGlzIHVzZWQgZm9yIHRlc3QtbW9kdWxlLWxvYWQtbGlzdC5qc1xuXG4gIHN3aXRjaCAodHR5X3dyYXAuZ3Vlc3NIYW5kbGVUeXBlKGZkKSkge1xuICAgIGNhc2UgJ1RUWSc6XG4gICAgICBzdHJlYW0gPSBuZXcgdHR5LldyaXRlU3RyZWFtKGZkKTtcbiAgICAgIHN0cmVhbS5fdHlwZSA9ICd0dHknO1xuXG4gICAgICAvLyBIYWNrIHRvIGhhdmUgc3RyZWFtIG5vdCBrZWVwIHRoZSBldmVudCBsb29wIGFsaXZlLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcyNlxuICAgICAgaWYgKHN0cmVhbS5faGFuZGxlICYmIHN0cmVhbS5faGFuZGxlLnVucmVmKSB7XG4gICAgICAgIHN0cmVhbS5faGFuZGxlLnVucmVmKCk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ0ZJTEUnOlxuICAgICAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICAgIHN0cmVhbSA9IG5ldyBmcy5TeW5jV3JpdGVTdHJlYW0oZmQsIHsgYXV0b0Nsb3NlOiBmYWxzZSB9KTtcbiAgICAgIHN0cmVhbS5fdHlwZSA9ICdmcyc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ1BJUEUnOlxuICAgIGNhc2UgJ1RDUCc6XG4gICAgICB2YXIgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG4gICAgICBzdHJlYW0gPSBuZXcgbmV0LlNvY2tldCh7XG4gICAgICAgIGZkOiBmZCxcbiAgICAgICAgcmVhZGFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEZJWE1FIFNob3VsZCBwcm9iYWJseSBoYXZlIGFuIG9wdGlvbiBpbiBuZXQuU29ja2V0IHRvIGNyZWF0ZSBhXG4gICAgICAvLyBzdHJlYW0gZnJvbSBhbiBleGlzdGluZyBmZCB3aGljaCBpcyB3cml0YWJsZSBvbmx5LiBCdXQgZm9yIG5vd1xuICAgICAgLy8gd2UnbGwganVzdCBhZGQgdGhpcyBoYWNrIGFuZCBzZXQgdGhlIGByZWFkYWJsZWAgbWVtYmVyIHRvIGZhbHNlLlxuICAgICAgLy8gVGVzdDogLi9ub2RlIHRlc3QvZml4dHVyZXMvZWNoby5qcyA8IC9ldGMvcGFzc3dkXG4gICAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZWFkID0gbnVsbDtcbiAgICAgIHN0cmVhbS5fdHlwZSA9ICdwaXBlJztcblxuICAgICAgLy8gRklYTUUgSGFjayB0byBoYXZlIHN0cmVhbSBub3Qga2VlcCB0aGUgZXZlbnQgbG9vcCBhbGl2ZS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MjZcbiAgICAgIGlmIChzdHJlYW0uX2hhbmRsZSAmJiBzdHJlYW0uX2hhbmRsZS51bnJlZikge1xuICAgICAgICBzdHJlYW0uX2hhbmRsZS51bnJlZigpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gUHJvYmFibHkgYW4gZXJyb3Igb24gaW4gdXZfZ3Vlc3NfaGFuZGxlKClcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW1wbGVtZW50IG1lLiBVbmtub3duIHN0cmVhbSBmaWxlIHR5cGUhJyk7XG4gIH1cblxuICAvLyBGb3Igc3VwcG9ydGluZyBsZWdhY3kgQVBJIHdlIHB1dCB0aGUgRkQgaGVyZS5cbiAgc3RyZWFtLmZkID0gZmQ7XG5cbiAgc3RyZWFtLl9pc1N0ZGlvID0gdHJ1ZTtcblxuICByZXR1cm4gc3RyZWFtO1xufVxuXG4vKipcbiAqIEluaXQgbG9naWMgZm9yIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICpcbiAqIENyZWF0ZSBhIG5ldyBgaW5zcGVjdE9wdHNgIG9iamVjdCBpbiBjYXNlIGB1c2VDb2xvcnNgIGlzIHNldFxuICogZGlmZmVyZW50bHkgZm9yIGEgcGFydGljdWxhciBgZGVidWdgIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGluaXQgKGRlYnVnKSB7XG4gIGRlYnVnLmluc3BlY3RPcHRzID0ge307XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhleHBvcnRzLmluc3BlY3RPcHRzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVidWcuaW5zcGVjdE9wdHNba2V5c1tpXV0gPSBleHBvcnRzLmluc3BlY3RPcHRzW2tleXNbaV1dO1xuICB9XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBwcm9jZXNzLmVudi5ERUJVR2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG4iXSwibmFtZXMiOlsidHR5IiwicmVxdWlyZSIsInV0aWwiLCJleHBvcnRzIiwibW9kdWxlIiwiaW5pdCIsImxvZyIsImZvcm1hdEFyZ3MiLCJzYXZlIiwibG9hZCIsInVzZUNvbG9ycyIsImNvbG9ycyIsImluc3BlY3RPcHRzIiwiT2JqZWN0Iiwia2V5cyIsInByb2Nlc3MiLCJlbnYiLCJmaWx0ZXIiLCJrZXkiLCJ0ZXN0IiwicmVkdWNlIiwib2JqIiwicHJvcCIsInN1YnN0cmluZyIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsIl8iLCJrIiwidG9VcHBlckNhc2UiLCJ2YWwiLCJOdW1iZXIiLCJmZCIsInBhcnNlSW50IiwiREVCVUdfRkQiLCJkZXByZWNhdGUiLCJzdHJlYW0iLCJzdGRvdXQiLCJzdGRlcnIiLCJjcmVhdGVXcml0YWJsZVN0ZGlvU3RyZWFtIiwiQm9vbGVhbiIsImlzYXR0eSIsImZvcm1hdHRlcnMiLCJvIiwidiIsImluc3BlY3QiLCJzcGxpdCIsIm1hcCIsInN0ciIsInRyaW0iLCJqb2luIiwiTyIsImFyZ3MiLCJuYW1lIiwibmFtZXNwYWNlIiwiYyIsImNvbG9yIiwicHJlZml4IiwicHVzaCIsImh1bWFuaXplIiwiZGlmZiIsIkRhdGUiLCJ0b1VUQ1N0cmluZyIsIndyaXRlIiwiZm9ybWF0IiwiYXBwbHkiLCJhcmd1bWVudHMiLCJuYW1lc3BhY2VzIiwiREVCVUciLCJ0dHlfd3JhcCIsImJpbmRpbmciLCJndWVzc0hhbmRsZVR5cGUiLCJXcml0ZVN0cmVhbSIsIl90eXBlIiwiX2hhbmRsZSIsInVucmVmIiwiZnMiLCJTeW5jV3JpdGVTdHJlYW0iLCJhdXRvQ2xvc2UiLCJuZXQiLCJTb2NrZXQiLCJyZWFkYWJsZSIsIndyaXRhYmxlIiwicmVhZCIsIkVycm9yIiwiX2lzU3RkaW8iLCJkZWJ1ZyIsImkiLCJsZW5ndGgiLCJlbmFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/node_modules/debug/src/node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/node_modules/ms/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/websocket/node_modules/ms/index.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("/**\n * Helpers.\n */ var s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */ module.exports = function(val, options) {\n    options = options || {};\n    var type = typeof val;\n    if (type === \"string\" && val.length > 0) {\n        return parse(val);\n    } else if (type === \"number\" && isNaN(val) === false) {\n        return options.long ? fmtLong(val) : fmtShort(val);\n    }\n    throw new Error(\"val is not a non-empty string or a valid number. val=\" + JSON.stringify(val));\n};\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */ function parse(str) {\n    str = String(str);\n    if (str.length > 100) {\n        return;\n    }\n    var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n    if (!match) {\n        return;\n    }\n    var n = parseFloat(match[1]);\n    var type = (match[2] || \"ms\").toLowerCase();\n    switch(type){\n        case \"years\":\n        case \"year\":\n        case \"yrs\":\n        case \"yr\":\n        case \"y\":\n            return n * y;\n        case \"days\":\n        case \"day\":\n        case \"d\":\n            return n * d;\n        case \"hours\":\n        case \"hour\":\n        case \"hrs\":\n        case \"hr\":\n        case \"h\":\n            return n * h;\n        case \"minutes\":\n        case \"minute\":\n        case \"mins\":\n        case \"min\":\n        case \"m\":\n            return n * m;\n        case \"seconds\":\n        case \"second\":\n        case \"secs\":\n        case \"sec\":\n        case \"s\":\n            return n * s;\n        case \"milliseconds\":\n        case \"millisecond\":\n        case \"msecs\":\n        case \"msec\":\n        case \"ms\":\n            return n;\n        default:\n            return undefined;\n    }\n}\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */ function fmtShort(ms) {\n    if (ms >= d) {\n        return Math.round(ms / d) + \"d\";\n    }\n    if (ms >= h) {\n        return Math.round(ms / h) + \"h\";\n    }\n    if (ms >= m) {\n        return Math.round(ms / m) + \"m\";\n    }\n    if (ms >= s) {\n        return Math.round(ms / s) + \"s\";\n    }\n    return ms + \"ms\";\n}\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */ function fmtLong(ms) {\n    return plural(ms, d, \"day\") || plural(ms, h, \"hour\") || plural(ms, m, \"minute\") || plural(ms, s, \"second\") || ms + \" ms\";\n}\n/**\n * Pluralization helper.\n */ function plural(ms, n, name) {\n    if (ms < n) {\n        return;\n    }\n    if (ms < n * 1.5) {\n        return Math.floor(ms / n) + \" \" + name;\n    }\n    return Math.ceil(ms / n) + \" \" + name + \"s\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb2NrZXRoLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9ub2RlX21vZHVsZXMvbXMvaW5kZXguanM/MzhhZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxuICAgIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICB9XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG4iXSwibmFtZXMiOlsicyIsIm0iLCJoIiwiZCIsInkiLCJtb2R1bGUiLCJleHBvcnRzIiwidmFsIiwib3B0aW9ucyIsInR5cGUiLCJsZW5ndGgiLCJwYXJzZSIsImlzTmFOIiwibG9uZyIsImZtdExvbmciLCJmbXRTaG9ydCIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsInN0ciIsIlN0cmluZyIsIm1hdGNoIiwiZXhlYyIsIm4iLCJwYXJzZUZsb2F0IiwidG9Mb3dlckNhc2UiLCJ1bmRlZmluZWQiLCJtcyIsIk1hdGgiLCJyb3VuZCIsInBsdXJhbCIsIm5hbWUiLCJmbG9vciIsImNlaWwiXSwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBRUQsSUFBSUEsSUFBSTtBQUNSLElBQUlDLElBQUlELElBQUk7QUFDWixJQUFJRSxJQUFJRCxJQUFJO0FBQ1osSUFBSUUsSUFBSUQsSUFBSTtBQUNaLElBQUlFLElBQUlELElBQUk7QUFFWjs7Ozs7Ozs7Ozs7O0NBWUMsR0FFREUsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLEdBQUcsRUFBRUMsT0FBTztJQUNwQ0EsVUFBVUEsV0FBVyxDQUFDO0lBQ3RCLElBQUlDLE9BQU8sT0FBT0Y7SUFDbEIsSUFBSUUsU0FBUyxZQUFZRixJQUFJRyxNQUFNLEdBQUcsR0FBRztRQUN2QyxPQUFPQyxNQUFNSjtJQUNmLE9BQU8sSUFBSUUsU0FBUyxZQUFZRyxNQUFNTCxTQUFTLE9BQU87UUFDcEQsT0FBT0MsUUFBUUssSUFBSSxHQUFHQyxRQUFRUCxPQUFPUSxTQUFTUjtJQUNoRDtJQUNBLE1BQU0sSUFBSVMsTUFDUiwwREFDRUMsS0FBS0MsU0FBUyxDQUFDWDtBQUVyQjtBQUVBOzs7Ozs7Q0FNQyxHQUVELFNBQVNJLE1BQU1RLEdBQUc7SUFDaEJBLE1BQU1DLE9BQU9EO0lBQ2IsSUFBSUEsSUFBSVQsTUFBTSxHQUFHLEtBQUs7UUFDcEI7SUFDRjtJQUNBLElBQUlXLFFBQVEsd0hBQXdIQyxJQUFJLENBQ3RJSDtJQUVGLElBQUksQ0FBQ0UsT0FBTztRQUNWO0lBQ0Y7SUFDQSxJQUFJRSxJQUFJQyxXQUFXSCxLQUFLLENBQUMsRUFBRTtJQUMzQixJQUFJWixPQUFPLEFBQUNZLENBQUFBLEtBQUssQ0FBQyxFQUFFLElBQUksSUFBRyxFQUFHSSxXQUFXO0lBQ3pDLE9BQVFoQjtRQUNOLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT2MsSUFBSW5CO1FBQ2IsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT21CLElBQUlwQjtRQUNiLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT29CLElBQUlyQjtRQUNiLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT3FCLElBQUl0QjtRQUNiLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT3NCLElBQUl2QjtRQUNiLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT3VCO1FBQ1Q7WUFDRSxPQUFPRztJQUNYO0FBQ0Y7QUFFQTs7Ozs7O0NBTUMsR0FFRCxTQUFTWCxTQUFTWSxFQUFFO0lBQ2xCLElBQUlBLE1BQU14QixHQUFHO1FBQ1gsT0FBT3lCLEtBQUtDLEtBQUssQ0FBQ0YsS0FBS3hCLEtBQUs7SUFDOUI7SUFDQSxJQUFJd0IsTUFBTXpCLEdBQUc7UUFDWCxPQUFPMEIsS0FBS0MsS0FBSyxDQUFDRixLQUFLekIsS0FBSztJQUM5QjtJQUNBLElBQUl5QixNQUFNMUIsR0FBRztRQUNYLE9BQU8yQixLQUFLQyxLQUFLLENBQUNGLEtBQUsxQixLQUFLO0lBQzlCO0lBQ0EsSUFBSTBCLE1BQU0zQixHQUFHO1FBQ1gsT0FBTzRCLEtBQUtDLEtBQUssQ0FBQ0YsS0FBSzNCLEtBQUs7SUFDOUI7SUFDQSxPQUFPMkIsS0FBSztBQUNkO0FBRUE7Ozs7OztDQU1DLEdBRUQsU0FBU2IsUUFBUWEsRUFBRTtJQUNqQixPQUFPRyxPQUFPSCxJQUFJeEIsR0FBRyxVQUNuQjJCLE9BQU9ILElBQUl6QixHQUFHLFdBQ2Q0QixPQUFPSCxJQUFJMUIsR0FBRyxhQUNkNkIsT0FBT0gsSUFBSTNCLEdBQUcsYUFDZDJCLEtBQUs7QUFDVDtBQUVBOztDQUVDLEdBRUQsU0FBU0csT0FBT0gsRUFBRSxFQUFFSixDQUFDLEVBQUVRLElBQUk7SUFDekIsSUFBSUosS0FBS0osR0FBRztRQUNWO0lBQ0Y7SUFDQSxJQUFJSSxLQUFLSixJQUFJLEtBQUs7UUFDaEIsT0FBT0ssS0FBS0ksS0FBSyxDQUFDTCxLQUFLSixLQUFLLE1BQU1RO0lBQ3BDO0lBQ0EsT0FBT0gsS0FBS0ssSUFBSSxDQUFDTixLQUFLSixLQUFLLE1BQU1RLE9BQU87QUFDMUMiLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/node_modules/ms/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/vendor/FastBufferList.js":
/*!*********************************************************!*\
  !*** ./node_modules/websocket/vendor/FastBufferList.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// This file was copied from https://github.com/substack/node-bufferlist\n// and modified to be able to copy bytes from the bufferlist directly into\n// a pre-existing fixed-size buffer without an additional memory allocation.\n// bufferlist.js\n// Treat a linked list of buffers as a single variable-size buffer.\nvar Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar bufferAllocUnsafe = (__webpack_require__(/*! ../lib/utils */ \"(ssr)/./node_modules/websocket/lib/utils.js\").bufferAllocUnsafe);\nmodule.exports = BufferList;\nmodule.exports.BufferList = BufferList; // backwards compatibility\nfunction BufferList(opts) {\n    if (!(this instanceof BufferList)) return new BufferList(opts);\n    EventEmitter.call(this);\n    var self = this;\n    if (typeof opts == \"undefined\") opts = {};\n    // default encoding to use for take(). Leaving as 'undefined'\n    // makes take() return a Buffer instead.\n    self.encoding = opts.encoding;\n    var head = {\n        next: null,\n        buffer: null\n    };\n    var last = {\n        next: null,\n        buffer: null\n    };\n    // length can get negative when advanced past the end\n    // and this is the desired behavior\n    var length = 0;\n    self.__defineGetter__(\"length\", function() {\n        return length;\n    });\n    // keep an offset of the head to decide when to head = head.next\n    var offset = 0;\n    // Write to the bufferlist. Emits 'write'. Always returns true.\n    self.write = function(buf) {\n        if (!head.buffer) {\n            head.buffer = buf;\n            last = head;\n        } else {\n            last.next = {\n                next: null,\n                buffer: buf\n            };\n            last = last.next;\n        }\n        length += buf.length;\n        self.emit(\"write\", buf);\n        return true;\n    };\n    self.end = function(buf) {\n        if (Buffer.isBuffer(buf)) self.write(buf);\n    };\n    // Push buffers to the end of the linked list. (deprecated)\n    // Return this (self).\n    self.push = function() {\n        var args = [].concat.apply([], arguments);\n        args.forEach(self.write);\n        return self;\n    };\n    // For each buffer, perform some action.\n    // If fn's result is a true value, cut out early.\n    // Returns this (self).\n    self.forEach = function(fn) {\n        if (!head.buffer) return bufferAllocUnsafe(0);\n        if (head.buffer.length - offset <= 0) return self;\n        var firstBuf = head.buffer.slice(offset);\n        var b = {\n            buffer: firstBuf,\n            next: head.next\n        };\n        while(b && b.buffer){\n            var r = fn(b.buffer);\n            if (r) break;\n            b = b.next;\n        }\n        return self;\n    };\n    // Create a single Buffer out of all the chunks or some subset specified by\n    // start and one-past the end (like slice) in bytes.\n    self.join = function(start, end) {\n        if (!head.buffer) return bufferAllocUnsafe(0);\n        if (start == undefined) start = 0;\n        if (end == undefined) end = self.length;\n        var big = bufferAllocUnsafe(end - start);\n        var ix = 0;\n        self.forEach(function(buffer) {\n            if (start < ix + buffer.length && ix < end) {\n                // at least partially contained in the range\n                buffer.copy(big, Math.max(0, ix - start), Math.max(0, start - ix), Math.min(buffer.length, end - ix));\n            }\n            ix += buffer.length;\n            if (ix > end) return true; // stop processing past end\n        });\n        return big;\n    };\n    self.joinInto = function(targetBuffer, targetStart, sourceStart, sourceEnd) {\n        if (!head.buffer) return new bufferAllocUnsafe(0);\n        if (sourceStart == undefined) sourceStart = 0;\n        if (sourceEnd == undefined) sourceEnd = self.length;\n        var big = targetBuffer;\n        if (big.length - targetStart < sourceEnd - sourceStart) {\n            throw new Error(\"Insufficient space available in target Buffer.\");\n        }\n        var ix = 0;\n        self.forEach(function(buffer) {\n            if (sourceStart < ix + buffer.length && ix < sourceEnd) {\n                // at least partially contained in the range\n                buffer.copy(big, Math.max(targetStart, targetStart + ix - sourceStart), Math.max(0, sourceStart - ix), Math.min(buffer.length, sourceEnd - ix));\n            }\n            ix += buffer.length;\n            if (ix > sourceEnd) return true; // stop processing past end\n        });\n        return big;\n    };\n    // Advance the buffer stream by n bytes.\n    // If n the aggregate advance offset passes the end of the buffer list,\n    // operations such as .take() will return empty strings until enough data is\n    // pushed.\n    // Returns this (self).\n    self.advance = function(n) {\n        offset += n;\n        length -= n;\n        while(head.buffer && offset >= head.buffer.length){\n            offset -= head.buffer.length;\n            head = head.next ? head.next : {\n                buffer: null,\n                next: null\n            };\n        }\n        if (head.buffer === null) last = {\n            next: null,\n            buffer: null\n        };\n        self.emit(\"advance\", n);\n        return self;\n    };\n    // Take n bytes from the start of the buffers.\n    // Returns a string.\n    // If there are less than n bytes in all the buffers or n is undefined,\n    // returns the entire concatenated buffer string.\n    self.take = function(n, encoding) {\n        if (n == undefined) n = self.length;\n        else if (typeof n !== \"number\") {\n            encoding = n;\n            n = self.length;\n        }\n        var b = head;\n        if (!encoding) encoding = self.encoding;\n        if (encoding) {\n            var acc = \"\";\n            self.forEach(function(buffer) {\n                if (n <= 0) return true;\n                acc += buffer.toString(encoding, 0, Math.min(n, buffer.length));\n                n -= buffer.length;\n            });\n            return acc;\n        } else {\n            // If no 'encoding' is specified, then return a Buffer.\n            return self.join(0, n);\n        }\n    };\n    // The entire concatenated buffer as a string.\n    self.toString = function() {\n        return self.take(\"binary\");\n    };\n}\n(__webpack_require__(/*! util */ \"util\").inherits)(BufferList, EventEmitter);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L3ZlbmRvci9GYXN0QnVmZmVyTGlzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx3RUFBd0U7QUFDeEUsMEVBQTBFO0FBQzFFLDRFQUE0RTtBQUU1RSxnQkFBZ0I7QUFDaEIsbUVBQW1FO0FBQ25FLElBQUlBLFNBQVNDLG9EQUF3QjtBQUNyQyxJQUFJQyxlQUFlRCwwREFBOEI7QUFDakQsSUFBSUUsb0JBQW9CRiwwR0FBeUM7QUFFakVHLE9BQU9DLE9BQU8sR0FBR0M7QUFDakJGLHlCQUF5QixHQUFHRSxZQUFZLDBCQUEwQjtBQUVsRSxTQUFTQSxXQUFXQyxJQUFJO0lBQ3BCLElBQUksQ0FBRSxLQUFJLFlBQVlELFVBQVMsR0FBSSxPQUFPLElBQUlBLFdBQVdDO0lBQ3pETCxhQUFhTSxJQUFJLENBQUMsSUFBSTtJQUN0QixJQUFJQyxPQUFPLElBQUk7SUFFZixJQUFJLE9BQU9GLFFBQVMsYUFBYUEsT0FBTyxDQUFDO0lBRXpDLDZEQUE2RDtJQUM3RCx3Q0FBd0M7SUFDeENFLEtBQUtDLFFBQVEsR0FBR0gsS0FBS0csUUFBUTtJQUU3QixJQUFJQyxPQUFPO1FBQUVDLE1BQU87UUFBTUMsUUFBUztJQUFLO0lBQ3hDLElBQUlDLE9BQU87UUFBRUYsTUFBTztRQUFNQyxRQUFTO0lBQUs7SUFFeEMscURBQXFEO0lBQ3JELG1DQUFtQztJQUNuQyxJQUFJRSxTQUFTO0lBQ2JOLEtBQUtPLGdCQUFnQixDQUFDLFVBQVU7UUFDNUIsT0FBT0Q7SUFDWDtJQUVBLGdFQUFnRTtJQUNoRSxJQUFJRSxTQUFTO0lBRWIsK0RBQStEO0lBQy9EUixLQUFLUyxLQUFLLEdBQUcsU0FBVUMsR0FBRztRQUN0QixJQUFJLENBQUNSLEtBQUtFLE1BQU0sRUFBRTtZQUNkRixLQUFLRSxNQUFNLEdBQUdNO1lBQ2RMLE9BQU9IO1FBQ1gsT0FDSztZQUNERyxLQUFLRixJQUFJLEdBQUc7Z0JBQUVBLE1BQU87Z0JBQU1DLFFBQVNNO1lBQUk7WUFDeENMLE9BQU9BLEtBQUtGLElBQUk7UUFDcEI7UUFDQUcsVUFBVUksSUFBSUosTUFBTTtRQUNwQk4sS0FBS1csSUFBSSxDQUFDLFNBQVNEO1FBQ25CLE9BQU87SUFDWDtJQUVBVixLQUFLWSxHQUFHLEdBQUcsU0FBVUYsR0FBRztRQUNwQixJQUFJbkIsT0FBT3NCLFFBQVEsQ0FBQ0gsTUFBTVYsS0FBS1MsS0FBSyxDQUFDQztJQUN6QztJQUVBLDJEQUEyRDtJQUMzRCxzQkFBc0I7SUFDdEJWLEtBQUtjLElBQUksR0FBRztRQUNSLElBQUlDLE9BQU8sRUFBRSxDQUFDQyxNQUFNLENBQUNDLEtBQUssQ0FBQyxFQUFFLEVBQUVDO1FBQy9CSCxLQUFLSSxPQUFPLENBQUNuQixLQUFLUyxLQUFLO1FBQ3ZCLE9BQU9UO0lBQ1g7SUFFQSx3Q0FBd0M7SUFDeEMsaURBQWlEO0lBQ2pELHVCQUF1QjtJQUN2QkEsS0FBS21CLE9BQU8sR0FBRyxTQUFVQyxFQUFFO1FBQ3ZCLElBQUksQ0FBQ2xCLEtBQUtFLE1BQU0sRUFBRSxPQUFPVixrQkFBa0I7UUFFM0MsSUFBSVEsS0FBS0UsTUFBTSxDQUFDRSxNQUFNLEdBQUdFLFVBQVUsR0FBRyxPQUFPUjtRQUM3QyxJQUFJcUIsV0FBV25CLEtBQUtFLE1BQU0sQ0FBQ2tCLEtBQUssQ0FBQ2Q7UUFFakMsSUFBSWUsSUFBSTtZQUFFbkIsUUFBU2lCO1lBQVVsQixNQUFPRCxLQUFLQyxJQUFJO1FBQUM7UUFFOUMsTUFBT29CLEtBQUtBLEVBQUVuQixNQUFNLENBQUU7WUFDbEIsSUFBSW9CLElBQUlKLEdBQUdHLEVBQUVuQixNQUFNO1lBQ25CLElBQUlvQixHQUFHO1lBQ1BELElBQUlBLEVBQUVwQixJQUFJO1FBQ2Q7UUFFQSxPQUFPSDtJQUNYO0lBRUEsMkVBQTJFO0lBQzNFLG9EQUFvRDtJQUNwREEsS0FBS3lCLElBQUksR0FBRyxTQUFVQyxLQUFLLEVBQUVkLEdBQUc7UUFDNUIsSUFBSSxDQUFDVixLQUFLRSxNQUFNLEVBQUUsT0FBT1Ysa0JBQWtCO1FBQzNDLElBQUlnQyxTQUFTQyxXQUFXRCxRQUFRO1FBQ2hDLElBQUlkLE9BQU9lLFdBQVdmLE1BQU1aLEtBQUtNLE1BQU07UUFFdkMsSUFBSXNCLE1BQU1sQyxrQkFBa0JrQixNQUFNYztRQUNsQyxJQUFJRyxLQUFLO1FBQ1Q3QixLQUFLbUIsT0FBTyxDQUFDLFNBQVVmLE1BQU07WUFDekIsSUFBSXNCLFFBQVNHLEtBQUt6QixPQUFPRSxNQUFNLElBQUt1QixLQUFLakIsS0FBSztnQkFDMUMsNENBQTRDO2dCQUM1Q1IsT0FBTzBCLElBQUksQ0FDUEYsS0FDQUcsS0FBS0MsR0FBRyxDQUFDLEdBQUdILEtBQUtILFFBQ2pCSyxLQUFLQyxHQUFHLENBQUMsR0FBR04sUUFBUUcsS0FDcEJFLEtBQUtFLEdBQUcsQ0FBQzdCLE9BQU9FLE1BQU0sRUFBRU0sTUFBTWlCO1lBRXRDO1lBQ0FBLE1BQU16QixPQUFPRSxNQUFNO1lBQ25CLElBQUl1QixLQUFLakIsS0FBSyxPQUFPLE1BQU0sMkJBQTJCO1FBQzFEO1FBRUEsT0FBT2dCO0lBQ1g7SUFFQTVCLEtBQUtrQyxRQUFRLEdBQUcsU0FBVUMsWUFBWSxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsU0FBUztRQUN2RSxJQUFJLENBQUNwQyxLQUFLRSxNQUFNLEVBQUUsT0FBTyxJQUFJVixrQkFBa0I7UUFDL0MsSUFBSTJDLGVBQWVWLFdBQVdVLGNBQWM7UUFDNUMsSUFBSUMsYUFBYVgsV0FBV1csWUFBWXRDLEtBQUtNLE1BQU07UUFFbkQsSUFBSXNCLE1BQU1PO1FBQ1YsSUFBSVAsSUFBSXRCLE1BQU0sR0FBRzhCLGNBQWNFLFlBQVlELGFBQWE7WUFDcEQsTUFBTSxJQUFJRSxNQUFNO1FBQ3BCO1FBQ0EsSUFBSVYsS0FBSztRQUNUN0IsS0FBS21CLE9BQU8sQ0FBQyxTQUFVZixNQUFNO1lBQ3pCLElBQUlpQyxjQUFlUixLQUFLekIsT0FBT0UsTUFBTSxJQUFLdUIsS0FBS1MsV0FBVztnQkFDdEQsNENBQTRDO2dCQUM1Q2xDLE9BQU8wQixJQUFJLENBQ1BGLEtBQ0FHLEtBQUtDLEdBQUcsQ0FBQ0ksYUFBYUEsY0FBY1AsS0FBS1EsY0FDekNOLEtBQUtDLEdBQUcsQ0FBQyxHQUFHSyxjQUFjUixLQUMxQkUsS0FBS0UsR0FBRyxDQUFDN0IsT0FBT0UsTUFBTSxFQUFFZ0MsWUFBWVQ7WUFFNUM7WUFDQUEsTUFBTXpCLE9BQU9FLE1BQU07WUFDbkIsSUFBSXVCLEtBQUtTLFdBQVcsT0FBTyxNQUFNLDJCQUEyQjtRQUNoRTtRQUVBLE9BQU9WO0lBQ1g7SUFFQSx3Q0FBd0M7SUFDeEMsdUVBQXVFO0lBQ3ZFLDRFQUE0RTtJQUM1RSxVQUFVO0lBQ1YsdUJBQXVCO0lBQ3ZCNUIsS0FBS3dDLE9BQU8sR0FBRyxTQUFVQyxDQUFDO1FBQ3RCakMsVUFBVWlDO1FBQ1ZuQyxVQUFVbUM7UUFDVixNQUFPdkMsS0FBS0UsTUFBTSxJQUFJSSxVQUFVTixLQUFLRSxNQUFNLENBQUNFLE1BQU0sQ0FBRTtZQUNoREUsVUFBVU4sS0FBS0UsTUFBTSxDQUFDRSxNQUFNO1lBQzVCSixPQUFPQSxLQUFLQyxJQUFJLEdBQ1ZELEtBQUtDLElBQUksR0FDVDtnQkFBRUMsUUFBUztnQkFBTUQsTUFBTztZQUFLO1FBRXZDO1FBQ0EsSUFBSUQsS0FBS0UsTUFBTSxLQUFLLE1BQU1DLE9BQU87WUFBRUYsTUFBTztZQUFNQyxRQUFTO1FBQUs7UUFDOURKLEtBQUtXLElBQUksQ0FBQyxXQUFXOEI7UUFDckIsT0FBT3pDO0lBQ1g7SUFFQSw4Q0FBOEM7SUFDOUMsb0JBQW9CO0lBQ3BCLHVFQUF1RTtJQUN2RSxpREFBaUQ7SUFDakRBLEtBQUswQyxJQUFJLEdBQUcsU0FBVUQsQ0FBQyxFQUFFeEMsUUFBUTtRQUM3QixJQUFJd0MsS0FBS2QsV0FBV2MsSUFBSXpDLEtBQUtNLE1BQU07YUFDOUIsSUFBSSxPQUFPbUMsTUFBTSxVQUFVO1lBQzVCeEMsV0FBV3dDO1lBQ1hBLElBQUl6QyxLQUFLTSxNQUFNO1FBQ25CO1FBQ0EsSUFBSWlCLElBQUlyQjtRQUNSLElBQUksQ0FBQ0QsVUFBVUEsV0FBV0QsS0FBS0MsUUFBUTtRQUN2QyxJQUFJQSxVQUFVO1lBQ1YsSUFBSTBDLE1BQU07WUFDVjNDLEtBQUttQixPQUFPLENBQUMsU0FBVWYsTUFBTTtnQkFDekIsSUFBSXFDLEtBQUssR0FBRyxPQUFPO2dCQUNuQkUsT0FBT3ZDLE9BQU93QyxRQUFRLENBQ2xCM0MsVUFBVSxHQUFHOEIsS0FBS0UsR0FBRyxDQUFDUSxHQUFFckMsT0FBT0UsTUFBTTtnQkFFekNtQyxLQUFLckMsT0FBT0UsTUFBTTtZQUN0QjtZQUNBLE9BQU9xQztRQUNYLE9BQU87WUFDSCx1REFBdUQ7WUFDdkQsT0FBTzNDLEtBQUt5QixJQUFJLENBQUMsR0FBR2dCO1FBQ3hCO0lBQ0o7SUFFQSw4Q0FBOEM7SUFDOUN6QyxLQUFLNEMsUUFBUSxHQUFHO1FBQ1osT0FBTzVDLEtBQUswQyxJQUFJLENBQUM7SUFDckI7QUFDSjtBQUNBbEQsa0RBQXdCLENBQUNLLFlBQVlKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ja2V0aC8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvdmVuZG9yL0Zhc3RCdWZmZXJMaXN0LmpzP2E2YTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBmaWxlIHdhcyBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svbm9kZS1idWZmZXJsaXN0XG4vLyBhbmQgbW9kaWZpZWQgdG8gYmUgYWJsZSB0byBjb3B5IGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmxpc3QgZGlyZWN0bHkgaW50b1xuLy8gYSBwcmUtZXhpc3RpbmcgZml4ZWQtc2l6ZSBidWZmZXIgd2l0aG91dCBhbiBhZGRpdGlvbmFsIG1lbW9yeSBhbGxvY2F0aW9uLlxuXG4vLyBidWZmZXJsaXN0LmpzXG4vLyBUcmVhdCBhIGxpbmtlZCBsaXN0IG9mIGJ1ZmZlcnMgYXMgYSBzaW5nbGUgdmFyaWFibGUtc2l6ZSBidWZmZXIuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBidWZmZXJBbGxvY1Vuc2FmZSA9IHJlcXVpcmUoJy4uL2xpYi91dGlscycpLmJ1ZmZlckFsbG9jVW5zYWZlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlckxpc3Q7XG5tb2R1bGUuZXhwb3J0cy5CdWZmZXJMaXN0ID0gQnVmZmVyTGlzdDsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuZnVuY3Rpb24gQnVmZmVyTGlzdChvcHRzKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlckxpc3QpKSByZXR1cm4gbmV3IEJ1ZmZlckxpc3Qob3B0cyk7XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIFxuICAgIGlmICh0eXBlb2Yob3B0cykgPT0gJ3VuZGVmaW5lZCcpIG9wdHMgPSB7fTtcbiAgICBcbiAgICAvLyBkZWZhdWx0IGVuY29kaW5nIHRvIHVzZSBmb3IgdGFrZSgpLiBMZWF2aW5nIGFzICd1bmRlZmluZWQnXG4gICAgLy8gbWFrZXMgdGFrZSgpIHJldHVybiBhIEJ1ZmZlciBpbnN0ZWFkLlxuICAgIHNlbGYuZW5jb2RpbmcgPSBvcHRzLmVuY29kaW5nO1xuICAgIFxuICAgIHZhciBoZWFkID0geyBuZXh0IDogbnVsbCwgYnVmZmVyIDogbnVsbCB9O1xuICAgIHZhciBsYXN0ID0geyBuZXh0IDogbnVsbCwgYnVmZmVyIDogbnVsbCB9O1xuICAgIFxuICAgIC8vIGxlbmd0aCBjYW4gZ2V0IG5lZ2F0aXZlIHdoZW4gYWR2YW5jZWQgcGFzdCB0aGUgZW5kXG4gICAgLy8gYW5kIHRoaXMgaXMgdGhlIGRlc2lyZWQgYmVoYXZpb3JcbiAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICBzZWxmLl9fZGVmaW5lR2V0dGVyX18oJ2xlbmd0aCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBrZWVwIGFuIG9mZnNldCBvZiB0aGUgaGVhZCB0byBkZWNpZGUgd2hlbiB0byBoZWFkID0gaGVhZC5uZXh0XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgXG4gICAgLy8gV3JpdGUgdG8gdGhlIGJ1ZmZlcmxpc3QuIEVtaXRzICd3cml0ZScuIEFsd2F5cyByZXR1cm5zIHRydWUuXG4gICAgc2VsZi53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICAgICAgaWYgKCFoZWFkLmJ1ZmZlcikge1xuICAgICAgICAgICAgaGVhZC5idWZmZXIgPSBidWY7XG4gICAgICAgICAgICBsYXN0ID0gaGVhZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhc3QubmV4dCA9IHsgbmV4dCA6IG51bGwsIGJ1ZmZlciA6IGJ1ZiB9O1xuICAgICAgICAgICAgbGFzdCA9IGxhc3QubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgc2VsZi5lbWl0KCd3cml0ZScsIGJ1Zik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgXG4gICAgc2VsZi5lbmQgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmKSkgc2VsZi53cml0ZShidWYpO1xuICAgIH07XG4gICAgXG4gICAgLy8gUHVzaCBidWZmZXJzIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmtlZCBsaXN0LiAoZGVwcmVjYXRlZClcbiAgICAvLyBSZXR1cm4gdGhpcyAoc2VsZikuXG4gICAgc2VsZi5wdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLmNvbmNhdC5hcHBseShbXSwgYXJndW1lbnRzKTtcbiAgICAgICAgYXJncy5mb3JFYWNoKHNlbGYud3JpdGUpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIFxuICAgIC8vIEZvciBlYWNoIGJ1ZmZlciwgcGVyZm9ybSBzb21lIGFjdGlvbi5cbiAgICAvLyBJZiBmbidzIHJlc3VsdCBpcyBhIHRydWUgdmFsdWUsIGN1dCBvdXQgZWFybHkuXG4gICAgLy8gUmV0dXJucyB0aGlzIChzZWxmKS5cbiAgICBzZWxmLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgaWYgKCFoZWFkLmJ1ZmZlcikgcmV0dXJuIGJ1ZmZlckFsbG9jVW5zYWZlKDApO1xuICAgICAgICBcbiAgICAgICAgaWYgKGhlYWQuYnVmZmVyLmxlbmd0aCAtIG9mZnNldCA8PSAwKSByZXR1cm4gc2VsZjtcbiAgICAgICAgdmFyIGZpcnN0QnVmID0gaGVhZC5idWZmZXIuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgXG4gICAgICAgIHZhciBiID0geyBidWZmZXIgOiBmaXJzdEJ1ZiwgbmV4dCA6IGhlYWQubmV4dCB9O1xuICAgICAgICBcbiAgICAgICAgd2hpbGUgKGIgJiYgYi5idWZmZXIpIHtcbiAgICAgICAgICAgIHZhciByID0gZm4oYi5idWZmZXIpO1xuICAgICAgICAgICAgaWYgKHIpIGJyZWFrO1xuICAgICAgICAgICAgYiA9IGIubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBzaW5nbGUgQnVmZmVyIG91dCBvZiBhbGwgdGhlIGNodW5rcyBvciBzb21lIHN1YnNldCBzcGVjaWZpZWQgYnlcbiAgICAvLyBzdGFydCBhbmQgb25lLXBhc3QgdGhlIGVuZCAobGlrZSBzbGljZSkgaW4gYnl0ZXMuXG4gICAgc2VsZi5qb2luID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKCFoZWFkLmJ1ZmZlcikgcmV0dXJuIGJ1ZmZlckFsbG9jVW5zYWZlKDApO1xuICAgICAgICBpZiAoc3RhcnQgPT0gdW5kZWZpbmVkKSBzdGFydCA9IDA7XG4gICAgICAgIGlmIChlbmQgPT0gdW5kZWZpbmVkKSBlbmQgPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgXG4gICAgICAgIHZhciBiaWcgPSBidWZmZXJBbGxvY1Vuc2FmZShlbmQgLSBzdGFydCk7XG4gICAgICAgIHZhciBpeCA9IDA7XG4gICAgICAgIHNlbGYuZm9yRWFjaChmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCAoaXggKyBidWZmZXIubGVuZ3RoKSAmJiBpeCA8IGVuZCkge1xuICAgICAgICAgICAgICAgIC8vIGF0IGxlYXN0IHBhcnRpYWxseSBjb250YWluZWQgaW4gdGhlIHJhbmdlXG4gICAgICAgICAgICAgICAgYnVmZmVyLmNvcHkoXG4gICAgICAgICAgICAgICAgICAgIGJpZyxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgaXggLSBzdGFydCksXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KDAsIHN0YXJ0IC0gaXgpLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihidWZmZXIubGVuZ3RoLCBlbmQgLSBpeClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXggKz0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpeCA+IGVuZCkgcmV0dXJuIHRydWU7IC8vIHN0b3AgcHJvY2Vzc2luZyBwYXN0IGVuZFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBiaWc7XG4gICAgfTtcbiAgICBcbiAgICBzZWxmLmpvaW5JbnRvID0gZnVuY3Rpb24gKHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQsIHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpIHtcbiAgICAgICAgaWYgKCFoZWFkLmJ1ZmZlcikgcmV0dXJuIG5ldyBidWZmZXJBbGxvY1Vuc2FmZSgwKTtcbiAgICAgICAgaWYgKHNvdXJjZVN0YXJ0ID09IHVuZGVmaW5lZCkgc291cmNlU3RhcnQgPSAwO1xuICAgICAgICBpZiAoc291cmNlRW5kID09IHVuZGVmaW5lZCkgc291cmNlRW5kID0gc2VsZi5sZW5ndGg7XG4gICAgICAgIFxuICAgICAgICB2YXIgYmlnID0gdGFyZ2V0QnVmZmVyO1xuICAgICAgICBpZiAoYmlnLmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgc291cmNlRW5kIC0gc291cmNlU3RhcnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluc3VmZmljaWVudCBzcGFjZSBhdmFpbGFibGUgaW4gdGFyZ2V0IEJ1ZmZlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGl4ID0gMDtcbiAgICAgICAgc2VsZi5mb3JFYWNoKGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VTdGFydCA8IChpeCArIGJ1ZmZlci5sZW5ndGgpICYmIGl4IDwgc291cmNlRW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gYXQgbGVhc3QgcGFydGlhbGx5IGNvbnRhaW5lZCBpbiB0aGUgcmFuZ2VcbiAgICAgICAgICAgICAgICBidWZmZXIuY29weShcbiAgICAgICAgICAgICAgICAgICAgYmlnLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCh0YXJnZXRTdGFydCwgdGFyZ2V0U3RhcnQgKyBpeCAtIHNvdXJjZVN0YXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgc291cmNlU3RhcnQgLSBpeCksXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGJ1ZmZlci5sZW5ndGgsIHNvdXJjZUVuZCAtIGl4KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpeCArPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGl4ID4gc291cmNlRW5kKSByZXR1cm4gdHJ1ZTsgLy8gc3RvcCBwcm9jZXNzaW5nIHBhc3QgZW5kXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGJpZztcbiAgICB9O1xuICAgIFxuICAgIC8vIEFkdmFuY2UgdGhlIGJ1ZmZlciBzdHJlYW0gYnkgbiBieXRlcy5cbiAgICAvLyBJZiBuIHRoZSBhZ2dyZWdhdGUgYWR2YW5jZSBvZmZzZXQgcGFzc2VzIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBsaXN0LFxuICAgIC8vIG9wZXJhdGlvbnMgc3VjaCBhcyAudGFrZSgpIHdpbGwgcmV0dXJuIGVtcHR5IHN0cmluZ3MgdW50aWwgZW5vdWdoIGRhdGEgaXNcbiAgICAvLyBwdXNoZWQuXG4gICAgLy8gUmV0dXJucyB0aGlzIChzZWxmKS5cbiAgICBzZWxmLmFkdmFuY2UgPSBmdW5jdGlvbiAobikge1xuICAgICAgICBvZmZzZXQgKz0gbjtcbiAgICAgICAgbGVuZ3RoIC09IG47XG4gICAgICAgIHdoaWxlIChoZWFkLmJ1ZmZlciAmJiBvZmZzZXQgPj0gaGVhZC5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBvZmZzZXQgLT0gaGVhZC5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaGVhZCA9IGhlYWQubmV4dFxuICAgICAgICAgICAgICAgID8gaGVhZC5uZXh0XG4gICAgICAgICAgICAgICAgOiB7IGJ1ZmZlciA6IG51bGwsIG5leHQgOiBudWxsIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZC5idWZmZXIgPT09IG51bGwpIGxhc3QgPSB7IG5leHQgOiBudWxsLCBidWZmZXIgOiBudWxsIH07XG4gICAgICAgIHNlbGYuZW1pdCgnYWR2YW5jZScsIG4pO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIFxuICAgIC8vIFRha2UgbiBieXRlcyBmcm9tIHRoZSBzdGFydCBvZiB0aGUgYnVmZmVycy5cbiAgICAvLyBSZXR1cm5zIGEgc3RyaW5nLlxuICAgIC8vIElmIHRoZXJlIGFyZSBsZXNzIHRoYW4gbiBieXRlcyBpbiBhbGwgdGhlIGJ1ZmZlcnMgb3IgbiBpcyB1bmRlZmluZWQsXG4gICAgLy8gcmV0dXJucyB0aGUgZW50aXJlIGNvbmNhdGVuYXRlZCBidWZmZXIgc3RyaW5nLlxuICAgIHNlbGYudGFrZSA9IGZ1bmN0aW9uIChuLCBlbmNvZGluZykge1xuICAgICAgICBpZiAobiA9PSB1bmRlZmluZWQpIG4gPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBlbmNvZGluZyA9IG47XG4gICAgICAgICAgICBuID0gc2VsZi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGIgPSBoZWFkO1xuICAgICAgICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHNlbGYuZW5jb2Rpbmc7XG4gICAgICAgIGlmIChlbmNvZGluZykge1xuICAgICAgICAgICAgdmFyIGFjYyA9ICcnO1xuICAgICAgICAgICAgc2VsZi5mb3JFYWNoKGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobiA8PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhY2MgKz0gYnVmZmVyLnRvU3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZywgMCwgTWF0aC5taW4obixidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbiAtPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgbm8gJ2VuY29kaW5nJyBpcyBzcGVjaWZpZWQsIHRoZW4gcmV0dXJuIGEgQnVmZmVyLlxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuam9pbigwLCBuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLy8gVGhlIGVudGlyZSBjb25jYXRlbmF0ZWQgYnVmZmVyIGFzIGEgc3RyaW5nLlxuICAgIHNlbGYudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnRha2UoJ2JpbmFyeScpO1xuICAgIH07XG59XG5yZXF1aXJlKCd1dGlsJykuaW5oZXJpdHMoQnVmZmVyTGlzdCwgRXZlbnRFbWl0dGVyKTtcbiJdLCJuYW1lcyI6WyJCdWZmZXIiLCJyZXF1aXJlIiwiRXZlbnRFbWl0dGVyIiwiYnVmZmVyQWxsb2NVbnNhZmUiLCJtb2R1bGUiLCJleHBvcnRzIiwiQnVmZmVyTGlzdCIsIm9wdHMiLCJjYWxsIiwic2VsZiIsImVuY29kaW5nIiwiaGVhZCIsIm5leHQiLCJidWZmZXIiLCJsYXN0IiwibGVuZ3RoIiwiX19kZWZpbmVHZXR0ZXJfXyIsIm9mZnNldCIsIndyaXRlIiwiYnVmIiwiZW1pdCIsImVuZCIsImlzQnVmZmVyIiwicHVzaCIsImFyZ3MiLCJjb25jYXQiLCJhcHBseSIsImFyZ3VtZW50cyIsImZvckVhY2giLCJmbiIsImZpcnN0QnVmIiwic2xpY2UiLCJiIiwiciIsImpvaW4iLCJzdGFydCIsInVuZGVmaW5lZCIsImJpZyIsIml4IiwiY29weSIsIk1hdGgiLCJtYXgiLCJtaW4iLCJqb2luSW50byIsInRhcmdldEJ1ZmZlciIsInRhcmdldFN0YXJ0Iiwic291cmNlU3RhcnQiLCJzb3VyY2VFbmQiLCJFcnJvciIsImFkdmFuY2UiLCJuIiwidGFrZSIsImFjYyIsInRvU3RyaW5nIiwiaW5oZXJpdHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/vendor/FastBufferList.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/package.json":
/*!*********************************************!*\
  !*** ./node_modules/websocket/package.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"websocket","description":"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.","keywords":["websocket","websockets","socket","networking","comet","push","RFC-6455","realtime","server","client"],"author":"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)","contributors":["Iaki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"],"version":"1.0.34","repository":{"type":"git","url":"https://github.com/theturtle32/WebSocket-Node.git"},"homepage":"https://github.com/theturtle32/WebSocket-Node","engines":{"node":">=4.0.0"},"dependencies":{"bufferutil":"^4.0.1","debug":"^2.2.0","es5-ext":"^0.10.50","typedarray-to-buffer":"^3.1.5","utf-8-validate":"^5.0.2","yaeti":"^0.0.6"},"devDependencies":{"buffer-equal":"^1.0.0","gulp":"^4.0.2","gulp-jshint":"^2.0.4","jshint-stylish":"^2.2.1","jshint":"^2.0.0","tape":"^4.9.1"},"config":{"verbose":false},"scripts":{"test":"tape test/unit/*.js","gulp":"gulp"},"main":"index","directories":{"lib":"./lib"},"browser":"lib/browser.js","license":"Apache-2.0"}');

/***/ })

};
;