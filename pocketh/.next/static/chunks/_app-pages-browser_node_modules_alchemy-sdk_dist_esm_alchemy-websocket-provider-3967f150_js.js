/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_alchemy-sdk_dist_esm_alchemy-websocket-provider-3967f150_js"],{

/***/ "(app-pages-browser)/./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocketProvider: function() { return /* binding */ WebSocketProvider; }\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(app-pages-browser)/./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(app-pages-browser)/./node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./json-rpc-provider */ \"(app-pages-browser)/./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\");\n/* harmony import */ var _ws__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ws */ \"(app-pages-browser)/./node_modules/@ethersproject/providers/lib.esm/ws.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(app-pages-browser)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(app-pages-browser)/./node_modules/@ethersproject/providers/lib.esm/_version.js\");\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\nlet NextId = 1;\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\nclass WebSocketProvider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider {\n    constructor(url, network) {\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n        if (typeof (url) === \"string\") {\n            super(url, network);\n        }\n        else {\n            super(\"_websocket\", network);\n        }\n        this._pollingInterval = -1;\n        this._wsReady = false;\n        if (typeof (url) === \"string\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_websocket\", new _ws__WEBPACK_IMPORTED_MODULE_4__.WebSocket(this.connection.url));\n        }\n        else {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_websocket\", url);\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_requests\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_subs\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_subIds\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_detectNetwork\", super.detectNetwork());\n        // Stall sending requests until the socket is open...\n        this.websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this.websocket.send(this._requests[id].payload);\n            });\n        };\n        this.websocket.onmessage = (messageEvent) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n                }\n                else {\n                    let error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(error, \"code\", result.error.code || null);\n                        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(error, \"response\", data);\n                    }\n                    else {\n                        error = new Error(\"unknown error\");\n                    }\n                    request.callback(error, undefined);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n                }\n            }\n            else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result);\n                }\n            }\n            else {\n                console.warn(\"this should not happen\");\n            }\n        };\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) {\n            fauxPoll.unref();\n        }\n    }\n    // Cannot narrow the type of _websocket, as that is not backwards compatible\n    // so we add a getter and let the WebSocket be a public API.\n    get websocket() { return this._websocket; }\n    detectNetwork() {\n        return this._detectNetwork;\n    }\n    get pollingInterval() {\n        return 0;\n    }\n    resetEventsBlock(blockNumber) {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n    set pollingInterval(value) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return null;\n        });\n    }\n    set polling(value) {\n        if (!value) {\n            return;\n        }\n        logger.throwError(\"cannot set polling on WebSocketProvider\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n    send(method, params) {\n        const rid = NextId++;\n        return new Promise((resolve, reject) => {\n            function callback(error, result) {\n                if (error) {\n                    return reject(error);\n                }\n                return resolve(result);\n            }\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n            this._requests[String(rid)] = { callback, payload };\n            if (this._wsReady) {\n                this.websocket.send(payload);\n            }\n        });\n    }\n    static defaultUrl() {\n        return \"ws:/\\/localhost:8546\";\n    }\n    _subscribe(tag, param, processFunc) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let subIdPromise = this._subIds[tag];\n            if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then((param) => {\n                    return this.send(\"eth_subscribe\", param);\n                });\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            this._subs[subId] = { tag, processFunc };\n        });\n    }\n    _startEvent(event) {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [\"newHeads\"], (result) => {\n                    const blockNumber = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_5__.BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n            case \"pending\":\n                this._subscribe(\"pending\", [\"newPendingTransactions\"], (result) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n            case \"filter\":\n                this._subscribe(event.tag, [\"logs\", this._getFilter(event.filter)], (result) => {\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n            case \"tx\": {\n                const emitReceipt = (event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) {\n                            return;\n                        }\n                        this.emit(hash, receipt);\n                    });\n                };\n                // In case it is already mined\n                emitReceipt(event);\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [\"newHeads\"], (result) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n    _stopEvent(event) {\n        let tag = event.tag;\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        }\n        else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        const subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        subId.then((subId) => {\n            if (!this._subs[subId]) {\n                return;\n            }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [subId]);\n        });\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Wait until we have connected before trying to disconnect\n            if (this.websocket.readyState === _ws__WEBPACK_IMPORTED_MODULE_4__.WebSocket.CONNECTING) {\n                yield (new Promise((resolve) => {\n                    this.websocket.onopen = function () {\n                        resolve(true);\n                    };\n                    this.websocket.onerror = function () {\n                        resolve(false);\n                    };\n                }));\n            }\n            // Hangup\n            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n            this.websocket.close(1000);\n        });\n    }\n}\n//# sourceMappingURL=websocket-provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS93ZWJzb2NrZXQtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFhO0FBQ2IsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ3FEO0FBQ007QUFDTDtBQUNyQjtBQUNjO0FBQ1Y7QUFDckMsbUJBQW1CLHlEQUFNLENBQUMsNkNBQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGdDQUFnQywrREFBZTtBQUN0RDtBQUNBLDZDQUE2QztBQUM3QztBQUNBLHNGQUFzRix5REFBTTtBQUM1RjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUVBQWMseUJBQXlCLDBDQUFTO0FBQzVEO0FBQ0E7QUFDQSxZQUFZLHlFQUFjO0FBQzFCO0FBQ0EsUUFBUSx5RUFBYyxzQkFBc0I7QUFDNUMsUUFBUSx5RUFBYyxrQkFBa0I7QUFDeEMsUUFBUSx5RUFBYyxvQkFBb0I7QUFDMUMsUUFBUSx5RUFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlFQUFjO0FBQ3RDLHdCQUF3Qix5RUFBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUseURBQU07QUFDbEY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhFQUE4RSx5REFBTTtBQUNwRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLHlEQUFNO0FBQzNFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywrREFBUztBQUNqRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywwQ0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL3dlYnNvY2tldC1wcm92aWRlci5qcz8yMjdiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBKc29uUnBjUHJvdmlkZXIgfSBmcm9tIFwiLi9qc29uLXJwYy1wcm92aWRlclwiO1xuaW1wb3J0IHsgV2ViU29ja2V0IH0gZnJvbSBcIi4vd3NcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbi8qKlxuICogIE5vdGVzOlxuICpcbiAqICBUaGlzIHByb3ZpZGVyIGRpZmZlcnMgYSBiaXQgZnJvbSB0aGUgcG9sbGluZyBwcm92aWRlcnMuIE9uZSBtYWluXG4gKiAgZGlmZmVyZW5jZSBpcyBob3cgaXQgaGFuZGxlcyBjb25zaXN0ZW5jeS4gVGhlIHBvbGxpbmcgcHJvdmlkZXJzXG4gKiAgd2lsbCBzdGFsbCByZXNwb25zZXMgdG8gZW5zdXJlIGEgY29uc2lzdGVudCBzdGF0ZSwgd2hpbGUgdGhpc1xuICogIFdlYlNvY2tldCBwcm92aWRlciBhc3N1bWVzIHRoZSBjb25uZWN0ZWQgYmFja2VuZCB3aWxsIG1hbmFnZSB0aGlzLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgaWYgYSBwb2xsaW5nIHByb3ZpZGVyIGVtaXRzIGFuIGV2ZW50IHdoaWNoIGluZGljYXRlc1xuICogIHRoZSBldmVudCBvY2N1cnJlZCBpbiBibG9ja2hhc2ggWFhYLCBhIGNhbGwgdG8gZmV0Y2ggdGhhdCBibG9jayBieVxuICogIGl0cyBoYXNoIFhYWCwgaWYgbm90IHByZXNlbnQgd2lsbCByZXRyeSB1bnRpbCBpdCBpcyBwcmVzZW50LiBUaGlzXG4gKiAgY2FuIG9jY3VyIHdoZW4gcXVlcnlpbmcgYSBwb29sIG9mIG5vZGVzIHRoYXQgYXJlIG1pbGRseSBvdXQgb2Ygc3luY1xuICogIHdpdGggZWFjaCBvdGhlci5cbiAqL1xubGV0IE5leHRJZCA9IDE7XG4vLyBGb3IgbW9yZSBpbmZvIGFib3V0IHRoZSBSZWFsLXRpbWUgRXZlbnQgQVBJIHNlZTpcbi8vICAgaHR0cHM6Ly9nZXRoLmV0aGVyZXVtLm9yZy9kb2NzL3JwYy9wdWJzdWJcbmV4cG9ydCBjbGFzcyBXZWJTb2NrZXRQcm92aWRlciBleHRlbmRzIEpzb25ScGNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IodXJsLCBuZXR3b3JrKSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBhZGRlZCBpbiB0aGUgZnV0dXJlOyBwbGVhc2Ugb3BlbiBhbiBpc3N1ZSB0byBleHBlZGl0ZVxuICAgICAgICBpZiAobmV0d29yayA9PT0gXCJhbnlcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJXZWJTb2NrZXRQcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0ICdhbnknIG5ldHdvcmsgeWV0XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldHdvcms6YW55XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHVybCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHN1cGVyKHVybCwgbmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlcihcIl93ZWJzb2NrZXRcIiwgbmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcG9sbGluZ0ludGVydmFsID0gLTE7XG4gICAgICAgIHRoaXMuX3dzUmVhZHkgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfd2Vic29ja2V0XCIsIG5ldyBXZWJTb2NrZXQodGhpcy5jb25uZWN0aW9uLnVybCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfd2Vic29ja2V0XCIsIHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfcmVxdWVzdHNcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9zdWJzXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfc3ViSWRzXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfZGV0ZWN0TmV0d29ya1wiLCBzdXBlci5kZXRlY3ROZXR3b3JrKCkpO1xuICAgICAgICAvLyBTdGFsbCBzZW5kaW5nIHJlcXVlc3RzIHVudGlsIHRoZSBzb2NrZXQgaXMgb3Blbi4uLlxuICAgICAgICB0aGlzLndlYnNvY2tldC5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl93c1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3JlcXVlc3RzKS5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMud2Vic29ja2V0LnNlbmQodGhpcy5fcmVxdWVzdHNbaWRdLnBheWxvYWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2Vic29ja2V0Lm9ubWVzc2FnZSA9IChtZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBtZXNzYWdlRXZlbnQuZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IFN0cmluZyhyZXN1bHQuaWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLl9yZXF1ZXN0c1tpZF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3JlcXVlc3RzW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2sobnVsbCwgcmVzdWx0LnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogSlNPTi5wYXJzZShyZXF1ZXN0LnBheWxvYWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3VsdC5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlIHx8IFwidW5rbm93biBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KGVycm9yLCBcImNvZGVcIiwgcmVzdWx0LmVycm9yLmNvZGUgfHwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seShlcnJvciwgXCJyZXNwb25zZVwiLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwidW5rbm93biBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKGVycm9yLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IEpTT04ucGFyc2UocmVxdWVzdC5wYXlsb2FkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5tZXRob2QgPT09IFwiZXRoX3N1YnNjcmlwdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgLy8gU3Vic2NyaXB0aW9uLi4uXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViID0gdGhpcy5fc3Vic1tyZXN1bHQucGFyYW1zLnN1YnNjcmlwdGlvbl07XG4gICAgICAgICAgICAgICAgaWYgKHN1Yikge1xuICAgICAgICAgICAgICAgICAgICAvL3RoaXMuZW1pdC5hcHBseSh0aGlzLCAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHN1Yi5wcm9jZXNzRnVuYyhyZXN1bHQucGFyYW1zLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwidGhpcyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhpcyBQcm92aWRlciBkb2VzIG5vdCBhY3R1YWxseSBwb2xsLCBidXQgd2Ugd2FudCB0byB0cmlnZ2VyXG4gICAgICAgIC8vIHBvbGwgZXZlbnRzIGZvciB0aGluZ3MgdGhhdCBkZXBlbmQgb24gdGhlbSAobGlrZSBzdGFsbGluZyBmb3JcbiAgICAgICAgLy8gYmxvY2sgYW5kIHRyYW5zYWN0aW9uIGxvb2t1cHMpXG4gICAgICAgIGNvbnN0IGZhdXhQb2xsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwicG9sbFwiKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIGlmIChmYXV4UG9sbC51bnJlZikge1xuICAgICAgICAgICAgZmF1eFBvbGwudW5yZWYoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDYW5ub3QgbmFycm93IHRoZSB0eXBlIG9mIF93ZWJzb2NrZXQsIGFzIHRoYXQgaXMgbm90IGJhY2t3YXJkcyBjb21wYXRpYmxlXG4gICAgLy8gc28gd2UgYWRkIGEgZ2V0dGVyIGFuZCBsZXQgdGhlIFdlYlNvY2tldCBiZSBhIHB1YmxpYyBBUEkuXG4gICAgZ2V0IHdlYnNvY2tldCgpIHsgcmV0dXJuIHRoaXMuX3dlYnNvY2tldDsgfVxuICAgIGRldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXRlY3ROZXR3b3JrO1xuICAgIH1cbiAgICBnZXQgcG9sbGluZ0ludGVydmFsKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmVzZXRFdmVudHNCbG9jayhibG9ja051bWJlcikge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCByZXNldCBldmVudHMgYmxvY2sgb24gV2ViU29ja2V0UHJvdmlkZXJcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXNldEV2ZW50QmxvY2tcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0IHBvbGxpbmdJbnRlcnZhbCh2YWx1ZSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBzZXQgcG9sbGluZyBpbnRlcnZhbCBvbiBXZWJTb2NrZXRQcm92aWRlclwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldFBvbGxpbmdJbnRlcnZhbFwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb2xsKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXQgcG9sbGluZyh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3Qgc2V0IHBvbGxpbmcgb24gV2ViU29ja2V0UHJvdmlkZXJcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXRQb2xsaW5nXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmlkID0gTmV4dElkKys7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayhlcnJvciwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICBpZDogcmlkLFxuICAgICAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogSlNPTi5wYXJzZShwYXlsb2FkKSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0c1tTdHJpbmcocmlkKV0gPSB7IGNhbGxiYWNrLCBwYXlsb2FkIH07XG4gICAgICAgICAgICBpZiAodGhpcy5fd3NSZWFkeSkge1xuICAgICAgICAgICAgICAgIHRoaXMud2Vic29ja2V0LnNlbmQocGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmYXVsdFVybCgpIHtcbiAgICAgICAgcmV0dXJuIFwid3M6L1xcL2xvY2FsaG9zdDo4NTQ2XCI7XG4gICAgfVxuICAgIF9zdWJzY3JpYmUodGFnLCBwYXJhbSwgcHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBzdWJJZFByb21pc2UgPSB0aGlzLl9zdWJJZHNbdGFnXTtcbiAgICAgICAgICAgIGlmIChzdWJJZFByb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN1YklkUHJvbWlzZSA9IFByb21pc2UuYWxsKHBhcmFtKS50aGVuKChwYXJhbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kKFwiZXRoX3N1YnNjcmliZVwiLCBwYXJhbSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3ViSWRzW3RhZ10gPSBzdWJJZFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdWJJZCA9IHlpZWxkIHN1YklkUHJvbWlzZTtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNbc3ViSWRdID0geyB0YWcsIHByb2Nlc3NGdW5jIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc3RhcnRFdmVudChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJibG9ja1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZShcImJsb2NrXCIsIFtcIm5ld0hlYWRzXCJdLCAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gQmlnTnVtYmVyLmZyb20ocmVzdWx0Lm51bWJlcikudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZC5ibG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJibG9ja1wiLCBibG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZShcInBlbmRpbmdcIiwgW1wibmV3UGVuZGluZ1RyYW5zYWN0aW9uc1wiXSwgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJwZW5kaW5nXCIsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmlsdGVyXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKGV2ZW50LnRhZywgW1wibG9nc1wiLCB0aGlzLl9nZXRGaWx0ZXIoZXZlbnQuZmlsdGVyKV0sIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZW1vdmVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZW1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50LmZpbHRlciwgdGhpcy5mb3JtYXR0ZXIuZmlsdGVyTG9nKHJlc3VsdCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInR4XCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWl0UmVjZWlwdCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0gZXZlbnQuaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCkudGhlbigocmVjZWlwdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWNlaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGhhc2gsIHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgaXQgaXMgYWxyZWFkeSBtaW5lZFxuICAgICAgICAgICAgICAgIGVtaXRSZWNlaXB0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBUbyBrZWVwIHRoaW5ncyBzaW1wbGUsIHdlIHN0YXJ0IHVwIGEgc2luZ2xlIG5ld0hlYWRzIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgICAgIC8vIHRvIGtlZXAgYW4gZXllIG91dCBmb3IgdHJhbnNhY3Rpb25zIHdlIGFyZSB3YXRjaGluZyBmb3IuXG4gICAgICAgICAgICAgICAgLy8gU3RhcnRpbmcgYSBzdWJzY3JpcHRpb24gZm9yIGFuIGV2ZW50IChpLmUuIFwidHhcIikgdGhhdCBpcyBhbHJlYWR5XG4gICAgICAgICAgICAgICAgLy8gcnVubmluZyBpcyAoYmFzaWNhbGx5KSBhIG5vcC5cbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUoXCJ0eFwiLCBbXCJuZXdIZWFkc1wiXSwgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHMuZmlsdGVyKChlKSA9PiAoZS50eXBlID09PSBcInR4XCIpKS5mb3JFYWNoKGVtaXRSZWNlaXB0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdGhpbmcgaXMgbmVlZGVkXG4gICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwb2xsXCI6XG4gICAgICAgICAgICBjYXNlIFwid2lsbFBvbGxcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkaWRQb2xsXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1bmhhbmRsZWQ6XCIsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGxldCB0YWcgPSBldmVudC50YWc7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSBcInR4XCIpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSByZW1haW5pbmcgdHJhbnNhY3Rpb24gZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRzLmZpbHRlcigoZSkgPT4gKGUudHlwZSA9PT0gXCJ0eFwiKSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFnID0gXCJ0eFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGlzdGVuZXJDb3VudChldmVudC5ldmVudCkpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSByZW1haW5pbmcgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3ViSWQgPSB0aGlzLl9zdWJJZHNbdGFnXTtcbiAgICAgICAgaWYgKCFzdWJJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJJZHNbdGFnXTtcbiAgICAgICAgc3ViSWQudGhlbigoc3ViSWQpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3Vic1tzdWJJZF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc3Vic1tzdWJJZF07XG4gICAgICAgICAgICB0aGlzLnNlbmQoXCJldGhfdW5zdWJzY3JpYmVcIiwgW3N1YklkXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCB3ZSBoYXZlIGNvbm5lY3RlZCBiZWZvcmUgdHJ5aW5nIHRvIGRpc2Nvbm5lY3RcbiAgICAgICAgICAgIGlmICh0aGlzLndlYnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgICAgICAgICAgIHlpZWxkIChuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndlYnNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndlYnNvY2tldC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFuZ3VwXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50I1N0YXR1c19jb2Rlc1xuICAgICAgICAgICAgdGhpcy53ZWJzb2NrZXQuY2xvc2UoMTAwMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYnNvY2tldC1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@ethersproject/providers/lib.esm/ws.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/ws.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocket: function() { return /* binding */ WS; }\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(app-pages-browser)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(app-pages-browser)/./node_modules/@ethersproject/providers/lib.esm/_version.js\");\n\n\n\nlet WS = null;\ntry {\n    WS = WebSocket;\n    if (WS == null) {\n        throw new Error(\"inject please\");\n    }\n}\ncatch (error) {\n    const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n    WS = function () {\n        logger.throwError(\"WebSockets not supported in this environment\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    };\n}\n//export default WS;\n//module.exports = WS;\n\n//# sourceMappingURL=ws.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS93cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBYTtBQUNrQztBQUNWO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseURBQU0sQ0FBQyw2Q0FBTztBQUNyQztBQUNBLDBFQUEwRSx5REFBTTtBQUNoRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUMyQjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vd3MuanM/MWM0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xubGV0IFdTID0gbnVsbDtcbnRyeSB7XG4gICAgV1MgPSBXZWJTb2NrZXQ7XG4gICAgaWYgKFdTID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5qZWN0IHBsZWFzZVwiKTtcbiAgICB9XG59XG5jYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuICAgIFdTID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIldlYlNvY2tldHMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IFdlYlNvY2tldCgpXCJcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8vZXhwb3J0IGRlZmF1bHQgV1M7XG4vL21vZHVsZS5leHBvcnRzID0gV1M7XG5leHBvcnQgeyBXUyBhcyBXZWJTb2NrZXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@ethersproject/providers/lib.esm/ws.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/alchemy-sdk/dist/esm/alchemy-provider-5e530ed5.js":
/*!************************************************************************!*\
  !*** ./node_modules/alchemy-sdk/dist/esm/alchemy-provider-5e530ed5.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AlchemyProvider: function() { return /* binding */ AlchemyProvider; }\n/* harmony export */ });\n/* harmony import */ var _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-1f2f6032.js */ \"(app-pages-browser)/./node_modules/alchemy-sdk/dist/esm/index-1f2f6032.js\");\n/* harmony import */ var _ethersproject_networks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/networks */ \"(app-pages-browser)/./node_modules/@ethersproject/networks/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_providers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/providers */ \"(app-pages-browser)/./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/web */ \"(app-pages-browser)/./node_modules/@ethersproject/web/lib.esm/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n\n\n\n\n\n\n\n\n/** Maximum size of a batch on the rpc provider. */\r\nconst DEFAULT_MAX_REQUEST_BATCH_SIZE = 100;\r\n/** Timeout interval before the pending batch is sent. */\r\nconst DEFAULT_REQUEST_BATCH_DELAY_MS = 10;\r\n/**\r\n * Internal class to enqueue requests and automatically send/process batches.\r\n *\r\n * The underlying batching mechanism is loosely based on ethers.js's\r\n * `JsonRpcBatchProvider`.\r\n *\r\n * @internal\r\n */\r\nclass RequestBatcher {\r\n    constructor(sendBatchFn, maxBatchSize = DEFAULT_MAX_REQUEST_BATCH_SIZE) {\r\n        this.sendBatchFn = sendBatchFn;\r\n        this.maxBatchSize = maxBatchSize;\r\n        /**\r\n         * Array of enqueued requests along with the constructed promise handlers for\r\n         * each request.\r\n         */\r\n        this.pendingBatch = [];\r\n    }\r\n    /**\r\n     * Enqueues the provided request. The batch is immediately sent if the maximum\r\n     * batch size is reached. Otherwise, the request is enqueued onto a batch that\r\n     * is sent after 10ms.\r\n     *\r\n     * Returns a promise that resolves with the result of the request.\r\n     */\r\n    enqueueRequest(request) {\r\n        return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            const inflightRequest = {\r\n                request,\r\n                resolve: undefined,\r\n                reject: undefined\r\n            };\r\n            const promise = new Promise((resolve, reject) => {\r\n                inflightRequest.resolve = resolve;\r\n                inflightRequest.reject = reject;\r\n            });\r\n            this.pendingBatch.push(inflightRequest);\r\n            if (this.pendingBatch.length === this.maxBatchSize) {\r\n                // Send batch immediately if we are at the maximum batch size.\r\n                void this.sendBatchRequest();\r\n            }\r\n            else if (!this.pendingBatchTimer) {\r\n                // Schedule batch for next event loop + short duration\r\n                this.pendingBatchTimer = setTimeout(() => this.sendBatchRequest(), DEFAULT_REQUEST_BATCH_DELAY_MS);\r\n            }\r\n            return promise;\r\n        });\r\n    }\r\n    /**\r\n     * Sends the currently queued batches and resets the batch and timer. Processes\r\n     * the batched response results back to the original promises.\r\n     */\r\n    sendBatchRequest() {\r\n        return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            // Get the current batch and clear it, so new requests\r\n            // go into the next batch\r\n            const batch = this.pendingBatch;\r\n            this.pendingBatch = [];\r\n            if (this.pendingBatchTimer) {\r\n                clearTimeout(this.pendingBatchTimer);\r\n                this.pendingBatchTimer = undefined;\r\n            }\r\n            // Get the request as an array of requests\r\n            const request = batch.map(inflight => inflight.request);\r\n            return this.sendBatchFn(request).then(result => {\r\n                // For each result, feed it to the correct Promise, depending\r\n                // on whether it was a success or error\r\n                batch.forEach((inflightRequest, index) => {\r\n                    const payload = result[index];\r\n                    if (payload.error) {\r\n                        const error = new Error(payload.error.message);\r\n                        error.code = payload.error.code;\r\n                        error.data = payload.error.data;\r\n                        inflightRequest.reject(error);\r\n                    }\r\n                    else {\r\n                        inflightRequest.resolve(payload.result);\r\n                    }\r\n                });\r\n            }, error => {\r\n                batch.forEach(inflightRequest => {\r\n                    inflightRequest.reject(error);\r\n                });\r\n            });\r\n        });\r\n    }\r\n}\n\n/**\r\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getProvider()}.\r\n *\r\n * @public\r\n */\r\nclass AlchemyProvider extends _ethersproject_providers__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider {\r\n    /** @internal */\r\n    constructor(config) {\r\n        // Normalize the API Key to a string.\r\n        const apiKey = AlchemyProvider.getApiKey(config.apiKey);\r\n        // Generate our own connection info with the correct endpoint URLs.\r\n        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\r\n        const connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'http');\r\n        // If a hardcoded url was specified in the config, use that instead of the\r\n        // provided apiKey or network.\r\n        if (config.url !== undefined) {\r\n            connection.url = config.url;\r\n        }\r\n        connection.throttleLimit = config.maxRetries;\r\n        // Normalize the Alchemy named network input to the network names used by\r\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\r\n        // correctly set the network.\r\n        const ethersNetwork = _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.E[alchemyNetwork];\r\n        super(connection, ethersNetwork);\r\n        this.apiKey = config.apiKey;\r\n        this.maxRetries = config.maxRetries;\r\n        this.batchRequests = config.batchRequests;\r\n        // TODO: support individual headers when calling batch\r\n        const batcherConnection = Object.assign(Object.assign({}, this.connection), { headers: Object.assign(Object.assign({}, this.connection.headers), { 'Alchemy-Ethers-Sdk-Method': 'batchSend' }) });\r\n        const sendBatchFn = (requests) => {\r\n            return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_3__.fetchJson)(batcherConnection, JSON.stringify(requests));\r\n        };\r\n        this.batcher = new RequestBatcher(sendBatchFn);\r\n        this.modifyFormatter();\r\n    }\r\n    /**\r\n     * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\r\n     * ethers.js. Returns the API key for an Alchemy provider.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getApiKey(apiKey) {\r\n        if (apiKey == null) {\r\n            return _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.D;\r\n        }\r\n        if (apiKey && typeof apiKey !== 'string') {\r\n            throw new Error(`Invalid apiKey '${apiKey}' provided. apiKey must be a string.`);\r\n        }\r\n        return apiKey;\r\n    }\r\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getNetwork(network) {\r\n        if (typeof network === 'string' && network in _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.C) {\r\n            return _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.C[network];\r\n        }\r\n        // Call the standard ethers.js getNetwork method for other networks.\r\n        return (0,_ethersproject_networks__WEBPACK_IMPORTED_MODULE_4__.getNetwork)(network);\r\n    }\r\n    /**\r\n     * Converts the `Networkish` input to the network enum used by Alchemy.\r\n     *\r\n     * @internal\r\n     */\r\n    static getAlchemyNetwork(network) {\r\n        if (network === undefined) {\r\n            return _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.a;\r\n        }\r\n        if (typeof network === 'number') {\r\n            throw new Error(`Invalid network '${network}' provided. Network must be a string.`);\r\n        }\r\n        // Guaranteed that `typeof network === 'string`.\r\n        const isValidNetwork = Object.values(_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.N).includes(network);\r\n        if (!isValidNetwork) {\r\n            throw new Error(`Invalid network '${network}' provided. Network must be one of: ` +\r\n                `${Object.values(_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.N).join(', ')}.`);\r\n        }\r\n        return network;\r\n    }\r\n    /**\r\n     * Returns a {@link ConnectionInfo} object compatible with ethers that contains\r\n     * the correct URLs for Alchemy.\r\n     *\r\n     * @internal\r\n     */\r\n    static getAlchemyConnectionInfo(network, apiKey, type) {\r\n        const url = type === 'http'\r\n            ? (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.g)(network, apiKey)\r\n            : (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.b)(network, apiKey);\r\n        return {\r\n            headers: _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.I\r\n                ? {\r\n                    'Alchemy-Ethers-Sdk-Version': _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.V\r\n                }\r\n                : {\r\n                    'Alchemy-Ethers-Sdk-Version': _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.V,\r\n                    'Accept-Encoding': 'gzip'\r\n                },\r\n            allowGzip: true,\r\n            url\r\n        };\r\n    }\r\n    /**\r\n     * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\r\n     * method is called when calling methods on the parent class `BaseProvider`.\r\n     *\r\n     * @override\r\n     */\r\n    detectNetwork() {\r\n        const _super = Object.create(null, {\r\n            detectNetwork: { get: () => super.detectNetwork }\r\n        });\r\n        return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            let network = this.network;\r\n            if (network == null) {\r\n                network = yield _super.detectNetwork.call(this);\r\n                if (!network) {\r\n                    throw new Error('No network detected');\r\n                }\r\n            }\r\n            return network;\r\n        });\r\n    }\r\n    _startPending() {\r\n        (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.l)('WARNING: Alchemy Provider does not support pending filters');\r\n    }\r\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\r\n    isCommunityResource() {\r\n        return this.apiKey === _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.D;\r\n    }\r\n    /**\r\n     * Overrides the base {@link JsonRpcProvider.send} method to implement custom\r\n     * logic for sending requests to Alchemy.\r\n     *\r\n     * @param method The method name to use for the request.\r\n     * @param params The parameters to use for the request.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Add headers for `perform()` override.\r\n    send(method, params) {\r\n        return this._send(method, params, 'send');\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `JsonRpcProvider.send()`.\r\n     *\r\n     * This method is copied over directly in order to implement custom headers\r\n     *\r\n     * @internal\r\n     */\r\n    _send(method, params, methodName, forceBatch = false) {\r\n        const request = {\r\n            method,\r\n            params,\r\n            id: this._nextId++,\r\n            jsonrpc: '2.0'\r\n        };\r\n        // START MODIFIED CODE\r\n        const connection = Object.assign({}, this.connection);\r\n        connection.headers['Alchemy-Ethers-Sdk-Method'] = methodName;\r\n        if (this.batchRequests || forceBatch) {\r\n            return this.batcher.enqueueRequest(request);\r\n        }\r\n        // END MODIFIED CODE\r\n        this.emit('debug', {\r\n            action: 'request',\r\n            request: (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.d)(request),\r\n            provider: this\r\n        });\r\n        // We can expand this in the future to any call, but for now these\r\n        // are the biggest wins and do not require any serializing parameters.\r\n        const cache = ['eth_chainId', 'eth_blockNumber'].indexOf(method) >= 0;\r\n        if (cache && this._cache[method]) {\r\n            return this._cache[method];\r\n        }\r\n        const result = (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_3__.fetchJson)(this.connection, JSON.stringify(request), getResult).then(result => {\r\n            this.emit('debug', {\r\n                action: 'response',\r\n                request,\r\n                response: result,\r\n                provider: this\r\n            });\r\n            return result;\r\n        }, error => {\r\n            this.emit('debug', {\r\n                action: 'response',\r\n                error,\r\n                request,\r\n                provider: this\r\n            });\r\n            throw error;\r\n        });\r\n        // Cache the fetch, but clear it on the next event loop\r\n        if (cache) {\r\n            this._cache[method] = result;\r\n            setTimeout(() => {\r\n                // @ts-ignore - This is done by ethers.\r\n                this._cache[method] = null;\r\n            }, 0);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Overrides the base `Formatter` class inherited from ethers to support\r\n     * returning custom fields in Ethers response types.\r\n     *\r\n     * For context, ethers has a `Formatter` class that is used to format the\r\n     * response from a JSON-RPC request. Any fields that are not defined in the\r\n     * `Formatter` class are removed from the returned response. By modifying the\r\n     * `Formatter` class in this method, we can add support for fields that are\r\n     * not defined in ethers.\r\n     */\r\n    modifyFormatter() {\r\n        this.formatter.formats['receiptLog']['removed'] = val => {\r\n            if (typeof val === 'boolean') {\r\n                return val;\r\n            }\r\n            return undefined;\r\n        };\r\n    }\r\n}\r\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * Original code copied over from ether.js's\r\n * `@ethersproject/web/src.ts/index.ts`. Used to support\r\n * {@link AlchemyProvider._send}, which is also copied over.\r\n */\r\nfunction getResult(payload) {\r\n    if (payload.error) {\r\n        const error = new Error(payload.error.message);\r\n        error.code = payload.error.code;\r\n        error.data = payload.error.data;\r\n        throw error;\r\n    }\r\n    return payload.result;\r\n}\n\n\n//# sourceMappingURL=alchemy-provider-5e530ed5.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hbGNoZW15LXNkay9kaXN0L2VzbS9hbGNoZW15LXByb3ZpZGVyLTVlNTMwZWQ1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMFE7QUFDck47QUFDTTtBQUNaO0FBQzFCO0FBQ2E7QUFDbkI7QUFDMkI7QUFDWDtBQUNHOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxlQUFlLFVBQVUsbUNBQW1DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixxRUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpREFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHNCQUFzQix1Q0FBdUMsOEJBQThCLDBDQUEwQyxHQUFHO0FBQ3hNO0FBQ0EsbUJBQW1CLDZEQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUF1QjtBQUMxQztBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsaURBQWM7QUFDcEUsbUJBQW1CLGlEQUFjO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlLG1FQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQWU7QUFDbEM7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQSw2Q0FBNkMsaURBQU87QUFDcEQ7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RCxtQkFBbUIsY0FBYyxpREFBTyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFEQUFpQjtBQUMvQixjQUFjLHFEQUFlO0FBQzdCO0FBQ0EscUJBQXFCLGlEQUFVO0FBQy9CO0FBQ0Esa0RBQWtELGlEQUFPO0FBQ3pEO0FBQ0E7QUFDQSxrREFBa0QsaURBQU87QUFDekQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLFNBQVM7QUFDVCxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVEscURBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlEQUF1QjtBQUN0RDtBQUNBO0FBQ0EsMkJBQTJCLDRCQUE0QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxREFBUTtBQUM3QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkRBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FsY2hlbXktc2RrL2Rpc3QvZXNtL2FsY2hlbXktcHJvdmlkZXItNWU1MzBlZDUuanM/MGI2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfIGFzIF9fYXdhaXRlciwgRCBhcyBERUZBVUxUX0FMQ0hFTVlfQVBJX0tFWSwgQyBhcyBDdXN0b21OZXR3b3JrcywgYSBhcyBERUZBVUxUX05FVFdPUkssIE4gYXMgTmV0d29yaywgSSBhcyBJU19CUk9XU0VSLCBWIGFzIFZFUlNJT04sIGwgYXMgbG9nV2FybiwgZCBhcyBkZWVwQ29weSwgRSBhcyBFdGhlcnNOZXR3b3JrLCBnIGFzIGdldEFsY2hlbXlIdHRwVXJsLCBiIGFzIGdldEFsY2hlbXlXc1VybCB9IGZyb20gJy4vaW5kZXgtMWYyZjYwMzIuanMnO1xuaW1wb3J0IHsgZ2V0TmV0d29yayB9IGZyb20gJ0BldGhlcnNwcm9qZWN0L25ldHdvcmtzJztcbmltcG9ydCB7IEpzb25ScGNQcm92aWRlciB9IGZyb20gJ0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycyc7XG5pbXBvcnQgeyBmZXRjaEpzb24gfSBmcm9tICdAZXRoZXJzcHJvamVjdC93ZWInO1xuaW1wb3J0ICcuL2FwaS91dGlscyc7XG5pbXBvcnQgJ0BldGhlcnNwcm9qZWN0L2JpZ251bWJlcic7XG5pbXBvcnQgJ2F4aW9zJztcbmltcG9ydCAnQGV0aGVyc3Byb2plY3QvYWJzdHJhY3QtcHJvdmlkZXInO1xuaW1wb3J0ICdAZXRoZXJzcHJvamVjdC93YWxsZXQnO1xuaW1wb3J0ICdAZXRoZXJzcHJvamVjdC9jb250cmFjdHMnO1xuXG4vKiogTWF4aW11bSBzaXplIG9mIGEgYmF0Y2ggb24gdGhlIHJwYyBwcm92aWRlci4gKi9cclxuY29uc3QgREVGQVVMVF9NQVhfUkVRVUVTVF9CQVRDSF9TSVpFID0gMTAwO1xyXG4vKiogVGltZW91dCBpbnRlcnZhbCBiZWZvcmUgdGhlIHBlbmRpbmcgYmF0Y2ggaXMgc2VudC4gKi9cclxuY29uc3QgREVGQVVMVF9SRVFVRVNUX0JBVENIX0RFTEFZX01TID0gMTA7XHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBjbGFzcyB0byBlbnF1ZXVlIHJlcXVlc3RzIGFuZCBhdXRvbWF0aWNhbGx5IHNlbmQvcHJvY2VzcyBiYXRjaGVzLlxyXG4gKlxyXG4gKiBUaGUgdW5kZXJseWluZyBiYXRjaGluZyBtZWNoYW5pc20gaXMgbG9vc2VseSBiYXNlZCBvbiBldGhlcnMuanMnc1xyXG4gKiBgSnNvblJwY0JhdGNoUHJvdmlkZXJgLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFJlcXVlc3RCYXRjaGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlbmRCYXRjaEZuLCBtYXhCYXRjaFNpemUgPSBERUZBVUxUX01BWF9SRVFVRVNUX0JBVENIX1NJWkUpIHtcclxuICAgICAgICB0aGlzLnNlbmRCYXRjaEZuID0gc2VuZEJhdGNoRm47XHJcbiAgICAgICAgdGhpcy5tYXhCYXRjaFNpemUgPSBtYXhCYXRjaFNpemU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXJyYXkgb2YgZW5xdWV1ZWQgcmVxdWVzdHMgYWxvbmcgd2l0aCB0aGUgY29uc3RydWN0ZWQgcHJvbWlzZSBoYW5kbGVycyBmb3JcclxuICAgICAgICAgKiBlYWNoIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nQmF0Y2ggPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5xdWV1ZXMgdGhlIHByb3ZpZGVkIHJlcXVlc3QuIFRoZSBiYXRjaCBpcyBpbW1lZGlhdGVseSBzZW50IGlmIHRoZSBtYXhpbXVtXHJcbiAgICAgKiBiYXRjaCBzaXplIGlzIHJlYWNoZWQuIE90aGVyd2lzZSwgdGhlIHJlcXVlc3QgaXMgZW5xdWV1ZWQgb250byBhIGJhdGNoIHRoYXRcclxuICAgICAqIGlzIHNlbnQgYWZ0ZXIgMTBtcy5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgZW5xdWV1ZVJlcXVlc3QocmVxdWVzdCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZmxpZ2h0UmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgICAgICByZXNvbHZlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICByZWplY3Q6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlamVjdCA9IHJlamVjdDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0JhdGNoLnB1c2goaW5mbGlnaHRSZXF1ZXN0KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0JhdGNoLmxlbmd0aCA9PT0gdGhpcy5tYXhCYXRjaFNpemUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNlbmQgYmF0Y2ggaW1tZWRpYXRlbHkgaWYgd2UgYXJlIGF0IHRoZSBtYXhpbXVtIGJhdGNoIHNpemUuXHJcbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMuc2VuZEJhdGNoUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLnBlbmRpbmdCYXRjaFRpbWVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTY2hlZHVsZSBiYXRjaCBmb3IgbmV4dCBldmVudCBsb29wICsgc2hvcnQgZHVyYXRpb25cclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0JhdGNoVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VuZEJhdGNoUmVxdWVzdCgpLCBERUZBVUxUX1JFUVVFU1RfQkFUQ0hfREVMQVlfTVMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kcyB0aGUgY3VycmVudGx5IHF1ZXVlZCBiYXRjaGVzIGFuZCByZXNldHMgdGhlIGJhdGNoIGFuZCB0aW1lci4gUHJvY2Vzc2VzXHJcbiAgICAgKiB0aGUgYmF0Y2hlZCByZXNwb25zZSByZXN1bHRzIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHByb21pc2VzLlxyXG4gICAgICovXHJcbiAgICBzZW5kQmF0Y2hSZXF1ZXN0KCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBiYXRjaCBhbmQgY2xlYXIgaXQsIHNvIG5ldyByZXF1ZXN0c1xyXG4gICAgICAgICAgICAvLyBnbyBpbnRvIHRoZSBuZXh0IGJhdGNoXHJcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gdGhpcy5wZW5kaW5nQmF0Y2g7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0JhdGNoID0gW107XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdCYXRjaFRpbWVyKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wZW5kaW5nQmF0Y2hUaW1lcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCYXRjaFRpbWVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcmVxdWVzdCBhcyBhbiBhcnJheSBvZiByZXF1ZXN0c1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gYmF0Y2gubWFwKGluZmxpZ2h0ID0+IGluZmxpZ2h0LnJlcXVlc3QpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kQmF0Y2hGbihyZXF1ZXN0KS50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgZWFjaCByZXN1bHQsIGZlZWQgaXQgdG8gdGhlIGNvcnJlY3QgUHJvbWlzZSwgZGVwZW5kaW5nXHJcbiAgICAgICAgICAgICAgICAvLyBvbiB3aGV0aGVyIGl0IHdhcyBhIHN1Y2Nlc3Mgb3IgZXJyb3JcclxuICAgICAgICAgICAgICAgIGJhdGNoLmZvckVhY2goKGluZmxpZ2h0UmVxdWVzdCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gcmVzdWx0W2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihwYXlsb2FkLmVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gcGF5bG9hZC5lcnJvci5jb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5kYXRhID0gcGF5bG9hZC5lcnJvci5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZsaWdodFJlcXVlc3QucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZXNvbHZlKHBheWxvYWQucmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgYmF0Y2guZm9yRWFjaChpbmZsaWdodFJlcXVlc3QgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBTREsncyBjdXN0b20gaW1wbGVtZW50YXRpb24gb2YgZXRoZXJzLmpzJ3MgJ0FsY2hlbXlQcm92aWRlcicuXHJcbiAqXHJcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIGluc3RhbnRpYXRlIGFuIGluc3RhbmNlIG9mXHJcbiAqIHtAbGluayBBbGNoZW15fSBhbmQgY2FsbCB7QGxpbmsgQWxjaGVteS5jb25maWcuZ2V0UHJvdmlkZXIoKX0uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIEFsY2hlbXlQcm92aWRlciBleHRlbmRzIEpzb25ScGNQcm92aWRlciB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIEFQSSBLZXkgdG8gYSBzdHJpbmcuXHJcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gQWxjaGVteVByb3ZpZGVyLmdldEFwaUtleShjb25maWcuYXBpS2V5KTtcclxuICAgICAgICAvLyBHZW5lcmF0ZSBvdXIgb3duIGNvbm5lY3Rpb24gaW5mbyB3aXRoIHRoZSBjb3JyZWN0IGVuZHBvaW50IFVSTHMuXHJcbiAgICAgICAgY29uc3QgYWxjaGVteU5ldHdvcmsgPSBBbGNoZW15UHJvdmlkZXIuZ2V0QWxjaGVteU5ldHdvcmsoY29uZmlnLm5ldHdvcmspO1xyXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBBbGNoZW15UHJvdmlkZXIuZ2V0QWxjaGVteUNvbm5lY3Rpb25JbmZvKGFsY2hlbXlOZXR3b3JrLCBhcGlLZXksICdodHRwJyk7XHJcbiAgICAgICAgLy8gSWYgYSBoYXJkY29kZWQgdXJsIHdhcyBzcGVjaWZpZWQgaW4gdGhlIGNvbmZpZywgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGVcclxuICAgICAgICAvLyBwcm92aWRlZCBhcGlLZXkgb3IgbmV0d29yay5cclxuICAgICAgICBpZiAoY29uZmlnLnVybCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rpb24udXJsID0gY29uZmlnLnVybDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29ubmVjdGlvbi50aHJvdHRsZUxpbWl0ID0gY29uZmlnLm1heFJldHJpZXM7XHJcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBBbGNoZW15IG5hbWVkIG5ldHdvcmsgaW5wdXQgdG8gdGhlIG5ldHdvcmsgbmFtZXMgdXNlZCBieVxyXG4gICAgICAgIC8vIGV0aGVycy4gVGhpcyBhbGxvd3MgdGhlIHBhcmVudCBzdXBlciBjb25zdHJ1Y3RvciBpbiBKc29uUnBjUHJvdmlkZXIgdG9cclxuICAgICAgICAvLyBjb3JyZWN0bHkgc2V0IHRoZSBuZXR3b3JrLlxyXG4gICAgICAgIGNvbnN0IGV0aGVyc05ldHdvcmsgPSBFdGhlcnNOZXR3b3JrW2FsY2hlbXlOZXR3b3JrXTtcclxuICAgICAgICBzdXBlcihjb25uZWN0aW9uLCBldGhlcnNOZXR3b3JrKTtcclxuICAgICAgICB0aGlzLmFwaUtleSA9IGNvbmZpZy5hcGlLZXk7XHJcbiAgICAgICAgdGhpcy5tYXhSZXRyaWVzID0gY29uZmlnLm1heFJldHJpZXM7XHJcbiAgICAgICAgdGhpcy5iYXRjaFJlcXVlc3RzID0gY29uZmlnLmJhdGNoUmVxdWVzdHM7XHJcbiAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBpbmRpdmlkdWFsIGhlYWRlcnMgd2hlbiBjYWxsaW5nIGJhdGNoXHJcbiAgICAgICAgY29uc3QgYmF0Y2hlckNvbm5lY3Rpb24gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29ubmVjdGlvbiksIHsgaGVhZGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbm5lY3Rpb24uaGVhZGVycyksIHsgJ0FsY2hlbXktRXRoZXJzLVNkay1NZXRob2QnOiAnYmF0Y2hTZW5kJyB9KSB9KTtcclxuICAgICAgICBjb25zdCBzZW5kQmF0Y2hGbiA9IChyZXF1ZXN0cykgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hKc29uKGJhdGNoZXJDb25uZWN0aW9uLCBKU09OLnN0cmluZ2lmeShyZXF1ZXN0cykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5iYXRjaGVyID0gbmV3IFJlcXVlc3RCYXRjaGVyKHNlbmRCYXRjaEZuKTtcclxuICAgICAgICB0aGlzLm1vZGlmeUZvcm1hdHRlcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGBVcmxKc29uUnBjUHJvdmlkZXIuZ2V0QXBpS2V5YCBtZXRob2QgYXMgaW1wbGVtZW50ZWQgYnlcclxuICAgICAqIGV0aGVycy5qcy4gUmV0dXJucyB0aGUgQVBJIGtleSBmb3IgYW4gQWxjaGVteSBwcm92aWRlci5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0QXBpS2V5KGFwaUtleSkge1xyXG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gREVGQVVMVF9BTENIRU1ZX0FQSV9LRVk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcGlLZXkgJiYgdHlwZW9mIGFwaUtleSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFwaUtleSAnJHthcGlLZXl9JyBwcm92aWRlZC4gYXBpS2V5IG11c3QgYmUgYSBzdHJpbmcuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcGlLZXk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgYEJhc2VQcm92aWRlci5nZXROZXR3b3JrYCBtZXRob2QgYXMgaW1wbGVtZW50ZWQgYnkgZXRoZXJzLmpzLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgb3ZlcnJpZGUgYWxsb3dzIHRoZSBTREsgdG8gc2V0IHRoZSBwcm92aWRlcidzIG5ldHdvcmsgdG8gdmFsdWVzIG5vdFxyXG4gICAgICogeWV0IHN1cHBvcnRlZCBieSBldGhlcnMuanMuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldE5ldHdvcmsobmV0d29yaykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmV0d29yayA9PT0gJ3N0cmluZycgJiYgbmV0d29yayBpbiBDdXN0b21OZXR3b3Jrcykge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3VzdG9tTmV0d29ya3NbbmV0d29ya107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbGwgdGhlIHN0YW5kYXJkIGV0aGVycy5qcyBnZXROZXR3b3JrIG1ldGhvZCBmb3Igb3RoZXIgbmV0d29ya3MuXHJcbiAgICAgICAgcmV0dXJuIGdldE5ldHdvcmsobmV0d29yayk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBgTmV0d29ya2lzaGAgaW5wdXQgdG8gdGhlIG5ldHdvcmsgZW51bSB1c2VkIGJ5IEFsY2hlbXkuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRBbGNoZW15TmV0d29yayhuZXR3b3JrKSB7XHJcbiAgICAgICAgaWYgKG5ldHdvcmsgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gREVGQVVMVF9ORVRXT1JLO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG5ldHdvcmsgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuZXR3b3JrICcke25ldHdvcmt9JyBwcm92aWRlZC4gTmV0d29yayBtdXN0IGJlIGEgc3RyaW5nLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHdWFyYW50ZWVkIHRoYXQgYHR5cGVvZiBuZXR3b3JrID09PSAnc3RyaW5nYC5cclxuICAgICAgICBjb25zdCBpc1ZhbGlkTmV0d29yayA9IE9iamVjdC52YWx1ZXMoTmV0d29yaykuaW5jbHVkZXMobmV0d29yayk7XHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkTmV0d29yaykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbmV0d29yayAnJHtuZXR3b3JrfScgcHJvdmlkZWQuIE5ldHdvcmsgbXVzdCBiZSBvbmUgb2Y6IGAgK1xyXG4gICAgICAgICAgICAgICAgYCR7T2JqZWN0LnZhbHVlcyhOZXR3b3JrKS5qb2luKCcsICcpfS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldHdvcms7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgQ29ubmVjdGlvbkluZm99IG9iamVjdCBjb21wYXRpYmxlIHdpdGggZXRoZXJzIHRoYXQgY29udGFpbnNcclxuICAgICAqIHRoZSBjb3JyZWN0IFVSTHMgZm9yIEFsY2hlbXkuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRBbGNoZW15Q29ubmVjdGlvbkluZm8obmV0d29yaywgYXBpS2V5LCB0eXBlKSB7XHJcbiAgICAgICAgY29uc3QgdXJsID0gdHlwZSA9PT0gJ2h0dHAnXHJcbiAgICAgICAgICAgID8gZ2V0QWxjaGVteUh0dHBVcmwobmV0d29yaywgYXBpS2V5KVxyXG4gICAgICAgICAgICA6IGdldEFsY2hlbXlXc1VybChuZXR3b3JrLCBhcGlLZXkpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGhlYWRlcnM6IElTX0JST1dTRVJcclxuICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgICdBbGNoZW15LUV0aGVycy1TZGstVmVyc2lvbic6IFZFUlNJT05cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgICAgICdBbGNoZW15LUV0aGVycy1TZGstVmVyc2lvbic6IFZFUlNJT04sXHJcbiAgICAgICAgICAgICAgICAgICAgJ0FjY2VwdC1FbmNvZGluZyc6ICdnemlwJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWxsb3dHemlwOiB0cnVlLFxyXG4gICAgICAgICAgICB1cmxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIG1ldGhvZCBpbiBldGhlcnMuanMncyBgU3RhdGljSnNvblJwY1Byb3ZpZGVyYCBjbGFzcy4gVGhpc1xyXG4gICAgICogbWV0aG9kIGlzIGNhbGxlZCB3aGVuIGNhbGxpbmcgbWV0aG9kcyBvbiB0aGUgcGFyZW50IGNsYXNzIGBCYXNlUHJvdmlkZXJgLlxyXG4gICAgICpcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBkZXRlY3ROZXR3b3JrKCkge1xyXG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICAgICAgICBkZXRlY3ROZXR3b3JrOiB7IGdldDogKCkgPT4gc3VwZXIuZGV0ZWN0TmV0d29yayB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgbGV0IG5ldHdvcmsgPSB0aGlzLm5ldHdvcms7XHJcbiAgICAgICAgICAgIGlmIChuZXR3b3JrID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIG5ldHdvcmsgPSB5aWVsZCBfc3VwZXIuZGV0ZWN0TmV0d29yay5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFuZXR3b3JrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBuZXR3b3JrIGRldGVjdGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfc3RhcnRQZW5kaW5nKCkge1xyXG4gICAgICAgIGxvZ1dhcm4oJ1dBUk5JTkc6IEFsY2hlbXkgUHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBwZW5kaW5nIGZpbHRlcnMnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBldGhlcidzIGBpc0NvbW11bml0eVJlc291cmNlKClgIG1ldGhvZC4gUmV0dXJucyB0cnVlIGlmIHRoZVxyXG4gICAgICogY3VycmVudCBhcGkga2V5IGlzIHRoZSBkZWZhdWx0IGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcGlLZXkgPT09IERFRkFVTFRfQUxDSEVNWV9BUElfS0VZO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGJhc2Uge0BsaW5rIEpzb25ScGNQcm92aWRlci5zZW5kfSBtZXRob2QgdG8gaW1wbGVtZW50IGN1c3RvbVxyXG4gICAgICogbG9naWMgZm9yIHNlbmRpbmcgcmVxdWVzdHMgdG8gQWxjaGVteS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWV0aG9kIFRoZSBtZXRob2QgbmFtZSB0byB1c2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBUaGUgcGFyYW1ldGVycyB0byB1c2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIC8vIFRPRE86IEFkZCBoZWFkZXJzIGZvciBgcGVyZm9ybSgpYCBvdmVycmlkZS5cclxuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2VuZChtZXRob2QsIHBhcmFtcywgJ3NlbmQnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRE8gTk9UIE1PRElGWS5cclxuICAgICAqXHJcbiAgICAgKiBPcmlnaW5hbCBjb2RlIGNvcGllZCBvdmVyIGZyb20gZXRoZXIuanMncyBgSnNvblJwY1Byb3ZpZGVyLnNlbmQoKWAuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY29waWVkIG92ZXIgZGlyZWN0bHkgaW4gb3JkZXIgdG8gaW1wbGVtZW50IGN1c3RvbSBoZWFkZXJzXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9zZW5kKG1ldGhvZCwgcGFyYW1zLCBtZXRob2ROYW1lLCBmb3JjZUJhdGNoID0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICBtZXRob2QsXHJcbiAgICAgICAgICAgIHBhcmFtcyxcclxuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRJZCsrLFxyXG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gU1RBUlQgTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbm5lY3Rpb24pO1xyXG4gICAgICAgIGNvbm5lY3Rpb24uaGVhZGVyc1snQWxjaGVteS1FdGhlcnMtU2RrLU1ldGhvZCddID0gbWV0aG9kTmFtZTtcclxuICAgICAgICBpZiAodGhpcy5iYXRjaFJlcXVlc3RzIHx8IGZvcmNlQmF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmF0Y2hlci5lbnF1ZXVlUmVxdWVzdChyZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRU5EIE1PRElGSUVEIENPREVcclxuICAgICAgICB0aGlzLmVtaXQoJ2RlYnVnJywge1xyXG4gICAgICAgICAgICBhY3Rpb246ICdyZXF1ZXN0JyxcclxuICAgICAgICAgICAgcmVxdWVzdDogZGVlcENvcHkocmVxdWVzdCksXHJcbiAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gV2UgY2FuIGV4cGFuZCB0aGlzIGluIHRoZSBmdXR1cmUgdG8gYW55IGNhbGwsIGJ1dCBmb3Igbm93IHRoZXNlXHJcbiAgICAgICAgLy8gYXJlIHRoZSBiaWdnZXN0IHdpbnMgYW5kIGRvIG5vdCByZXF1aXJlIGFueSBzZXJpYWxpemluZyBwYXJhbWV0ZXJzLlxyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gWydldGhfY2hhaW5JZCcsICdldGhfYmxvY2tOdW1iZXInXS5pbmRleE9mKG1ldGhvZCkgPj0gMDtcclxuICAgICAgICBpZiAoY2FjaGUgJiYgdGhpcy5fY2FjaGVbbWV0aG9kXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVbbWV0aG9kXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZmV0Y2hKc29uKHRoaXMuY29ubmVjdGlvbiwgSlNPTi5zdHJpbmdpZnkocmVxdWVzdCksIGdldFJlc3VsdCkudGhlbihyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RlYnVnJywge1xyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAncmVzcG9uc2UnLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXN1bHQsXHJcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9LCBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGVidWcnLCB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdyZXNwb25zZScsXHJcbiAgICAgICAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gQ2FjaGUgdGhlIGZldGNoLCBidXQgY2xlYXIgaXQgb24gdGhlIG5leHQgZXZlbnQgbG9vcFxyXG4gICAgICAgIGlmIChjYWNoZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jYWNoZVttZXRob2RdID0gcmVzdWx0O1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSBUaGlzIGlzIGRvbmUgYnkgZXRoZXJzLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVbbWV0aG9kXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGJhc2UgYEZvcm1hdHRlcmAgY2xhc3MgaW5oZXJpdGVkIGZyb20gZXRoZXJzIHRvIHN1cHBvcnRcclxuICAgICAqIHJldHVybmluZyBjdXN0b20gZmllbGRzIGluIEV0aGVycyByZXNwb25zZSB0eXBlcy5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgY29udGV4dCwgZXRoZXJzIGhhcyBhIGBGb3JtYXR0ZXJgIGNsYXNzIHRoYXQgaXMgdXNlZCB0byBmb3JtYXQgdGhlXHJcbiAgICAgKiByZXNwb25zZSBmcm9tIGEgSlNPTi1SUEMgcmVxdWVzdC4gQW55IGZpZWxkcyB0aGF0IGFyZSBub3QgZGVmaW5lZCBpbiB0aGVcclxuICAgICAqIGBGb3JtYXR0ZXJgIGNsYXNzIGFyZSByZW1vdmVkIGZyb20gdGhlIHJldHVybmVkIHJlc3BvbnNlLiBCeSBtb2RpZnlpbmcgdGhlXHJcbiAgICAgKiBgRm9ybWF0dGVyYCBjbGFzcyBpbiB0aGlzIG1ldGhvZCwgd2UgY2FuIGFkZCBzdXBwb3J0IGZvciBmaWVsZHMgdGhhdCBhcmVcclxuICAgICAqIG5vdCBkZWZpbmVkIGluIGV0aGVycy5cclxuICAgICAqL1xyXG4gICAgbW9kaWZ5Rm9ybWF0dGVyKCkge1xyXG4gICAgICAgIHRoaXMuZm9ybWF0dGVyLmZvcm1hdHNbJ3JlY2VpcHRMb2cnXVsncmVtb3ZlZCddID0gdmFsID0+IHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERPIE5PVCBNT0RJRlkuXHJcbiAqXHJcbiAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzXHJcbiAqIGBAZXRoZXJzcHJvamVjdC93ZWIvc3JjLnRzL2luZGV4LnRzYC4gVXNlZCB0byBzdXBwb3J0XHJcbiAqIHtAbGluayBBbGNoZW15UHJvdmlkZXIuX3NlbmR9LCB3aGljaCBpcyBhbHNvIGNvcGllZCBvdmVyLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmVzdWx0KHBheWxvYWQpIHtcclxuICAgIGlmIChwYXlsb2FkLmVycm9yKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IocGF5bG9hZC5lcnJvci5tZXNzYWdlKTtcclxuICAgICAgICBlcnJvci5jb2RlID0gcGF5bG9hZC5lcnJvci5jb2RlO1xyXG4gICAgICAgIGVycm9yLmRhdGEgPSBwYXlsb2FkLmVycm9yLmRhdGE7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF5bG9hZC5yZXN1bHQ7XHJcbn1cblxuZXhwb3J0IHsgQWxjaGVteVByb3ZpZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGNoZW15LXByb3ZpZGVyLTVlNTMwZWQ1LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/alchemy-sdk/dist/esm/alchemy-provider-5e530ed5.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-3967f150.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-3967f150.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AlchemyWebSocketProvider: function() { return /* binding */ AlchemyWebSocketProvider; }\n/* harmony export */ });\n/* harmony import */ var _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-1f2f6032.js */ \"(app-pages-browser)/./node_modules/alchemy-sdk/dist/esm/index-1f2f6032.js\");\n/* harmony import */ var sturdy_websocket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sturdy-websocket */ \"(app-pages-browser)/./node_modules/sturdy-websocket/dist/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(app-pages-browser)/./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_networks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/networks */ \"(app-pages-browser)/./node_modules/@ethersproject/networks/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_providers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/providers */ \"(app-pages-browser)/./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js\");\n/* harmony import */ var _alchemy_provider_5e530ed5_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./alchemy-provider-5e530ed5.js */ \"(app-pages-browser)/./node_modules/alchemy-sdk/dist/esm/alchemy-provider-5e530ed5.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n * The maximum number of blocks to backfill. If more than this many blocks have\r\n * been missed, then we'll sadly miss data, but we want to make sure we don't\r\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\r\n */\r\nconst MAX_BACKFILL_BLOCKS = 120;\r\n/**\r\n * The WebsocketBackfiller fetches events that were sent since a provided block\r\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\r\n * events that were transmitted while the websocket connection was down.\r\n *\r\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\r\n *\r\n * @internal\r\n */\r\nclass WebsocketBackfiller {\r\n    constructor(provider) {\r\n        this.provider = provider;\r\n        // TODO: Use HTTP provider to do backfill.\r\n        this.maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\r\n    }\r\n    /**\r\n     * Runs backfill for `newHeads` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param previousHeads Previous head requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     * @returns A list of `newHeads` events that were sent since the last backfill.\r\n     */\r\n    getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\r\n        return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous heads to fetch, return new heads since\r\n            // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\r\n            if (previousHeads.length === 0) {\r\n                return this.getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted event is too far back in the past, there's no need\r\n            // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\r\n            // new heads.\r\n            const lastSeenBlockNumber = (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.f)(previousHeads[previousHeads.length - 1].number);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber <= minBlockNumber) {\r\n                return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // To capture all `newHeads` events, return all head events from the last\r\n            // seen block number to current + any of the previous heads that were re-orged.\r\n            const reorgHeads = yield this.getReorgHeads(isCancelled, previousHeads);\r\n            throwIfCancelled(isCancelled);\r\n            const intermediateHeads = yield this.getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1);\r\n            throwIfCancelled(isCancelled);\r\n            return [...reorgHeads, ...intermediateHeads];\r\n        });\r\n    }\r\n    /**\r\n     * Runs backfill for `logs` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param filter The filter object that accompanies a logs subscription.\r\n     * @param previousLogs Previous log requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     */\r\n    getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\r\n        return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous logs to fetch, return new logs since\r\n            // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\r\n            if (previousLogs.length === 0) {\r\n                return this.getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted log is too far back in the past, there's no need\r\n            // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\r\n            // worth of logs.\r\n            const lastSeenBlockNumber = (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.f)(previousLogs[previousLogs.length - 1].blockNumber);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber < minBlockNumber) {\r\n                return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // Return all log events that have happened along with log events that have\r\n            // been removed due to a chain reorg.\r\n            const commonAncestor = yield this.getCommonAncestor(isCancelled, previousLogs);\r\n            throwIfCancelled(isCancelled);\r\n            // All previous logs with a block number greater than the common ancestor\r\n            // were part of a re-org, so mark them as such.\r\n            const removedLogs = previousLogs\r\n                .filter(log => (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.f)(log.blockNumber) > commonAncestor.blockNumber)\r\n                .map(log => (Object.assign(Object.assign({}, log), { removed: true })));\r\n            // If no common ancestor was found, start backfill from the oldest log's\r\n            // block number.\r\n            const fromBlockInclusive = commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\r\n                ? (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.f)(previousLogs[0].blockNumber)\r\n                : commonAncestor.blockNumber;\r\n            let addedLogs = yield this.getLogsInRange(filter, fromBlockInclusive, toBlockNumber + 1);\r\n            // De-dupe any logs that were already emitted.\r\n            addedLogs = addedLogs.filter(log => log &&\r\n                ((0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.f)(log.blockNumber) > commonAncestor.blockNumber ||\r\n                    (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.f)(log.logIndex) > commonAncestor.logIndex));\r\n            throwIfCancelled(isCancelled);\r\n            return [...removedLogs, ...addedLogs];\r\n        });\r\n    }\r\n    /**\r\n     * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */\r\n    setMaxBackfillBlock(newMax) {\r\n        this.maxBackfillBlocks = newMax;\r\n    }\r\n    /**\r\n     * Gets the current block number as a number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockNumber() {\r\n        return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            const blockNumberHex = yield this.provider.send('eth_blockNumber');\r\n            return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.f)(blockNumberHex);\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `newHead` events in the provided range. Note that the returned\r\n     * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\r\n     * that were part of a re-org.\r\n     *\r\n     * @private\r\n     */\r\n    getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\r\n        return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const batchParts = [];\r\n            for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\r\n                batchParts.push({\r\n                    method: 'eth_getBlockByNumber',\r\n                    params: [(0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.t)(i), false]\r\n                });\r\n            }\r\n            // TODO: handle errors\r\n            const blockHeads = yield this.provider.sendBatch(batchParts);\r\n            return blockHeads.map(toNewHeadsEvent);\r\n        });\r\n    }\r\n    /**\r\n     * Returns all heads that were part of a reorg event.\r\n     *\r\n     * @private\r\n     */\r\n    getReorgHeads(isCancelled, previousHeads) {\r\n        return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            const result = [];\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            for (let i = previousHeads.length - 1; i >= 0; i--) {\r\n                const oldEvent = previousHeads[i];\r\n                const blockHead = yield this.getBlockByNumber((0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.f)(oldEvent.number));\r\n                throwIfCancelled(isCancelled);\r\n                // If the hashes match, then current head in the iteration was not re-orged.\r\n                if (oldEvent.hash === blockHead.hash) {\r\n                    break;\r\n                }\r\n                result.push(toNewHeadsEvent(blockHead));\r\n            }\r\n            return result.reverse();\r\n        });\r\n    }\r\n    /**\r\n     * Simple wrapper around `eth_getBlockByNumber` that returns the complete\r\n     * block information for the provided block number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockByNumber(blockNumber) {\r\n        return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            return this.provider.send('eth_getBlockByNumber', [\r\n                (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.t)(blockNumber),\r\n                false\r\n            ]);\r\n        });\r\n    }\r\n    /**\r\n     * Given a list of previous log events, finds the common block number from the\r\n     * logs that matches the block head.\r\n     *\r\n     * This can be used to identify which logs are part of a re-org.\r\n     *\r\n     * Returns 1 less than the oldest log's block number if no common ancestor was found.\r\n     *\r\n     * @private\r\n     */\r\n    getCommonAncestor(isCancelled, previousLogs) {\r\n        return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            let blockHead = yield this.getBlockByNumber((0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.f)(previousLogs[previousLogs.length - 1].blockNumber));\r\n            throwIfCancelled(isCancelled);\r\n            for (let i = previousLogs.length - 1; i >= 0; i--) {\r\n                const oldLog = previousLogs[i];\r\n                // Ensure that updated blocks are fetched every time the log's block number\r\n                // changes.\r\n                if (oldLog.blockNumber !== blockHead.number) {\r\n                    blockHead = yield this.getBlockByNumber((0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.f)(oldLog.blockNumber));\r\n                }\r\n                // Since logs are ordered in ascending order, the first log that matches\r\n                // the hash should be the largest logIndex.\r\n                if (oldLog.blockHash === blockHead.hash) {\r\n                    return {\r\n                        blockNumber: (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.f)(oldLog.blockNumber),\r\n                        logIndex: (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.f)(oldLog.logIndex)\r\n                    };\r\n                }\r\n            }\r\n            return {\r\n                blockNumber: Number.NEGATIVE_INFINITY,\r\n                logIndex: Number.NEGATIVE_INFINITY\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `logs` events in the provided range. Note that the returned logs\r\n     * do not include removed logs.\r\n     *\r\n     * @private\r\n     */ getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\r\n        return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const rangeFilter = Object.assign(Object.assign({}, filter), { fromBlock: (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.t)(fromBlockInclusive), toBlock: (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.t)(toBlockExclusive - 1) });\r\n            return this.provider.send('eth_getLogs', [rangeFilter]);\r\n        });\r\n    }\r\n}\r\nfunction toNewHeadsEvent(head) {\r\n    const result = Object.assign({}, head);\r\n    delete result.totalDifficulty;\r\n    delete result.transactions;\r\n    delete result.uncles;\r\n    return result;\r\n}\r\nfunction dedupeNewHeads(events) {\r\n    return dedupe(events, event => event.hash);\r\n}\r\nfunction dedupeLogs(events) {\r\n    return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\r\n}\r\nfunction dedupe(items, getKey) {\r\n    const keysSeen = new Set();\r\n    const result = [];\r\n    items.forEach(item => {\r\n        const key = getKey(item);\r\n        if (!keysSeen.has(key)) {\r\n            keysSeen.add(key);\r\n            result.push(item);\r\n        }\r\n    });\r\n    return result;\r\n}\r\nconst CANCELLED = new Error('Cancelled');\r\nfunction throwIfCancelled(isCancelled) {\r\n    if (isCancelled()) {\r\n        throw CANCELLED;\r\n    }\r\n}\n\nconst HEARTBEAT_INTERVAL = 30000;\r\nconst HEARTBEAT_WAIT_TIME = 10000;\r\nconst BACKFILL_TIMEOUT = 60000;\r\nconst BACKFILL_RETRIES = 5;\r\n/**\r\n * Subscriptions have a memory of recent events they have sent so that in the\r\n * event that they disconnect and need to backfill, they can detect re-orgs.\r\n * Keep a buffer that goes back at least these many blocks, the maximum amount\r\n * at which we might conceivably see a re-org.\r\n *\r\n * Note that while our buffer goes back this many blocks, it may contain more\r\n * than this many elements, since in the case of logs subscriptions more than\r\n * one event may be emitted for a block.\r\n */\r\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\r\n/**\r\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\r\n *\r\n * @public\r\n */\r\nclass AlchemyWebSocketProvider extends _ethersproject_providers__WEBPACK_IMPORTED_MODULE_3__.WebSocketProvider {\r\n    /** @internal */\r\n    constructor(config, wsConstructor) {\r\n        var _a;\r\n        // Normalize the API Key to a string.\r\n        const apiKey = _alchemy_provider_5e530ed5_js__WEBPACK_IMPORTED_MODULE_4__.AlchemyProvider.getApiKey(config.apiKey);\r\n        // Generate our own connection info with the correct endpoint URLs.\r\n        const alchemyNetwork = _alchemy_provider_5e530ed5_js__WEBPACK_IMPORTED_MODULE_4__.AlchemyProvider.getAlchemyNetwork(config.network);\r\n        const connection = _alchemy_provider_5e530ed5_js__WEBPACK_IMPORTED_MODULE_4__.AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'wss');\r\n        const protocol = `alchemy-sdk-${_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.V}`;\r\n        // Use the provided config URL override if it exists, otherwise use the created one.\r\n        const ws = new sturdy_websocket__WEBPACK_IMPORTED_MODULE_0__[\"default\"]((_a = config.url) !== null && _a !== void 0 ? _a : connection.url, protocol, {\r\n            wsConstructor: wsConstructor !== null && wsConstructor !== void 0 ? wsConstructor : getWebsocketConstructor()\r\n        });\r\n        // Normalize the Alchemy named network input to the network names used by\r\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\r\n        // correctly set the network.\r\n        const ethersNetwork = _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.E[alchemyNetwork];\r\n        super(ws, ethersNetwork);\r\n        this._events = [];\r\n        // In the case of a WebSocket reconnection, all subscriptions are lost and we\r\n        // create new ones to replace them, but we want to create the illusion that\r\n        // the original subscriptions persist. Thus, maintain a mapping from the\r\n        // \"virtual\" subscription ids which are visible to the consumer to the\r\n        // \"physical\" subscription ids of the actual connections. This terminology is\r\n        // borrowed from virtual and physical memory, which has a similar mapping.\r\n        /** @internal */\r\n        this.virtualSubscriptionsById = new Map();\r\n        /** @internal */\r\n        this.virtualIdsByPhysicalId = new Map();\r\n        /**\r\n         * The underlying ethers {@link WebSocketProvider} already handles and emits\r\n         * messages. To allow backfilling, track all messages that are emitted.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleMessage = (event) => {\r\n            const message = JSON.parse(event.data);\r\n            if (!isSubscriptionEvent(message)) {\r\n                return;\r\n            }\r\n            const physicalId = message.params.subscription;\r\n            const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\r\n            if (!virtualId) {\r\n                return;\r\n            }\r\n            const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n            if (subscription.method !== 'eth_subscribe') {\r\n                return;\r\n            }\r\n            switch (subscription.params[0]) {\r\n                case 'newHeads': {\r\n                    const newHeadsSubscription = subscription;\r\n                    const newHeadsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = newHeadsSubscription;\r\n                    const { result } = newHeadsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToNewHeadsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    else {\r\n                        // Ethers subscription mapping will emit the event, just store it.\r\n                        this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                case 'logs': {\r\n                    const logsSubscription = subscription;\r\n                    const logsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = logsSubscription;\r\n                    const { result } = logsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToLogsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (virtualId !== physicalId) {\r\n                        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    else {\r\n                        this.rememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        const { result } = message.params;\r\n                        this.emitEvent(virtualId, result);\r\n                    }\r\n            }\r\n        };\r\n        /**\r\n         * When the websocket connection reopens:\r\n         *\r\n         * 1. Resubscribe to all existing subscriptions and start backfilling\r\n         * 2. Restart heart beat.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleReopen = () => {\r\n            this.virtualIdsByPhysicalId.clear();\r\n            const { cancel, isCancelled } = makeCancelToken();\r\n            this.cancelBackfill = cancel;\r\n            for (const subscription of this.virtualSubscriptionsById.values()) {\r\n                void (() => (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n                    try {\r\n                        yield this.resubscribeAndBackfill(isCancelled, subscription);\r\n                    }\r\n                    catch (error) {\r\n                        if (!isCancelled()) {\r\n                            console.error(`Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`, error);\r\n                        }\r\n                    }\r\n                }))();\r\n            }\r\n            this.startHeartbeat();\r\n        };\r\n        /**\r\n         * Cancels the heartbeat and any pending backfills being performed. This is\r\n         * called when the websocket connection goes down or is disconnected.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.stopHeartbeatAndBackfill = () => {\r\n            if (this.heartbeatIntervalId != null) {\r\n                clearInterval(this.heartbeatIntervalId);\r\n                this.heartbeatIntervalId = undefined;\r\n            }\r\n            this.cancelBackfill();\r\n        };\r\n        this.apiKey = apiKey;\r\n        // Start heartbeat and backfiller for the websocket connection.\r\n        this.backfiller = new WebsocketBackfiller(this);\r\n        this.addSocketListeners();\r\n        this.startHeartbeat();\r\n        this.cancelBackfill = _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.n;\r\n    }\r\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getNetwork(network) {\r\n        if (typeof network === 'string' && network in _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.C) {\r\n            return _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.C[network];\r\n        }\r\n        // Call the standard ethers.js getNetwork method for other networks.\r\n        return (0,_ethersproject_networks__WEBPACK_IMPORTED_MODULE_5__.getNetwork)(network);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based subscriptions.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    on(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, false);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based\r\n     * subscriptions. Adds a listener to the triggered for only the next\r\n     * {@link eventName} event, after which it will be removed.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    once(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, true);\r\n    }\r\n    /**\r\n     * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n     * listener is provided, all listeners for the event will be removed.\r\n     *\r\n     * @param eventName Event to unlisten to.\r\n     * @param listener The listener function to remove.\r\n     * @override\r\n     * @public\r\n     */\r\n    off(eventName, listener) {\r\n        if ((0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.i)(eventName)) {\r\n            return this._off(eventName, listener);\r\n        }\r\n        else {\r\n            return super.off(eventName, listener);\r\n        }\r\n    }\r\n    /**\r\n     * Remove all listeners for the provided {@link eventName} event. If no event\r\n     * is provided, all events and their listeners are removed.\r\n     *\r\n     * @param eventName The event to remove all listeners for.\r\n     * @override\r\n     * @public\r\n     */\r\n    removeAllListeners(eventName) {\r\n        if (eventName !== undefined && (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.i)(eventName)) {\r\n            return this._removeAllListeners(eventName);\r\n        }\r\n        else {\r\n            return super.removeAllListeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the number of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, the total number of listeners for all events is returned.\r\n     *\r\n     * @param eventName The event to get the number of listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listenerCount(eventName) {\r\n        if (eventName !== undefined && (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.i)(eventName)) {\r\n            return this._listenerCount(eventName);\r\n        }\r\n        else {\r\n            return super.listenerCount(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns an array of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, all listeners will be included.\r\n     *\r\n     * @param eventName The event to get the listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listeners(eventName) {\r\n        if (eventName !== undefined && (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.i)(eventName)) {\r\n            return this._listeners(eventName);\r\n        }\r\n        else {\r\n            return super.listeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the method in `BaseProvider` in order to properly format the\r\n     * Alchemy subscription events.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _addEventListener(eventName, listener, once) {\r\n        if ((0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.i)(eventName)) {\r\n            (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.v)(eventName);\r\n            const event = new _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.c((0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.e)(eventName), listener, once);\r\n            this._events.push(event);\r\n            this._startEvent(event);\r\n            return this;\r\n        }\r\n        else {\r\n            return super._addEventListener(eventName, listener, once);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the `_startEvent()` method in ethers.js's\r\n     * {@link WebSocketProvider} to include additional alchemy methods.\r\n     *\r\n     * @param event\r\n     * @override\r\n     * @internal\r\n     */\r\n    _startEvent(event) {\r\n        // Check if the event type is a custom Alchemy subscription.\r\n        const customLogicTypes = [..._index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.A, 'block', 'filter'];\r\n        if (customLogicTypes.includes(event.type)) {\r\n            this.customStartEvent(event);\r\n        }\r\n        else {\r\n            super._startEvent(event);\r\n        }\r\n    }\r\n    /**\r\n     * Overridden from ethers.js's {@link WebSocketProvider}\r\n     *\r\n     * Modified in order to add mappings for backfilling.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _subscribe(tag, param, processFunc, event) {\r\n        return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            let subIdPromise = this._subIds[tag];\r\n            // BEGIN MODIFIED CODE\r\n            const startingBlockNumber = yield this.getBlockNumber();\r\n            // END MODIFIED CODE\r\n            if (subIdPromise == null) {\r\n                subIdPromise = Promise.all(param).then(param => {\r\n                    return this.send('eth_subscribe', param);\r\n                });\r\n                this._subIds[tag] = subIdPromise;\r\n            }\r\n            const subId = yield subIdPromise;\r\n            // BEGIN MODIFIED CODE\r\n            const resolvedParams = yield Promise.all(param);\r\n            this.virtualSubscriptionsById.set(subId, {\r\n                event: event,\r\n                method: 'eth_subscribe',\r\n                params: resolvedParams,\r\n                startingBlockNumber,\r\n                virtualId: subId,\r\n                physicalId: subId,\r\n                sentEvents: [],\r\n                isBackfilling: false,\r\n                backfillBuffer: []\r\n            });\r\n            this.virtualIdsByPhysicalId.set(subId, subId);\r\n            // END MODIFIED CODE\r\n            this._subs[subId] = { tag, processFunc };\r\n        });\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    emit(eventName, ...args) {\r\n        if ((0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.i)(eventName)) {\r\n            let result = false;\r\n            const stopped = [];\r\n            // This line is the only modified line from the original method.\r\n            const eventTag = (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.e)(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                setTimeout(() => {\r\n                    event.listener.apply(this, args);\r\n                }, 0);\r\n                result = true;\r\n                if (event.once) {\r\n                    stopped.push(event);\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n            stopped.forEach(event => {\r\n                this._stopEvent(event);\r\n            });\r\n            return result;\r\n        }\r\n        else {\r\n            return super.emit(eventName, ...args);\r\n        }\r\n    }\r\n    /** @internal */\r\n    sendBatch(parts) {\r\n        return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            let nextId = 0;\r\n            const payload = parts.map(({ method, params }) => {\r\n                return {\r\n                    method,\r\n                    params,\r\n                    jsonrpc: '2.0',\r\n                    id: `alchemy-sdk:${nextId++}`\r\n                };\r\n            });\r\n            return this.sendBatchConcurrently(payload);\r\n        });\r\n    }\r\n    /** @override */\r\n    destroy() {\r\n        this.removeSocketListeners();\r\n        this.stopHeartbeatAndBackfill();\r\n        return super.destroy();\r\n    }\r\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\r\n    isCommunityResource() {\r\n        return this.apiKey === _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.D;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\r\n     *\r\n     * This method is copied over directly in order to support Alchemy's\r\n     * subscription type by allowing the provider to properly stop Alchemy's\r\n     * subscription events.\r\n     *\r\n     * @internal\r\n     */\r\n    _stopEvent(event) {\r\n        let tag = event.tag;\r\n        // START MODIFIED CODE\r\n        if (_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.A.includes(event.type)) {\r\n            // There are remaining pending transaction listeners.\r\n            if (this._events.filter(e => _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.A.includes(e.type)).length) {\r\n                return;\r\n            }\r\n            // END MODIFIED CODE\r\n        }\r\n        else if (event.type === 'tx') {\r\n            // There are remaining transaction event listeners\r\n            if (this._events.filter(e => e.type === 'tx').length) {\r\n                return;\r\n            }\r\n            tag = 'tx';\r\n        }\r\n        else if (this.listenerCount(event.event)) {\r\n            // There are remaining event listeners\r\n            return;\r\n        }\r\n        const subId = this._subIds[tag];\r\n        if (!subId) {\r\n            return;\r\n        }\r\n        delete this._subIds[tag];\r\n        void subId.then(subId => {\r\n            if (!this._subs[subId]) {\r\n                return;\r\n            }\r\n            delete this._subs[subId];\r\n            void this.send('eth_unsubscribe', [subId]);\r\n        });\r\n    }\r\n    /** @internal */\r\n    addSocketListeners() {\r\n        this._websocket.addEventListener('message', this.handleMessage);\r\n        this._websocket.addEventListener('reopen', this.handleReopen);\r\n        this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /** @internal */\r\n    removeSocketListeners() {\r\n        this._websocket.removeEventListener('message', this.handleMessage);\r\n        this._websocket.removeEventListener('reopen', this.handleReopen);\r\n        this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /**\r\n     * Reopens the backfill based on\r\n     *\r\n     * @param isCancelled\r\n     * @param subscription\r\n     * @internal\r\n     */\r\n    resubscribeAndBackfill(isCancelled, subscription) {\r\n        return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            const { virtualId, method, params, sentEvents, backfillBuffer, startingBlockNumber } = subscription;\r\n            subscription.isBackfilling = true;\r\n            backfillBuffer.length = 0;\r\n            try {\r\n                const physicalId = yield this.send(method, params);\r\n                throwIfCancelled(isCancelled);\r\n                subscription.physicalId = physicalId;\r\n                this.virtualIdsByPhysicalId.set(physicalId, virtualId);\r\n                switch (params[0]) {\r\n                    case 'newHeads': {\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    case 'logs': {\r\n                        const filter = params[1] || {};\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getLogsBackfill(isCancelled, filter, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitLogsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n            finally {\r\n                subscription.isBackfilling = false;\r\n                backfillBuffer.length = 0;\r\n            }\r\n        });\r\n    }\r\n    /** @internal */\r\n    emitNewHeadsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitLogsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n    }\r\n    /**\r\n     * Emits an event to consumers, but also remembers it in its subscriptions's\r\n     * `sentEvents` buffer so that we can detect re-orgs if the connection drops\r\n     * and needs to be reconnected.\r\n     *\r\n     * @internal\r\n     */\r\n    emitAndRememberEvent(virtualId, result, getBlockNumber) {\r\n        this.rememberEvent(virtualId, result, getBlockNumber);\r\n        this.emitEvent(virtualId, result);\r\n    }\r\n    emitEvent(virtualId, result) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        this.emitGenericEvent(subscription, result);\r\n    }\r\n    /** @internal */\r\n    rememberEvent(virtualId, result, getBlockNumber) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        // Web3 modifies these event objects once we pass them on (changing hex\r\n        // numbers to numbers). We want the original event, so make a defensive\r\n        // copy.\r\n        addToPastEventsBuffer(subscription.sentEvents, Object.assign({}, result), getBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitGenericEvent(subscription, result) {\r\n        const emitFunction = this.emitProcessFn(subscription.event);\r\n        emitFunction(result);\r\n    }\r\n    /**\r\n     * Starts a heartbeat that pings the websocket server periodically to ensure\r\n     * that the connection stays open.\r\n     *\r\n     * @internal\r\n     */\r\n    startHeartbeat() {\r\n        if (this.heartbeatIntervalId != null) {\r\n            return;\r\n        }\r\n        this.heartbeatIntervalId = setInterval(() => (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            try {\r\n                yield withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\r\n            }\r\n            catch (_a) {\r\n                this._websocket.reconnect();\r\n            }\r\n        }), HEARTBEAT_INTERVAL);\r\n    }\r\n    /**\r\n     * This method sends the batch concurrently as individual requests rather than\r\n     * as a batch, which was the original implementation. The original batch logic\r\n     * is preserved in this implementation in order for faster porting.\r\n     *\r\n     * @param payload\r\n     * @internal\r\n     */\r\n    // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\r\n    // TODO(errors): Use allSettled() once we have more error handling.\r\n    sendBatchConcurrently(payload) {\r\n        return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            return Promise.all(payload.map(req => this.send(req.method, req.params)));\r\n        });\r\n    }\r\n    /** @internal */\r\n    customStartEvent(event) {\r\n        if (event.type === _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.h) {\r\n            const { fromAddress, toAddress, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.j.PENDING_TRANSACTIONS,\r\n                { fromAddress, toAddress, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.k) {\r\n            const { addresses, includeRemoved, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.j.MINED_TRANSACTIONS,\r\n                { addresses, includeRemoved, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'block') {\r\n            void this._subscribe('block', ['newHeads'], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'filter') {\r\n            void this._subscribe(event.tag, ['logs', this._getFilter(event.filter)], this.emitProcessFn(event), event);\r\n        }\r\n    }\r\n    /** @internal */\r\n    emitProcessFn(event) {\r\n        switch (event.type) {\r\n            case _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.h:\r\n                return result => this.emit({\r\n                    method: _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.j.PENDING_TRANSACTIONS,\r\n                    fromAddress: event.fromAddress,\r\n                    toAddress: event.toAddress,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.k:\r\n                return result => this.emit({\r\n                    method: _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.j.MINED_TRANSACTIONS,\r\n                    addresses: event.addresses,\r\n                    includeRemoved: event.includeRemoved,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case 'block':\r\n                return result => {\r\n                    const blockNumber = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result.number).toNumber();\r\n                    this._emitted.block = blockNumber;\r\n                    this.emit('block', blockNumber);\r\n                };\r\n            case 'filter':\r\n                return result => {\r\n                    if (result.removed == null) {\r\n                        result.removed = false;\r\n                    }\r\n                    this.emit(event.filter, this.formatter.filterLog(result));\r\n                };\r\n            default:\r\n                throw new Error('Invalid event type to `emitProcessFn()`');\r\n        }\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.off()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _off(eventName, listener) {\r\n        if (listener == null) {\r\n            return this.removeAllListeners(eventName);\r\n        }\r\n        const stopped = [];\r\n        let found = false;\r\n        const eventTag = (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.e)(eventName);\r\n        this._events = this._events.filter(event => {\r\n            if (event.tag !== eventTag || event.listener != listener) {\r\n                return true;\r\n            }\r\n            if (found) {\r\n                return true;\r\n            }\r\n            found = true;\r\n            stopped.push(event);\r\n            return false;\r\n        });\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _removeAllListeners(eventName) {\r\n        let stopped = [];\r\n        if (eventName == null) {\r\n            stopped = this._events;\r\n            this._events = [];\r\n        }\r\n        else {\r\n            const eventTag = (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.e)(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                stopped.push(event);\r\n                return false;\r\n            });\r\n        }\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listenerCount(eventName) {\r\n        if (!eventName) {\r\n            return this._events.length;\r\n        }\r\n        const eventTag = (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.e)(eventName);\r\n        return this._events.filter(event => {\r\n            return event.tag === eventTag;\r\n        }).length;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listeners(eventName) {\r\n        if (eventName == null) {\r\n            return this._events.map(event => event.listener);\r\n        }\r\n        const eventTag = (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.e)(eventName);\r\n        return this._events\r\n            .filter(event => event.tag === eventTag)\r\n            .map(event => event.listener);\r\n    }\r\n}\r\nfunction getWebsocketConstructor() {\r\n    return isNodeEnvironment() ? (__webpack_require__(/*! websocket */ \"(app-pages-browser)/./node_modules/websocket/lib/browser.js\").w3cwebsocket) : WebSocket;\r\n}\r\nfunction isNodeEnvironment() {\r\n    return (typeof process !== 'undefined' &&\r\n        process != null &&\r\n        process.versions != null &&\r\n        process.versions.node != null);\r\n}\r\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\r\nfunction makeCancelToken() {\r\n    let cancelled = false;\r\n    return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\r\n}\r\n// TODO(cleanup): replace with SDK's backoff implementation\r\nconst MIN_RETRY_DELAY = 1000;\r\nconst RETRY_BACKOFF_FACTOR = 2;\r\nconst MAX_RETRY_DELAY = 30000;\r\nfunction withBackoffRetries(f, retryCount, shouldRetry = () => true) {\r\n    return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n        let nextWaitTime = 0;\r\n        let i = 0;\r\n        while (true) {\r\n            try {\r\n                return yield f();\r\n            }\r\n            catch (error) {\r\n                i++;\r\n                if (i >= retryCount || !shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                yield delay(nextWaitTime);\r\n                if (!shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                nextWaitTime =\r\n                    nextWaitTime === 0\r\n                        ? MIN_RETRY_DELAY\r\n                        : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction delay(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\nfunction withTimeout(promise, ms) {\r\n    return Promise.race([\r\n        promise,\r\n        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), ms))\r\n    ]);\r\n}\r\nfunction getNewHeadsBlockNumber(event) {\r\n    return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.f)(event.number);\r\n}\r\nfunction getLogsBlockNumber(event) {\r\n    return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_2__.f)(event.blockNumber);\r\n}\r\nfunction isResponse(message) {\r\n    return (Array.isArray(message) ||\r\n        (message.jsonrpc === '2.0' && message.id !== undefined));\r\n}\r\nfunction isSubscriptionEvent(message) {\r\n    return !isResponse(message);\r\n}\r\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\r\n}\r\nfunction addToLogsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\r\n}\r\n/**\r\n * Adds a new event to an array of events, evicting any events which are so old\r\n * that they will no longer feasibly be part of a reorg.\r\n */\r\nfunction addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\r\n    const currentBlockNumber = getBlockNumber(event);\r\n    // Find first index of an event recent enough to retain, then drop everything\r\n    // at a lower index.\r\n    const firstGoodIndex = pastEvents.findIndex(e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT);\r\n    if (firstGoodIndex === -1) {\r\n        pastEvents.length = 0;\r\n    }\r\n    else {\r\n        pastEvents.splice(0, firstGoodIndex);\r\n    }\r\n    pastEvents.push(event);\r\n}\n\n\n//# sourceMappingURL=alchemy-websocket-provider-3967f150.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hbGNoZW15LXNkay9kaXN0L2VzbS9hbGNoZW15LXdlYnNvY2tldC1wcm92aWRlci0zOTY3ZjE1MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQTBaO0FBQzNXO0FBQ007QUFDQTtBQUNRO0FBQ0k7QUFDNUM7QUFDTjtBQUMyQjtBQUNYO0FBQ0c7QUFDTjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQ0FBZ0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHFEQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MscURBQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxREFBTztBQUN0QywyREFBMkQsVUFBVSxlQUFlO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxREFBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxREFBTztBQUN4QixvQkFBb0IscURBQU87QUFDM0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0EsbUJBQW1CLHFEQUFPO0FBQzFCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQscUJBQXFCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHNCQUFzQjtBQUNuRTtBQUNBO0FBQ0EsNkJBQTZCLHFEQUFLO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQSw4REFBOEQscURBQU87QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBUztBQUN4QjtBQUNBLGdCQUFnQixxREFBSztBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQVM7QUFDeEI7QUFDQTtBQUNBLHdEQUF3RCxxREFBTztBQUMvRDtBQUNBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHFEQUFPO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMscURBQU87QUFDNUMsa0NBQWtDLHFEQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsYUFBYSxXQUFXLHFEQUFLLCtCQUErQixxREFBSyx3QkFBd0I7QUFDdko7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0IsR0FBRyxlQUFlO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGVBQWUsVUFBVSw0Q0FBNEM7QUFDekU7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVFQUFpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwRUFBZTtBQUN0QztBQUNBLCtCQUErQiwwRUFBZTtBQUM5QywyQkFBMkIsMEVBQWU7QUFDMUMsd0NBQXdDLGlEQUFPLENBQUM7QUFDaEQ7QUFDQSx1QkFBdUIsd0RBQWU7QUFDdEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlEQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHlCQUF5QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQ0FBZ0M7QUFDNUQsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQ0FBZ0M7QUFDNUQsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBLDRCQUE0QixxREFBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHVCQUF1QjtBQUM3RjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpREFBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGlEQUFjO0FBQ3BFLG1CQUFtQixpREFBYztBQUNqQztBQUNBO0FBQ0EsZUFBZSxtRUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUJBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0JBQWdCLFNBQVMsaUJBQWlCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGlCQUFpQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxREFBYztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxpQkFBaUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMscURBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsaUJBQWlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHFEQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFjO0FBQzFCLFlBQVkscURBQXNCO0FBQ2xDLDhCQUE4QixpREFBVyxDQUFDLHFEQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUJBQXlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlEQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMEJBQTBCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscURBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFEQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQVM7QUFDeEI7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpREFBdUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpREFBbUI7QUFDL0I7QUFDQSx5Q0FBeUMsaURBQW1CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBUztBQUN4QixvQkFBb0IsNkVBQTZFO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxxREFBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBUztBQUN4QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaURBQXVDO0FBQ2xFLG9CQUFvQixxQ0FBcUM7QUFDekQ7QUFDQSxnQkFBZ0IsaURBQW1CO0FBQ25DLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZ0NBQWdDLGlEQUFxQztBQUNyRSxvQkFBb0Isd0NBQXdDO0FBQzVEO0FBQ0EsZ0JBQWdCLGlEQUFtQjtBQUNuQyxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlEQUF1QztBQUN4RDtBQUNBLDRCQUE0QixpREFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQixpREFBcUM7QUFDdEQ7QUFDQSw0QkFBNEIsaURBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esd0NBQXdDLCtEQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMEJBQTBCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFEQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMEJBQTBCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscURBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQkFBMEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBa0I7QUFDM0M7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQkFBMEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtIQUFpQztBQUNsRTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsUUFBUSxPQUFPO0FBQ2YsUUFBUSxPQUFPO0FBQ2YsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxREFBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscURBQU87QUFDbEI7QUFDQTtBQUNBLFdBQVcscURBQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9DO0FBQ3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hbGNoZW15LXNkay9kaXN0L2VzbS9hbGNoZW15LXdlYnNvY2tldC1wcm92aWRlci0zOTY3ZjE1MC5qcz9iMzJkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF8gYXMgX19hd2FpdGVyLCBmIGFzIGZyb21IZXgsIHQgYXMgdG9IZXgsIG4gYXMgbm9vcCwgQyBhcyBDdXN0b21OZXR3b3JrcywgaSBhcyBpc0FsY2hlbXlFdmVudCwgdiBhcyB2ZXJpZnlBbGNoZW15RXZlbnROYW1lLCBjIGFzIEV0aGVyc0V2ZW50LCBlIGFzIGdldEFsY2hlbXlFdmVudFRhZywgRCBhcyBERUZBVUxUX0FMQ0hFTVlfQVBJX0tFWSwgQSBhcyBBTENIRU1ZX0VWRU5UX1RZUEVTLCBoIGFzIEFMQ0hFTVlfUEVORElOR19UUkFOU0FDVElPTlNfRVZFTlRfVFlQRSwgaiBhcyBBbGNoZW15U3Vic2NyaXB0aW9uLCBrIGFzIEFMQ0hFTVlfTUlORURfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUsIFYgYXMgVkVSU0lPTiwgRSBhcyBFdGhlcnNOZXR3b3JrIH0gZnJvbSAnLi9pbmRleC0xZjJmNjAzMi5qcyc7XG5pbXBvcnQgU3R1cmR5V2ViU29ja2V0IGZyb20gJ3N0dXJkeS13ZWJzb2NrZXQnO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyJztcbmltcG9ydCB7IGdldE5ldHdvcmsgfSBmcm9tICdAZXRoZXJzcHJvamVjdC9uZXR3b3Jrcyc7XG5pbXBvcnQgeyBXZWJTb2NrZXRQcm92aWRlciB9IGZyb20gJ0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycyc7XG5pbXBvcnQgeyBBbGNoZW15UHJvdmlkZXIgfSBmcm9tICcuL2FsY2hlbXktcHJvdmlkZXItNWU1MzBlZDUuanMnO1xuaW1wb3J0ICcuL2FwaS91dGlscyc7XG5pbXBvcnQgJ2F4aW9zJztcbmltcG9ydCAnQGV0aGVyc3Byb2plY3QvYWJzdHJhY3QtcHJvdmlkZXInO1xuaW1wb3J0ICdAZXRoZXJzcHJvamVjdC93YWxsZXQnO1xuaW1wb3J0ICdAZXRoZXJzcHJvamVjdC9jb250cmFjdHMnO1xuaW1wb3J0ICdAZXRoZXJzcHJvamVjdC93ZWInO1xuXG4vKipcclxuICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGJsb2NrcyB0byBiYWNrZmlsbC4gSWYgbW9yZSB0aGFuIHRoaXMgbWFueSBibG9ja3MgaGF2ZVxyXG4gKiBiZWVuIG1pc3NlZCwgdGhlbiB3ZSdsbCBzYWRseSBtaXNzIGRhdGEsIGJ1dCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBkb24ndFxyXG4gKiBlbmQgdXAgcmVxdWVzdGluZyB0aG91c2FuZHMgb2YgYmxvY2tzIGlmIHNvbWVib2R5IGxlZnQgdGhlaXIgbGFwdG9wIGNsb3NlZCBmb3IgYSB3ZWVrLlxyXG4gKi9cclxuY29uc3QgTUFYX0JBQ0tGSUxMX0JMT0NLUyA9IDEyMDtcclxuLyoqXHJcbiAqIFRoZSBXZWJzb2NrZXRCYWNrZmlsbGVyIGZldGNoZXMgZXZlbnRzIHRoYXQgd2VyZSBzZW50IHNpbmNlIGEgcHJvdmlkZWQgYmxvY2tcclxuICogbnVtYmVyLiBUaGlzIGlzIHVzZWQgaW4gdGhlIHtAbGluayBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXJ9IHRvIGJhY2tmaWxsXHJcbiAqIGV2ZW50cyB0aGF0IHdlcmUgdHJhbnNtaXR0ZWQgd2hpbGUgdGhlIHdlYnNvY2tldCBjb25uZWN0aW9uIHdhcyBkb3duLlxyXG4gKlxyXG4gKiBUaGUgYmFja2ZpbGxlciBiYWNrZmlsbHMgdHdvIG1haW4gZXRoX3N1YnNjcmliZSBldmVudHM6IGBsb2dzYCBhbmQgYG5ld0hlYWRzYC5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBXZWJzb2NrZXRCYWNrZmlsbGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xyXG4gICAgICAgIC8vIFRPRE86IFVzZSBIVFRQIHByb3ZpZGVyIHRvIGRvIGJhY2tmaWxsLlxyXG4gICAgICAgIHRoaXMubWF4QmFja2ZpbGxCbG9ja3MgPSBNQVhfQkFDS0ZJTExfQkxPQ0tTO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSdW5zIGJhY2tmaWxsIGZvciBgbmV3SGVhZHNgIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaXNDYW5jZWxsZWQgV2hldGhlciB0aGUgYmFja2ZpbGwgcmVxdWVzdCBpcyBjYW5jZWxsZWQuXHJcbiAgICAgKiBAcGFyYW0gcHJldmlvdXNIZWFkcyBQcmV2aW91cyBoZWFkIHJlcXVlc3RzIHRoYXQgd2VyZSBzZW50LlxyXG4gICAgICogQHBhcmFtIGZyb21CbG9ja051bWJlciBUaGUgYmxvY2sgbnVtYmVyIHRvIHN0YXJ0IGJhY2tmaWxsaW5nIGZyb20uXHJcbiAgICAgKiBAcmV0dXJucyBBIGxpc3Qgb2YgYG5ld0hlYWRzYCBldmVudHMgdGhhdCB3ZXJlIHNlbnQgc2luY2UgdGhlIGxhc3QgYmFja2ZpbGwuXHJcbiAgICAgKi9cclxuICAgIGdldE5ld0hlYWRzQmFja2ZpbGwoaXNDYW5jZWxsZWQsIHByZXZpb3VzSGVhZHMsIGZyb21CbG9ja051bWJlcikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICBjb25zdCB0b0Jsb2NrTnVtYmVyID0geWllbGQgdGhpcy5nZXRCbG9ja051bWJlcigpO1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHByZXZpb3VzIGhlYWRzIHRvIGZldGNoLCByZXR1cm4gbmV3IGhlYWRzIHNpbmNlXHJcbiAgICAgICAgICAgIC8vIGBmcm9tQmxvY2tOdW1iZXJgLCBvciB1cCB0byBtYXhCYWNrZmlsbEJsb2NrcyBmcm9tIHRoZSBjdXJyZW50IGhlYWQuXHJcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0hlYWRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SGVhZEV2ZW50c0luUmFuZ2UoTWF0aC5tYXgoZnJvbUJsb2NrTnVtYmVyLCB0b0Jsb2NrTnVtYmVyIC0gdGhpcy5tYXhCYWNrZmlsbEJsb2NrcykgKyAxLCB0b0Jsb2NrTnVtYmVyICsgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgdGhlIGxhc3QgZW1pdHRlZCBldmVudCBpcyB0b28gZmFyIGJhY2sgaW4gdGhlIHBhc3QsIHRoZXJlJ3Mgbm8gbmVlZFxyXG4gICAgICAgICAgICAvLyB0byBiYWNrZmlsbCBmb3IgcmVvcmdzLiBKdXN0IGZldGNoIHRoZSBsYXN0IGBtYXhCYWNrZmlsbEJsb2Nrc2Agd29ydGggb2ZcclxuICAgICAgICAgICAgLy8gbmV3IGhlYWRzLlxyXG4gICAgICAgICAgICBjb25zdCBsYXN0U2VlbkJsb2NrTnVtYmVyID0gZnJvbUhleChwcmV2aW91c0hlYWRzW3ByZXZpb3VzSGVhZHMubGVuZ3RoIC0gMV0ubnVtYmVyKTtcclxuICAgICAgICAgICAgY29uc3QgbWluQmxvY2tOdW1iZXIgPSB0b0Jsb2NrTnVtYmVyIC0gdGhpcy5tYXhCYWNrZmlsbEJsb2NrcyArIDE7XHJcbiAgICAgICAgICAgIGlmIChsYXN0U2VlbkJsb2NrTnVtYmVyIDw9IG1pbkJsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWFkRXZlbnRzSW5SYW5nZShtaW5CbG9ja051bWJlciwgdG9CbG9ja051bWJlciArIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRvIGNhcHR1cmUgYWxsIGBuZXdIZWFkc2AgZXZlbnRzLCByZXR1cm4gYWxsIGhlYWQgZXZlbnRzIGZyb20gdGhlIGxhc3RcclxuICAgICAgICAgICAgLy8gc2VlbiBibG9jayBudW1iZXIgdG8gY3VycmVudCArIGFueSBvZiB0aGUgcHJldmlvdXMgaGVhZHMgdGhhdCB3ZXJlIHJlLW9yZ2VkLlxyXG4gICAgICAgICAgICBjb25zdCByZW9yZ0hlYWRzID0geWllbGQgdGhpcy5nZXRSZW9yZ0hlYWRzKGlzQ2FuY2VsbGVkLCBwcmV2aW91c0hlYWRzKTtcclxuICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGludGVybWVkaWF0ZUhlYWRzID0geWllbGQgdGhpcy5nZXRIZWFkRXZlbnRzSW5SYW5nZShsYXN0U2VlbkJsb2NrTnVtYmVyICsgMSwgdG9CbG9ja051bWJlciArIDEpO1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgcmV0dXJuIFsuLi5yZW9yZ0hlYWRzLCAuLi5pbnRlcm1lZGlhdGVIZWFkc107XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgYmFja2ZpbGwgZm9yIGBsb2dzYCBldmVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlzQ2FuY2VsbGVkIFdoZXRoZXIgdGhlIGJhY2tmaWxsIHJlcXVlc3QgaXMgY2FuY2VsbGVkLlxyXG4gICAgICogQHBhcmFtIGZpbHRlciBUaGUgZmlsdGVyIG9iamVjdCB0aGF0IGFjY29tcGFuaWVzIGEgbG9ncyBzdWJzY3JpcHRpb24uXHJcbiAgICAgKiBAcGFyYW0gcHJldmlvdXNMb2dzIFByZXZpb3VzIGxvZyByZXF1ZXN0cyB0aGF0IHdlcmUgc2VudC5cclxuICAgICAqIEBwYXJhbSBmcm9tQmxvY2tOdW1iZXIgVGhlIGJsb2NrIG51bWJlciB0byBzdGFydCBiYWNrZmlsbGluZyBmcm9tLlxyXG4gICAgICovXHJcbiAgICBnZXRMb2dzQmFja2ZpbGwoaXNDYW5jZWxsZWQsIGZpbHRlciwgcHJldmlvdXNMb2dzLCBmcm9tQmxvY2tOdW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgY29uc3QgdG9CbG9ja051bWJlciA9IHlpZWxkIHRoaXMuZ2V0QmxvY2tOdW1iZXIoKTtcclxuICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBwcmV2aW91cyBsb2dzIHRvIGZldGNoLCByZXR1cm4gbmV3IGxvZ3Mgc2luY2VcclxuICAgICAgICAgICAgLy8gYGZyb21CbG9ja051bWJlcmAsIG9yIHVwIHRvIGBtYXhCYWNrZmlsbEJsb2Nrc2AgZnJvbSB0aGUgY3VycmVudCBoZWFkLlxyXG4gICAgICAgICAgICBpZiAocHJldmlvdXNMb2dzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9nc0luUmFuZ2UoZmlsdGVyLCBNYXRoLm1heChmcm9tQmxvY2tOdW1iZXIsIHRvQmxvY2tOdW1iZXIgLSB0aGlzLm1heEJhY2tmaWxsQmxvY2tzKSArIDEsIHRvQmxvY2tOdW1iZXIgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgbGFzdCBlbWl0dGVkIGxvZyBpcyB0b28gZmFyIGJhY2sgaW4gdGhlIHBhc3QsIHRoZXJlJ3Mgbm8gbmVlZFxyXG4gICAgICAgICAgICAvLyB0byBiYWNrZmlsbCBmb3IgcmVtb3ZlZCBsb2dzLiBKdXN0IGZldGNoIHRoZSBsYXN0IGBtYXhCYWNrZmlsbEJsb2Nrc2BcclxuICAgICAgICAgICAgLy8gd29ydGggb2YgbG9ncy5cclxuICAgICAgICAgICAgY29uc3QgbGFzdFNlZW5CbG9ja051bWJlciA9IGZyb21IZXgocHJldmlvdXNMb2dzW3ByZXZpb3VzTG9ncy5sZW5ndGggLSAxXS5ibG9ja051bWJlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbkJsb2NrTnVtYmVyID0gdG9CbG9ja051bWJlciAtIHRoaXMubWF4QmFja2ZpbGxCbG9ja3MgKyAxO1xyXG4gICAgICAgICAgICBpZiAobGFzdFNlZW5CbG9ja051bWJlciA8IG1pbkJsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb2dzSW5SYW5nZShmaWx0ZXIsIG1pbkJsb2NrTnVtYmVyLCB0b0Jsb2NrTnVtYmVyICsgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUmV0dXJuIGFsbCBsb2cgZXZlbnRzIHRoYXQgaGF2ZSBoYXBwZW5lZCBhbG9uZyB3aXRoIGxvZyBldmVudHMgdGhhdCBoYXZlXHJcbiAgICAgICAgICAgIC8vIGJlZW4gcmVtb3ZlZCBkdWUgdG8gYSBjaGFpbiByZW9yZy5cclxuICAgICAgICAgICAgY29uc3QgY29tbW9uQW5jZXN0b3IgPSB5aWVsZCB0aGlzLmdldENvbW1vbkFuY2VzdG9yKGlzQ2FuY2VsbGVkLCBwcmV2aW91c0xvZ3MpO1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgLy8gQWxsIHByZXZpb3VzIGxvZ3Mgd2l0aCBhIGJsb2NrIG51bWJlciBncmVhdGVyIHRoYW4gdGhlIGNvbW1vbiBhbmNlc3RvclxyXG4gICAgICAgICAgICAvLyB3ZXJlIHBhcnQgb2YgYSByZS1vcmcsIHNvIG1hcmsgdGhlbSBhcyBzdWNoLlxyXG4gICAgICAgICAgICBjb25zdCByZW1vdmVkTG9ncyA9IHByZXZpb3VzTG9nc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihsb2cgPT4gZnJvbUhleChsb2cuYmxvY2tOdW1iZXIpID4gY29tbW9uQW5jZXN0b3IuYmxvY2tOdW1iZXIpXHJcbiAgICAgICAgICAgICAgICAubWFwKGxvZyA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBsb2cpLCB7IHJlbW92ZWQ6IHRydWUgfSkpKTtcclxuICAgICAgICAgICAgLy8gSWYgbm8gY29tbW9uIGFuY2VzdG9yIHdhcyBmb3VuZCwgc3RhcnQgYmFja2ZpbGwgZnJvbSB0aGUgb2xkZXN0IGxvZydzXHJcbiAgICAgICAgICAgIC8vIGJsb2NrIG51bWJlci5cclxuICAgICAgICAgICAgY29uc3QgZnJvbUJsb2NrSW5jbHVzaXZlID0gY29tbW9uQW5jZXN0b3IuYmxvY2tOdW1iZXIgPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxyXG4gICAgICAgICAgICAgICAgPyBmcm9tSGV4KHByZXZpb3VzTG9nc1swXS5ibG9ja051bWJlcilcclxuICAgICAgICAgICAgICAgIDogY29tbW9uQW5jZXN0b3IuYmxvY2tOdW1iZXI7XHJcbiAgICAgICAgICAgIGxldCBhZGRlZExvZ3MgPSB5aWVsZCB0aGlzLmdldExvZ3NJblJhbmdlKGZpbHRlciwgZnJvbUJsb2NrSW5jbHVzaXZlLCB0b0Jsb2NrTnVtYmVyICsgMSk7XHJcbiAgICAgICAgICAgIC8vIERlLWR1cGUgYW55IGxvZ3MgdGhhdCB3ZXJlIGFscmVhZHkgZW1pdHRlZC5cclxuICAgICAgICAgICAgYWRkZWRMb2dzID0gYWRkZWRMb2dzLmZpbHRlcihsb2cgPT4gbG9nICYmXHJcbiAgICAgICAgICAgICAgICAoZnJvbUhleChsb2cuYmxvY2tOdW1iZXIpID4gY29tbW9uQW5jZXN0b3IuYmxvY2tOdW1iZXIgfHxcclxuICAgICAgICAgICAgICAgICAgICBmcm9tSGV4KGxvZy5sb2dJbmRleCkgPiBjb21tb25BbmNlc3Rvci5sb2dJbmRleCkpO1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgcmV0dXJuIFsuLi5yZW1vdmVkTG9ncywgLi4uYWRkZWRMb2dzXTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIG5ldyBtYXggYmFja2ZpbGwgYmxvY2tzLiBWSVNJQkxFIE9OTFkgRk9SIFRFU1RJTkcuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHNldE1heEJhY2tmaWxsQmxvY2sobmV3TWF4KSB7XHJcbiAgICAgICAgdGhpcy5tYXhCYWNrZmlsbEJsb2NrcyA9IG5ld01heDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBibG9jayBudW1iZXIgYXMgYSBudW1iZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZ2V0QmxvY2tOdW1iZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXJIZXggPSB5aWVsZCB0aGlzLnByb3ZpZGVyLnNlbmQoJ2V0aF9ibG9ja051bWJlcicpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUhleChibG9ja051bWJlckhleCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYWxsIGBuZXdIZWFkYCBldmVudHMgaW4gdGhlIHByb3ZpZGVkIHJhbmdlLiBOb3RlIHRoYXQgdGhlIHJldHVybmVkXHJcbiAgICAgKiBoZWFkcyBkbyBub3QgaW5jbHVkZSByZS1vcmdlZCBoZWFkcy4gVXNlIHtAbGluayBnZXRSZW9yZ0hlYWRzfSB0byBmaW5kIGhlYWRzXHJcbiAgICAgKiB0aGF0IHdlcmUgcGFydCBvZiBhIHJlLW9yZy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBnZXRIZWFkRXZlbnRzSW5SYW5nZShmcm9tQmxvY2tJbmNsdXNpdmUsIHRvQmxvY2tFeGNsdXNpdmUpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUJsb2NrSW5jbHVzaXZlID49IHRvQmxvY2tFeGNsdXNpdmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBiYXRjaFBhcnRzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmcm9tQmxvY2tJbmNsdXNpdmU7IGkgPCB0b0Jsb2NrRXhjbHVzaXZlOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGJhdGNoUGFydHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX2dldEJsb2NrQnlOdW1iZXInLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogW3RvSGV4KGkpLCBmYWxzZV1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGhhbmRsZSBlcnJvcnNcclxuICAgICAgICAgICAgY29uc3QgYmxvY2tIZWFkcyA9IHlpZWxkIHRoaXMucHJvdmlkZXIuc2VuZEJhdGNoKGJhdGNoUGFydHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gYmxvY2tIZWFkcy5tYXAodG9OZXdIZWFkc0V2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgaGVhZHMgdGhhdCB3ZXJlIHBhcnQgb2YgYSByZW9yZyBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBnZXRSZW9yZ0hlYWRzKGlzQ2FuY2VsbGVkLCBwcmV2aW91c0hlYWRzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgZnJvbSB0aGUgbW9zdCByZWNlbnQgaGVhZCBiYWNrd2FyZHMgaW4gb3JkZXIgdG8gZmluZCB0aGUgZmlyc3RcclxuICAgICAgICAgICAgLy8gYmxvY2sgdGhhdCB3YXMgcGFydCBvZiBhIHJlLW9yZy5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHByZXZpb3VzSGVhZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZEV2ZW50ID0gcHJldmlvdXNIZWFkc1tpXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrSGVhZCA9IHlpZWxkIHRoaXMuZ2V0QmxvY2tCeU51bWJlcihmcm9tSGV4KG9sZEV2ZW50Lm51bWJlcikpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaGFzaGVzIG1hdGNoLCB0aGVuIGN1cnJlbnQgaGVhZCBpbiB0aGUgaXRlcmF0aW9uIHdhcyBub3QgcmUtb3JnZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAob2xkRXZlbnQuaGFzaCA9PT0gYmxvY2tIZWFkLmhhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRvTmV3SGVhZHNFdmVudChibG9ja0hlYWQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJldmVyc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2ltcGxlIHdyYXBwZXIgYXJvdW5kIGBldGhfZ2V0QmxvY2tCeU51bWJlcmAgdGhhdCByZXR1cm5zIHRoZSBjb21wbGV0ZVxyXG4gICAgICogYmxvY2sgaW5mb3JtYXRpb24gZm9yIHRoZSBwcm92aWRlZCBibG9jayBudW1iZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZ2V0QmxvY2tCeU51bWJlcihibG9ja051bWJlcikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnNlbmQoJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJywgW1xyXG4gICAgICAgICAgICAgICAgdG9IZXgoYmxvY2tOdW1iZXIpLFxyXG4gICAgICAgICAgICAgICAgZmFsc2VcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgbGlzdCBvZiBwcmV2aW91cyBsb2cgZXZlbnRzLCBmaW5kcyB0aGUgY29tbW9uIGJsb2NrIG51bWJlciBmcm9tIHRoZVxyXG4gICAgICogbG9ncyB0aGF0IG1hdGNoZXMgdGhlIGJsb2NrIGhlYWQuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpZGVudGlmeSB3aGljaCBsb2dzIGFyZSBwYXJ0IG9mIGEgcmUtb3JnLlxyXG4gICAgICpcclxuICAgICAqIFJldHVybnMgMSBsZXNzIHRoYW4gdGhlIG9sZGVzdCBsb2cncyBibG9jayBudW1iZXIgaWYgbm8gY29tbW9uIGFuY2VzdG9yIHdhcyBmb3VuZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBnZXRDb21tb25BbmNlc3Rvcihpc0NhbmNlbGxlZCwgcHJldmlvdXNMb2dzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSBmcm9tIHRoZSBtb3N0IHJlY2VudCBoZWFkIGJhY2t3YXJkcyBpbiBvcmRlciB0byBmaW5kIHRoZSBmaXJzdFxyXG4gICAgICAgICAgICAvLyBibG9jayB0aGF0IHdhcyBwYXJ0IG9mIGEgcmUtb3JnLlxyXG4gICAgICAgICAgICBsZXQgYmxvY2tIZWFkID0geWllbGQgdGhpcy5nZXRCbG9ja0J5TnVtYmVyKGZyb21IZXgocHJldmlvdXNMb2dzW3ByZXZpb3VzTG9ncy5sZW5ndGggLSAxXS5ibG9ja051bWJlcikpO1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHByZXZpb3VzTG9ncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkTG9nID0gcHJldmlvdXNMb2dzW2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgdXBkYXRlZCBibG9ja3MgYXJlIGZldGNoZWQgZXZlcnkgdGltZSB0aGUgbG9nJ3MgYmxvY2sgbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgICAgaWYgKG9sZExvZy5ibG9ja051bWJlciAhPT0gYmxvY2tIZWFkLm51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrSGVhZCA9IHlpZWxkIHRoaXMuZ2V0QmxvY2tCeU51bWJlcihmcm9tSGV4KG9sZExvZy5ibG9ja051bWJlcikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgbG9ncyBhcmUgb3JkZXJlZCBpbiBhc2NlbmRpbmcgb3JkZXIsIHRoZSBmaXJzdCBsb2cgdGhhdCBtYXRjaGVzXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgaGFzaCBzaG91bGQgYmUgdGhlIGxhcmdlc3QgbG9nSW5kZXguXHJcbiAgICAgICAgICAgICAgICBpZiAob2xkTG9nLmJsb2NrSGFzaCA9PT0gYmxvY2tIZWFkLmhhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlcjogZnJvbUhleChvbGRMb2cuYmxvY2tOdW1iZXIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dJbmRleDogZnJvbUhleChvbGRMb2cubG9nSW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcclxuICAgICAgICAgICAgICAgIGxvZ0luZGV4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbGwgYGxvZ3NgIGV2ZW50cyBpbiB0aGUgcHJvdmlkZWQgcmFuZ2UuIE5vdGUgdGhhdCB0aGUgcmV0dXJuZWQgbG9nc1xyXG4gICAgICogZG8gbm90IGluY2x1ZGUgcmVtb3ZlZCBsb2dzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi8gZ2V0TG9nc0luUmFuZ2UoZmlsdGVyLCBmcm9tQmxvY2tJbmNsdXNpdmUsIHRvQmxvY2tFeGNsdXNpdmUpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUJsb2NrSW5jbHVzaXZlID49IHRvQmxvY2tFeGNsdXNpdmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByYW5nZUZpbHRlciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmlsdGVyKSwgeyBmcm9tQmxvY2s6IHRvSGV4KGZyb21CbG9ja0luY2x1c2l2ZSksIHRvQmxvY2s6IHRvSGV4KHRvQmxvY2tFeGNsdXNpdmUgLSAxKSB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZCgnZXRoX2dldExvZ3MnLCBbcmFuZ2VGaWx0ZXJdKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0b05ld0hlYWRzRXZlbnQoaGVhZCkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgaGVhZCk7XHJcbiAgICBkZWxldGUgcmVzdWx0LnRvdGFsRGlmZmljdWx0eTtcclxuICAgIGRlbGV0ZSByZXN1bHQudHJhbnNhY3Rpb25zO1xyXG4gICAgZGVsZXRlIHJlc3VsdC51bmNsZXM7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGRlZHVwZU5ld0hlYWRzKGV2ZW50cykge1xyXG4gICAgcmV0dXJuIGRlZHVwZShldmVudHMsIGV2ZW50ID0+IGV2ZW50Lmhhc2gpO1xyXG59XHJcbmZ1bmN0aW9uIGRlZHVwZUxvZ3MoZXZlbnRzKSB7XHJcbiAgICByZXR1cm4gZGVkdXBlKGV2ZW50cywgZXZlbnQgPT4gYCR7ZXZlbnQuYmxvY2tIYXNofS8ke2V2ZW50LmxvZ0luZGV4fWApO1xyXG59XHJcbmZ1bmN0aW9uIGRlZHVwZShpdGVtcywgZ2V0S2V5KSB7XHJcbiAgICBjb25zdCBrZXlzU2VlbiA9IG5ldyBTZXQoKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICBjb25zdCBrZXkgPSBnZXRLZXkoaXRlbSk7XHJcbiAgICAgICAgaWYgKCFrZXlzU2Vlbi5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICBrZXlzU2Vlbi5hZGQoa2V5KTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmNvbnN0IENBTkNFTExFRCA9IG5ldyBFcnJvcignQ2FuY2VsbGVkJyk7XHJcbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpIHtcclxuICAgIGlmIChpc0NhbmNlbGxlZCgpKSB7XHJcbiAgICAgICAgdGhyb3cgQ0FOQ0VMTEVEO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IEhFQVJUQkVBVF9JTlRFUlZBTCA9IDMwMDAwO1xyXG5jb25zdCBIRUFSVEJFQVRfV0FJVF9USU1FID0gMTAwMDA7XHJcbmNvbnN0IEJBQ0tGSUxMX1RJTUVPVVQgPSA2MDAwMDtcclxuY29uc3QgQkFDS0ZJTExfUkVUUklFUyA9IDU7XHJcbi8qKlxyXG4gKiBTdWJzY3JpcHRpb25zIGhhdmUgYSBtZW1vcnkgb2YgcmVjZW50IGV2ZW50cyB0aGV5IGhhdmUgc2VudCBzbyB0aGF0IGluIHRoZVxyXG4gKiBldmVudCB0aGF0IHRoZXkgZGlzY29ubmVjdCBhbmQgbmVlZCB0byBiYWNrZmlsbCwgdGhleSBjYW4gZGV0ZWN0IHJlLW9yZ3MuXHJcbiAqIEtlZXAgYSBidWZmZXIgdGhhdCBnb2VzIGJhY2sgYXQgbGVhc3QgdGhlc2UgbWFueSBibG9ja3MsIHRoZSBtYXhpbXVtIGFtb3VudFxyXG4gKiBhdCB3aGljaCB3ZSBtaWdodCBjb25jZWl2YWJseSBzZWUgYSByZS1vcmcuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB3aGlsZSBvdXIgYnVmZmVyIGdvZXMgYmFjayB0aGlzIG1hbnkgYmxvY2tzLCBpdCBtYXkgY29udGFpbiBtb3JlXHJcbiAqIHRoYW4gdGhpcyBtYW55IGVsZW1lbnRzLCBzaW5jZSBpbiB0aGUgY2FzZSBvZiBsb2dzIHN1YnNjcmlwdGlvbnMgbW9yZSB0aGFuXHJcbiAqIG9uZSBldmVudCBtYXkgYmUgZW1pdHRlZCBmb3IgYSBibG9jay5cclxuICovXHJcbmNvbnN0IFJFVEFJTkVEX0VWRU5UX0JMT0NLX0NPVU5UID0gMTA7XHJcbi8qKlxyXG4gKiBTREsncyBjdXN0b20gaW1wbGVtZW50YXRpb24gZm8gdGhlIGV0aGVycy5qcydzICdBbGNoZW15V2ViU29ja2V0UHJvdmlkZXInLlxyXG4gKlxyXG4gKiBEbyBub3QgY2FsbCB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LiBJbnN0ZWFkLCBpbnN0YW50aWF0ZSBhbiBpbnN0YW5jZSBvZlxyXG4gKiB7QGxpbmsgQWxjaGVteX0gYW5kIGNhbGwge0BsaW5rIEFsY2hlbXkuY29uZmlnLmdldFdlYlNvY2tldFByb3ZpZGVyKCl9LlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIgZXh0ZW5kcyBXZWJTb2NrZXRQcm92aWRlciB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHdzQ29uc3RydWN0b3IpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBBUEkgS2V5IHRvIGEgc3RyaW5nLlxyXG4gICAgICAgIGNvbnN0IGFwaUtleSA9IEFsY2hlbXlQcm92aWRlci5nZXRBcGlLZXkoY29uZmlnLmFwaUtleSk7XHJcbiAgICAgICAgLy8gR2VuZXJhdGUgb3VyIG93biBjb25uZWN0aW9uIGluZm8gd2l0aCB0aGUgY29ycmVjdCBlbmRwb2ludCBVUkxzLlxyXG4gICAgICAgIGNvbnN0IGFsY2hlbXlOZXR3b3JrID0gQWxjaGVteVByb3ZpZGVyLmdldEFsY2hlbXlOZXR3b3JrKGNvbmZpZy5uZXR3b3JrKTtcclxuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gQWxjaGVteVByb3ZpZGVyLmdldEFsY2hlbXlDb25uZWN0aW9uSW5mbyhhbGNoZW15TmV0d29yaywgYXBpS2V5LCAnd3NzJyk7XHJcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSBgYWxjaGVteS1zZGstJHtWRVJTSU9OfWA7XHJcbiAgICAgICAgLy8gVXNlIHRoZSBwcm92aWRlZCBjb25maWcgVVJMIG92ZXJyaWRlIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIHVzZSB0aGUgY3JlYXRlZCBvbmUuXHJcbiAgICAgICAgY29uc3Qgd3MgPSBuZXcgU3R1cmR5V2ViU29ja2V0KChfYSA9IGNvbmZpZy51cmwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbm5lY3Rpb24udXJsLCBwcm90b2NvbCwge1xyXG4gICAgICAgICAgICB3c0NvbnN0cnVjdG9yOiB3c0NvbnN0cnVjdG9yICE9PSBudWxsICYmIHdzQ29uc3RydWN0b3IgIT09IHZvaWQgMCA/IHdzQ29uc3RydWN0b3IgOiBnZXRXZWJzb2NrZXRDb25zdHJ1Y3RvcigpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBBbGNoZW15IG5hbWVkIG5ldHdvcmsgaW5wdXQgdG8gdGhlIG5ldHdvcmsgbmFtZXMgdXNlZCBieVxyXG4gICAgICAgIC8vIGV0aGVycy4gVGhpcyBhbGxvd3MgdGhlIHBhcmVudCBzdXBlciBjb25zdHJ1Y3RvciBpbiBKc29uUnBjUHJvdmlkZXIgdG9cclxuICAgICAgICAvLyBjb3JyZWN0bHkgc2V0IHRoZSBuZXR3b3JrLlxyXG4gICAgICAgIGNvbnN0IGV0aGVyc05ldHdvcmsgPSBFdGhlcnNOZXR3b3JrW2FsY2hlbXlOZXR3b3JrXTtcclxuICAgICAgICBzdXBlcih3cywgZXRoZXJzTmV0d29yayk7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gW107XHJcbiAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYSBXZWJTb2NrZXQgcmVjb25uZWN0aW9uLCBhbGwgc3Vic2NyaXB0aW9ucyBhcmUgbG9zdCBhbmQgd2VcclxuICAgICAgICAvLyBjcmVhdGUgbmV3IG9uZXMgdG8gcmVwbGFjZSB0aGVtLCBidXQgd2Ugd2FudCB0byBjcmVhdGUgdGhlIGlsbHVzaW9uIHRoYXRcclxuICAgICAgICAvLyB0aGUgb3JpZ2luYWwgc3Vic2NyaXB0aW9ucyBwZXJzaXN0LiBUaHVzLCBtYWludGFpbiBhIG1hcHBpbmcgZnJvbSB0aGVcclxuICAgICAgICAvLyBcInZpcnR1YWxcIiBzdWJzY3JpcHRpb24gaWRzIHdoaWNoIGFyZSB2aXNpYmxlIHRvIHRoZSBjb25zdW1lciB0byB0aGVcclxuICAgICAgICAvLyBcInBoeXNpY2FsXCIgc3Vic2NyaXB0aW9uIGlkcyBvZiB0aGUgYWN0dWFsIGNvbm5lY3Rpb25zLiBUaGlzIHRlcm1pbm9sb2d5IGlzXHJcbiAgICAgICAgLy8gYm9ycm93ZWQgZnJvbSB2aXJ0dWFsIGFuZCBwaHlzaWNhbCBtZW1vcnksIHdoaWNoIGhhcyBhIHNpbWlsYXIgbWFwcGluZy5cclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy52aXJ0dWFsU3Vic2NyaXB0aW9uc0J5SWQgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMudmlydHVhbElkc0J5UGh5c2ljYWxJZCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdW5kZXJseWluZyBldGhlcnMge0BsaW5rIFdlYlNvY2tldFByb3ZpZGVyfSBhbHJlYWR5IGhhbmRsZXMgYW5kIGVtaXRzXHJcbiAgICAgICAgICogbWVzc2FnZXMuIFRvIGFsbG93IGJhY2tmaWxsaW5nLCB0cmFjayBhbGwgbWVzc2FnZXMgdGhhdCBhcmUgZW1pdHRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgaXMgYSBmaWVsZCBhcnJvdyBmdW5jdGlvbiBpbiBvcmRlciB0byBwcmVzZXJ2ZSBgdGhpc2AgY29udGV4dCB3aGVuXHJcbiAgICAgICAgICogcGFzc2luZyB0aGUgbWV0aG9kIGFzIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5oYW5kbGVNZXNzYWdlID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xyXG4gICAgICAgICAgICBpZiAoIWlzU3Vic2NyaXB0aW9uRXZlbnQobWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBwaHlzaWNhbElkID0gbWVzc2FnZS5wYXJhbXMuc3Vic2NyaXB0aW9uO1xyXG4gICAgICAgICAgICBjb25zdCB2aXJ0dWFsSWQgPSB0aGlzLnZpcnR1YWxJZHNCeVBoeXNpY2FsSWQuZ2V0KHBoeXNpY2FsSWQpO1xyXG4gICAgICAgICAgICBpZiAoIXZpcnR1YWxJZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMudmlydHVhbFN1YnNjcmlwdGlvbnNCeUlkLmdldCh2aXJ0dWFsSWQpO1xyXG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLm1ldGhvZCAhPT0gJ2V0aF9zdWJzY3JpYmUnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3dpdGNoIChzdWJzY3JpcHRpb24ucGFyYW1zWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICduZXdIZWFkcyc6IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdIZWFkc1N1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdIZWFkc01lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNCYWNrZmlsbGluZywgYmFja2ZpbGxCdWZmZXIgfSA9IG5ld0hlYWRzU3Vic2NyaXB0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSBuZXdIZWFkc01lc3NhZ2UucGFyYW1zO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0JhY2tmaWxsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFRvTmV3SGVhZHNFdmVudHNCdWZmZXIoYmFja2ZpbGxCdWZmZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBoeXNpY2FsSWQgIT09IHZpcnR1YWxJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhIHJlLW9wZW5lZCBzdWJzY3JpcHRpb24sIGV0aGVycyB3aWxsIG5vdCBlbWl0IHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBldmVudCwgc28gdGhlIFNESyBoYXMgdG8uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdEFuZFJlbWVtYmVyRXZlbnQodmlydHVhbElkLCByZXN1bHQsIGdldE5ld0hlYWRzQmxvY2tOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXRoZXJzIHN1YnNjcmlwdGlvbiBtYXBwaW5nIHdpbGwgZW1pdCB0aGUgZXZlbnQsIGp1c3Qgc3RvcmUgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtZW1iZXJFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCwgZ2V0TmV3SGVhZHNCbG9ja051bWJlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSAnbG9ncyc6IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dzU3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ3NNZXNzYWdlID0gbWVzc2FnZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGlzQmFja2ZpbGxpbmcsIGJhY2tmaWxsQnVmZmVyIH0gPSBsb2dzU3Vic2NyaXB0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSBsb2dzTWVzc2FnZS5wYXJhbXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQmFja2ZpbGxpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkVG9Mb2dzRXZlbnRzQnVmZmVyKGJhY2tmaWxsQnVmZmVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2aXJ0dWFsSWQgIT09IHBoeXNpY2FsSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0QW5kUmVtZW1iZXJFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCwgZ2V0TG9nc0Jsb2NrTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtZW1iZXJFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCwgZ2V0TG9nc0Jsb2NrTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwaHlzaWNhbElkICE9PSB2aXJ0dWFsSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYSByZS1vcGVuZWQgc3Vic2NyaXB0aW9uLCBldGhlcnMgd2lsbCBub3QgZW1pdCB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXZlbnQsIHNvIHRoZSBTREsgaGFzIHRvLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlc3VsdCB9ID0gbWVzc2FnZS5wYXJhbXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZW4gdGhlIHdlYnNvY2tldCBjb25uZWN0aW9uIHJlb3BlbnM6XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAxLiBSZXN1YnNjcmliZSB0byBhbGwgZXhpc3Rpbmcgc3Vic2NyaXB0aW9ucyBhbmQgc3RhcnQgYmFja2ZpbGxpbmdcclxuICAgICAgICAgKiAyLiBSZXN0YXJ0IGhlYXJ0IGJlYXQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGlzIGlzIGEgZmllbGQgYXJyb3cgZnVuY3Rpb24gaW4gb3JkZXIgdG8gcHJlc2VydmUgYHRoaXNgIGNvbnRleHQgd2hlblxyXG4gICAgICAgICAqIHBhc3NpbmcgdGhlIG1ldGhvZCBhcyBhbiBldmVudCBsaXN0ZW5lci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaGFuZGxlUmVvcGVuID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxJZHNCeVBoeXNpY2FsSWQuY2xlYXIoKTtcclxuICAgICAgICAgICAgY29uc3QgeyBjYW5jZWwsIGlzQ2FuY2VsbGVkIH0gPSBtYWtlQ2FuY2VsVG9rZW4oKTtcclxuICAgICAgICAgICAgdGhpcy5jYW5jZWxCYWNrZmlsbCA9IGNhbmNlbDtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBzdWJzY3JpcHRpb24gb2YgdGhpcy52aXJ0dWFsU3Vic2NyaXB0aW9uc0J5SWQudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgICAgIHZvaWQgKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnJlc3Vic2NyaWJlQW5kQmFja2ZpbGwoaXNDYW5jZWxsZWQsIHN1YnNjcmlwdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ2FuY2VsbGVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHdoaWxlIGJhY2tmaWxsaW5nIFwiJHtzdWJzY3JpcHRpb24ucGFyYW1zWzBdfVwiIHN1YnNjcmlwdGlvbi4gU29tZSBldmVudHMgbWF5IGJlIG1pc3NpbmcuYCwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkpKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGFydEhlYXJ0YmVhdCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FuY2VscyB0aGUgaGVhcnRiZWF0IGFuZCBhbnkgcGVuZGluZyBiYWNrZmlsbHMgYmVpbmcgcGVyZm9ybWVkLiBUaGlzIGlzXHJcbiAgICAgICAgICogY2FsbGVkIHdoZW4gdGhlIHdlYnNvY2tldCBjb25uZWN0aW9uIGdvZXMgZG93biBvciBpcyBkaXNjb25uZWN0ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGlzIGlzIGEgZmllbGQgYXJyb3cgZnVuY3Rpb24gaW4gb3JkZXIgdG8gcHJlc2VydmUgYHRoaXNgIGNvbnRleHQgd2hlblxyXG4gICAgICAgICAqIHBhc3NpbmcgdGhlIG1ldGhvZCBhcyBhbiBldmVudCBsaXN0ZW5lci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3RvcEhlYXJ0YmVhdEFuZEJhY2tmaWxsID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5oZWFydGJlYXRJbnRlcnZhbElkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5oZWFydGJlYXRJbnRlcnZhbElkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxJZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNhbmNlbEJhY2tmaWxsKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcclxuICAgICAgICAvLyBTdGFydCBoZWFydGJlYXQgYW5kIGJhY2tmaWxsZXIgZm9yIHRoZSB3ZWJzb2NrZXQgY29ubmVjdGlvbi5cclxuICAgICAgICB0aGlzLmJhY2tmaWxsZXIgPSBuZXcgV2Vic29ja2V0QmFja2ZpbGxlcih0aGlzKTtcclxuICAgICAgICB0aGlzLmFkZFNvY2tldExpc3RlbmVycygpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRIZWFydGJlYXQoKTtcclxuICAgICAgICB0aGlzLmNhbmNlbEJhY2tmaWxsID0gbm9vcDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBgQmFzZVByb3ZpZGVyLmdldE5ldHdvcmtgIG1ldGhvZCBhcyBpbXBsZW1lbnRlZCBieSBldGhlcnMuanMuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBvdmVycmlkZSBhbGxvd3MgdGhlIFNESyB0byBzZXQgdGhlIHByb3ZpZGVyJ3MgbmV0d29yayB0byB2YWx1ZXMgbm90XHJcbiAgICAgKiB5ZXQgc3VwcG9ydGVkIGJ5IGV0aGVycy5qcy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0TmV0d29yayhuZXR3b3JrKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXR3b3JrID09PSAnc3RyaW5nJyAmJiBuZXR3b3JrIGluIEN1c3RvbU5ldHdvcmtzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDdXN0b21OZXR3b3Jrc1tuZXR3b3JrXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2FsbCB0aGUgc3RhbmRhcmQgZXRoZXJzLmpzIGdldE5ldHdvcmsgbWV0aG9kIGZvciBvdGhlciBuZXR3b3Jrcy5cclxuICAgICAgICByZXR1cm4gZ2V0TmV0d29yayhuZXR3b3JrKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGRlbiBpbXBsZW1lbnRhdGlvbiBvZiBldGhlcnMgdGhhdCBpbmNsdWRlcyBBbGNoZW15IGJhc2VkIHN1YnNjcmlwdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBFdmVudCB0byBzdWJzY3JpYmUgdG9cclxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgLy8gVE9ETzogT3ZlcnJpZGUgYExpc3RlbmVyYCB0eXBlIHRvIGdldCB0eXBlIGF1dG9jb21wbGV0aW9ucy5cclxuICAgIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRkZW4gaW1wbGVtZW50YXRpb24gb2YgZXRoZXJzIHRoYXQgaW5jbHVkZXMgQWxjaGVteSBiYXNlZFxyXG4gICAgICogc3Vic2NyaXB0aW9ucy4gQWRkcyBhIGxpc3RlbmVyIHRvIHRoZSB0cmlnZ2VyZWQgZm9yIG9ubHkgdGhlIG5leHRcclxuICAgICAqIHtAbGluayBldmVudE5hbWV9IGV2ZW50LCBhZnRlciB3aGljaCBpdCB3aWxsIGJlIHJlbW92ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBFdmVudCB0byBzdWJzY3JpYmUgdG9cclxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgLy8gVE9ETzogT3ZlcnJpZGUgYExpc3RlbmVyYCB0eXBlIHRvIGdldCB0eXBlIGF1dG9jb21wbGV0aW9ucy5cclxuICAgIG9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBwcm92aWRlZCB7QGxpbmsgbGlzdGVuZXJ9IGZvciB0aGUge0BsaW5rIGV2ZW50TmFtZX0gZXZlbnQuIElmIG5vXHJcbiAgICAgKiBsaXN0ZW5lciBpcyBwcm92aWRlZCwgYWxsIGxpc3RlbmVycyBmb3IgdGhlIGV2ZW50IHdpbGwgYmUgcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIEV2ZW50IHRvIHVubGlzdGVuIHRvLlxyXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byByZW1vdmUuXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICBpZiAoaXNBbGNoZW15RXZlbnQoZXZlbnROYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLm9mZihldmVudE5hbWUsIGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciB0aGUgcHJvdmlkZWQge0BsaW5rIGV2ZW50TmFtZX0gZXZlbnQuIElmIG5vIGV2ZW50XHJcbiAgICAgKiBpcyBwcm92aWRlZCwgYWxsIGV2ZW50cyBhbmQgdGhlaXIgbGlzdGVuZXJzIGFyZSByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIGV2ZW50IHRvIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvci5cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgaWYgKGV2ZW50TmFtZSAhPT0gdW5kZWZpbmVkICYmIGlzQWxjaGVteUV2ZW50KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBmb3IgdGhlIHByb3ZpZGVkIHtAbGluayBldmVudE5hbWV9IGV2ZW50LiBJZlxyXG4gICAgICogbm8gZXZlbnQgaXMgcHJvdmlkZWQsIHRoZSB0b3RhbCBudW1iZXIgb2YgbGlzdGVuZXJzIGZvciBhbGwgZXZlbnRzIGlzIHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIGV2ZW50IHRvIGdldCB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBmb3IuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgbGlzdGVuZXJDb3VudChldmVudE5hbWUpIHtcclxuICAgICAgICBpZiAoZXZlbnROYW1lICE9PSB1bmRlZmluZWQgJiYgaXNBbGNoZW15RXZlbnQoZXZlbnROYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXJDb3VudChldmVudE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmxpc3RlbmVyQ291bnQoZXZlbnROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIGZvciB0aGUgcHJvdmlkZWQge0BsaW5rIGV2ZW50TmFtZX0gZXZlbnQuIElmXHJcbiAgICAgKiBubyBldmVudCBpcyBwcm92aWRlZCwgYWxsIGxpc3RlbmVycyB3aWxsIGJlIGluY2x1ZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIGV2ZW50IHRvIGdldCB0aGUgbGlzdGVuZXJzIGZvci5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBsaXN0ZW5lcnMoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgaWYgKGV2ZW50TmFtZSAhPT0gdW5kZWZpbmVkICYmIGlzQWxjaGVteUV2ZW50KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3RlbmVycyhldmVudE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmxpc3RlbmVycyhldmVudE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBtZXRob2QgaW4gYEJhc2VQcm92aWRlcmAgaW4gb3JkZXIgdG8gcHJvcGVybHkgZm9ybWF0IHRoZVxyXG4gICAgICogQWxjaGVteSBzdWJzY3JpcHRpb24gZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIF9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9uY2UpIHtcclxuICAgICAgICBpZiAoaXNBbGNoZW15RXZlbnQoZXZlbnROYW1lKSkge1xyXG4gICAgICAgICAgICB2ZXJpZnlBbGNoZW15RXZlbnROYW1lKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV0aGVyc0V2ZW50KGdldEFsY2hlbXlFdmVudFRhZyhldmVudE5hbWUpLCBsaXN0ZW5lciwgb25jZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKGV2ZW50KTtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRFdmVudChldmVudCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLl9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9uY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBgX3N0YXJ0RXZlbnQoKWAgbWV0aG9kIGluIGV0aGVycy5qcydzXHJcbiAgICAgKiB7QGxpbmsgV2ViU29ja2V0UHJvdmlkZXJ9IHRvIGluY2x1ZGUgYWRkaXRpb25hbCBhbGNoZW15IG1ldGhvZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50XHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfc3RhcnRFdmVudChldmVudCkge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBldmVudCB0eXBlIGlzIGEgY3VzdG9tIEFsY2hlbXkgc3Vic2NyaXB0aW9uLlxyXG4gICAgICAgIGNvbnN0IGN1c3RvbUxvZ2ljVHlwZXMgPSBbLi4uQUxDSEVNWV9FVkVOVF9UWVBFUywgJ2Jsb2NrJywgJ2ZpbHRlciddO1xyXG4gICAgICAgIGlmIChjdXN0b21Mb2dpY1R5cGVzLmluY2x1ZGVzKGV2ZW50LnR5cGUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RhcnRFdmVudChldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdXBlci5fc3RhcnRFdmVudChldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZGVuIGZyb20gZXRoZXJzLmpzJ3Mge0BsaW5rIFdlYlNvY2tldFByb3ZpZGVyfVxyXG4gICAgICpcclxuICAgICAqIE1vZGlmaWVkIGluIG9yZGVyIHRvIGFkZCBtYXBwaW5ncyBmb3IgYmFja2ZpbGxpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgX3N1YnNjcmliZSh0YWcsIHBhcmFtLCBwcm9jZXNzRnVuYywgZXZlbnQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBsZXQgc3ViSWRQcm9taXNlID0gdGhpcy5fc3ViSWRzW3RhZ107XHJcbiAgICAgICAgICAgIC8vIEJFR0lOIE1PRElGSUVEIENPREVcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnRpbmdCbG9ja051bWJlciA9IHlpZWxkIHRoaXMuZ2V0QmxvY2tOdW1iZXIoKTtcclxuICAgICAgICAgICAgLy8gRU5EIE1PRElGSUVEIENPREVcclxuICAgICAgICAgICAgaWYgKHN1YklkUHJvbWlzZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzdWJJZFByb21pc2UgPSBQcm9taXNlLmFsbChwYXJhbSkudGhlbihwYXJhbSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCgnZXRoX3N1YnNjcmliZScsIHBhcmFtKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3ViSWRzW3RhZ10gPSBzdWJJZFByb21pc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc3ViSWQgPSB5aWVsZCBzdWJJZFByb21pc2U7XHJcbiAgICAgICAgICAgIC8vIEJFR0lOIE1PRElGSUVEIENPREVcclxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXJhbXMgPSB5aWVsZCBQcm9taXNlLmFsbChwYXJhbSk7XHJcbiAgICAgICAgICAgIHRoaXMudmlydHVhbFN1YnNjcmlwdGlvbnNCeUlkLnNldChzdWJJZCwge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX3N1YnNjcmliZScsXHJcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHJlc29sdmVkUGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRpbmdCbG9ja051bWJlcixcclxuICAgICAgICAgICAgICAgIHZpcnR1YWxJZDogc3ViSWQsXHJcbiAgICAgICAgICAgICAgICBwaHlzaWNhbElkOiBzdWJJZCxcclxuICAgICAgICAgICAgICAgIHNlbnRFdmVudHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgaXNCYWNrZmlsbGluZzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBiYWNrZmlsbEJ1ZmZlcjogW11cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMudmlydHVhbElkc0J5UGh5c2ljYWxJZC5zZXQoc3ViSWQsIHN1YklkKTtcclxuICAgICAgICAgICAgLy8gRU5EIE1PRElGSUVEIENPREVcclxuICAgICAgICAgICAgdGhpcy5fc3Vic1tzdWJJZF0gPSB7IHRhZywgcHJvY2Vzc0Z1bmMgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRE8gTk9UIE1PRElGWS5cclxuICAgICAqXHJcbiAgICAgKiBPcmlnaW5hbCBjb2RlIGNvcGllZCBvdmVyIGZyb20gZXRoZXIuanMncyBgQmFzZVByb3ZpZGVyYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjb3BpZWQgb3ZlciBkaXJlY3RseSBpbiBvcmRlciB0byBpbXBsZW1lbnQgQWxjaGVteSdzIHVuaXF1ZVxyXG4gICAgICogc3Vic2NyaXB0aW9uIHR5cGVzLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhpcyBtZXRob2QgY2FsbHNcclxuICAgICAqIHtAbGluayBnZXRBbGNoZW15RXZlbnRUYWd9IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGBnZXRFdmVudFRhZygpYCBtZXRob2QgaW5cclxuICAgICAqIG9yZGVyIHRvIHBhcnNlIHRoZSBBbGNoZW15IHN1YnNjcmlwdGlvbiBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBlbWl0KGV2ZW50TmFtZSwgLi4uYXJncykge1xyXG4gICAgICAgIGlmIChpc0FsY2hlbXlFdmVudChldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3Qgc3RvcHBlZCA9IFtdO1xyXG4gICAgICAgICAgICAvLyBUaGlzIGxpbmUgaXMgdGhlIG9ubHkgbW9kaWZpZWQgbGluZSBmcm9tIHRoZSBvcmlnaW5hbCBtZXRob2QuXHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50VGFnID0gZ2V0QWxjaGVteUV2ZW50VGFnKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhZyAhPT0gZXZlbnRUYWcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Lmxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50Lm9uY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc3RvcHBlZC5mb3JFYWNoKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BFdmVudChldmVudCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXZlbnROYW1lLCAuLi5hcmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBzZW5kQmF0Y2gocGFydHMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBsZXQgbmV4dElkID0gMDtcclxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHBhcnRzLm1hcCgoeyBtZXRob2QsIHBhcmFtcyB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMsXHJcbiAgICAgICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGBhbGNoZW15LXNkazoke25leHRJZCsrfWBcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kQmF0Y2hDb25jdXJyZW50bHkocGF5bG9hZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKiogQG92ZXJyaWRlICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlU29ja2V0TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgdGhpcy5zdG9wSGVhcnRiZWF0QW5kQmFja2ZpbGwoKTtcclxuICAgICAgICByZXR1cm4gc3VwZXIuZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGV0aGVyJ3MgYGlzQ29tbXVuaXR5UmVzb3VyY2UoKWAgbWV0aG9kLiBSZXR1cm5zIHRydWUgaWYgdGhlXHJcbiAgICAgKiBjdXJyZW50IGFwaSBrZXkgaXMgdGhlIGRlZmF1bHQga2V5LlxyXG4gICAgICpcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwaUtleSA9PT0gREVGQVVMVF9BTENIRU1ZX0FQSV9LRVk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERPIE5PVCBNT0RJRlkuXHJcbiAgICAgKlxyXG4gICAgICogT3JpZ2luYWwgY29kZSBjb3BpZWQgb3ZlciBmcm9tIGV0aGVyLmpzJ3MgYFdlYlNvY2tldFByb3ZpZGVyLl9zdG9wRXZlbnQoKWAuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY29waWVkIG92ZXIgZGlyZWN0bHkgaW4gb3JkZXIgdG8gc3VwcG9ydCBBbGNoZW15J3NcclxuICAgICAqIHN1YnNjcmlwdGlvbiB0eXBlIGJ5IGFsbG93aW5nIHRoZSBwcm92aWRlciB0byBwcm9wZXJseSBzdG9wIEFsY2hlbXknc1xyXG4gICAgICogc3Vic2NyaXB0aW9uIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3N0b3BFdmVudChldmVudCkge1xyXG4gICAgICAgIGxldCB0YWcgPSBldmVudC50YWc7XHJcbiAgICAgICAgLy8gU1RBUlQgTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgIGlmIChBTENIRU1ZX0VWRU5UX1RZUEVTLmluY2x1ZGVzKGV2ZW50LnR5cGUpKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSByZW1haW5pbmcgcGVuZGluZyB0cmFuc2FjdGlvbiBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudHMuZmlsdGVyKGUgPT4gQUxDSEVNWV9FVkVOVF9UWVBFUy5pbmNsdWRlcyhlLnR5cGUpKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBFTkQgTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChldmVudC50eXBlID09PSAndHgnKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSByZW1haW5pbmcgdHJhbnNhY3Rpb24gZXZlbnQgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudHMuZmlsdGVyKGUgPT4gZS50eXBlID09PSAndHgnKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0YWcgPSAndHgnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoZXZlbnQuZXZlbnQpKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSByZW1haW5pbmcgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3ViSWQgPSB0aGlzLl9zdWJJZHNbdGFnXTtcclxuICAgICAgICBpZiAoIXN1YklkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX3N1Yklkc1t0YWddO1xyXG4gICAgICAgIHZvaWQgc3ViSWQudGhlbihzdWJJZCA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3Vic1tzdWJJZF0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc3Vic1tzdWJJZF07XHJcbiAgICAgICAgICAgIHZvaWQgdGhpcy5zZW5kKCdldGhfdW5zdWJzY3JpYmUnLCBbc3ViSWRdKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGFkZFNvY2tldExpc3RlbmVycygpIHtcclxuICAgICAgICB0aGlzLl93ZWJzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuaGFuZGxlTWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlb3BlbicsIHRoaXMuaGFuZGxlUmVvcGVuKTtcclxuICAgICAgICB0aGlzLl93ZWJzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZG93bicsIHRoaXMuc3RvcEhlYXJ0YmVhdEFuZEJhY2tmaWxsKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHJlbW92ZVNvY2tldExpc3RlbmVycygpIHtcclxuICAgICAgICB0aGlzLl93ZWJzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuaGFuZGxlTWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlb3BlbicsIHRoaXMuaGFuZGxlUmVvcGVuKTtcclxuICAgICAgICB0aGlzLl93ZWJzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZG93bicsIHRoaXMuc3RvcEhlYXJ0YmVhdEFuZEJhY2tmaWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVvcGVucyB0aGUgYmFja2ZpbGwgYmFzZWQgb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaXNDYW5jZWxsZWRcclxuICAgICAqIEBwYXJhbSBzdWJzY3JpcHRpb25cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICByZXN1YnNjcmliZUFuZEJhY2tmaWxsKGlzQ2FuY2VsbGVkLCBzdWJzY3JpcHRpb24pIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHZpcnR1YWxJZCwgbWV0aG9kLCBwYXJhbXMsIHNlbnRFdmVudHMsIGJhY2tmaWxsQnVmZmVyLCBzdGFydGluZ0Jsb2NrTnVtYmVyIH0gPSBzdWJzY3JpcHRpb247XHJcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5pc0JhY2tmaWxsaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgYmFja2ZpbGxCdWZmZXIubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBoeXNpY2FsSWQgPSB5aWVsZCB0aGlzLnNlbmQobWV0aG9kLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24ucGh5c2ljYWxJZCA9IHBoeXNpY2FsSWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpcnR1YWxJZHNCeVBoeXNpY2FsSWQuc2V0KHBoeXNpY2FsSWQsIHZpcnR1YWxJZCk7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhcmFtc1swXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ25ld0hlYWRzJzoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWNrZmlsbEV2ZW50cyA9IHlpZWxkIHdpdGhCYWNrb2ZmUmV0cmllcygoKSA9PiB3aXRoVGltZW91dCh0aGlzLmJhY2tmaWxsZXIuZ2V0TmV3SGVhZHNCYWNrZmlsbChpc0NhbmNlbGxlZCwgc2VudEV2ZW50cywgc3RhcnRpbmdCbG9ja051bWJlciksIEJBQ0tGSUxMX1RJTUVPVVQpLCBCQUNLRklMTF9SRVRSSUVTLCAoKSA9PiAhaXNDYW5jZWxsZWQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudHMgPSBkZWR1cGVOZXdIZWFkcyhbLi4uYmFja2ZpbGxFdmVudHMsIC4uLmJhY2tmaWxsQnVmZmVyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHRoaXMuZW1pdE5ld0hlYWRzRXZlbnQodmlydHVhbElkLCBldmVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbG9ncyc6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyID0gcGFyYW1zWzFdIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWNrZmlsbEV2ZW50cyA9IHlpZWxkIHdpdGhCYWNrb2ZmUmV0cmllcygoKSA9PiB3aXRoVGltZW91dCh0aGlzLmJhY2tmaWxsZXIuZ2V0TG9nc0JhY2tmaWxsKGlzQ2FuY2VsbGVkLCBmaWx0ZXIsIHNlbnRFdmVudHMsIHN0YXJ0aW5nQmxvY2tOdW1iZXIpLCBCQUNLRklMTF9USU1FT1VUKSwgQkFDS0ZJTExfUkVUUklFUywgKCkgPT4gIWlzQ2FuY2VsbGVkKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gZGVkdXBlTG9ncyhbLi4uYmFja2ZpbGxFdmVudHMsIC4uLmJhY2tmaWxsQnVmZmVyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHRoaXMuZW1pdExvZ3NFdmVudCh2aXJ0dWFsSWQsIGV2ZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5pc0JhY2tmaWxsaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBiYWNrZmlsbEJ1ZmZlci5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBlbWl0TmV3SGVhZHNFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCkge1xyXG4gICAgICAgIHRoaXMuZW1pdEFuZFJlbWVtYmVyRXZlbnQodmlydHVhbElkLCByZXN1bHQsIGdldE5ld0hlYWRzQmxvY2tOdW1iZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgZW1pdExvZ3NFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCkge1xyXG4gICAgICAgIHRoaXMuZW1pdEFuZFJlbWVtYmVyRXZlbnQodmlydHVhbElkLCByZXN1bHQsIGdldExvZ3NCbG9ja051bWJlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVtaXRzIGFuIGV2ZW50IHRvIGNvbnN1bWVycywgYnV0IGFsc28gcmVtZW1iZXJzIGl0IGluIGl0cyBzdWJzY3JpcHRpb25zJ3NcclxuICAgICAqIGBzZW50RXZlbnRzYCBidWZmZXIgc28gdGhhdCB3ZSBjYW4gZGV0ZWN0IHJlLW9yZ3MgaWYgdGhlIGNvbm5lY3Rpb24gZHJvcHNcclxuICAgICAqIGFuZCBuZWVkcyB0byBiZSByZWNvbm5lY3RlZC5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgZW1pdEFuZFJlbWVtYmVyRXZlbnQodmlydHVhbElkLCByZXN1bHQsIGdldEJsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5yZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXRCbG9ja051bWJlcik7XHJcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQodmlydHVhbElkLCByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgZW1pdEV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0KSB7XHJcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy52aXJ0dWFsU3Vic2NyaXB0aW9uc0J5SWQuZ2V0KHZpcnR1YWxJZCk7XHJcbiAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVtaXRHZW5lcmljRXZlbnQoc3Vic2NyaXB0aW9uLCByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcmVtZW1iZXJFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCwgZ2V0QmxvY2tOdW1iZXIpIHtcclxuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLnZpcnR1YWxTdWJzY3JpcHRpb25zQnlJZC5nZXQodmlydHVhbElkKTtcclxuICAgICAgICBpZiAoIXN1YnNjcmlwdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlYjMgbW9kaWZpZXMgdGhlc2UgZXZlbnQgb2JqZWN0cyBvbmNlIHdlIHBhc3MgdGhlbSBvbiAoY2hhbmdpbmcgaGV4XHJcbiAgICAgICAgLy8gbnVtYmVycyB0byBudW1iZXJzKS4gV2Ugd2FudCB0aGUgb3JpZ2luYWwgZXZlbnQsIHNvIG1ha2UgYSBkZWZlbnNpdmVcclxuICAgICAgICAvLyBjb3B5LlxyXG4gICAgICAgIGFkZFRvUGFzdEV2ZW50c0J1ZmZlcihzdWJzY3JpcHRpb24uc2VudEV2ZW50cywgT2JqZWN0LmFzc2lnbih7fSwgcmVzdWx0KSwgZ2V0QmxvY2tOdW1iZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgZW1pdEdlbmVyaWNFdmVudChzdWJzY3JpcHRpb24sIHJlc3VsdCkge1xyXG4gICAgICAgIGNvbnN0IGVtaXRGdW5jdGlvbiA9IHRoaXMuZW1pdFByb2Nlc3NGbihzdWJzY3JpcHRpb24uZXZlbnQpO1xyXG4gICAgICAgIGVtaXRGdW5jdGlvbihyZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgYSBoZWFydGJlYXQgdGhhdCBwaW5ncyB0aGUgd2Vic29ja2V0IHNlcnZlciBwZXJpb2RpY2FsbHkgdG8gZW5zdXJlXHJcbiAgICAgKiB0aGF0IHRoZSBjb25uZWN0aW9uIHN0YXlzIG9wZW4uXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHN0YXJ0SGVhcnRiZWF0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmhlYXJ0YmVhdEludGVydmFsSWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHdpdGhUaW1lb3V0KHRoaXMuc2VuZCgnbmV0X3ZlcnNpb24nKSwgSEVBUlRCRUFUX1dBSVRfVElNRSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWJzb2NrZXQucmVjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSwgSEVBUlRCRUFUX0lOVEVSVkFMKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgc2VuZHMgdGhlIGJhdGNoIGNvbmN1cnJlbnRseSBhcyBpbmRpdmlkdWFsIHJlcXVlc3RzIHJhdGhlciB0aGFuXHJcbiAgICAgKiBhcyBhIGJhdGNoLCB3aGljaCB3YXMgdGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uLiBUaGUgb3JpZ2luYWwgYmF0Y2ggbG9naWNcclxuICAgICAqIGlzIHByZXNlcnZlZCBpbiB0aGlzIGltcGxlbWVudGF0aW9uIGluIG9yZGVyIGZvciBmYXN0ZXIgcG9ydGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF5bG9hZFxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIC8vIFRPRE8oY2xlYW51cCk6IFJlZmFjdG9yIGFuZCByZW1vdmUgdXNhZ2VzIG9mIGBzZW5kQmF0Y2goKWAuXHJcbiAgICAvLyBUT0RPKGVycm9ycyk6IFVzZSBhbGxTZXR0bGVkKCkgb25jZSB3ZSBoYXZlIG1vcmUgZXJyb3IgaGFuZGxpbmcuXHJcbiAgICBzZW5kQmF0Y2hDb25jdXJyZW50bHkocGF5bG9hZCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwYXlsb2FkLm1hcChyZXEgPT4gdGhpcy5zZW5kKHJlcS5tZXRob2QsIHJlcS5wYXJhbXMpKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBjdXN0b21TdGFydEV2ZW50KGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IEFMQ0hFTVlfUEVORElOR19UUkFOU0FDVElPTlNfRVZFTlRfVFlQRSkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGZyb21BZGRyZXNzLCB0b0FkZHJlc3MsIGhhc2hlc09ubHkgfSA9IGV2ZW50O1xyXG4gICAgICAgICAgICB2b2lkIHRoaXMuX3N1YnNjcmliZShldmVudC50YWcsIFtcclxuICAgICAgICAgICAgICAgIEFsY2hlbXlTdWJzY3JpcHRpb24uUEVORElOR19UUkFOU0FDVElPTlMsXHJcbiAgICAgICAgICAgICAgICB7IGZyb21BZGRyZXNzLCB0b0FkZHJlc3MsIGhhc2hlc09ubHkgfVxyXG4gICAgICAgICAgICBdLCB0aGlzLmVtaXRQcm9jZXNzRm4oZXZlbnQpLCBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IEFMQ0hFTVlfTUlORURfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBhZGRyZXNzZXMsIGluY2x1ZGVSZW1vdmVkLCBoYXNoZXNPbmx5IH0gPSBldmVudDtcclxuICAgICAgICAgICAgdm9pZCB0aGlzLl9zdWJzY3JpYmUoZXZlbnQudGFnLCBbXHJcbiAgICAgICAgICAgICAgICBBbGNoZW15U3Vic2NyaXB0aW9uLk1JTkVEX1RSQU5TQUNUSU9OUyxcclxuICAgICAgICAgICAgICAgIHsgYWRkcmVzc2VzLCBpbmNsdWRlUmVtb3ZlZCwgaGFzaGVzT25seSB9XHJcbiAgICAgICAgICAgIF0sIHRoaXMuZW1pdFByb2Nlc3NGbihldmVudCksIGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ2Jsb2NrJykge1xyXG4gICAgICAgICAgICB2b2lkIHRoaXMuX3N1YnNjcmliZSgnYmxvY2snLCBbJ25ld0hlYWRzJ10sIHRoaXMuZW1pdFByb2Nlc3NGbihldmVudCksIGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ2ZpbHRlcicpIHtcclxuICAgICAgICAgICAgdm9pZCB0aGlzLl9zdWJzY3JpYmUoZXZlbnQudGFnLCBbJ2xvZ3MnLCB0aGlzLl9nZXRGaWx0ZXIoZXZlbnQuZmlsdGVyKV0sIHRoaXMuZW1pdFByb2Nlc3NGbihldmVudCksIGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBlbWl0UHJvY2Vzc0ZuKGV2ZW50KSB7XHJcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgQUxDSEVNWV9QRU5ESU5HX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PiB0aGlzLmVtaXQoe1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogQWxjaGVteVN1YnNjcmlwdGlvbi5QRU5ESU5HX1RSQU5TQUNUSU9OUyxcclxuICAgICAgICAgICAgICAgICAgICBmcm9tQWRkcmVzczogZXZlbnQuZnJvbUFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9BZGRyZXNzOiBldmVudC50b0FkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgaGFzaGVzT25seTogZXZlbnQuaGFzaGVzT25seVxyXG4gICAgICAgICAgICAgICAgfSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgY2FzZSBBTENIRU1ZX01JTkVEX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PiB0aGlzLmVtaXQoe1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogQWxjaGVteVN1YnNjcmlwdGlvbi5NSU5FRF9UUkFOU0FDVElPTlMsXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzOiBldmVudC5hZGRyZXNzZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZVJlbW92ZWQ6IGV2ZW50LmluY2x1ZGVSZW1vdmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIGhhc2hlc09ubHk6IGV2ZW50Lmhhc2hlc09ubHlcclxuICAgICAgICAgICAgICAgIH0sIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gQmlnTnVtYmVyLmZyb20ocmVzdWx0Lm51bWJlcikudG9OdW1iZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkLmJsb2NrID0gYmxvY2tOdW1iZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdibG9jaycsIGJsb2NrTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNhc2UgJ2ZpbHRlcic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlbW92ZWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVtb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnQuZmlsdGVyLCB0aGlzLmZvcm1hdHRlci5maWx0ZXJMb2cocmVzdWx0KSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGV2ZW50IHR5cGUgdG8gYGVtaXRQcm9jZXNzRm4oKWAnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERPIE5PVCBNT0RJRlkuXHJcbiAgICAgKlxyXG4gICAgICogT3JpZ2luYWwgY29kZSBjb3BpZWQgb3ZlciBmcm9tIGV0aGVyLmpzJ3MgYEJhc2VQcm92aWRlci5vZmYoKWAuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY29waWVkIG92ZXIgZGlyZWN0bHkgaW4gb3JkZXIgdG8gaW1wbGVtZW50IEFsY2hlbXkncyB1bmlxdWVcclxuICAgICAqIHN1YnNjcmlwdGlvbiB0eXBlcy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IHRoaXMgbWV0aG9kIGNhbGxzXHJcbiAgICAgKiB7QGxpbmsgZ2V0QWxjaGVteUV2ZW50VGFnfSBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBgZ2V0RXZlbnRUYWcoKWAgbWV0aG9kIGluXHJcbiAgICAgKiBvcmRlciB0byBwYXJzZSB0aGUgQWxjaGVteSBzdWJzY3JpcHRpb24gZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX29mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN0b3BwZWQgPSBbXTtcclxuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBldmVudFRhZyA9IGdldEFsY2hlbXlFdmVudFRhZyhldmVudE5hbWUpO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZyB8fCBldmVudC5saXN0ZW5lciAhPSBsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzdG9wcGVkLmZvckVhY2goZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBETyBOT1QgTU9ESUZZLlxyXG4gICAgICpcclxuICAgICAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzIGBCYXNlUHJvdmlkZXIucmVtb3ZlQWxsTGlzdGVuZXJzKClgLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNvcGllZCBvdmVyIGRpcmVjdGx5IGluIG9yZGVyIHRvIGltcGxlbWVudCBBbGNoZW15J3MgdW5pcXVlXHJcbiAgICAgKiBzdWJzY3JpcHRpb24gdHlwZXMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCB0aGlzIG1ldGhvZCBjYWxsc1xyXG4gICAgICoge0BsaW5rIGdldEFsY2hlbXlFdmVudFRhZ30gaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgYGdldEV2ZW50VGFnKClgIG1ldGhvZCBpblxyXG4gICAgICogb3JkZXIgdG8gcGFyc2UgdGhlIEFsY2hlbXkgc3Vic2NyaXB0aW9uIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgbGV0IHN0b3BwZWQgPSBbXTtcclxuICAgICAgICBpZiAoZXZlbnROYW1lID09IG51bGwpIHtcclxuICAgICAgICAgICAgc3RvcHBlZCA9IHRoaXMuX2V2ZW50cztcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBldmVudFRhZyA9IGdldEFsY2hlbXlFdmVudFRhZyhldmVudE5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMuZmlsdGVyKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RvcHBlZC5mb3JFYWNoKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRE8gTk9UIE1PRElGWS5cclxuICAgICAqXHJcbiAgICAgKiBPcmlnaW5hbCBjb2RlIGNvcGllZCBvdmVyIGZyb20gZXRoZXIuanMncyBgQmFzZVByb3ZpZGVyLmxpc3RlbmVyQ291bnQoKWAuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY29waWVkIG92ZXIgZGlyZWN0bHkgaW4gb3JkZXIgdG8gaW1wbGVtZW50IEFsY2hlbXkncyB1bmlxdWVcclxuICAgICAqIHN1YnNjcmlwdGlvbiB0eXBlcy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IHRoaXMgbWV0aG9kIGNhbGxzXHJcbiAgICAgKiB7QGxpbmsgZ2V0QWxjaGVteUV2ZW50VGFnfSBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBgZ2V0RXZlbnRUYWcoKWAgbWV0aG9kIGluXHJcbiAgICAgKiBvcmRlciB0byBwYXJzZSB0aGUgQWxjaGVteSBzdWJzY3JpcHRpb24gZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2xpc3RlbmVyQ291bnQoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgaWYgKCFldmVudE5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGV2ZW50VGFnID0gZ2V0QWxjaGVteUV2ZW50VGFnKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5maWx0ZXIoZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQudGFnID09PSBldmVudFRhZztcclxuICAgICAgICB9KS5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERPIE5PVCBNT0RJRlkuXHJcbiAgICAgKlxyXG4gICAgICogT3JpZ2luYWwgY29kZSBjb3BpZWQgb3ZlciBmcm9tIGV0aGVyLmpzJ3MgYEJhc2VQcm92aWRlci5saXN0ZW5lcnMoKWAuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY29waWVkIG92ZXIgZGlyZWN0bHkgaW4gb3JkZXIgdG8gaW1wbGVtZW50IEFsY2hlbXkncyB1bmlxdWVcclxuICAgICAqIHN1YnNjcmlwdGlvbiB0eXBlcy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IHRoaXMgbWV0aG9kIGNhbGxzXHJcbiAgICAgKiB7QGxpbmsgZ2V0QWxjaGVteUV2ZW50VGFnfSBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBgZ2V0RXZlbnRUYWcoKWAgbWV0aG9kIGluXHJcbiAgICAgKiBvcmRlciB0byBwYXJzZSB0aGUgQWxjaGVteSBzdWJzY3JpcHRpb24gZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2xpc3RlbmVycyhldmVudE5hbWUpIHtcclxuICAgICAgICBpZiAoZXZlbnROYW1lID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5tYXAoZXZlbnQgPT4gZXZlbnQubGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBldmVudFRhZyA9IGdldEFsY2hlbXlFdmVudFRhZyhldmVudE5hbWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHNcclxuICAgICAgICAgICAgLmZpbHRlcihldmVudCA9PiBldmVudC50YWcgPT09IGV2ZW50VGFnKVxyXG4gICAgICAgICAgICAubWFwKGV2ZW50ID0+IGV2ZW50Lmxpc3RlbmVyKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRXZWJzb2NrZXRDb25zdHJ1Y3RvcigpIHtcclxuICAgIHJldHVybiBpc05vZGVFbnZpcm9ubWVudCgpID8gcmVxdWlyZSgnd2Vic29ja2V0JykudzNjd2Vic29ja2V0IDogV2ViU29ja2V0O1xyXG59XHJcbmZ1bmN0aW9uIGlzTm9kZUVudmlyb25tZW50KCkge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICBwcm9jZXNzICE9IG51bGwgJiZcclxuICAgICAgICBwcm9jZXNzLnZlcnNpb25zICE9IG51bGwgJiZcclxuICAgICAgICBwcm9jZXNzLnZlcnNpb25zLm5vZGUgIT0gbnVsbCk7XHJcbn1cclxuLy8gVE9ETyhjbGVhbnVwKTogVXNlIGNsYXNzIHZhcmlhYmxlIHJhdGhlciB0aGFuIHBhc3NpbmcgYGlzQ2FuY2VsbGVkYCBldmVyeXdoZXJlLlxyXG5mdW5jdGlvbiBtYWtlQ2FuY2VsVG9rZW4oKSB7XHJcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XHJcbiAgICByZXR1cm4geyBjYW5jZWw6ICgpID0+IChjYW5jZWxsZWQgPSB0cnVlKSwgaXNDYW5jZWxsZWQ6ICgpID0+IGNhbmNlbGxlZCB9O1xyXG59XHJcbi8vIFRPRE8oY2xlYW51cCk6IHJlcGxhY2Ugd2l0aCBTREsncyBiYWNrb2ZmIGltcGxlbWVudGF0aW9uXHJcbmNvbnN0IE1JTl9SRVRSWV9ERUxBWSA9IDEwMDA7XHJcbmNvbnN0IFJFVFJZX0JBQ0tPRkZfRkFDVE9SID0gMjtcclxuY29uc3QgTUFYX1JFVFJZX0RFTEFZID0gMzAwMDA7XHJcbmZ1bmN0aW9uIHdpdGhCYWNrb2ZmUmV0cmllcyhmLCByZXRyeUNvdW50LCBzaG91bGRSZXRyeSA9ICgpID0+IHRydWUpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgbGV0IG5leHRXYWl0VGltZSA9IDA7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgZigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gcmV0cnlDb3VudCB8fCAhc2hvdWxkUmV0cnkoZXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB5aWVsZCBkZWxheShuZXh0V2FpdFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzaG91bGRSZXRyeShlcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5leHRXYWl0VGltZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFdhaXRUaW1lID09PSAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gTUlOX1JFVFJZX0RFTEFZXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5taW4oTUFYX1JFVFJZX0RFTEFZLCBSRVRSWV9CQUNLT0ZGX0ZBQ1RPUiAqIG5leHRXYWl0VGltZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBkZWxheShtcykge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xyXG59XHJcbmZ1bmN0aW9uIHdpdGhUaW1lb3V0KHByb21pc2UsIG1zKSB7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcclxuICAgICAgICBwcm9taXNlLFxyXG4gICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignVGltZW91dCcpKSwgbXMpKVxyXG4gICAgXSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmV3SGVhZHNCbG9ja051bWJlcihldmVudCkge1xyXG4gICAgcmV0dXJuIGZyb21IZXgoZXZlbnQubnVtYmVyKTtcclxufVxyXG5mdW5jdGlvbiBnZXRMb2dzQmxvY2tOdW1iZXIoZXZlbnQpIHtcclxuICAgIHJldHVybiBmcm9tSGV4KGV2ZW50LmJsb2NrTnVtYmVyKTtcclxufVxyXG5mdW5jdGlvbiBpc1Jlc3BvbnNlKG1lc3NhZ2UpIHtcclxuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShtZXNzYWdlKSB8fFxyXG4gICAgICAgIChtZXNzYWdlLmpzb25ycGMgPT09ICcyLjAnICYmIG1lc3NhZ2UuaWQgIT09IHVuZGVmaW5lZCkpO1xyXG59XHJcbmZ1bmN0aW9uIGlzU3Vic2NyaXB0aW9uRXZlbnQobWVzc2FnZSkge1xyXG4gICAgcmV0dXJuICFpc1Jlc3BvbnNlKG1lc3NhZ2UpO1xyXG59XHJcbmZ1bmN0aW9uIGFkZFRvTmV3SGVhZHNFdmVudHNCdWZmZXIocGFzdEV2ZW50cywgZXZlbnQpIHtcclxuICAgIGFkZFRvUGFzdEV2ZW50c0J1ZmZlcihwYXN0RXZlbnRzLCBldmVudCwgZ2V0TmV3SGVhZHNCbG9ja051bWJlcik7XHJcbn1cclxuZnVuY3Rpb24gYWRkVG9Mb2dzRXZlbnRzQnVmZmVyKHBhc3RFdmVudHMsIGV2ZW50KSB7XHJcbiAgICBhZGRUb1Bhc3RFdmVudHNCdWZmZXIocGFzdEV2ZW50cywgZXZlbnQsIGdldExvZ3NCbG9ja051bWJlcik7XHJcbn1cclxuLyoqXHJcbiAqIEFkZHMgYSBuZXcgZXZlbnQgdG8gYW4gYXJyYXkgb2YgZXZlbnRzLCBldmljdGluZyBhbnkgZXZlbnRzIHdoaWNoIGFyZSBzbyBvbGRcclxuICogdGhhdCB0aGV5IHdpbGwgbm8gbG9uZ2VyIGZlYXNpYmx5IGJlIHBhcnQgb2YgYSByZW9yZy5cclxuICovXHJcbmZ1bmN0aW9uIGFkZFRvUGFzdEV2ZW50c0J1ZmZlcihwYXN0RXZlbnRzLCBldmVudCwgZ2V0QmxvY2tOdW1iZXIpIHtcclxuICAgIGNvbnN0IGN1cnJlbnRCbG9ja051bWJlciA9IGdldEJsb2NrTnVtYmVyKGV2ZW50KTtcclxuICAgIC8vIEZpbmQgZmlyc3QgaW5kZXggb2YgYW4gZXZlbnQgcmVjZW50IGVub3VnaCB0byByZXRhaW4sIHRoZW4gZHJvcCBldmVyeXRoaW5nXHJcbiAgICAvLyBhdCBhIGxvd2VyIGluZGV4LlxyXG4gICAgY29uc3QgZmlyc3RHb29kSW5kZXggPSBwYXN0RXZlbnRzLmZpbmRJbmRleChlID0+IGdldEJsb2NrTnVtYmVyKGUpID4gY3VycmVudEJsb2NrTnVtYmVyIC0gUkVUQUlORURfRVZFTlRfQkxPQ0tfQ09VTlQpO1xyXG4gICAgaWYgKGZpcnN0R29vZEluZGV4ID09PSAtMSkge1xyXG4gICAgICAgIHBhc3RFdmVudHMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHBhc3RFdmVudHMuc3BsaWNlKDAsIGZpcnN0R29vZEluZGV4KTtcclxuICAgIH1cclxuICAgIHBhc3RFdmVudHMucHVzaChldmVudCk7XHJcbn1cblxuZXhwb3J0IHsgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGNoZW15LXdlYnNvY2tldC1wcm92aWRlci0zOTY3ZjE1MC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-3967f150.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/es5-ext/global.js":
/*!****************************************!*\
  !*** ./node_modules/es5-ext/global.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Fallback to standard globalThis if available\n\tif (typeof globalThis === \"object\" && globalThis) return globalThis;\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of updates to Object.prototype being restricted\n\t\t// via preventExtensions, seal or freeze\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ works, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lczUtZXh0L2dsb2JhbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2VzNS1leHQvZ2xvYmFsLmpzP2U0ZWQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIG5haXZlRmFsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiAmJiBzZWxmKSByZXR1cm4gc2VsZjtcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgJiYgd2luZG93KSByZXR1cm4gd2luZG93O1xuXHR0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmVzb2x2ZSBnbG9iYWwgYHRoaXNgXCIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuXHRpZiAodGhpcykgcmV0dXJuIHRoaXM7XG5cblx0Ly8gVW5leHBlY3RlZCBzdHJpY3QgbW9kZSAobWF5IGhhcHBlbiBpZiBlLmcuIGJ1bmRsZWQgaW50byBFU00gbW9kdWxlKVxuXG5cdC8vIEZhbGxiYWNrIHRvIHN0YW5kYXJkIGdsb2JhbFRoaXMgaWYgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIiAmJiBnbG9iYWxUaGlzKSByZXR1cm4gZ2xvYmFsVGhpcztcblxuXHQvLyBUaGFua3MgQG1hdGhpYXNieW5lbnMgLT4gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2dsb2JhbHRoaXNcblx0Ly8gSW4gYWxsIEVTNSsgZW5naW5lcyBnbG9iYWwgb2JqZWN0IGluaGVyaXRzIGZyb20gT2JqZWN0LnByb3RvdHlwZVxuXHQvLyAoaWYgeW91IGFwcHJvYWNoZWQgb25lIHRoYXQgZG9lc24ndCBwbGVhc2UgcmVwb3J0KVxuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QucHJvdG90eXBlLCBcIl9fZ2xvYmFsX19cIiwge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gVW5mb3J0dW5hdGUgY2FzZSBvZiB1cGRhdGVzIHRvIE9iamVjdC5wcm90b3R5cGUgYmVpbmcgcmVzdHJpY3RlZFxuXHRcdC8vIHZpYSBwcmV2ZW50RXh0ZW5zaW9ucywgc2VhbCBvciBmcmVlemVcblx0XHRyZXR1cm4gbmFpdmVGYWxsYmFjaygpO1xuXHR9XG5cdHRyeSB7XG5cdFx0Ly8gU2FmYXJpIGNhc2UgKHdpbmRvdy5fX2dsb2JhbF9fIHdvcmtzLCBidXQgX19nbG9iYWxfXyBkb2VzIG5vdClcblx0XHRpZiAoIV9fZ2xvYmFsX18pIHJldHVybiBuYWl2ZUZhbGxiYWNrKCk7XG5cdFx0cmV0dXJuIF9fZ2xvYmFsX187XG5cdH0gZmluYWxseSB7XG5cdFx0ZGVsZXRlIE9iamVjdC5wcm90b3R5cGUuX19nbG9iYWxfXztcblx0fVxufSkoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/es5-ext/global.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/sturdy-websocket/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/sturdy-websocket/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\nvar SturdyWebSocket = /** @class */ (function () {\n    function SturdyWebSocket(url, protocolsOrOptions, options) {\n        if (options === void 0) { options = {}; }\n        this.url = url;\n        this.onclose = null;\n        this.onerror = null;\n        this.onmessage = null;\n        this.onopen = null;\n        this.ondown = null;\n        this.onreopen = null;\n        this.CONNECTING = SturdyWebSocket.CONNECTING;\n        this.OPEN = SturdyWebSocket.OPEN;\n        this.CLOSING = SturdyWebSocket.CLOSING;\n        this.CLOSED = SturdyWebSocket.CLOSED;\n        this.hasBeenOpened = false;\n        this.isClosed = false;\n        this.messageBuffer = [];\n        this.nextRetryTime = 0;\n        this.reconnectCount = 0;\n        this.lastKnownExtensions = \"\";\n        this.lastKnownProtocol = \"\";\n        this.listeners = {};\n        if (protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)) {\n            this.protocols = protocolsOrOptions;\n        }\n        else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            }\n            else {\n                throw new Error(\"WebSocket not present in global scope and no \" +\n                    \"wsConstructor option was provided.\");\n            }\n        }\n        this.openNewWebSocket();\n    }\n    Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n        get: function () {\n            return this.binaryTypeInternal || \"blob\";\n        },\n        set: function (binaryType) {\n            this.binaryTypeInternal = binaryType;\n            if (this.ws) {\n                this.ws.binaryType = binaryType;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n        get: function () {\n            var sum = this.ws ? this.ws.bufferedAmount : 0;\n            var hasUnknownAmount = false;\n            this.messageBuffer.forEach(function (data) {\n                var byteLength = getDataByteLength(data);\n                if (byteLength != null) {\n                    sum += byteLength;\n                }\n                else {\n                    hasUnknownAmount = true;\n                }\n            });\n            if (hasUnknownAmount) {\n                this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\");\n            }\n            return sum;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n        get: function () {\n            return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n        get: function () {\n            return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n        get: function () {\n            return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SturdyWebSocket.prototype.close = function (code, reason) {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    };\n    SturdyWebSocket.prototype.send = function (data) {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        }\n        else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        }\n        else {\n            this.messageBuffer.push(data);\n        }\n    };\n    SturdyWebSocket.prototype.reconnect = function () {\n        if (this.isClosed) {\n            throw new Error(\"Cannot call reconnect() on socket which is permanently closed.\");\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    };\n    SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    };\n    SturdyWebSocket.prototype.dispatchEvent = function (event) {\n        return this.dispatchEventOfType(event.type, event);\n    };\n    SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(function (l) { return l !== listener; });\n        }\n    };\n    SturdyWebSocket.prototype.openNewWebSocket = function () {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, connectTimeout = _a.connectTimeout, wsConstructor = _a.wsConstructor;\n        this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n        var ws = new wsConstructor(this.url, this.protocols);\n        ws.onclose = function (event) { return _this.handleClose(event); };\n        ws.onerror = function (event) { return _this.handleError(event); };\n        ws.onmessage = function (event) { return _this.handleMessage(event); };\n        ws.onopen = function (event) { return _this.handleOpen(event); };\n        this.connectTimeoutId = setTimeout(function () {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            _this.clearConnectTimeout();\n            _this.disposeSocket();\n            _this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    };\n    SturdyWebSocket.prototype.handleOpen = function (event) {\n        var _this = this;\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        var allClearResetTime = this.options.allClearResetTime;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        }\n        else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        }\n        else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(function (message) { return _this.send(message); });\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(function () {\n            _this.clearAllClearTimeout();\n            _this.nextRetryTime = 0;\n            _this.reconnectCount = 0;\n            var openTime = (allClearResetTime / 1000) | 0;\n            _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" +\n                \" retry time and count.\");\n        }, allClearResetTime);\n    };\n    SturdyWebSocket.prototype.handleMessage = function (event) {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    };\n    SturdyWebSocket.prototype.handleClose = function (event) {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, maxReconnectAttempts = _a.maxReconnectAttempts, shouldReconnect = _a.shouldReconnect;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n            return;\n        }\n        var willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n        }\n        else {\n            willReconnect.then(function (willReconnectResolved) {\n                if (_this.isClosed) {\n                    return;\n                }\n                _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n            });\n        }\n    };\n    SturdyWebSocket.prototype.handleError = function (event) {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    };\n    SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n        if (willReconnect) {\n            this.reestablishConnection();\n        }\n        else {\n            this.stopReconnecting(event, denialReason);\n        }\n    };\n    SturdyWebSocket.prototype.reestablishConnection = function () {\n        var _this = this;\n        var _a = this.options, minReconnectDelay = _a.minReconnectDelay, maxReconnectDelay = _a.maxReconnectDelay, reconnectBackoffFactor = _a.reconnectBackoffFactor;\n        this.reconnectCount++;\n        var retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n        setTimeout(function () { return _this.openNewWebSocket(); }, retryTime);\n        var retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n    };\n    SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    };\n    SturdyWebSocket.prototype.shutdown = function () {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    };\n    SturdyWebSocket.prototype.disposeSocket = function (closeCode, reason) {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    };\n    SturdyWebSocket.prototype.clearAllTimeouts = function () {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    };\n    SturdyWebSocket.prototype.clearConnectTimeout = function () {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n        var _this = this;\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(function (listener) { return _this.callListener(listener, event); });\n        }\n        return !event || !event.defaultPrevented;\n    };\n    SturdyWebSocket.prototype.callListener = function (listener, event) {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        }\n        else {\n            listener.handleEvent.call(this, event);\n        }\n    };\n    SturdyWebSocket.prototype.debugLog = function (message) {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    };\n    SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n        var maxReconnectAttempts = this.options.maxReconnectAttempts;\n        return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n    };\n    SturdyWebSocket.DEFAULT_OPTIONS = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: function () { return true; },\n        wsConstructor: undefined,\n    };\n    SturdyWebSocket.CONNECTING = 0;\n    SturdyWebSocket.OPEN = 1;\n    SturdyWebSocket.CLOSING = 2;\n    SturdyWebSocket.CLOSED = 3;\n    return SturdyWebSocket;\n}());\nexports[\"default\"] = SturdyWebSocket;\nfunction applyDefaultOptions(options) {\n    var result = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(function (key) {\n        var value = options[key];\n        result[key] =\n            value === undefined\n                ? SturdyWebSocket.DEFAULT_OPTIONS[key]\n                : value;\n    });\n    return result;\n}\nfunction getDataByteLength(data) {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    }\n    else if (data instanceof Blob) {\n        return data.size;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction pluralize(s, n) {\n    return n === 1 ? s : s + \"s\";\n}\nfunction noop() {\n    // Nothing.\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHVyZHktd2Vic29ja2V0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLHdCQUF3QjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEMsMENBQTBDO0FBQzFDLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw2QkFBNkI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0NBQWtDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNkNBQTZDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zdHVyZHktd2Vic29ja2V0L2Rpc3QvaW5kZXguanM/YjQyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTSE9VTERfUkVDT05ORUNUX0ZBTFNFX01FU1NBR0UgPSBcIlByb3ZpZGVkIHNob3VsZFJlY29ubmVjdCgpIHJldHVybmVkIGZhbHNlLiBDbG9zaW5nIHBlcm1hbmVudGx5LlwiO1xudmFyIFNIT1VMRF9SRUNPTk5FQ1RfUFJPTUlTRV9GQUxTRV9NRVNTQUdFID0gXCJQcm92aWRlZCBzaG91bGRSZWNvbm5lY3QoKSByZXNvbHZlZCB0byBmYWxzZS4gQ2xvc2luZyBwZXJtYW5lbnRseS5cIjtcbnZhciBTdHVyZHlXZWJTb2NrZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3R1cmR5V2ViU29ja2V0KHVybCwgcHJvdG9jb2xzT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLm9uY2xvc2UgPSBudWxsO1xuICAgICAgICB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHRoaXMub25vcGVuID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbmRvd24gPSBudWxsO1xuICAgICAgICB0aGlzLm9ucmVvcGVuID0gbnVsbDtcbiAgICAgICAgdGhpcy5DT05ORUNUSU5HID0gU3R1cmR5V2ViU29ja2V0LkNPTk5FQ1RJTkc7XG4gICAgICAgIHRoaXMuT1BFTiA9IFN0dXJkeVdlYlNvY2tldC5PUEVOO1xuICAgICAgICB0aGlzLkNMT1NJTkcgPSBTdHVyZHlXZWJTb2NrZXQuQ0xPU0lORztcbiAgICAgICAgdGhpcy5DTE9TRUQgPSBTdHVyZHlXZWJTb2NrZXQuQ0xPU0VEO1xuICAgICAgICB0aGlzLmhhc0JlZW5PcGVuZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1lc3NhZ2VCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0UmV0cnlUaW1lID0gMDtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RDb3VudCA9IDA7XG4gICAgICAgIHRoaXMubGFzdEtub3duRXh0ZW5zaW9ucyA9IFwiXCI7XG4gICAgICAgIHRoaXMubGFzdEtub3duUHJvdG9jb2wgPSBcIlwiO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuICAgICAgICBpZiAocHJvdG9jb2xzT3JPcHRpb25zID09IG51bGwgfHxcbiAgICAgICAgICAgIHR5cGVvZiBwcm90b2NvbHNPck9wdGlvbnMgPT09IFwic3RyaW5nXCIgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocHJvdG9jb2xzT3JPcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5wcm90b2NvbHMgPSBwcm90b2NvbHNPck9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gcHJvdG9jb2xzT3JPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGFwcGx5RGVmYXVsdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLndzQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLndzQ29uc3RydWN0b3IgPSBXZWJTb2NrZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJTb2NrZXQgbm90IHByZXNlbnQgaW4gZ2xvYmFsIHNjb3BlIGFuZCBubyBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwid3NDb25zdHJ1Y3RvciBvcHRpb24gd2FzIHByb3ZpZGVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wZW5OZXdXZWJTb2NrZXQoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUsIFwiYmluYXJ5VHlwZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5VHlwZUludGVybmFsIHx8IFwiYmxvYlwiO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChiaW5hcnlUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeVR5cGVJbnRlcm5hbCA9IGJpbmFyeVR5cGU7XG4gICAgICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgICAgICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9IGJpbmFyeVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLCBcImJ1ZmZlcmVkQW1vdW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gdGhpcy53cyA/IHRoaXMud3MuYnVmZmVyZWRBbW91bnQgOiAwO1xuICAgICAgICAgICAgdmFyIGhhc1Vua25vd25BbW91bnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZUJ1ZmZlci5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ5dGVMZW5ndGggPSBnZXREYXRhQnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzVW5rbm93bkFtb3VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaGFzVW5rbm93bkFtb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coXCJTb21lIGJ1ZmZlcmVkIGRhdGEgaGFkIHVua25vd24gbGVuZ3RoLiBidWZmZXJlZEFtb3VudCgpXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIiByZXR1cm4gdmFsdWUgbWF5IGJlIGJlbG93IHRoZSBjb3JyZWN0IGFtb3VudC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZSwgXCJleHRlbnNpb25zXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cyA/IHRoaXMud3MuZXh0ZW5zaW9ucyA6IHRoaXMubGFzdEtub3duRXh0ZW5zaW9ucztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUsIFwicHJvdG9jb2xcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndzID8gdGhpcy53cy5wcm90b2NvbCA6IHRoaXMubGFzdEtub3duUHJvdG9jb2w7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLCBcInJlYWR5U3RhdGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzQ2xvc2VkID8gU3R1cmR5V2ViU29ja2V0LkNMT1NFRCA6IFN0dXJkeVdlYlNvY2tldC5PUEVOO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGNvZGUsIHJlYXNvbikge1xuICAgICAgICB0aGlzLmRpc3Bvc2VTb2NrZXQoY29kZSwgcmVhc29uKTtcbiAgICAgICAgdGhpcy5zaHV0ZG93bigpO1xuICAgICAgICB0aGlzLmRlYnVnTG9nKFwiV2ViU29ja2V0IHBlcm1hbmVudGx5IGNsb3NlZCBieSBjbGllbnQuXCIpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlYlNvY2tldCBpcyBhbHJlYWR5IGluIENMT1NJTkcgb3IgQ0xPU0VEIHN0YXRlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLndzICYmIHRoaXMud3MucmVhZHlTdGF0ZSA9PT0gdGhpcy5PUEVOKSB7XG4gICAgICAgICAgICB0aGlzLndzLnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VCdWZmZXIucHVzaChkYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCByZWNvbm5lY3QoKSBvbiBzb2NrZXQgd2hpY2ggaXMgcGVybWFuZW50bHkgY2xvc2VkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3Bvc2VTb2NrZXQoMTAwMCwgXCJDbGllbnQgcmVxdWVzdGVkIHJlY29ubmVjdC5cIik7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xvc2UodW5kZWZpbmVkKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIXRoaXMubGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoZXZlbnQudHlwZSwgZXZlbnQpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSB0aGlzLmxpc3RlbmVyc1t0eXBlXS5maWx0ZXIoZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwgIT09IGxpc3RlbmVyOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5vcGVuTmV3V2ViU29ja2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucywgY29ubmVjdFRpbWVvdXQgPSBfYS5jb25uZWN0VGltZW91dCwgd3NDb25zdHJ1Y3RvciA9IF9hLndzQ29uc3RydWN0b3I7XG4gICAgICAgIHRoaXMuZGVidWdMb2coXCJPcGVuaW5nIG5ldyBXZWJTb2NrZXQgdG8gXCIgKyB0aGlzLnVybCArIFwiLlwiKTtcbiAgICAgICAgdmFyIHdzID0gbmV3IHdzQ29uc3RydWN0b3IodGhpcy51cmwsIHRoaXMucHJvdG9jb2xzKTtcbiAgICAgICAgd3Mub25jbG9zZSA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gX3RoaXMuaGFuZGxlQ2xvc2UoZXZlbnQpOyB9O1xuICAgICAgICB3cy5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5oYW5kbGVFcnJvcihldmVudCk7IH07XG4gICAgICAgIHdzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gX3RoaXMuaGFuZGxlTWVzc2FnZShldmVudCk7IH07XG4gICAgICAgIHdzLm9ub3BlbiA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gX3RoaXMuaGFuZGxlT3BlbihldmVudCk7IH07XG4gICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBydW5uaW5nLCB3ZSBzdGlsbCBoYXZlbid0IG9wZW5lZCB0aGUgd2Vic29ja2V0LlxuICAgICAgICAgICAgLy8gS2lsbCBpdCBzbyB3ZSBjYW4gdHJ5IGFnYWluLlxuICAgICAgICAgICAgX3RoaXMuY2xlYXJDb25uZWN0VGltZW91dCgpO1xuICAgICAgICAgICAgX3RoaXMuZGlzcG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlQ2xvc2UodW5kZWZpbmVkKTtcbiAgICAgICAgfSwgY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICB0aGlzLndzID0gd3M7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmhhbmRsZU9wZW4gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLndzIHx8IHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxsQ2xlYXJSZXNldFRpbWUgPSB0aGlzLm9wdGlvbnMuYWxsQ2xlYXJSZXNldFRpbWU7XG4gICAgICAgIHRoaXMuZGVidWdMb2coXCJXZWJTb2NrZXQgb3BlbmVkLlwiKTtcbiAgICAgICAgaWYgKHRoaXMuYmluYXJ5VHlwZUludGVybmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9IHRoaXMuYmluYXJ5VHlwZUludGVybmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iaW5hcnlUeXBlSW50ZXJuYWwgPSB0aGlzLndzLmJpbmFyeVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhckNvbm5lY3RUaW1lb3V0KCk7XG4gICAgICAgIGlmICh0aGlzLmhhc0JlZW5PcGVuZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudE9mVHlwZShcInJlb3BlblwiLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoXCJvcGVuXCIsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuaGFzQmVlbk9wZW5lZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXNzYWdlQnVmZmVyLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcmV0dXJuIF90aGlzLnNlbmQobWVzc2FnZSk7IH0pO1xuICAgICAgICB0aGlzLm1lc3NhZ2VCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5hbGxDbGVhclRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2xlYXJBbGxDbGVhclRpbWVvdXQoKTtcbiAgICAgICAgICAgIF90aGlzLm5leHRSZXRyeVRpbWUgPSAwO1xuICAgICAgICAgICAgX3RoaXMucmVjb25uZWN0Q291bnQgPSAwO1xuICAgICAgICAgICAgdmFyIG9wZW5UaW1lID0gKGFsbENsZWFyUmVzZXRUaW1lIC8gMTAwMCkgfCAwO1xuICAgICAgICAgICAgX3RoaXMuZGVidWdMb2coXCJXZWJTb2NrZXQgcmVtYWluZWQgb3BlbiBmb3IgXCIgKyBvcGVuVGltZSArIFwiIHNlY29uZHMuIFJlc2V0dGluZ1wiICtcbiAgICAgICAgICAgICAgICBcIiByZXRyeSB0aW1lIGFuZCBjb3VudC5cIik7XG4gICAgICAgIH0sIGFsbENsZWFyUmVzZXRUaW1lKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuaGFuZGxlTWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudE9mVHlwZShcIm1lc3NhZ2VcIiwgZXZlbnQpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5oYW5kbGVDbG9zZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucywgbWF4UmVjb25uZWN0QXR0ZW1wdHMgPSBfYS5tYXhSZWNvbm5lY3RBdHRlbXB0cywgc2hvdWxkUmVjb25uZWN0ID0gX2Euc2hvdWxkUmVjb25uZWN0O1xuICAgICAgICB0aGlzLmNsZWFyQ29ubmVjdFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5jbGVhckFsbENsZWFyVGltZW91dCgpO1xuICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgICAgdGhpcy5sYXN0S25vd25FeHRlbnNpb25zID0gdGhpcy53cy5leHRlbnNpb25zO1xuICAgICAgICAgICAgdGhpcy5sYXN0S25vd25Qcm90b2NvbCA9IHRoaXMud3MucHJvdG9jb2w7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoXCJkb3duXCIsIGV2ZW50KTtcbiAgICAgICAgaWYgKHRoaXMucmVjb25uZWN0Q291bnQgPj0gbWF4UmVjb25uZWN0QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFJlY29ubmVjdGluZyhldmVudCwgdGhpcy5nZXRUb29NYW55RmFpbGVkUmVjb25uZWN0c01lc3NhZ2UoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpbGxSZWNvbm5lY3QgPSAhZXZlbnQgfHwgc2hvdWxkUmVjb25uZWN0KGV2ZW50KTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWxsUmVjb25uZWN0ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVXaWxsUmVjb25uZWN0KHdpbGxSZWNvbm5lY3QsIGV2ZW50LCBTSE9VTERfUkVDT05ORUNUX0ZBTFNFX01FU1NBR0UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2lsbFJlY29ubmVjdC50aGVuKGZ1bmN0aW9uICh3aWxsUmVjb25uZWN0UmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVXaWxsUmVjb25uZWN0KHdpbGxSZWNvbm5lY3RSZXNvbHZlZCwgZXZlbnQsIFNIT1VMRF9SRUNPTk5FQ1RfUFJPTUlTRV9GQUxTRV9NRVNTQUdFKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmhhbmRsZUVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudE9mVHlwZShcImVycm9yXCIsIGV2ZW50KTtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhcIldlYlNvY2tldCBlbmNvdW50ZXJlZCBhbiBlcnJvci5cIik7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmhhbmRsZVdpbGxSZWNvbm5lY3QgPSBmdW5jdGlvbiAod2lsbFJlY29ubmVjdCwgZXZlbnQsIGRlbmlhbFJlYXNvbikge1xuICAgICAgICBpZiAod2lsbFJlY29ubmVjdCkge1xuICAgICAgICAgICAgdGhpcy5yZWVzdGFibGlzaENvbm5lY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFJlY29ubmVjdGluZyhldmVudCwgZGVuaWFsUmVhc29uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5yZWVzdGFibGlzaENvbm5lY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucywgbWluUmVjb25uZWN0RGVsYXkgPSBfYS5taW5SZWNvbm5lY3REZWxheSwgbWF4UmVjb25uZWN0RGVsYXkgPSBfYS5tYXhSZWNvbm5lY3REZWxheSwgcmVjb25uZWN0QmFja29mZkZhY3RvciA9IF9hLnJlY29ubmVjdEJhY2tvZmZGYWN0b3I7XG4gICAgICAgIHRoaXMucmVjb25uZWN0Q291bnQrKztcbiAgICAgICAgdmFyIHJldHJ5VGltZSA9IHRoaXMubmV4dFJldHJ5VGltZTtcbiAgICAgICAgdGhpcy5uZXh0UmV0cnlUaW1lID0gTWF0aC5tYXgobWluUmVjb25uZWN0RGVsYXksIE1hdGgubWluKHRoaXMubmV4dFJldHJ5VGltZSAqIHJlY29ubmVjdEJhY2tvZmZGYWN0b3IsIG1heFJlY29ubmVjdERlbGF5KSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub3Blbk5ld1dlYlNvY2tldCgpOyB9LCByZXRyeVRpbWUpO1xuICAgICAgICB2YXIgcmV0cnlUaW1lU2Vjb25kcyA9IChyZXRyeVRpbWUgLyAxMDAwKSB8IDA7XG4gICAgICAgIHRoaXMuZGVidWdMb2coXCJXZWJTb2NrZXQgd2FzIGNsb3NlZC4gUmUtb3BlbmluZyBpbiBcIiArIHJldHJ5VGltZVNlY29uZHMgKyBcIiBzZWNvbmRzLlwiKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuc3RvcFJlY29ubmVjdGluZyA9IGZ1bmN0aW9uIChldmVudCwgZGVidWdSZWFzb24pIHtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhkZWJ1Z1JlYXNvbik7XG4gICAgICAgIHRoaXMuc2h1dGRvd24oKTtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoXCJjbG9zZVwiLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuc2h1dGRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsZWFyQWxsVGltZW91dHMoKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuZGlzcG9zZVNvY2tldCgpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5kaXNwb3NlU29ja2V0ID0gZnVuY3Rpb24gKGNsb3NlQ29kZSwgcmVhc29uKSB7XG4gICAgICAgIGlmICghdGhpcy53cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBub29wIGhhbmRsZXJzIGluc3RlYWQgb2YgbnVsbCBiZWNhdXNlIHNvbWUgV2ViU29ja2V0XG4gICAgICAgIC8vIGltcGxlbWVudGF0aW9ucywgc3VjaCBhcyB0aGUgb25lIGZyb20gaXNvbW9ycGhpYy13cywgcmFpc2UgYSBzdGluayBvblxuICAgICAgICAvLyB1bmhhbmRsZWQgZXZlbnRzLlxuICAgICAgICB0aGlzLndzLm9uZXJyb3IgPSBub29wO1xuICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSBub29wO1xuICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IG5vb3A7XG4gICAgICAgIHRoaXMud3Mub25vcGVuID0gbm9vcDtcbiAgICAgICAgdGhpcy53cy5jbG9zZShjbG9zZUNvZGUsIHJlYXNvbik7XG4gICAgICAgIHRoaXMud3MgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmNsZWFyQWxsVGltZW91dHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJDb25uZWN0VGltZW91dCgpO1xuICAgICAgICB0aGlzLmNsZWFyQWxsQ2xlYXJUaW1lb3V0KCk7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmNsZWFyQ29ubmVjdFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0SWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdFRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0SWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuY2xlYXJBbGxDbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmFsbENsZWFyVGltZW91dElkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmFsbENsZWFyVGltZW91dElkKTtcbiAgICAgICAgICAgIHRoaXMuYWxsQ2xlYXJUaW1lb3V0SWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudE9mVHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJjbG9zZVwiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uY2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmNsb3NlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25lcnJvcihldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbm1lc3NhZ2UoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJvcGVuXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25vcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25vcGVuKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZG93blwiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uZG93bikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uZG93bihldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJlb3BlblwiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9ucmVvcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25yZW9wZW4oZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSBpbiB0aGlzLmxpc3RlbmVycykge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV1cbiAgICAgICAgICAgICAgICAuc2xpY2UoKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gX3RoaXMuY2FsbExpc3RlbmVyKGxpc3RlbmVyLCBldmVudCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhZXZlbnQgfHwgIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmNhbGxMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lciwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLmhhbmRsZUV2ZW50LmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmRlYnVnTG9nID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmdldFRvb01hbnlGYWlsZWRSZWNvbm5lY3RzTWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1heFJlY29ubmVjdEF0dGVtcHRzID0gdGhpcy5vcHRpb25zLm1heFJlY29ubmVjdEF0dGVtcHRzO1xuICAgICAgICByZXR1cm4gXCJGYWlsZWQgdG8gcmVjb25uZWN0IGFmdGVyIFwiICsgbWF4UmVjb25uZWN0QXR0ZW1wdHMgKyBcIiBcIiArIHBsdXJhbGl6ZShcImF0dGVtcHRcIiwgbWF4UmVjb25uZWN0QXR0ZW1wdHMpICsgXCIuIENsb3NpbmcgcGVybWFuZW50bHkuXCI7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQuREVGQVVMVF9PUFRJT05TID0ge1xuICAgICAgICBhbGxDbGVhclJlc2V0VGltZTogNTAwMCxcbiAgICAgICAgY29ubmVjdFRpbWVvdXQ6IDUwMDAsXG4gICAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgICAgbWluUmVjb25uZWN0RGVsYXk6IDEwMDAsXG4gICAgICAgIG1heFJlY29ubmVjdERlbGF5OiAzMDAwMCxcbiAgICAgICAgbWF4UmVjb25uZWN0QXR0ZW1wdHM6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgcmVjb25uZWN0QmFja29mZkZhY3RvcjogMS41LFxuICAgICAgICBzaG91bGRSZWNvbm5lY3Q6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgIHdzQ29uc3RydWN0b3I6IHVuZGVmaW5lZCxcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5DT05ORUNUSU5HID0gMDtcbiAgICBTdHVyZHlXZWJTb2NrZXQuT1BFTiA9IDE7XG4gICAgU3R1cmR5V2ViU29ja2V0LkNMT1NJTkcgPSAyO1xuICAgIFN0dXJkeVdlYlNvY2tldC5DTE9TRUQgPSAzO1xuICAgIHJldHVybiBTdHVyZHlXZWJTb2NrZXQ7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3R1cmR5V2ViU29ja2V0O1xuZnVuY3Rpb24gYXBwbHlEZWZhdWx0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIE9iamVjdC5rZXlzKFN0dXJkeVdlYlNvY2tldC5ERUZBVUxUX09QVElPTlMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICAgIHJlc3VsdFtrZXldID1cbiAgICAgICAgICAgIHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IFN0dXJkeVdlYlNvY2tldC5ERUZBVUxUX09QVElPTlNba2V5XVxuICAgICAgICAgICAgICAgIDogdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldERhdGFCeXRlTGVuZ3RoKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gVVRGLTE2IHN0cmluZ3MgdXNlIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLlxuICAgICAgICByZXR1cm4gMiAqIGRhdGEubGVuZ3RoO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEuc2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcGx1cmFsaXplKHMsIG4pIHtcbiAgICByZXR1cm4gbiA9PT0gMSA/IHMgOiBzICsgXCJzXCI7XG59XG5mdW5jdGlvbiBub29wKCkge1xuICAgIC8vIE5vdGhpbmcuXG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/sturdy-websocket/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/websocket/lib/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/browser.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var _globalThis;\nif (typeof globalThis === 'object') {\n\t_globalThis = globalThis;\n} else {\n\ttry {\n\t\t_globalThis = __webpack_require__(/*! es5-ext/global */ \"(app-pages-browser)/./node_modules/es5-ext/global.js\");\n\t} catch (error) {\n\t} finally {\n\t\tif (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }\n\t\tif (!_globalThis) { throw new Error('Could not determine global this'); }\n\t}\n}\n\nvar NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\nvar websocket_version = __webpack_require__(/*! ./version */ \"(app-pages-browser)/./node_modules/websocket/lib/version.js\");\n\n\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */\nfunction W3CWebSocket(uri, protocols) {\n\tvar native_instance;\n\n\tif (protocols) {\n\t\tnative_instance = new NativeWebSocket(uri, protocols);\n\t}\n\telse {\n\t\tnative_instance = new NativeWebSocket(uri);\n\t}\n\n\t/**\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t * class). Since it is an Object it will be returned as it is when creating an\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t *\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t */\n\treturn native_instance;\n}\nif (NativeWebSocket) {\n\t['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {\n\t\tObject.defineProperty(W3CWebSocket, prop, {\n\t\t\tget: function() { return NativeWebSocket[prop]; }\n\t\t});\n\t});\n}\n\n/**\n * Module exports.\n */\nmodule.exports = {\n    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,\n    'version'      : websocket_version\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsNEVBQWdCO0FBQ3hDLEdBQUc7QUFDSCxHQUFHO0FBQ0gsdURBQXVEO0FBQ3ZELHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsOEVBQVc7OztBQUczQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsR0FBRztBQUNILEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9icm93c2VyLmpzPzA1YzgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9nbG9iYWxUaGlzO1xuaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0Jykge1xuXHRfZ2xvYmFsVGhpcyA9IGdsb2JhbFRoaXM7XG59IGVsc2Uge1xuXHR0cnkge1xuXHRcdF9nbG9iYWxUaGlzID0gcmVxdWlyZSgnZXM1LWV4dC9nbG9iYWwnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0fSBmaW5hbGx5IHtcblx0XHRpZiAoIV9nbG9iYWxUaGlzICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IF9nbG9iYWxUaGlzID0gd2luZG93OyB9XG5cdFx0aWYgKCFfZ2xvYmFsVGhpcykgeyB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgZ2xvYmFsIHRoaXMnKTsgfVxuXHR9XG59XG5cbnZhciBOYXRpdmVXZWJTb2NrZXQgPSBfZ2xvYmFsVGhpcy5XZWJTb2NrZXQgfHwgX2dsb2JhbFRoaXMuTW96V2ViU29ja2V0O1xudmFyIHdlYnNvY2tldF92ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG5cblxuLyoqXG4gKiBFeHBvc2UgYSBXM0MgV2ViU29ja2V0IGNsYXNzIHdpdGgganVzdCBvbmUgb3IgdHdvIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gVzNDV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzKSB7XG5cdHZhciBuYXRpdmVfaW5zdGFuY2U7XG5cblx0aWYgKHByb3RvY29scykge1xuXHRcdG5hdGl2ZV9pbnN0YW5jZSA9IG5ldyBOYXRpdmVXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdG5hdGl2ZV9pbnN0YW5jZSA9IG5ldyBOYXRpdmVXZWJTb2NrZXQodXJpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiAnbmF0aXZlX2luc3RhbmNlJyBpcyBhbiBpbnN0YW5jZSBvZiBuYXRpdmVXZWJTb2NrZXQgKHRoZSBicm93c2VyJ3MgV2ViU29ja2V0XG5cdCAqIGNsYXNzKS4gU2luY2UgaXQgaXMgYW4gT2JqZWN0IGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMgaXQgaXMgd2hlbiBjcmVhdGluZyBhblxuXHQgKiBpbnN0YW5jZSBvZiBXM0NXZWJTb2NrZXQgdmlhICduZXcgVzNDV2ViU29ja2V0KCknLlxuXHQgKlxuXHQgKiBFQ01BU2NyaXB0IDU6IGh0dHA6Ly9iY2xhcnkuY29tLzIwMDQvMTEvMDcvI2EtMTMuMi4yXG5cdCAqL1xuXHRyZXR1cm4gbmF0aXZlX2luc3RhbmNlO1xufVxuaWYgKE5hdGl2ZVdlYlNvY2tldCkge1xuXHRbJ0NPTk5FQ1RJTkcnLCAnT1BFTicsICdDTE9TSU5HJywgJ0NMT1NFRCddLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXM0NXZWJTb2NrZXQsIHByb3AsIHtcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBOYXRpdmVXZWJTb2NrZXRbcHJvcF07IH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICd3M2N3ZWJzb2NrZXQnIDogTmF0aXZlV2ViU29ja2V0ID8gVzNDV2ViU29ja2V0IDogbnVsbCxcbiAgICAndmVyc2lvbicgICAgICA6IHdlYnNvY2tldF92ZXJzaW9uXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/websocket/lib/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/websocket/lib/version.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/version.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ../package.json */ \"(app-pages-browser)/./node_modules/websocket/package.json\").version;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQUEsZ0lBQW1EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL3ZlcnNpb24uanM/ZTgzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/websocket/lib/version.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/websocket/package.json":
/*!*********************************************!*\
  !*** ./node_modules/websocket/package.json ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
module.exports = JSON.parse('{"name":"websocket","description":"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.","keywords":["websocket","websockets","socket","networking","comet","push","RFC-6455","realtime","server","client"],"author":"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)","contributors":["Iaki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"],"version":"1.0.34","repository":{"type":"git","url":"https://github.com/theturtle32/WebSocket-Node.git"},"homepage":"https://github.com/theturtle32/WebSocket-Node","engines":{"node":">=4.0.0"},"dependencies":{"bufferutil":"^4.0.1","debug":"^2.2.0","es5-ext":"^0.10.50","typedarray-to-buffer":"^3.1.5","utf-8-validate":"^5.0.2","yaeti":"^0.0.6"},"devDependencies":{"buffer-equal":"^1.0.0","gulp":"^4.0.2","gulp-jshint":"^2.0.4","jshint-stylish":"^2.2.1","jshint":"^2.0.0","tape":"^4.9.1"},"config":{"verbose":false},"scripts":{"test":"tape test/unit/*.js","gulp":"gulp"},"main":"index","directories":{"lib":"./lib"},"browser":"lib/browser.js","license":"Apache-2.0"}');

/***/ })

}]);