"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_alchemy-sdk_dist_esm_alchemy-provider-5e530ed5_js"],{

/***/ "(app-pages-browser)/./node_modules/alchemy-sdk/dist/esm/alchemy-provider-5e530ed5.js":
/*!************************************************************************!*\
  !*** ./node_modules/alchemy-sdk/dist/esm/alchemy-provider-5e530ed5.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AlchemyProvider: function() { return /* binding */ AlchemyProvider; }\n/* harmony export */ });\n/* harmony import */ var _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-1f2f6032.js */ \"(app-pages-browser)/./node_modules/alchemy-sdk/dist/esm/index-1f2f6032.js\");\n/* harmony import */ var _ethersproject_networks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/networks */ \"(app-pages-browser)/./node_modules/@ethersproject/networks/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_providers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/providers */ \"(app-pages-browser)/./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/web */ \"(app-pages-browser)/./node_modules/@ethersproject/web/lib.esm/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n\n\n\n\n\n\n\n\n/** Maximum size of a batch on the rpc provider. */\r\nconst DEFAULT_MAX_REQUEST_BATCH_SIZE = 100;\r\n/** Timeout interval before the pending batch is sent. */\r\nconst DEFAULT_REQUEST_BATCH_DELAY_MS = 10;\r\n/**\r\n * Internal class to enqueue requests and automatically send/process batches.\r\n *\r\n * The underlying batching mechanism is loosely based on ethers.js's\r\n * `JsonRpcBatchProvider`.\r\n *\r\n * @internal\r\n */\r\nclass RequestBatcher {\r\n    constructor(sendBatchFn, maxBatchSize = DEFAULT_MAX_REQUEST_BATCH_SIZE) {\r\n        this.sendBatchFn = sendBatchFn;\r\n        this.maxBatchSize = maxBatchSize;\r\n        /**\r\n         * Array of enqueued requests along with the constructed promise handlers for\r\n         * each request.\r\n         */\r\n        this.pendingBatch = [];\r\n    }\r\n    /**\r\n     * Enqueues the provided request. The batch is immediately sent if the maximum\r\n     * batch size is reached. Otherwise, the request is enqueued onto a batch that\r\n     * is sent after 10ms.\r\n     *\r\n     * Returns a promise that resolves with the result of the request.\r\n     */\r\n    enqueueRequest(request) {\r\n        return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            const inflightRequest = {\r\n                request,\r\n                resolve: undefined,\r\n                reject: undefined\r\n            };\r\n            const promise = new Promise((resolve, reject) => {\r\n                inflightRequest.resolve = resolve;\r\n                inflightRequest.reject = reject;\r\n            });\r\n            this.pendingBatch.push(inflightRequest);\r\n            if (this.pendingBatch.length === this.maxBatchSize) {\r\n                // Send batch immediately if we are at the maximum batch size.\r\n                void this.sendBatchRequest();\r\n            }\r\n            else if (!this.pendingBatchTimer) {\r\n                // Schedule batch for next event loop + short duration\r\n                this.pendingBatchTimer = setTimeout(() => this.sendBatchRequest(), DEFAULT_REQUEST_BATCH_DELAY_MS);\r\n            }\r\n            return promise;\r\n        });\r\n    }\r\n    /**\r\n     * Sends the currently queued batches and resets the batch and timer. Processes\r\n     * the batched response results back to the original promises.\r\n     */\r\n    sendBatchRequest() {\r\n        return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            // Get the current batch and clear it, so new requests\r\n            // go into the next batch\r\n            const batch = this.pendingBatch;\r\n            this.pendingBatch = [];\r\n            if (this.pendingBatchTimer) {\r\n                clearTimeout(this.pendingBatchTimer);\r\n                this.pendingBatchTimer = undefined;\r\n            }\r\n            // Get the request as an array of requests\r\n            const request = batch.map(inflight => inflight.request);\r\n            return this.sendBatchFn(request).then(result => {\r\n                // For each result, feed it to the correct Promise, depending\r\n                // on whether it was a success or error\r\n                batch.forEach((inflightRequest, index) => {\r\n                    const payload = result[index];\r\n                    if (payload.error) {\r\n                        const error = new Error(payload.error.message);\r\n                        error.code = payload.error.code;\r\n                        error.data = payload.error.data;\r\n                        inflightRequest.reject(error);\r\n                    }\r\n                    else {\r\n                        inflightRequest.resolve(payload.result);\r\n                    }\r\n                });\r\n            }, error => {\r\n                batch.forEach(inflightRequest => {\r\n                    inflightRequest.reject(error);\r\n                });\r\n            });\r\n        });\r\n    }\r\n}\n\n/**\r\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getProvider()}.\r\n *\r\n * @public\r\n */\r\nclass AlchemyProvider extends _ethersproject_providers__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider {\r\n    /** @internal */\r\n    constructor(config) {\r\n        // Normalize the API Key to a string.\r\n        const apiKey = AlchemyProvider.getApiKey(config.apiKey);\r\n        // Generate our own connection info with the correct endpoint URLs.\r\n        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\r\n        const connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'http');\r\n        // If a hardcoded url was specified in the config, use that instead of the\r\n        // provided apiKey or network.\r\n        if (config.url !== undefined) {\r\n            connection.url = config.url;\r\n        }\r\n        connection.throttleLimit = config.maxRetries;\r\n        // Normalize the Alchemy named network input to the network names used by\r\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\r\n        // correctly set the network.\r\n        const ethersNetwork = _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.E[alchemyNetwork];\r\n        super(connection, ethersNetwork);\r\n        this.apiKey = config.apiKey;\r\n        this.maxRetries = config.maxRetries;\r\n        this.batchRequests = config.batchRequests;\r\n        // TODO: support individual headers when calling batch\r\n        const batcherConnection = Object.assign(Object.assign({}, this.connection), { headers: Object.assign(Object.assign({}, this.connection.headers), { 'Alchemy-Ethers-Sdk-Method': 'batchSend' }) });\r\n        const sendBatchFn = (requests) => {\r\n            return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_3__.fetchJson)(batcherConnection, JSON.stringify(requests));\r\n        };\r\n        this.batcher = new RequestBatcher(sendBatchFn);\r\n        this.modifyFormatter();\r\n    }\r\n    /**\r\n     * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\r\n     * ethers.js. Returns the API key for an Alchemy provider.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getApiKey(apiKey) {\r\n        if (apiKey == null) {\r\n            return _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.D;\r\n        }\r\n        if (apiKey && typeof apiKey !== 'string') {\r\n            throw new Error(`Invalid apiKey '${apiKey}' provided. apiKey must be a string.`);\r\n        }\r\n        return apiKey;\r\n    }\r\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getNetwork(network) {\r\n        if (typeof network === 'string' && network in _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.C) {\r\n            return _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.C[network];\r\n        }\r\n        // Call the standard ethers.js getNetwork method for other networks.\r\n        return (0,_ethersproject_networks__WEBPACK_IMPORTED_MODULE_4__.getNetwork)(network);\r\n    }\r\n    /**\r\n     * Converts the `Networkish` input to the network enum used by Alchemy.\r\n     *\r\n     * @internal\r\n     */\r\n    static getAlchemyNetwork(network) {\r\n        if (network === undefined) {\r\n            return _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.a;\r\n        }\r\n        if (typeof network === 'number') {\r\n            throw new Error(`Invalid network '${network}' provided. Network must be a string.`);\r\n        }\r\n        // Guaranteed that `typeof network === 'string`.\r\n        const isValidNetwork = Object.values(_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.N).includes(network);\r\n        if (!isValidNetwork) {\r\n            throw new Error(`Invalid network '${network}' provided. Network must be one of: ` +\r\n                `${Object.values(_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.N).join(', ')}.`);\r\n        }\r\n        return network;\r\n    }\r\n    /**\r\n     * Returns a {@link ConnectionInfo} object compatible with ethers that contains\r\n     * the correct URLs for Alchemy.\r\n     *\r\n     * @internal\r\n     */\r\n    static getAlchemyConnectionInfo(network, apiKey, type) {\r\n        const url = type === 'http'\r\n            ? (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.g)(network, apiKey)\r\n            : (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.b)(network, apiKey);\r\n        return {\r\n            headers: _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.I\r\n                ? {\r\n                    'Alchemy-Ethers-Sdk-Version': _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.V\r\n                }\r\n                : {\r\n                    'Alchemy-Ethers-Sdk-Version': _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.V,\r\n                    'Accept-Encoding': 'gzip'\r\n                },\r\n            allowGzip: true,\r\n            url\r\n        };\r\n    }\r\n    /**\r\n     * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\r\n     * method is called when calling methods on the parent class `BaseProvider`.\r\n     *\r\n     * @override\r\n     */\r\n    detectNetwork() {\r\n        const _super = Object.create(null, {\r\n            detectNetwork: { get: () => super.detectNetwork }\r\n        });\r\n        return (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            let network = this.network;\r\n            if (network == null) {\r\n                network = yield _super.detectNetwork.call(this);\r\n                if (!network) {\r\n                    throw new Error('No network detected');\r\n                }\r\n            }\r\n            return network;\r\n        });\r\n    }\r\n    _startPending() {\r\n        (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.l)('WARNING: Alchemy Provider does not support pending filters');\r\n    }\r\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\r\n    isCommunityResource() {\r\n        return this.apiKey === _index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.D;\r\n    }\r\n    /**\r\n     * Overrides the base {@link JsonRpcProvider.send} method to implement custom\r\n     * logic for sending requests to Alchemy.\r\n     *\r\n     * @param method The method name to use for the request.\r\n     * @param params The parameters to use for the request.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Add headers for `perform()` override.\r\n    send(method, params) {\r\n        return this._send(method, params, 'send');\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `JsonRpcProvider.send()`.\r\n     *\r\n     * This method is copied over directly in order to implement custom headers\r\n     *\r\n     * @internal\r\n     */\r\n    _send(method, params, methodName, forceBatch = false) {\r\n        const request = {\r\n            method,\r\n            params,\r\n            id: this._nextId++,\r\n            jsonrpc: '2.0'\r\n        };\r\n        // START MODIFIED CODE\r\n        const connection = Object.assign({}, this.connection);\r\n        connection.headers['Alchemy-Ethers-Sdk-Method'] = methodName;\r\n        if (this.batchRequests || forceBatch) {\r\n            return this.batcher.enqueueRequest(request);\r\n        }\r\n        // END MODIFIED CODE\r\n        this.emit('debug', {\r\n            action: 'request',\r\n            request: (0,_index_1f2f6032_js__WEBPACK_IMPORTED_MODULE_1__.d)(request),\r\n            provider: this\r\n        });\r\n        // We can expand this in the future to any call, but for now these\r\n        // are the biggest wins and do not require any serializing parameters.\r\n        const cache = ['eth_chainId', 'eth_blockNumber'].indexOf(method) >= 0;\r\n        if (cache && this._cache[method]) {\r\n            return this._cache[method];\r\n        }\r\n        const result = (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_3__.fetchJson)(this.connection, JSON.stringify(request), getResult).then(result => {\r\n            this.emit('debug', {\r\n                action: 'response',\r\n                request,\r\n                response: result,\r\n                provider: this\r\n            });\r\n            return result;\r\n        }, error => {\r\n            this.emit('debug', {\r\n                action: 'response',\r\n                error,\r\n                request,\r\n                provider: this\r\n            });\r\n            throw error;\r\n        });\r\n        // Cache the fetch, but clear it on the next event loop\r\n        if (cache) {\r\n            this._cache[method] = result;\r\n            setTimeout(() => {\r\n                // @ts-ignore - This is done by ethers.\r\n                this._cache[method] = null;\r\n            }, 0);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Overrides the base `Formatter` class inherited from ethers to support\r\n     * returning custom fields in Ethers response types.\r\n     *\r\n     * For context, ethers has a `Formatter` class that is used to format the\r\n     * response from a JSON-RPC request. Any fields that are not defined in the\r\n     * `Formatter` class are removed from the returned response. By modifying the\r\n     * `Formatter` class in this method, we can add support for fields that are\r\n     * not defined in ethers.\r\n     */\r\n    modifyFormatter() {\r\n        this.formatter.formats['receiptLog']['removed'] = val => {\r\n            if (typeof val === 'boolean') {\r\n                return val;\r\n            }\r\n            return undefined;\r\n        };\r\n    }\r\n}\r\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * Original code copied over from ether.js's\r\n * `@ethersproject/web/src.ts/index.ts`. Used to support\r\n * {@link AlchemyProvider._send}, which is also copied over.\r\n */\r\nfunction getResult(payload) {\r\n    if (payload.error) {\r\n        const error = new Error(payload.error.message);\r\n        error.code = payload.error.code;\r\n        error.data = payload.error.data;\r\n        throw error;\r\n    }\r\n    return payload.result;\r\n}\n\n\n//# sourceMappingURL=alchemy-provider-5e530ed5.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9hbGNoZW15LXNkay9kaXN0L2VzbS9hbGNoZW15LXByb3ZpZGVyLTVlNTMwZWQ1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMFE7QUFDck47QUFDTTtBQUNaO0FBQzFCO0FBQ2E7QUFDbkI7QUFDMkI7QUFDWDtBQUNHOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxlQUFlLFVBQVUsbUNBQW1DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixxRUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpREFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHNCQUFzQix1Q0FBdUMsOEJBQThCLDBDQUEwQyxHQUFHO0FBQ3hNO0FBQ0EsbUJBQW1CLDZEQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUF1QjtBQUMxQztBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsaURBQWM7QUFDcEUsbUJBQW1CLGlEQUFjO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlLG1FQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQWU7QUFDbEM7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQSw2Q0FBNkMsaURBQU87QUFDcEQ7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RCxtQkFBbUIsY0FBYyxpREFBTyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFEQUFpQjtBQUMvQixjQUFjLHFEQUFlO0FBQzdCO0FBQ0EscUJBQXFCLGlEQUFVO0FBQy9CO0FBQ0Esa0RBQWtELGlEQUFPO0FBQ3pEO0FBQ0E7QUFDQSxrREFBa0QsaURBQU87QUFDekQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLFNBQVM7QUFDVCxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVEscURBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlEQUF1QjtBQUN0RDtBQUNBO0FBQ0EsMkJBQTJCLDRCQUE0QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxREFBUTtBQUM3QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkRBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FsY2hlbXktc2RrL2Rpc3QvZXNtL2FsY2hlbXktcHJvdmlkZXItNWU1MzBlZDUuanM/MGI2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfIGFzIF9fYXdhaXRlciwgRCBhcyBERUZBVUxUX0FMQ0hFTVlfQVBJX0tFWSwgQyBhcyBDdXN0b21OZXR3b3JrcywgYSBhcyBERUZBVUxUX05FVFdPUkssIE4gYXMgTmV0d29yaywgSSBhcyBJU19CUk9XU0VSLCBWIGFzIFZFUlNJT04sIGwgYXMgbG9nV2FybiwgZCBhcyBkZWVwQ29weSwgRSBhcyBFdGhlcnNOZXR3b3JrLCBnIGFzIGdldEFsY2hlbXlIdHRwVXJsLCBiIGFzIGdldEFsY2hlbXlXc1VybCB9IGZyb20gJy4vaW5kZXgtMWYyZjYwMzIuanMnO1xuaW1wb3J0IHsgZ2V0TmV0d29yayB9IGZyb20gJ0BldGhlcnNwcm9qZWN0L25ldHdvcmtzJztcbmltcG9ydCB7IEpzb25ScGNQcm92aWRlciB9IGZyb20gJ0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycyc7XG5pbXBvcnQgeyBmZXRjaEpzb24gfSBmcm9tICdAZXRoZXJzcHJvamVjdC93ZWInO1xuaW1wb3J0ICcuL2FwaS91dGlscyc7XG5pbXBvcnQgJ0BldGhlcnNwcm9qZWN0L2JpZ251bWJlcic7XG5pbXBvcnQgJ2F4aW9zJztcbmltcG9ydCAnQGV0aGVyc3Byb2plY3QvYWJzdHJhY3QtcHJvdmlkZXInO1xuaW1wb3J0ICdAZXRoZXJzcHJvamVjdC93YWxsZXQnO1xuaW1wb3J0ICdAZXRoZXJzcHJvamVjdC9jb250cmFjdHMnO1xuXG4vKiogTWF4aW11bSBzaXplIG9mIGEgYmF0Y2ggb24gdGhlIHJwYyBwcm92aWRlci4gKi9cclxuY29uc3QgREVGQVVMVF9NQVhfUkVRVUVTVF9CQVRDSF9TSVpFID0gMTAwO1xyXG4vKiogVGltZW91dCBpbnRlcnZhbCBiZWZvcmUgdGhlIHBlbmRpbmcgYmF0Y2ggaXMgc2VudC4gKi9cclxuY29uc3QgREVGQVVMVF9SRVFVRVNUX0JBVENIX0RFTEFZX01TID0gMTA7XHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBjbGFzcyB0byBlbnF1ZXVlIHJlcXVlc3RzIGFuZCBhdXRvbWF0aWNhbGx5IHNlbmQvcHJvY2VzcyBiYXRjaGVzLlxyXG4gKlxyXG4gKiBUaGUgdW5kZXJseWluZyBiYXRjaGluZyBtZWNoYW5pc20gaXMgbG9vc2VseSBiYXNlZCBvbiBldGhlcnMuanMnc1xyXG4gKiBgSnNvblJwY0JhdGNoUHJvdmlkZXJgLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFJlcXVlc3RCYXRjaGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlbmRCYXRjaEZuLCBtYXhCYXRjaFNpemUgPSBERUZBVUxUX01BWF9SRVFVRVNUX0JBVENIX1NJWkUpIHtcclxuICAgICAgICB0aGlzLnNlbmRCYXRjaEZuID0gc2VuZEJhdGNoRm47XHJcbiAgICAgICAgdGhpcy5tYXhCYXRjaFNpemUgPSBtYXhCYXRjaFNpemU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXJyYXkgb2YgZW5xdWV1ZWQgcmVxdWVzdHMgYWxvbmcgd2l0aCB0aGUgY29uc3RydWN0ZWQgcHJvbWlzZSBoYW5kbGVycyBmb3JcclxuICAgICAgICAgKiBlYWNoIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nQmF0Y2ggPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5xdWV1ZXMgdGhlIHByb3ZpZGVkIHJlcXVlc3QuIFRoZSBiYXRjaCBpcyBpbW1lZGlhdGVseSBzZW50IGlmIHRoZSBtYXhpbXVtXHJcbiAgICAgKiBiYXRjaCBzaXplIGlzIHJlYWNoZWQuIE90aGVyd2lzZSwgdGhlIHJlcXVlc3QgaXMgZW5xdWV1ZWQgb250byBhIGJhdGNoIHRoYXRcclxuICAgICAqIGlzIHNlbnQgYWZ0ZXIgMTBtcy5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgZW5xdWV1ZVJlcXVlc3QocmVxdWVzdCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZmxpZ2h0UmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgICAgICByZXNvbHZlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICByZWplY3Q6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlamVjdCA9IHJlamVjdDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0JhdGNoLnB1c2goaW5mbGlnaHRSZXF1ZXN0KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0JhdGNoLmxlbmd0aCA9PT0gdGhpcy5tYXhCYXRjaFNpemUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNlbmQgYmF0Y2ggaW1tZWRpYXRlbHkgaWYgd2UgYXJlIGF0IHRoZSBtYXhpbXVtIGJhdGNoIHNpemUuXHJcbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMuc2VuZEJhdGNoUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLnBlbmRpbmdCYXRjaFRpbWVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTY2hlZHVsZSBiYXRjaCBmb3IgbmV4dCBldmVudCBsb29wICsgc2hvcnQgZHVyYXRpb25cclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0JhdGNoVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VuZEJhdGNoUmVxdWVzdCgpLCBERUZBVUxUX1JFUVVFU1RfQkFUQ0hfREVMQVlfTVMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kcyB0aGUgY3VycmVudGx5IHF1ZXVlZCBiYXRjaGVzIGFuZCByZXNldHMgdGhlIGJhdGNoIGFuZCB0aW1lci4gUHJvY2Vzc2VzXHJcbiAgICAgKiB0aGUgYmF0Y2hlZCByZXNwb25zZSByZXN1bHRzIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHByb21pc2VzLlxyXG4gICAgICovXHJcbiAgICBzZW5kQmF0Y2hSZXF1ZXN0KCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBiYXRjaCBhbmQgY2xlYXIgaXQsIHNvIG5ldyByZXF1ZXN0c1xyXG4gICAgICAgICAgICAvLyBnbyBpbnRvIHRoZSBuZXh0IGJhdGNoXHJcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gdGhpcy5wZW5kaW5nQmF0Y2g7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0JhdGNoID0gW107XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdCYXRjaFRpbWVyKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wZW5kaW5nQmF0Y2hUaW1lcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCYXRjaFRpbWVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcmVxdWVzdCBhcyBhbiBhcnJheSBvZiByZXF1ZXN0c1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gYmF0Y2gubWFwKGluZmxpZ2h0ID0+IGluZmxpZ2h0LnJlcXVlc3QpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kQmF0Y2hGbihyZXF1ZXN0KS50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgZWFjaCByZXN1bHQsIGZlZWQgaXQgdG8gdGhlIGNvcnJlY3QgUHJvbWlzZSwgZGVwZW5kaW5nXHJcbiAgICAgICAgICAgICAgICAvLyBvbiB3aGV0aGVyIGl0IHdhcyBhIHN1Y2Nlc3Mgb3IgZXJyb3JcclxuICAgICAgICAgICAgICAgIGJhdGNoLmZvckVhY2goKGluZmxpZ2h0UmVxdWVzdCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gcmVzdWx0W2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihwYXlsb2FkLmVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gcGF5bG9hZC5lcnJvci5jb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5kYXRhID0gcGF5bG9hZC5lcnJvci5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZsaWdodFJlcXVlc3QucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZXNvbHZlKHBheWxvYWQucmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgYmF0Y2guZm9yRWFjaChpbmZsaWdodFJlcXVlc3QgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBTREsncyBjdXN0b20gaW1wbGVtZW50YXRpb24gb2YgZXRoZXJzLmpzJ3MgJ0FsY2hlbXlQcm92aWRlcicuXHJcbiAqXHJcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIGluc3RhbnRpYXRlIGFuIGluc3RhbmNlIG9mXHJcbiAqIHtAbGluayBBbGNoZW15fSBhbmQgY2FsbCB7QGxpbmsgQWxjaGVteS5jb25maWcuZ2V0UHJvdmlkZXIoKX0uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIEFsY2hlbXlQcm92aWRlciBleHRlbmRzIEpzb25ScGNQcm92aWRlciB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIEFQSSBLZXkgdG8gYSBzdHJpbmcuXHJcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gQWxjaGVteVByb3ZpZGVyLmdldEFwaUtleShjb25maWcuYXBpS2V5KTtcclxuICAgICAgICAvLyBHZW5lcmF0ZSBvdXIgb3duIGNvbm5lY3Rpb24gaW5mbyB3aXRoIHRoZSBjb3JyZWN0IGVuZHBvaW50IFVSTHMuXHJcbiAgICAgICAgY29uc3QgYWxjaGVteU5ldHdvcmsgPSBBbGNoZW15UHJvdmlkZXIuZ2V0QWxjaGVteU5ldHdvcmsoY29uZmlnLm5ldHdvcmspO1xyXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBBbGNoZW15UHJvdmlkZXIuZ2V0QWxjaGVteUNvbm5lY3Rpb25JbmZvKGFsY2hlbXlOZXR3b3JrLCBhcGlLZXksICdodHRwJyk7XHJcbiAgICAgICAgLy8gSWYgYSBoYXJkY29kZWQgdXJsIHdhcyBzcGVjaWZpZWQgaW4gdGhlIGNvbmZpZywgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGVcclxuICAgICAgICAvLyBwcm92aWRlZCBhcGlLZXkgb3IgbmV0d29yay5cclxuICAgICAgICBpZiAoY29uZmlnLnVybCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rpb24udXJsID0gY29uZmlnLnVybDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29ubmVjdGlvbi50aHJvdHRsZUxpbWl0ID0gY29uZmlnLm1heFJldHJpZXM7XHJcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBBbGNoZW15IG5hbWVkIG5ldHdvcmsgaW5wdXQgdG8gdGhlIG5ldHdvcmsgbmFtZXMgdXNlZCBieVxyXG4gICAgICAgIC8vIGV0aGVycy4gVGhpcyBhbGxvd3MgdGhlIHBhcmVudCBzdXBlciBjb25zdHJ1Y3RvciBpbiBKc29uUnBjUHJvdmlkZXIgdG9cclxuICAgICAgICAvLyBjb3JyZWN0bHkgc2V0IHRoZSBuZXR3b3JrLlxyXG4gICAgICAgIGNvbnN0IGV0aGVyc05ldHdvcmsgPSBFdGhlcnNOZXR3b3JrW2FsY2hlbXlOZXR3b3JrXTtcclxuICAgICAgICBzdXBlcihjb25uZWN0aW9uLCBldGhlcnNOZXR3b3JrKTtcclxuICAgICAgICB0aGlzLmFwaUtleSA9IGNvbmZpZy5hcGlLZXk7XHJcbiAgICAgICAgdGhpcy5tYXhSZXRyaWVzID0gY29uZmlnLm1heFJldHJpZXM7XHJcbiAgICAgICAgdGhpcy5iYXRjaFJlcXVlc3RzID0gY29uZmlnLmJhdGNoUmVxdWVzdHM7XHJcbiAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBpbmRpdmlkdWFsIGhlYWRlcnMgd2hlbiBjYWxsaW5nIGJhdGNoXHJcbiAgICAgICAgY29uc3QgYmF0Y2hlckNvbm5lY3Rpb24gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29ubmVjdGlvbiksIHsgaGVhZGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbm5lY3Rpb24uaGVhZGVycyksIHsgJ0FsY2hlbXktRXRoZXJzLVNkay1NZXRob2QnOiAnYmF0Y2hTZW5kJyB9KSB9KTtcclxuICAgICAgICBjb25zdCBzZW5kQmF0Y2hGbiA9IChyZXF1ZXN0cykgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hKc29uKGJhdGNoZXJDb25uZWN0aW9uLCBKU09OLnN0cmluZ2lmeShyZXF1ZXN0cykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5iYXRjaGVyID0gbmV3IFJlcXVlc3RCYXRjaGVyKHNlbmRCYXRjaEZuKTtcclxuICAgICAgICB0aGlzLm1vZGlmeUZvcm1hdHRlcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGBVcmxKc29uUnBjUHJvdmlkZXIuZ2V0QXBpS2V5YCBtZXRob2QgYXMgaW1wbGVtZW50ZWQgYnlcclxuICAgICAqIGV0aGVycy5qcy4gUmV0dXJucyB0aGUgQVBJIGtleSBmb3IgYW4gQWxjaGVteSBwcm92aWRlci5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0QXBpS2V5KGFwaUtleSkge1xyXG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gREVGQVVMVF9BTENIRU1ZX0FQSV9LRVk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcGlLZXkgJiYgdHlwZW9mIGFwaUtleSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFwaUtleSAnJHthcGlLZXl9JyBwcm92aWRlZC4gYXBpS2V5IG11c3QgYmUgYSBzdHJpbmcuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcGlLZXk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgYEJhc2VQcm92aWRlci5nZXROZXR3b3JrYCBtZXRob2QgYXMgaW1wbGVtZW50ZWQgYnkgZXRoZXJzLmpzLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgb3ZlcnJpZGUgYWxsb3dzIHRoZSBTREsgdG8gc2V0IHRoZSBwcm92aWRlcidzIG5ldHdvcmsgdG8gdmFsdWVzIG5vdFxyXG4gICAgICogeWV0IHN1cHBvcnRlZCBieSBldGhlcnMuanMuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldE5ldHdvcmsobmV0d29yaykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmV0d29yayA9PT0gJ3N0cmluZycgJiYgbmV0d29yayBpbiBDdXN0b21OZXR3b3Jrcykge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3VzdG9tTmV0d29ya3NbbmV0d29ya107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbGwgdGhlIHN0YW5kYXJkIGV0aGVycy5qcyBnZXROZXR3b3JrIG1ldGhvZCBmb3Igb3RoZXIgbmV0d29ya3MuXHJcbiAgICAgICAgcmV0dXJuIGdldE5ldHdvcmsobmV0d29yayk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBgTmV0d29ya2lzaGAgaW5wdXQgdG8gdGhlIG5ldHdvcmsgZW51bSB1c2VkIGJ5IEFsY2hlbXkuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRBbGNoZW15TmV0d29yayhuZXR3b3JrKSB7XHJcbiAgICAgICAgaWYgKG5ldHdvcmsgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gREVGQVVMVF9ORVRXT1JLO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG5ldHdvcmsgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuZXR3b3JrICcke25ldHdvcmt9JyBwcm92aWRlZC4gTmV0d29yayBtdXN0IGJlIGEgc3RyaW5nLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHdWFyYW50ZWVkIHRoYXQgYHR5cGVvZiBuZXR3b3JrID09PSAnc3RyaW5nYC5cclxuICAgICAgICBjb25zdCBpc1ZhbGlkTmV0d29yayA9IE9iamVjdC52YWx1ZXMoTmV0d29yaykuaW5jbHVkZXMobmV0d29yayk7XHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkTmV0d29yaykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbmV0d29yayAnJHtuZXR3b3JrfScgcHJvdmlkZWQuIE5ldHdvcmsgbXVzdCBiZSBvbmUgb2Y6IGAgK1xyXG4gICAgICAgICAgICAgICAgYCR7T2JqZWN0LnZhbHVlcyhOZXR3b3JrKS5qb2luKCcsICcpfS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldHdvcms7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgQ29ubmVjdGlvbkluZm99IG9iamVjdCBjb21wYXRpYmxlIHdpdGggZXRoZXJzIHRoYXQgY29udGFpbnNcclxuICAgICAqIHRoZSBjb3JyZWN0IFVSTHMgZm9yIEFsY2hlbXkuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRBbGNoZW15Q29ubmVjdGlvbkluZm8obmV0d29yaywgYXBpS2V5LCB0eXBlKSB7XHJcbiAgICAgICAgY29uc3QgdXJsID0gdHlwZSA9PT0gJ2h0dHAnXHJcbiAgICAgICAgICAgID8gZ2V0QWxjaGVteUh0dHBVcmwobmV0d29yaywgYXBpS2V5KVxyXG4gICAgICAgICAgICA6IGdldEFsY2hlbXlXc1VybChuZXR3b3JrLCBhcGlLZXkpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGhlYWRlcnM6IElTX0JST1dTRVJcclxuICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgICdBbGNoZW15LUV0aGVycy1TZGstVmVyc2lvbic6IFZFUlNJT05cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgICAgICdBbGNoZW15LUV0aGVycy1TZGstVmVyc2lvbic6IFZFUlNJT04sXHJcbiAgICAgICAgICAgICAgICAgICAgJ0FjY2VwdC1FbmNvZGluZyc6ICdnemlwJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWxsb3dHemlwOiB0cnVlLFxyXG4gICAgICAgICAgICB1cmxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIG1ldGhvZCBpbiBldGhlcnMuanMncyBgU3RhdGljSnNvblJwY1Byb3ZpZGVyYCBjbGFzcy4gVGhpc1xyXG4gICAgICogbWV0aG9kIGlzIGNhbGxlZCB3aGVuIGNhbGxpbmcgbWV0aG9kcyBvbiB0aGUgcGFyZW50IGNsYXNzIGBCYXNlUHJvdmlkZXJgLlxyXG4gICAgICpcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBkZXRlY3ROZXR3b3JrKCkge1xyXG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICAgICAgICBkZXRlY3ROZXR3b3JrOiB7IGdldDogKCkgPT4gc3VwZXIuZGV0ZWN0TmV0d29yayB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgbGV0IG5ldHdvcmsgPSB0aGlzLm5ldHdvcms7XHJcbiAgICAgICAgICAgIGlmIChuZXR3b3JrID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIG5ldHdvcmsgPSB5aWVsZCBfc3VwZXIuZGV0ZWN0TmV0d29yay5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFuZXR3b3JrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBuZXR3b3JrIGRldGVjdGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfc3RhcnRQZW5kaW5nKCkge1xyXG4gICAgICAgIGxvZ1dhcm4oJ1dBUk5JTkc6IEFsY2hlbXkgUHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBwZW5kaW5nIGZpbHRlcnMnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBldGhlcidzIGBpc0NvbW11bml0eVJlc291cmNlKClgIG1ldGhvZC4gUmV0dXJucyB0cnVlIGlmIHRoZVxyXG4gICAgICogY3VycmVudCBhcGkga2V5IGlzIHRoZSBkZWZhdWx0IGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcGlLZXkgPT09IERFRkFVTFRfQUxDSEVNWV9BUElfS0VZO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGJhc2Uge0BsaW5rIEpzb25ScGNQcm92aWRlci5zZW5kfSBtZXRob2QgdG8gaW1wbGVtZW50IGN1c3RvbVxyXG4gICAgICogbG9naWMgZm9yIHNlbmRpbmcgcmVxdWVzdHMgdG8gQWxjaGVteS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWV0aG9kIFRoZSBtZXRob2QgbmFtZSB0byB1c2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBUaGUgcGFyYW1ldGVycyB0byB1c2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIC8vIFRPRE86IEFkZCBoZWFkZXJzIGZvciBgcGVyZm9ybSgpYCBvdmVycmlkZS5cclxuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2VuZChtZXRob2QsIHBhcmFtcywgJ3NlbmQnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRE8gTk9UIE1PRElGWS5cclxuICAgICAqXHJcbiAgICAgKiBPcmlnaW5hbCBjb2RlIGNvcGllZCBvdmVyIGZyb20gZXRoZXIuanMncyBgSnNvblJwY1Byb3ZpZGVyLnNlbmQoKWAuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY29waWVkIG92ZXIgZGlyZWN0bHkgaW4gb3JkZXIgdG8gaW1wbGVtZW50IGN1c3RvbSBoZWFkZXJzXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9zZW5kKG1ldGhvZCwgcGFyYW1zLCBtZXRob2ROYW1lLCBmb3JjZUJhdGNoID0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICBtZXRob2QsXHJcbiAgICAgICAgICAgIHBhcmFtcyxcclxuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRJZCsrLFxyXG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gU1RBUlQgTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbm5lY3Rpb24pO1xyXG4gICAgICAgIGNvbm5lY3Rpb24uaGVhZGVyc1snQWxjaGVteS1FdGhlcnMtU2RrLU1ldGhvZCddID0gbWV0aG9kTmFtZTtcclxuICAgICAgICBpZiAodGhpcy5iYXRjaFJlcXVlc3RzIHx8IGZvcmNlQmF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmF0Y2hlci5lbnF1ZXVlUmVxdWVzdChyZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRU5EIE1PRElGSUVEIENPREVcclxuICAgICAgICB0aGlzLmVtaXQoJ2RlYnVnJywge1xyXG4gICAgICAgICAgICBhY3Rpb246ICdyZXF1ZXN0JyxcclxuICAgICAgICAgICAgcmVxdWVzdDogZGVlcENvcHkocmVxdWVzdCksXHJcbiAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gV2UgY2FuIGV4cGFuZCB0aGlzIGluIHRoZSBmdXR1cmUgdG8gYW55IGNhbGwsIGJ1dCBmb3Igbm93IHRoZXNlXHJcbiAgICAgICAgLy8gYXJlIHRoZSBiaWdnZXN0IHdpbnMgYW5kIGRvIG5vdCByZXF1aXJlIGFueSBzZXJpYWxpemluZyBwYXJhbWV0ZXJzLlxyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gWydldGhfY2hhaW5JZCcsICdldGhfYmxvY2tOdW1iZXInXS5pbmRleE9mKG1ldGhvZCkgPj0gMDtcclxuICAgICAgICBpZiAoY2FjaGUgJiYgdGhpcy5fY2FjaGVbbWV0aG9kXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVbbWV0aG9kXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZmV0Y2hKc29uKHRoaXMuY29ubmVjdGlvbiwgSlNPTi5zdHJpbmdpZnkocmVxdWVzdCksIGdldFJlc3VsdCkudGhlbihyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RlYnVnJywge1xyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAncmVzcG9uc2UnLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXN1bHQsXHJcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9LCBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGVidWcnLCB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdyZXNwb25zZScsXHJcbiAgICAgICAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gQ2FjaGUgdGhlIGZldGNoLCBidXQgY2xlYXIgaXQgb24gdGhlIG5leHQgZXZlbnQgbG9vcFxyXG4gICAgICAgIGlmIChjYWNoZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jYWNoZVttZXRob2RdID0gcmVzdWx0O1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSBUaGlzIGlzIGRvbmUgYnkgZXRoZXJzLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVbbWV0aG9kXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGJhc2UgYEZvcm1hdHRlcmAgY2xhc3MgaW5oZXJpdGVkIGZyb20gZXRoZXJzIHRvIHN1cHBvcnRcclxuICAgICAqIHJldHVybmluZyBjdXN0b20gZmllbGRzIGluIEV0aGVycyByZXNwb25zZSB0eXBlcy5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgY29udGV4dCwgZXRoZXJzIGhhcyBhIGBGb3JtYXR0ZXJgIGNsYXNzIHRoYXQgaXMgdXNlZCB0byBmb3JtYXQgdGhlXHJcbiAgICAgKiByZXNwb25zZSBmcm9tIGEgSlNPTi1SUEMgcmVxdWVzdC4gQW55IGZpZWxkcyB0aGF0IGFyZSBub3QgZGVmaW5lZCBpbiB0aGVcclxuICAgICAqIGBGb3JtYXR0ZXJgIGNsYXNzIGFyZSByZW1vdmVkIGZyb20gdGhlIHJldHVybmVkIHJlc3BvbnNlLiBCeSBtb2RpZnlpbmcgdGhlXHJcbiAgICAgKiBgRm9ybWF0dGVyYCBjbGFzcyBpbiB0aGlzIG1ldGhvZCwgd2UgY2FuIGFkZCBzdXBwb3J0IGZvciBmaWVsZHMgdGhhdCBhcmVcclxuICAgICAqIG5vdCBkZWZpbmVkIGluIGV0aGVycy5cclxuICAgICAqL1xyXG4gICAgbW9kaWZ5Rm9ybWF0dGVyKCkge1xyXG4gICAgICAgIHRoaXMuZm9ybWF0dGVyLmZvcm1hdHNbJ3JlY2VpcHRMb2cnXVsncmVtb3ZlZCddID0gdmFsID0+IHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERPIE5PVCBNT0RJRlkuXHJcbiAqXHJcbiAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzXHJcbiAqIGBAZXRoZXJzcHJvamVjdC93ZWIvc3JjLnRzL2luZGV4LnRzYC4gVXNlZCB0byBzdXBwb3J0XHJcbiAqIHtAbGluayBBbGNoZW15UHJvdmlkZXIuX3NlbmR9LCB3aGljaCBpcyBhbHNvIGNvcGllZCBvdmVyLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmVzdWx0KHBheWxvYWQpIHtcclxuICAgIGlmIChwYXlsb2FkLmVycm9yKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IocGF5bG9hZC5lcnJvci5tZXNzYWdlKTtcclxuICAgICAgICBlcnJvci5jb2RlID0gcGF5bG9hZC5lcnJvci5jb2RlO1xyXG4gICAgICAgIGVycm9yLmRhdGEgPSBwYXlsb2FkLmVycm9yLmRhdGE7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF5bG9hZC5yZXN1bHQ7XHJcbn1cblxuZXhwb3J0IHsgQWxjaGVteVByb3ZpZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGNoZW15LXByb3ZpZGVyLTVlNTMwZWQ1LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/alchemy-sdk/dist/esm/alchemy-provider-5e530ed5.js\n"));

/***/ })

}]);